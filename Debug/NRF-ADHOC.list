
NRF-ADHOC.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00008f94  08000198  08000198  00010198  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000174  0800912c  0800912c  0001912c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  080092a0  080092a0  000192a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  080092a8  080092a8  000192a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  080092ac  080092ac  000192ac  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000154  20000000  080092b0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000b0f4  20000158  08009404  00020158  2**3
                  ALLOC
  8 ._user_heap_stack 00000600  2000b24c  08009404  0002b24c  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00020154  2**0
                  CONTENTS, READONLY
 10 .debug_info   00036299  00000000  00000000  00020184  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000072f7  00000000  00000000  0005641d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00010d99  00000000  00000000  0005d714  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00001300  00000000  00000000  0006e4b0  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00001520  00000000  00000000  0006f7b0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000bef0  00000000  00000000  00070cd0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000061cb  00000000  00000000  0007cbc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  00082d8b  2**0
                  CONTENTS, READONLY
 18 .debug_frame  000033dc  00000000  00000000  00082e08  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	; (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	; (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	; (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000158 	.word	0x20000158
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08009114 	.word	0x08009114

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	; (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	; (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	; (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	2000015c 	.word	0x2000015c
 80001d4:	08009114 	.word	0x08009114

080001d8 <strcmp>:
 80001d8:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001dc:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001e0:	2a01      	cmp	r2, #1
 80001e2:	bf28      	it	cs
 80001e4:	429a      	cmpcs	r2, r3
 80001e6:	d0f7      	beq.n	80001d8 <strcmp>
 80001e8:	1ad0      	subs	r0, r2, r3
 80001ea:	4770      	bx	lr

080001ec <strlen>:
 80001ec:	4603      	mov	r3, r0
 80001ee:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001f2:	2a00      	cmp	r2, #0
 80001f4:	d1fb      	bne.n	80001ee <strlen+0x2>
 80001f6:	1a18      	subs	r0, r3, r0
 80001f8:	3801      	subs	r0, #1
 80001fa:	4770      	bx	lr

080001fc <__aeabi_ldivmod>:
 80001fc:	b97b      	cbnz	r3, 800021e <__aeabi_ldivmod+0x22>
 80001fe:	b972      	cbnz	r2, 800021e <__aeabi_ldivmod+0x22>
 8000200:	2900      	cmp	r1, #0
 8000202:	bfbe      	ittt	lt
 8000204:	2000      	movlt	r0, #0
 8000206:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 800020a:	e006      	blt.n	800021a <__aeabi_ldivmod+0x1e>
 800020c:	bf08      	it	eq
 800020e:	2800      	cmpeq	r0, #0
 8000210:	bf1c      	itt	ne
 8000212:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 8000216:	f04f 30ff 	movne.w	r0, #4294967295
 800021a:	f000 b9c5 	b.w	80005a8 <__aeabi_idiv0>
 800021e:	f1ad 0c08 	sub.w	ip, sp, #8
 8000222:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000226:	2900      	cmp	r1, #0
 8000228:	db09      	blt.n	800023e <__aeabi_ldivmod+0x42>
 800022a:	2b00      	cmp	r3, #0
 800022c:	db1a      	blt.n	8000264 <__aeabi_ldivmod+0x68>
 800022e:	f000 f84d 	bl	80002cc <__udivmoddi4>
 8000232:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000236:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800023a:	b004      	add	sp, #16
 800023c:	4770      	bx	lr
 800023e:	4240      	negs	r0, r0
 8000240:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000244:	2b00      	cmp	r3, #0
 8000246:	db1b      	blt.n	8000280 <__aeabi_ldivmod+0x84>
 8000248:	f000 f840 	bl	80002cc <__udivmoddi4>
 800024c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000250:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000254:	b004      	add	sp, #16
 8000256:	4240      	negs	r0, r0
 8000258:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800025c:	4252      	negs	r2, r2
 800025e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000262:	4770      	bx	lr
 8000264:	4252      	negs	r2, r2
 8000266:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800026a:	f000 f82f 	bl	80002cc <__udivmoddi4>
 800026e:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000272:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000276:	b004      	add	sp, #16
 8000278:	4240      	negs	r0, r0
 800027a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800027e:	4770      	bx	lr
 8000280:	4252      	negs	r2, r2
 8000282:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000286:	f000 f821 	bl	80002cc <__udivmoddi4>
 800028a:	f8dd e004 	ldr.w	lr, [sp, #4]
 800028e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000292:	b004      	add	sp, #16
 8000294:	4252      	negs	r2, r2
 8000296:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800029a:	4770      	bx	lr

0800029c <__aeabi_uldivmod>:
 800029c:	b953      	cbnz	r3, 80002b4 <__aeabi_uldivmod+0x18>
 800029e:	b94a      	cbnz	r2, 80002b4 <__aeabi_uldivmod+0x18>
 80002a0:	2900      	cmp	r1, #0
 80002a2:	bf08      	it	eq
 80002a4:	2800      	cmpeq	r0, #0
 80002a6:	bf1c      	itt	ne
 80002a8:	f04f 31ff 	movne.w	r1, #4294967295
 80002ac:	f04f 30ff 	movne.w	r0, #4294967295
 80002b0:	f000 b97a 	b.w	80005a8 <__aeabi_idiv0>
 80002b4:	f1ad 0c08 	sub.w	ip, sp, #8
 80002b8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002bc:	f000 f806 	bl	80002cc <__udivmoddi4>
 80002c0:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002c4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002c8:	b004      	add	sp, #16
 80002ca:	4770      	bx	lr

080002cc <__udivmoddi4>:
 80002cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002d0:	468c      	mov	ip, r1
 80002d2:	460d      	mov	r5, r1
 80002d4:	4604      	mov	r4, r0
 80002d6:	9e08      	ldr	r6, [sp, #32]
 80002d8:	2b00      	cmp	r3, #0
 80002da:	d151      	bne.n	8000380 <__udivmoddi4+0xb4>
 80002dc:	428a      	cmp	r2, r1
 80002de:	4617      	mov	r7, r2
 80002e0:	d96d      	bls.n	80003be <__udivmoddi4+0xf2>
 80002e2:	fab2 fe82 	clz	lr, r2
 80002e6:	f1be 0f00 	cmp.w	lr, #0
 80002ea:	d00b      	beq.n	8000304 <__udivmoddi4+0x38>
 80002ec:	f1ce 0c20 	rsb	ip, lr, #32
 80002f0:	fa01 f50e 	lsl.w	r5, r1, lr
 80002f4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80002f8:	fa02 f70e 	lsl.w	r7, r2, lr
 80002fc:	ea4c 0c05 	orr.w	ip, ip, r5
 8000300:	fa00 f40e 	lsl.w	r4, r0, lr
 8000304:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 8000308:	0c25      	lsrs	r5, r4, #16
 800030a:	fbbc f8fa 	udiv	r8, ip, sl
 800030e:	fa1f f987 	uxth.w	r9, r7
 8000312:	fb0a cc18 	mls	ip, sl, r8, ip
 8000316:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 800031a:	fb08 f309 	mul.w	r3, r8, r9
 800031e:	42ab      	cmp	r3, r5
 8000320:	d90a      	bls.n	8000338 <__udivmoddi4+0x6c>
 8000322:	19ed      	adds	r5, r5, r7
 8000324:	f108 32ff 	add.w	r2, r8, #4294967295
 8000328:	f080 8123 	bcs.w	8000572 <__udivmoddi4+0x2a6>
 800032c:	42ab      	cmp	r3, r5
 800032e:	f240 8120 	bls.w	8000572 <__udivmoddi4+0x2a6>
 8000332:	f1a8 0802 	sub.w	r8, r8, #2
 8000336:	443d      	add	r5, r7
 8000338:	1aed      	subs	r5, r5, r3
 800033a:	b2a4      	uxth	r4, r4
 800033c:	fbb5 f0fa 	udiv	r0, r5, sl
 8000340:	fb0a 5510 	mls	r5, sl, r0, r5
 8000344:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000348:	fb00 f909 	mul.w	r9, r0, r9
 800034c:	45a1      	cmp	r9, r4
 800034e:	d909      	bls.n	8000364 <__udivmoddi4+0x98>
 8000350:	19e4      	adds	r4, r4, r7
 8000352:	f100 33ff 	add.w	r3, r0, #4294967295
 8000356:	f080 810a 	bcs.w	800056e <__udivmoddi4+0x2a2>
 800035a:	45a1      	cmp	r9, r4
 800035c:	f240 8107 	bls.w	800056e <__udivmoddi4+0x2a2>
 8000360:	3802      	subs	r0, #2
 8000362:	443c      	add	r4, r7
 8000364:	eba4 0409 	sub.w	r4, r4, r9
 8000368:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 800036c:	2100      	movs	r1, #0
 800036e:	2e00      	cmp	r6, #0
 8000370:	d061      	beq.n	8000436 <__udivmoddi4+0x16a>
 8000372:	fa24 f40e 	lsr.w	r4, r4, lr
 8000376:	2300      	movs	r3, #0
 8000378:	6034      	str	r4, [r6, #0]
 800037a:	6073      	str	r3, [r6, #4]
 800037c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000380:	428b      	cmp	r3, r1
 8000382:	d907      	bls.n	8000394 <__udivmoddi4+0xc8>
 8000384:	2e00      	cmp	r6, #0
 8000386:	d054      	beq.n	8000432 <__udivmoddi4+0x166>
 8000388:	2100      	movs	r1, #0
 800038a:	e886 0021 	stmia.w	r6, {r0, r5}
 800038e:	4608      	mov	r0, r1
 8000390:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000394:	fab3 f183 	clz	r1, r3
 8000398:	2900      	cmp	r1, #0
 800039a:	f040 808e 	bne.w	80004ba <__udivmoddi4+0x1ee>
 800039e:	42ab      	cmp	r3, r5
 80003a0:	d302      	bcc.n	80003a8 <__udivmoddi4+0xdc>
 80003a2:	4282      	cmp	r2, r0
 80003a4:	f200 80fa 	bhi.w	800059c <__udivmoddi4+0x2d0>
 80003a8:	1a84      	subs	r4, r0, r2
 80003aa:	eb65 0503 	sbc.w	r5, r5, r3
 80003ae:	2001      	movs	r0, #1
 80003b0:	46ac      	mov	ip, r5
 80003b2:	2e00      	cmp	r6, #0
 80003b4:	d03f      	beq.n	8000436 <__udivmoddi4+0x16a>
 80003b6:	e886 1010 	stmia.w	r6, {r4, ip}
 80003ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003be:	b912      	cbnz	r2, 80003c6 <__udivmoddi4+0xfa>
 80003c0:	2701      	movs	r7, #1
 80003c2:	fbb7 f7f2 	udiv	r7, r7, r2
 80003c6:	fab7 fe87 	clz	lr, r7
 80003ca:	f1be 0f00 	cmp.w	lr, #0
 80003ce:	d134      	bne.n	800043a <__udivmoddi4+0x16e>
 80003d0:	1beb      	subs	r3, r5, r7
 80003d2:	0c3a      	lsrs	r2, r7, #16
 80003d4:	fa1f fc87 	uxth.w	ip, r7
 80003d8:	2101      	movs	r1, #1
 80003da:	fbb3 f8f2 	udiv	r8, r3, r2
 80003de:	0c25      	lsrs	r5, r4, #16
 80003e0:	fb02 3318 	mls	r3, r2, r8, r3
 80003e4:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 80003e8:	fb0c f308 	mul.w	r3, ip, r8
 80003ec:	42ab      	cmp	r3, r5
 80003ee:	d907      	bls.n	8000400 <__udivmoddi4+0x134>
 80003f0:	19ed      	adds	r5, r5, r7
 80003f2:	f108 30ff 	add.w	r0, r8, #4294967295
 80003f6:	d202      	bcs.n	80003fe <__udivmoddi4+0x132>
 80003f8:	42ab      	cmp	r3, r5
 80003fa:	f200 80d1 	bhi.w	80005a0 <__udivmoddi4+0x2d4>
 80003fe:	4680      	mov	r8, r0
 8000400:	1aed      	subs	r5, r5, r3
 8000402:	b2a3      	uxth	r3, r4
 8000404:	fbb5 f0f2 	udiv	r0, r5, r2
 8000408:	fb02 5510 	mls	r5, r2, r0, r5
 800040c:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000410:	fb0c fc00 	mul.w	ip, ip, r0
 8000414:	45a4      	cmp	ip, r4
 8000416:	d907      	bls.n	8000428 <__udivmoddi4+0x15c>
 8000418:	19e4      	adds	r4, r4, r7
 800041a:	f100 33ff 	add.w	r3, r0, #4294967295
 800041e:	d202      	bcs.n	8000426 <__udivmoddi4+0x15a>
 8000420:	45a4      	cmp	ip, r4
 8000422:	f200 80b8 	bhi.w	8000596 <__udivmoddi4+0x2ca>
 8000426:	4618      	mov	r0, r3
 8000428:	eba4 040c 	sub.w	r4, r4, ip
 800042c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000430:	e79d      	b.n	800036e <__udivmoddi4+0xa2>
 8000432:	4631      	mov	r1, r6
 8000434:	4630      	mov	r0, r6
 8000436:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800043a:	f1ce 0420 	rsb	r4, lr, #32
 800043e:	fa05 f30e 	lsl.w	r3, r5, lr
 8000442:	fa07 f70e 	lsl.w	r7, r7, lr
 8000446:	fa20 f804 	lsr.w	r8, r0, r4
 800044a:	0c3a      	lsrs	r2, r7, #16
 800044c:	fa25 f404 	lsr.w	r4, r5, r4
 8000450:	ea48 0803 	orr.w	r8, r8, r3
 8000454:	fbb4 f1f2 	udiv	r1, r4, r2
 8000458:	ea4f 4518 	mov.w	r5, r8, lsr #16
 800045c:	fb02 4411 	mls	r4, r2, r1, r4
 8000460:	fa1f fc87 	uxth.w	ip, r7
 8000464:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 8000468:	fb01 f30c 	mul.w	r3, r1, ip
 800046c:	42ab      	cmp	r3, r5
 800046e:	fa00 f40e 	lsl.w	r4, r0, lr
 8000472:	d909      	bls.n	8000488 <__udivmoddi4+0x1bc>
 8000474:	19ed      	adds	r5, r5, r7
 8000476:	f101 30ff 	add.w	r0, r1, #4294967295
 800047a:	f080 808a 	bcs.w	8000592 <__udivmoddi4+0x2c6>
 800047e:	42ab      	cmp	r3, r5
 8000480:	f240 8087 	bls.w	8000592 <__udivmoddi4+0x2c6>
 8000484:	3902      	subs	r1, #2
 8000486:	443d      	add	r5, r7
 8000488:	1aeb      	subs	r3, r5, r3
 800048a:	fa1f f588 	uxth.w	r5, r8
 800048e:	fbb3 f0f2 	udiv	r0, r3, r2
 8000492:	fb02 3310 	mls	r3, r2, r0, r3
 8000496:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 800049a:	fb00 f30c 	mul.w	r3, r0, ip
 800049e:	42ab      	cmp	r3, r5
 80004a0:	d907      	bls.n	80004b2 <__udivmoddi4+0x1e6>
 80004a2:	19ed      	adds	r5, r5, r7
 80004a4:	f100 38ff 	add.w	r8, r0, #4294967295
 80004a8:	d26f      	bcs.n	800058a <__udivmoddi4+0x2be>
 80004aa:	42ab      	cmp	r3, r5
 80004ac:	d96d      	bls.n	800058a <__udivmoddi4+0x2be>
 80004ae:	3802      	subs	r0, #2
 80004b0:	443d      	add	r5, r7
 80004b2:	1aeb      	subs	r3, r5, r3
 80004b4:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80004b8:	e78f      	b.n	80003da <__udivmoddi4+0x10e>
 80004ba:	f1c1 0720 	rsb	r7, r1, #32
 80004be:	fa22 f807 	lsr.w	r8, r2, r7
 80004c2:	408b      	lsls	r3, r1
 80004c4:	fa05 f401 	lsl.w	r4, r5, r1
 80004c8:	ea48 0303 	orr.w	r3, r8, r3
 80004cc:	fa20 fe07 	lsr.w	lr, r0, r7
 80004d0:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 80004d4:	40fd      	lsrs	r5, r7
 80004d6:	ea4e 0e04 	orr.w	lr, lr, r4
 80004da:	fbb5 f9fc 	udiv	r9, r5, ip
 80004de:	ea4f 441e 	mov.w	r4, lr, lsr #16
 80004e2:	fb0c 5519 	mls	r5, ip, r9, r5
 80004e6:	fa1f f883 	uxth.w	r8, r3
 80004ea:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 80004ee:	fb09 f408 	mul.w	r4, r9, r8
 80004f2:	42ac      	cmp	r4, r5
 80004f4:	fa02 f201 	lsl.w	r2, r2, r1
 80004f8:	fa00 fa01 	lsl.w	sl, r0, r1
 80004fc:	d908      	bls.n	8000510 <__udivmoddi4+0x244>
 80004fe:	18ed      	adds	r5, r5, r3
 8000500:	f109 30ff 	add.w	r0, r9, #4294967295
 8000504:	d243      	bcs.n	800058e <__udivmoddi4+0x2c2>
 8000506:	42ac      	cmp	r4, r5
 8000508:	d941      	bls.n	800058e <__udivmoddi4+0x2c2>
 800050a:	f1a9 0902 	sub.w	r9, r9, #2
 800050e:	441d      	add	r5, r3
 8000510:	1b2d      	subs	r5, r5, r4
 8000512:	fa1f fe8e 	uxth.w	lr, lr
 8000516:	fbb5 f0fc 	udiv	r0, r5, ip
 800051a:	fb0c 5510 	mls	r5, ip, r0, r5
 800051e:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 8000522:	fb00 f808 	mul.w	r8, r0, r8
 8000526:	45a0      	cmp	r8, r4
 8000528:	d907      	bls.n	800053a <__udivmoddi4+0x26e>
 800052a:	18e4      	adds	r4, r4, r3
 800052c:	f100 35ff 	add.w	r5, r0, #4294967295
 8000530:	d229      	bcs.n	8000586 <__udivmoddi4+0x2ba>
 8000532:	45a0      	cmp	r8, r4
 8000534:	d927      	bls.n	8000586 <__udivmoddi4+0x2ba>
 8000536:	3802      	subs	r0, #2
 8000538:	441c      	add	r4, r3
 800053a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800053e:	eba4 0408 	sub.w	r4, r4, r8
 8000542:	fba0 8902 	umull	r8, r9, r0, r2
 8000546:	454c      	cmp	r4, r9
 8000548:	46c6      	mov	lr, r8
 800054a:	464d      	mov	r5, r9
 800054c:	d315      	bcc.n	800057a <__udivmoddi4+0x2ae>
 800054e:	d012      	beq.n	8000576 <__udivmoddi4+0x2aa>
 8000550:	b156      	cbz	r6, 8000568 <__udivmoddi4+0x29c>
 8000552:	ebba 030e 	subs.w	r3, sl, lr
 8000556:	eb64 0405 	sbc.w	r4, r4, r5
 800055a:	fa04 f707 	lsl.w	r7, r4, r7
 800055e:	40cb      	lsrs	r3, r1
 8000560:	431f      	orrs	r7, r3
 8000562:	40cc      	lsrs	r4, r1
 8000564:	6037      	str	r7, [r6, #0]
 8000566:	6074      	str	r4, [r6, #4]
 8000568:	2100      	movs	r1, #0
 800056a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800056e:	4618      	mov	r0, r3
 8000570:	e6f8      	b.n	8000364 <__udivmoddi4+0x98>
 8000572:	4690      	mov	r8, r2
 8000574:	e6e0      	b.n	8000338 <__udivmoddi4+0x6c>
 8000576:	45c2      	cmp	sl, r8
 8000578:	d2ea      	bcs.n	8000550 <__udivmoddi4+0x284>
 800057a:	ebb8 0e02 	subs.w	lr, r8, r2
 800057e:	eb69 0503 	sbc.w	r5, r9, r3
 8000582:	3801      	subs	r0, #1
 8000584:	e7e4      	b.n	8000550 <__udivmoddi4+0x284>
 8000586:	4628      	mov	r0, r5
 8000588:	e7d7      	b.n	800053a <__udivmoddi4+0x26e>
 800058a:	4640      	mov	r0, r8
 800058c:	e791      	b.n	80004b2 <__udivmoddi4+0x1e6>
 800058e:	4681      	mov	r9, r0
 8000590:	e7be      	b.n	8000510 <__udivmoddi4+0x244>
 8000592:	4601      	mov	r1, r0
 8000594:	e778      	b.n	8000488 <__udivmoddi4+0x1bc>
 8000596:	3802      	subs	r0, #2
 8000598:	443c      	add	r4, r7
 800059a:	e745      	b.n	8000428 <__udivmoddi4+0x15c>
 800059c:	4608      	mov	r0, r1
 800059e:	e708      	b.n	80003b2 <__udivmoddi4+0xe6>
 80005a0:	f1a8 0802 	sub.w	r8, r8, #2
 80005a4:	443d      	add	r5, r7
 80005a6:	e72b      	b.n	8000400 <__udivmoddi4+0x134>

080005a8 <__aeabi_idiv0>:
 80005a8:	4770      	bx	lr
 80005aa:	bf00      	nop

080005ac <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80005ac:	b510      	push	{r4, lr}
 80005ae:	4604      	mov	r4, r0
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 80005b0:	4b0e      	ldr	r3, [pc, #56]	; (80005ec <HAL_InitTick+0x40>)
 80005b2:	7818      	ldrb	r0, [r3, #0]
 80005b4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80005b8:	fbb3 f3f0 	udiv	r3, r3, r0
 80005bc:	4a0c      	ldr	r2, [pc, #48]	; (80005f0 <HAL_InitTick+0x44>)
 80005be:	6810      	ldr	r0, [r2, #0]
 80005c0:	fbb0 f0f3 	udiv	r0, r0, r3
 80005c4:	f000 f8a6 	bl	8000714 <HAL_SYSTICK_Config>
 80005c8:	b968      	cbnz	r0, 80005e6 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80005ca:	2c0f      	cmp	r4, #15
 80005cc:	d901      	bls.n	80005d2 <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 80005ce:	2001      	movs	r0, #1
  }

  /* Return function status */
  return HAL_OK;
}
 80005d0:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 80005d2:	2200      	movs	r2, #0
 80005d4:	4621      	mov	r1, r4
 80005d6:	f04f 30ff 	mov.w	r0, #4294967295
 80005da:	f000 f85f 	bl	800069c <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 80005de:	4b05      	ldr	r3, [pc, #20]	; (80005f4 <HAL_InitTick+0x48>)
 80005e0:	601c      	str	r4, [r3, #0]
  return HAL_OK;
 80005e2:	2000      	movs	r0, #0
 80005e4:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80005e6:	2001      	movs	r0, #1
 80005e8:	bd10      	pop	{r4, pc}
 80005ea:	bf00      	nop
 80005ec:	20000000 	.word	0x20000000
 80005f0:	20000100 	.word	0x20000100
 80005f4:	20000004 	.word	0x20000004

080005f8 <HAL_Init>:
{
 80005f8:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80005fa:	4b0b      	ldr	r3, [pc, #44]	; (8000628 <HAL_Init+0x30>)
 80005fc:	681a      	ldr	r2, [r3, #0]
 80005fe:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000602:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8000604:	681a      	ldr	r2, [r3, #0]
 8000606:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800060a:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800060c:	681a      	ldr	r2, [r3, #0]
 800060e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000612:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000614:	2003      	movs	r0, #3
 8000616:	f000 f82f 	bl	8000678 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 800061a:	2000      	movs	r0, #0
 800061c:	f7ff ffc6 	bl	80005ac <HAL_InitTick>
  HAL_MspInit();
 8000620:	f003 f9c7 	bl	80039b2 <HAL_MspInit>
}
 8000624:	2000      	movs	r0, #0
 8000626:	bd08      	pop	{r3, pc}
 8000628:	40023c00 	.word	0x40023c00

0800062c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 800062c:	4a03      	ldr	r2, [pc, #12]	; (800063c <HAL_IncTick+0x10>)
 800062e:	6811      	ldr	r1, [r2, #0]
 8000630:	4b03      	ldr	r3, [pc, #12]	; (8000640 <HAL_IncTick+0x14>)
 8000632:	781b      	ldrb	r3, [r3, #0]
 8000634:	440b      	add	r3, r1
 8000636:	6013      	str	r3, [r2, #0]
 8000638:	4770      	bx	lr
 800063a:	bf00      	nop
 800063c:	2000788c 	.word	0x2000788c
 8000640:	20000000 	.word	0x20000000

08000644 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000644:	4b01      	ldr	r3, [pc, #4]	; (800064c <HAL_GetTick+0x8>)
 8000646:	6818      	ldr	r0, [r3, #0]
}
 8000648:	4770      	bx	lr
 800064a:	bf00      	nop
 800064c:	2000788c 	.word	0x2000788c

08000650 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000650:	b538      	push	{r3, r4, r5, lr}
 8000652:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000654:	f7ff fff6 	bl	8000644 <HAL_GetTick>
 8000658:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800065a:	f1b4 3fff 	cmp.w	r4, #4294967295
 800065e:	d002      	beq.n	8000666 <HAL_Delay+0x16>
  {
    wait += (uint32_t)(uwTickFreq);
 8000660:	4b04      	ldr	r3, [pc, #16]	; (8000674 <HAL_Delay+0x24>)
 8000662:	781b      	ldrb	r3, [r3, #0]
 8000664:	441c      	add	r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 8000666:	f7ff ffed 	bl	8000644 <HAL_GetTick>
 800066a:	1b40      	subs	r0, r0, r5
 800066c:	4284      	cmp	r4, r0
 800066e:	d8fa      	bhi.n	8000666 <HAL_Delay+0x16>
  {
  }
}
 8000670:	bd38      	pop	{r3, r4, r5, pc}
 8000672:	bf00      	nop
 8000674:	20000000 	.word	0x20000000

08000678 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000678:	4a07      	ldr	r2, [pc, #28]	; (8000698 <HAL_NVIC_SetPriorityGrouping+0x20>)
 800067a:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800067c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000680:	041b      	lsls	r3, r3, #16
 8000682:	0c1b      	lsrs	r3, r3, #16
 8000684:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000688:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 800068c:	0200      	lsls	r0, r0, #8
 800068e:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 8000692:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8000694:	60d3      	str	r3, [r2, #12]
 8000696:	4770      	bx	lr
 8000698:	e000ed00 	.word	0xe000ed00

0800069c <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800069c:	b430      	push	{r4, r5}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800069e:	4b15      	ldr	r3, [pc, #84]	; (80006f4 <HAL_NVIC_SetPriority+0x58>)
 80006a0:	68dc      	ldr	r4, [r3, #12]
 80006a2:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80006a6:	f1c4 0307 	rsb	r3, r4, #7
 80006aa:	2b04      	cmp	r3, #4
 80006ac:	bf28      	it	cs
 80006ae:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80006b0:	1d25      	adds	r5, r4, #4
 80006b2:	2d06      	cmp	r5, #6
 80006b4:	bf8c      	ite	hi
 80006b6:	1ee5      	subhi	r5, r4, #3
 80006b8:	2500      	movls	r5, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80006ba:	2401      	movs	r4, #1
 80006bc:	fa04 f303 	lsl.w	r3, r4, r3
 80006c0:	3b01      	subs	r3, #1
 80006c2:	4019      	ands	r1, r3
 80006c4:	40a9      	lsls	r1, r5
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80006c6:	40ac      	lsls	r4, r5
 80006c8:	3c01      	subs	r4, #1
 80006ca:	4022      	ands	r2, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80006cc:	4311      	orrs	r1, r2
  if ((int32_t)(IRQn) < 0)
 80006ce:	2800      	cmp	r0, #0
 80006d0:	db09      	blt.n	80006e6 <HAL_NVIC_SetPriority+0x4a>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006d2:	0109      	lsls	r1, r1, #4
 80006d4:	b2c9      	uxtb	r1, r1
 80006d6:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80006da:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 80006de:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80006e2:	bc30      	pop	{r4, r5}
 80006e4:	4770      	bx	lr
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006e6:	f000 000f 	and.w	r0, r0, #15
 80006ea:	0109      	lsls	r1, r1, #4
 80006ec:	b2c9      	uxtb	r1, r1
 80006ee:	4b02      	ldr	r3, [pc, #8]	; (80006f8 <HAL_NVIC_SetPriority+0x5c>)
 80006f0:	5419      	strb	r1, [r3, r0]
 80006f2:	e7f6      	b.n	80006e2 <HAL_NVIC_SetPriority+0x46>
 80006f4:	e000ed00 	.word	0xe000ed00
 80006f8:	e000ed14 	.word	0xe000ed14

080006fc <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80006fc:	0942      	lsrs	r2, r0, #5
 80006fe:	f000 001f 	and.w	r0, r0, #31
 8000702:	2301      	movs	r3, #1
 8000704:	fa03 f000 	lsl.w	r0, r3, r0
 8000708:	4b01      	ldr	r3, [pc, #4]	; (8000710 <HAL_NVIC_EnableIRQ+0x14>)
 800070a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 800070e:	4770      	bx	lr
 8000710:	e000e100 	.word	0xe000e100

08000714 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000714:	3801      	subs	r0, #1
 8000716:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800071a:	d20a      	bcs.n	8000732 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800071c:	4b06      	ldr	r3, [pc, #24]	; (8000738 <HAL_SYSTICK_Config+0x24>)
 800071e:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000720:	21f0      	movs	r1, #240	; 0xf0
 8000722:	4a06      	ldr	r2, [pc, #24]	; (800073c <HAL_SYSTICK_Config+0x28>)
 8000724:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000728:	2000      	movs	r0, #0
 800072a:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800072c:	2207      	movs	r2, #7
 800072e:	601a      	str	r2, [r3, #0]
 8000730:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000732:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000734:	4770      	bx	lr
 8000736:	bf00      	nop
 8000738:	e000e010 	.word	0xe000e010
 800073c:	e000ed00 	.word	0xe000ed00

08000740 <HAL_SYSTICK_CLKSourceConfig>:
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000740:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000742:	4a04      	ldr	r2, [pc, #16]	; (8000754 <HAL_SYSTICK_CLKSourceConfig+0x14>)
 8000744:	6813      	ldr	r3, [r2, #0]
 8000746:	bf0c      	ite	eq
 8000748:	f043 0304 	orreq.w	r3, r3, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 800074c:	f023 0304 	bicne.w	r3, r3, #4
 8000750:	6013      	str	r3, [r2, #0]
 8000752:	4770      	bx	lr
 8000754:	e000e010 	.word	0xe000e010

08000758 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8000758:	4770      	bx	lr

0800075a <HAL_SYSTICK_IRQHandler>:
{
 800075a:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 800075c:	f7ff fffc 	bl	8000758 <HAL_SYSTICK_Callback>
 8000760:	bd08      	pop	{r3, pc}
	...

08000764 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000764:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000768:	b083      	sub	sp, #12
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 800076a:	2600      	movs	r6, #0
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 800076c:	f04f 0e01 	mov.w	lr, #1
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000770:	f04f 0903 	mov.w	r9, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000774:	f8df c180 	ldr.w	ip, [pc, #384]	; 80008f8 <HAL_GPIO_Init+0x194>

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000778:	f8df a180 	ldr.w	sl, [pc, #384]	; 80008fc <HAL_GPIO_Init+0x198>
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800077c:	4f5c      	ldr	r7, [pc, #368]	; (80008f0 <HAL_GPIO_Init+0x18c>)
 800077e:	e052      	b.n	8000826 <HAL_GPIO_Init+0xc2>
        temp = GPIOx->AFR[position >> 3U];
 8000780:	08f4      	lsrs	r4, r6, #3
 8000782:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8000786:	6a25      	ldr	r5, [r4, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8000788:	f006 0207 	and.w	r2, r6, #7
 800078c:	ea4f 0b82 	mov.w	fp, r2, lsl #2
 8000790:	220f      	movs	r2, #15
 8000792:	fa02 f20b 	lsl.w	r2, r2, fp
 8000796:	ea25 0502 	bic.w	r5, r5, r2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 800079a:	690a      	ldr	r2, [r1, #16]
 800079c:	fa02 f20b 	lsl.w	r2, r2, fp
 80007a0:	432a      	orrs	r2, r5
        GPIOx->AFR[position >> 3U] = temp;
 80007a2:	6222      	str	r2, [r4, #32]
 80007a4:	e04b      	b.n	800083e <HAL_GPIO_Init+0xda>
        temp = GPIOx->OSPEEDR; 
 80007a6:	6882      	ldr	r2, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80007a8:	ea04 0b02 	and.w	fp, r4, r2
        temp |= (GPIO_Init->Speed << (position * 2U));
 80007ac:	68ca      	ldr	r2, [r1, #12]
 80007ae:	40aa      	lsls	r2, r5
 80007b0:	ea42 020b 	orr.w	r2, r2, fp
        GPIOx->OSPEEDR = temp;
 80007b4:	6082      	str	r2, [r0, #8]
        temp = GPIOx->OTYPER;
 80007b6:	6842      	ldr	r2, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80007b8:	ea22 0b03 	bic.w	fp, r2, r3
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80007bc:	684a      	ldr	r2, [r1, #4]
 80007be:	f3c2 1300 	ubfx	r3, r2, #4, #1
 80007c2:	40b3      	lsls	r3, r6
 80007c4:	ea43 030b 	orr.w	r3, r3, fp
        GPIOx->OTYPER = temp;
 80007c8:	6043      	str	r3, [r0, #4]
 80007ca:	e04c      	b.n	8000866 <HAL_GPIO_Init+0x102>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80007cc:	2200      	movs	r2, #0
 80007ce:	40a2      	lsls	r2, r4
 80007d0:	432a      	orrs	r2, r5
        SYSCFG->EXTICR[position >> 2U] = temp;
 80007d2:	609a      	str	r2, [r3, #8]
        temp = EXTI->IMR;
 80007d4:	683b      	ldr	r3, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 80007d6:	ea6f 0408 	mvn.w	r4, r8
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80007da:	684a      	ldr	r2, [r1, #4]
 80007dc:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 80007e0:	bf0c      	ite	eq
 80007e2:	4023      	andeq	r3, r4
        {
          temp |= iocurrent;
 80007e4:	ea48 0303 	orrne.w	r3, r8, r3
        }
        EXTI->IMR = temp;
 80007e8:	603b      	str	r3, [r7, #0]

        temp = EXTI->EMR;
 80007ea:	687a      	ldr	r2, [r7, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80007ec:	684b      	ldr	r3, [r1, #4]
 80007ee:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 80007f2:	bf0c      	ite	eq
 80007f4:	4022      	andeq	r2, r4
        {
          temp |= iocurrent;
 80007f6:	ea48 0202 	orrne.w	r2, r8, r2
        }
        EXTI->EMR = temp;
 80007fa:	607a      	str	r2, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 80007fc:	68ba      	ldr	r2, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80007fe:	684b      	ldr	r3, [r1, #4]
 8000800:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 8000804:	bf0c      	ite	eq
 8000806:	4022      	andeq	r2, r4
        {
          temp |= iocurrent;
 8000808:	ea48 0202 	orrne.w	r2, r8, r2
        }
        EXTI->RTSR = temp;
 800080c:	60ba      	str	r2, [r7, #8]

        temp = EXTI->FTSR;
 800080e:	68fb      	ldr	r3, [r7, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000810:	684a      	ldr	r2, [r1, #4]
 8000812:	f412 1f00 	tst.w	r2, #2097152	; 0x200000
        temp &= ~((uint32_t)iocurrent);
 8000816:	bf0c      	ite	eq
 8000818:	4023      	andeq	r3, r4
        {
          temp |= iocurrent;
 800081a:	ea48 0303 	orrne.w	r3, r8, r3
        }
        EXTI->FTSR = temp;
 800081e:	60fb      	str	r3, [r7, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000820:	3601      	adds	r6, #1
 8000822:	2e10      	cmp	r6, #16
 8000824:	d060      	beq.n	80008e8 <HAL_GPIO_Init+0x184>
    ioposition = 0x01U << position;
 8000826:	fa0e f306 	lsl.w	r3, lr, r6
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800082a:	680a      	ldr	r2, [r1, #0]
 800082c:	ea03 0802 	and.w	r8, r3, r2
    if(iocurrent == ioposition)
 8000830:	4543      	cmp	r3, r8
 8000832:	d1f5      	bne.n	8000820 <HAL_GPIO_Init+0xbc>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000834:	684a      	ldr	r2, [r1, #4]
 8000836:	f022 0210 	bic.w	r2, r2, #16
 800083a:	2a02      	cmp	r2, #2
 800083c:	d0a0      	beq.n	8000780 <HAL_GPIO_Init+0x1c>
      temp = GPIOx->MODER;
 800083e:	6802      	ldr	r2, [r0, #0]
 8000840:	0075      	lsls	r5, r6, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000842:	fa09 f405 	lsl.w	r4, r9, r5
 8000846:	43e4      	mvns	r4, r4
 8000848:	ea02 0b04 	and.w	fp, r2, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800084c:	684a      	ldr	r2, [r1, #4]
 800084e:	f002 0203 	and.w	r2, r2, #3
 8000852:	40aa      	lsls	r2, r5
 8000854:	ea42 020b 	orr.w	r2, r2, fp
      GPIOx->MODER = temp;
 8000858:	6002      	str	r2, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800085a:	684a      	ldr	r2, [r1, #4]
 800085c:	f022 0210 	bic.w	r2, r2, #16
 8000860:	3a01      	subs	r2, #1
 8000862:	2a01      	cmp	r2, #1
 8000864:	d99f      	bls.n	80007a6 <HAL_GPIO_Init+0x42>
      temp = GPIOx->PUPDR;
 8000866:	68c3      	ldr	r3, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8000868:	401c      	ands	r4, r3
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800086a:	688b      	ldr	r3, [r1, #8]
 800086c:	fa03 f505 	lsl.w	r5, r3, r5
 8000870:	4325      	orrs	r5, r4
      GPIOx->PUPDR = temp;
 8000872:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000874:	684b      	ldr	r3, [r1, #4]
 8000876:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 800087a:	d0d1      	beq.n	8000820 <HAL_GPIO_Init+0xbc>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800087c:	2300      	movs	r3, #0
 800087e:	9301      	str	r3, [sp, #4]
 8000880:	f8dc 3044 	ldr.w	r3, [ip, #68]	; 0x44
 8000884:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000888:	f8cc 3044 	str.w	r3, [ip, #68]	; 0x44
 800088c:	f8dc 3044 	ldr.w	r3, [ip, #68]	; 0x44
 8000890:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000894:	9301      	str	r3, [sp, #4]
 8000896:	9b01      	ldr	r3, [sp, #4]
 8000898:	f026 0303 	bic.w	r3, r6, #3
 800089c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80008a0:	f503 339c 	add.w	r3, r3, #79872	; 0x13800
        temp = SYSCFG->EXTICR[position >> 2U];
 80008a4:	689d      	ldr	r5, [r3, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 80008a6:	f006 0203 	and.w	r2, r6, #3
 80008aa:	0094      	lsls	r4, r2, #2
 80008ac:	220f      	movs	r2, #15
 80008ae:	40a2      	lsls	r2, r4
 80008b0:	ea25 0502 	bic.w	r5, r5, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80008b4:	4550      	cmp	r0, sl
 80008b6:	d089      	beq.n	80007cc <HAL_GPIO_Init+0x68>
 80008b8:	4a0e      	ldr	r2, [pc, #56]	; (80008f4 <HAL_GPIO_Init+0x190>)
 80008ba:	4290      	cmp	r0, r2
 80008bc:	d00e      	beq.n	80008dc <HAL_GPIO_Init+0x178>
 80008be:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80008c2:	4290      	cmp	r0, r2
 80008c4:	d00c      	beq.n	80008e0 <HAL_GPIO_Init+0x17c>
 80008c6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80008ca:	4290      	cmp	r0, r2
 80008cc:	d00a      	beq.n	80008e4 <HAL_GPIO_Init+0x180>
 80008ce:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80008d2:	4290      	cmp	r0, r2
 80008d4:	bf0c      	ite	eq
 80008d6:	2204      	moveq	r2, #4
 80008d8:	2207      	movne	r2, #7
 80008da:	e778      	b.n	80007ce <HAL_GPIO_Init+0x6a>
 80008dc:	4672      	mov	r2, lr
 80008de:	e776      	b.n	80007ce <HAL_GPIO_Init+0x6a>
 80008e0:	2202      	movs	r2, #2
 80008e2:	e774      	b.n	80007ce <HAL_GPIO_Init+0x6a>
 80008e4:	464a      	mov	r2, r9
 80008e6:	e772      	b.n	80007ce <HAL_GPIO_Init+0x6a>
      }
    }
  }
}
 80008e8:	b003      	add	sp, #12
 80008ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80008ee:	bf00      	nop
 80008f0:	40013c00 	.word	0x40013c00
 80008f4:	40020400 	.word	0x40020400
 80008f8:	40023800 	.word	0x40023800
 80008fc:	40020000 	.word	0x40020000

08000900 <HAL_PCD_Init>:
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8000900:	2800      	cmp	r0, #0
 8000902:	d065      	beq.n	80009d0 <HAL_PCD_Init+0xd0>
{ 
 8000904:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000906:	b08b      	sub	sp, #44	; 0x2c
 8000908:	4605      	mov	r5, r0
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 800090a:	2303      	movs	r3, #3
 800090c:	f880 33b9 	strb.w	r3, [r0, #953]	; 0x3b9
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);
 8000910:	f003 f8e6 	bl	8003ae0 <HAL_PCD_MspInit>

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 8000914:	6828      	ldr	r0, [r5, #0]
 8000916:	f001 f972 	bl	8001bfe <USB_DisableGlobalInt>
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 800091a:	462c      	mov	r4, r5
 800091c:	f854 7b10 	ldr.w	r7, [r4], #16
 8000920:	466e      	mov	r6, sp
 8000922:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000924:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000926:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000928:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800092a:	e894 0003 	ldmia.w	r4, {r0, r1}
 800092e:	e886 0003 	stmia.w	r6, {r0, r1}
 8000932:	1d2b      	adds	r3, r5, #4
 8000934:	cb0e      	ldmia	r3, {r1, r2, r3}
 8000936:	4638      	mov	r0, r7
 8000938:	f001 f91d 	bl	8001b76 <USB_CoreInit>
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 800093c:	2100      	movs	r1, #0
 800093e:	6828      	ldr	r0, [r5, #0]
 8000940:	f001 f963 	bl	8001c0a <USB_SetCurrentMode>
 8000944:	462b      	mov	r3, r5
 8000946:	462a      	mov	r2, r5
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8000948:	2100      	movs	r1, #0
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 800094a:	2001      	movs	r0, #1
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 800094c:	460c      	mov	r4, r1
   hpcd->IN_ep[i].is_in = 1U;
 800094e:	f882 0039 	strb.w	r0, [r2, #57]	; 0x39
   hpcd->IN_ep[i].num = i;
 8000952:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
   hpcd->IN_ep[i].tx_fifo_num = i;
 8000956:	87d1      	strh	r1, [r2, #62]	; 0x3e
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000958:	f882 403b 	strb.w	r4, [r2, #59]	; 0x3b
   hpcd->IN_ep[i].maxpacket = 0U;
 800095c:	6414      	str	r4, [r2, #64]	; 0x40
   hpcd->IN_ep[i].xfer_buff = 0U;
 800095e:	6454      	str	r4, [r2, #68]	; 0x44
   hpcd->IN_ep[i].xfer_len = 0U;
 8000960:	64d4      	str	r4, [r2, #76]	; 0x4c
 for (i = 0U; i < 15U; i++)
 8000962:	3101      	adds	r1, #1
 8000964:	321c      	adds	r2, #28
 8000966:	290f      	cmp	r1, #15
 8000968:	d1f1      	bne.n	800094e <HAL_PCD_Init+0x4e>
 800096a:	2100      	movs	r1, #0
 }
 
 for (i = 0U; i < 15U; i++)
 {
   hpcd->OUT_ep[i].is_in = 0U;
 800096c:	460a      	mov	r2, r1
 800096e:	f883 21f9 	strb.w	r2, [r3, #505]	; 0x1f9
   hpcd->OUT_ep[i].num = i;
 8000972:	f883 11f8 	strb.w	r1, [r3, #504]	; 0x1f8
   hpcd->IN_ep[i].tx_fifo_num = i;
 8000976:	87d9      	strh	r1, [r3, #62]	; 0x3e
   /* Control until ep is activated */
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8000978:	f883 21fb 	strb.w	r2, [r3, #507]	; 0x1fb
   hpcd->OUT_ep[i].maxpacket = 0U;
 800097c:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
   hpcd->OUT_ep[i].xfer_buff = 0U;
 8000980:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
   hpcd->OUT_ep[i].xfer_len = 0U;
 8000984:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000988:	682c      	ldr	r4, [r5, #0]
 800098a:	f101 0040 	add.w	r0, r1, #64	; 0x40
 800098e:	eb04 0480 	add.w	r4, r4, r0, lsl #2
 8000992:	6062      	str	r2, [r4, #4]
 for (i = 0U; i < 15U; i++)
 8000994:	3101      	adds	r1, #1
 8000996:	331c      	adds	r3, #28
 8000998:	290f      	cmp	r1, #15
 800099a:	d1e8      	bne.n	800096e <HAL_PCD_Init+0x6e>
 }
 
 /* Init Device */
 USB_DevInit(hpcd->Instance, hpcd->Init);
 800099c:	462c      	mov	r4, r5
 800099e:	f854 7b10 	ldr.w	r7, [r4], #16
 80009a2:	466e      	mov	r6, sp
 80009a4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80009a6:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80009a8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80009aa:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80009ac:	e894 0003 	ldmia.w	r4, {r0, r1}
 80009b0:	e886 0003 	stmia.w	r6, {r0, r1}
 80009b4:	1d2b      	adds	r3, r5, #4
 80009b6:	cb0e      	ldmia	r3, {r1, r2, r3}
 80009b8:	4638      	mov	r0, r7
 80009ba:	f001 f93d 	bl	8001c38 <USB_DevInit>
 
 hpcd->State= HAL_PCD_STATE_READY;
 80009be:	2301      	movs	r3, #1
 80009c0:	f885 33b9 	strb.w	r3, [r5, #953]	; 0x3b9
 {
   HAL_PCDEx_ActivateBCD(hpcd);
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 80009c4:	6828      	ldr	r0, [r5, #0]
 80009c6:	f001 fd15 	bl	80023f4 <USB_DevDisconnect>
 return HAL_OK;
 80009ca:	2000      	movs	r0, #0
}
 80009cc:	b00b      	add	sp, #44	; 0x2c
 80009ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_ERROR;
 80009d0:	2001      	movs	r0, #1
 80009d2:	4770      	bx	lr

080009d4 <HAL_PCD_Start>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 80009d4:	f890 33b8 	ldrb.w	r3, [r0, #952]	; 0x3b8
 80009d8:	2b01      	cmp	r3, #1
 80009da:	d101      	bne.n	80009e0 <HAL_PCD_Start+0xc>
 80009dc:	2002      	movs	r0, #2
 80009de:	4770      	bx	lr
{ 
 80009e0:	b510      	push	{r4, lr}
 80009e2:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 80009e4:	2301      	movs	r3, #1
 80009e6:	f880 33b8 	strb.w	r3, [r0, #952]	; 0x3b8
  USB_DevConnect (hpcd->Instance);  
 80009ea:	6800      	ldr	r0, [r0, #0]
 80009ec:	f001 fcf6 	bl	80023dc <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 80009f0:	6820      	ldr	r0, [r4, #0]
 80009f2:	f001 f8fe 	bl	8001bf2 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd); 
 80009f6:	2000      	movs	r0, #0
 80009f8:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 80009fc:	bd10      	pop	{r4, pc}
	...

08000a00 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8000a00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000a04:	b089      	sub	sp, #36	; 0x24
 8000a06:	4604      	mov	r4, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8000a08:	f8d0 8000 	ldr.w	r8, [r0]
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000U;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8000a0c:	4640      	mov	r0, r8
 8000a0e:	f001 fd2d 	bl	800246c <USB_GetMode>
 8000a12:	b110      	cbz	r0, 8000a1a <HAL_PCD_IRQHandler+0x1a>
        HAL_PCD_DisconnectCallback(hpcd);
      }
      hpcd->Instance->GOTGINT |= temp;
    }
  }
}
 8000a14:	b009      	add	sp, #36	; 0x24
 8000a16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000a1a:	4681      	mov	r9, r0
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
 8000a1c:	6820      	ldr	r0, [r4, #0]
 8000a1e:	f001 fcf5 	bl	800240c <USB_ReadInterrupts>
 8000a22:	2800      	cmp	r0, #0
 8000a24:	d0f6      	beq.n	8000a14 <HAL_PCD_IRQHandler+0x14>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8000a26:	6820      	ldr	r0, [r4, #0]
 8000a28:	f001 fcf0 	bl	800240c <USB_ReadInterrupts>
 8000a2c:	f010 0f02 	tst.w	r0, #2
 8000a30:	d004      	beq.n	8000a3c <HAL_PCD_IRQHandler+0x3c>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8000a32:	6822      	ldr	r2, [r4, #0]
 8000a34:	6953      	ldr	r3, [r2, #20]
 8000a36:	f003 0302 	and.w	r3, r3, #2
 8000a3a:	6153      	str	r3, [r2, #20]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8000a3c:	6820      	ldr	r0, [r4, #0]
 8000a3e:	f001 fce5 	bl	800240c <USB_ReadInterrupts>
 8000a42:	f410 2f00 	tst.w	r0, #524288	; 0x80000
 8000a46:	d176      	bne.n	8000b36 <HAL_PCD_IRQHandler+0x136>
  uint32_t i = 0U, ep_intr = 0U, epint = 0U, epnum = 0U;
 8000a48:	46ca      	mov	sl, r9
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8000a4a:	6820      	ldr	r0, [r4, #0]
 8000a4c:	f001 fcde 	bl	800240c <USB_ReadInterrupts>
 8000a50:	f410 2f80 	tst.w	r0, #262144	; 0x40000
 8000a54:	f040 80ca 	bne.w	8000bec <HAL_PCD_IRQHandler+0x1ec>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8000a58:	6820      	ldr	r0, [r4, #0]
 8000a5a:	f001 fcd7 	bl	800240c <USB_ReadInterrupts>
 8000a5e:	2800      	cmp	r0, #0
 8000a60:	f2c0 8181 	blt.w	8000d66 <HAL_PCD_IRQHandler+0x366>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 8000a64:	6820      	ldr	r0, [r4, #0]
 8000a66:	f001 fcd1 	bl	800240c <USB_ReadInterrupts>
 8000a6a:	f410 6f00 	tst.w	r0, #2048	; 0x800
 8000a6e:	d00a      	beq.n	8000a86 <HAL_PCD_IRQHandler+0x86>
      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8000a70:	f8d8 3808 	ldr.w	r3, [r8, #2056]	; 0x808
 8000a74:	f013 0f01 	tst.w	r3, #1
 8000a78:	f040 8184 	bne.w	8000d84 <HAL_PCD_IRQHandler+0x384>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8000a7c:	6822      	ldr	r2, [r4, #0]
 8000a7e:	6953      	ldr	r3, [r2, #20]
 8000a80:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8000a84:	6153      	str	r3, [r2, #20]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8000a86:	6820      	ldr	r0, [r4, #0]
 8000a88:	f001 fcc0 	bl	800240c <USB_ReadInterrupts>
 8000a8c:	f410 5f80 	tst.w	r0, #4096	; 0x1000
 8000a90:	f040 817c 	bne.w	8000d8c <HAL_PCD_IRQHandler+0x38c>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8000a94:	6820      	ldr	r0, [r4, #0]
 8000a96:	f001 fcb9 	bl	800240c <USB_ReadInterrupts>
 8000a9a:	f410 5f00 	tst.w	r0, #8192	; 0x2000
 8000a9e:	f040 81bb 	bne.w	8000e18 <HAL_PCD_IRQHandler+0x418>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8000aa2:	6820      	ldr	r0, [r4, #0]
 8000aa4:	f001 fcb2 	bl	800240c <USB_ReadInterrupts>
 8000aa8:	f010 0f10 	tst.w	r0, #16
 8000aac:	d015      	beq.n	8000ada <HAL_PCD_IRQHandler+0xda>
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000aae:	6822      	ldr	r2, [r4, #0]
 8000ab0:	6993      	ldr	r3, [r2, #24]
 8000ab2:	f023 0310 	bic.w	r3, r3, #16
 8000ab6:	6193      	str	r3, [r2, #24]
      temp = USBx->GRXSTSP;
 8000ab8:	f8d8 5020 	ldr.w	r5, [r8, #32]
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8000abc:	f005 060f 	and.w	r6, r5, #15
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 8000ac0:	f3c5 4343 	ubfx	r3, r5, #17, #4
 8000ac4:	2b02      	cmp	r3, #2
 8000ac6:	f000 8237 	beq.w	8000f38 <HAL_PCD_IRQHandler+0x538>
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_SETUP_UPDT)
 8000aca:	2b06      	cmp	r3, #6
 8000acc:	f000 8254 	beq.w	8000f78 <HAL_PCD_IRQHandler+0x578>
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000ad0:	6822      	ldr	r2, [r4, #0]
 8000ad2:	6993      	ldr	r3, [r2, #24]
 8000ad4:	f043 0310 	orr.w	r3, r3, #16
 8000ad8:	6193      	str	r3, [r2, #24]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8000ada:	6820      	ldr	r0, [r4, #0]
 8000adc:	f001 fc96 	bl	800240c <USB_ReadInterrupts>
 8000ae0:	f010 0f08 	tst.w	r0, #8
 8000ae4:	f040 825a 	bne.w	8000f9c <HAL_PCD_IRQHandler+0x59c>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8000ae8:	6820      	ldr	r0, [r4, #0]
 8000aea:	f001 fc8f 	bl	800240c <USB_ReadInterrupts>
 8000aee:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
 8000af2:	f040 825c 	bne.w	8000fae <HAL_PCD_IRQHandler+0x5ae>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8000af6:	6820      	ldr	r0, [r4, #0]
 8000af8:	f001 fc88 	bl	800240c <USB_ReadInterrupts>
 8000afc:	f410 1f00 	tst.w	r0, #2097152	; 0x200000
 8000b00:	f040 8260 	bne.w	8000fc4 <HAL_PCD_IRQHandler+0x5c4>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8000b04:	6820      	ldr	r0, [r4, #0]
 8000b06:	f001 fc81 	bl	800240c <USB_ReadInterrupts>
 8000b0a:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 8000b0e:	f040 8264 	bne.w	8000fda <HAL_PCD_IRQHandler+0x5da>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8000b12:	6820      	ldr	r0, [r4, #0]
 8000b14:	f001 fc7a 	bl	800240c <USB_ReadInterrupts>
 8000b18:	f010 0f04 	tst.w	r0, #4
 8000b1c:	f43f af7a 	beq.w	8000a14 <HAL_PCD_IRQHandler+0x14>
      temp = hpcd->Instance->GOTGINT;
 8000b20:	6823      	ldr	r3, [r4, #0]
 8000b22:	685d      	ldr	r5, [r3, #4]
      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8000b24:	f015 0f04 	tst.w	r5, #4
 8000b28:	f040 8260 	bne.w	8000fec <HAL_PCD_IRQHandler+0x5ec>
      hpcd->Instance->GOTGINT |= temp;
 8000b2c:	6823      	ldr	r3, [r4, #0]
 8000b2e:	685a      	ldr	r2, [r3, #4]
 8000b30:	4315      	orrs	r5, r2
 8000b32:	605d      	str	r5, [r3, #4]
 8000b34:	e76e      	b.n	8000a14 <HAL_PCD_IRQHandler+0x14>
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8000b36:	6820      	ldr	r0, [r4, #0]
 8000b38:	f001 fc6c 	bl	8002414 <USB_ReadDevAllOutEpInterrupt>
      while ( ep_intr )
 8000b3c:	4605      	mov	r5, r0
 8000b3e:	2800      	cmp	r0, #0
 8000b40:	d052      	beq.n	8000be8 <HAL_PCD_IRQHandler+0x1e8>
 8000b42:	f508 6630 	add.w	r6, r8, #2816	; 0xb00
 8000b46:	4627      	mov	r7, r4
 8000b48:	46ca      	mov	sl, r9
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8000b4a:	f8cd 8008 	str.w	r8, [sp, #8]
 8000b4e:	e01b      	b.n	8000b88 <HAL_PCD_IRQHandler+0x188>
              hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
 8000b50:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 8000b54:	6933      	ldr	r3, [r6, #16]
 8000b56:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8000b5a:	1ad3      	subs	r3, r2, r3
 8000b5c:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
              hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
 8000b60:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 8000b64:	4413      	add	r3, r2
 8000b66:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
 8000b6a:	e01f      	b.n	8000bac <HAL_PCD_IRQHandler+0x1ac>
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8000b6c:	f018 0f08 	tst.w	r8, #8
 8000b70:	d131      	bne.n	8000bd6 <HAL_PCD_IRQHandler+0x1d6>
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8000b72:	f018 0f10 	tst.w	r8, #16
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8000b76:	bf1c      	itt	ne
 8000b78:	2310      	movne	r3, #16
 8000b7a:	60b3      	strne	r3, [r6, #8]
        epnum++;
 8000b7c:	f10a 0a01 	add.w	sl, sl, #1
 8000b80:	3620      	adds	r6, #32
 8000b82:	371c      	adds	r7, #28
      while ( ep_intr )
 8000b84:	086d      	lsrs	r5, r5, #1
 8000b86:	d02c      	beq.n	8000be2 <HAL_PCD_IRQHandler+0x1e2>
        if (ep_intr & 0x1U)
 8000b88:	f015 0f01 	tst.w	r5, #1
 8000b8c:	d0f6      	beq.n	8000b7c <HAL_PCD_IRQHandler+0x17c>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8000b8e:	fa5f fb8a 	uxtb.w	fp, sl
 8000b92:	4659      	mov	r1, fp
 8000b94:	6820      	ldr	r0, [r4, #0]
 8000b96:	f001 fc4d 	bl	8002434 <USB_ReadDevOutEPInterrupt>
 8000b9a:	4680      	mov	r8, r0
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8000b9c:	f010 0f01 	tst.w	r0, #1
 8000ba0:	d0e4      	beq.n	8000b6c <HAL_PCD_IRQHandler+0x16c>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8000ba2:	2301      	movs	r3, #1
 8000ba4:	60b3      	str	r3, [r6, #8]
            if(hpcd->Init.dma_enable == 1U)
 8000ba6:	6923      	ldr	r3, [r4, #16]
 8000ba8:	2b01      	cmp	r3, #1
 8000baa:	d0d1      	beq.n	8000b50 <HAL_PCD_IRQHandler+0x150>
            HAL_PCD_DataOutStageCallback(hpcd, epnum);
 8000bac:	4659      	mov	r1, fp
 8000bae:	4620      	mov	r0, r4
 8000bb0:	f002 ffdc 	bl	8003b6c <HAL_PCD_DataOutStageCallback>
            if(hpcd->Init.dma_enable == 1U)
 8000bb4:	6923      	ldr	r3, [r4, #16]
 8000bb6:	2b01      	cmp	r3, #1
 8000bb8:	d1d8      	bne.n	8000b6c <HAL_PCD_IRQHandler+0x16c>
              if((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8000bba:	f1ba 0f00 	cmp.w	sl, #0
 8000bbe:	d1d5      	bne.n	8000b6c <HAL_PCD_IRQHandler+0x16c>
 8000bc0:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
 8000bc4:	2b00      	cmp	r3, #0
 8000bc6:	d1d1      	bne.n	8000b6c <HAL_PCD_IRQHandler+0x16c>
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8000bc8:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 8000bcc:	2101      	movs	r1, #1
 8000bce:	6820      	ldr	r0, [r4, #0]
 8000bd0:	f001 fc6c 	bl	80024ac <USB_EP0_OutStart>
 8000bd4:	e7ca      	b.n	8000b6c <HAL_PCD_IRQHandler+0x16c>
            HAL_PCD_SetupStageCallback(hpcd);
 8000bd6:	4620      	mov	r0, r4
 8000bd8:	f002 ffc0 	bl	8003b5c <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8000bdc:	2308      	movs	r3, #8
 8000bde:	60b3      	str	r3, [r6, #8]
 8000be0:	e7c7      	b.n	8000b72 <HAL_PCD_IRQHandler+0x172>
 8000be2:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8000be6:	e730      	b.n	8000a4a <HAL_PCD_IRQHandler+0x4a>
      epnum = 0U;
 8000be8:	4682      	mov	sl, r0
 8000bea:	e72e      	b.n	8000a4a <HAL_PCD_IRQHandler+0x4a>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8000bec:	6820      	ldr	r0, [r4, #0]
 8000bee:	f001 fc19 	bl	8002424 <USB_ReadDevAllInEpInterrupt>
      while ( ep_intr )
 8000bf2:	4683      	mov	fp, r0
 8000bf4:	2800      	cmp	r0, #0
 8000bf6:	f000 80b4 	beq.w	8000d62 <HAL_PCD_IRQHandler+0x362>
 8000bfa:	f8cd 8014 	str.w	r8, [sp, #20]
 8000bfe:	f508 6710 	add.w	r7, r8, #2304	; 0x900
 8000c02:	46ca      	mov	sl, r9
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8000c04:	f8cd 8018 	str.w	r8, [sp, #24]
 8000c08:	46a0      	mov	r8, r4
 8000c0a:	f8cd 901c 	str.w	r9, [sp, #28]
 8000c0e:	e026      	b.n	8000c5e <HAL_PCD_IRQHandler+0x25e>
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
 8000c10:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 8000c14:	f8d8 2040 	ldr.w	r2, [r8, #64]	; 0x40
 8000c18:	4413      	add	r3, r2
 8000c1a:	f8c8 3044 	str.w	r3, [r8, #68]	; 0x44
 8000c1e:	e03c      	b.n	8000c9a <HAL_PCD_IRQHandler+0x29a>
           if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8000c20:	f015 0f08 	tst.w	r5, #8
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8000c24:	bf1c      	itt	ne
 8000c26:	2308      	movne	r3, #8
 8000c28:	60bb      	strne	r3, [r7, #8]
          if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8000c2a:	f015 0f10 	tst.w	r5, #16
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8000c2e:	bf1c      	itt	ne
 8000c30:	2310      	movne	r3, #16
 8000c32:	60bb      	strne	r3, [r7, #8]
          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8000c34:	f015 0f40 	tst.w	r5, #64	; 0x40
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8000c38:	bf1c      	itt	ne
 8000c3a:	2340      	movne	r3, #64	; 0x40
 8000c3c:	60bb      	strne	r3, [r7, #8]
          if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8000c3e:	f015 0f02 	tst.w	r5, #2
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8000c42:	bf1c      	itt	ne
 8000c44:	2302      	movne	r3, #2
 8000c46:	60bb      	strne	r3, [r7, #8]
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8000c48:	f015 0f80 	tst.w	r5, #128	; 0x80
 8000c4c:	d139      	bne.n	8000cc2 <HAL_PCD_IRQHandler+0x2c2>
        epnum++;
 8000c4e:	f10a 0a01 	add.w	sl, sl, #1
 8000c52:	f108 081c 	add.w	r8, r8, #28
 8000c56:	3720      	adds	r7, #32
      while ( ep_intr )
 8000c58:	ea5f 0b5b 	movs.w	fp, fp, lsr #1
 8000c5c:	d07c      	beq.n	8000d58 <HAL_PCD_IRQHandler+0x358>
        if (ep_intr & 0x1U) /* In ITR */
 8000c5e:	f01b 0f01 	tst.w	fp, #1
 8000c62:	d0f4      	beq.n	8000c4e <HAL_PCD_IRQHandler+0x24e>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 8000c64:	fa5f f38a 	uxtb.w	r3, sl
 8000c68:	9302      	str	r3, [sp, #8]
 8000c6a:	4619      	mov	r1, r3
 8000c6c:	6820      	ldr	r0, [r4, #0]
 8000c6e:	f001 fbeb 	bl	8002448 <USB_ReadDevInEPInterrupt>
 8000c72:	4605      	mov	r5, r0
           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8000c74:	f010 0f01 	tst.w	r0, #1
 8000c78:	d0d2      	beq.n	8000c20 <HAL_PCD_IRQHandler+0x220>
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000c7a:	9b05      	ldr	r3, [sp, #20]
 8000c7c:	f503 6200 	add.w	r2, r3, #2048	; 0x800
 8000c80:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
            fifoemptymsk = 0x1U << epnum;
 8000c84:	2101      	movs	r1, #1
 8000c86:	fa01 f10a 	lsl.w	r1, r1, sl
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000c8a:	ea23 0301 	bic.w	r3, r3, r1
 8000c8e:	6353      	str	r3, [r2, #52]	; 0x34
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8000c90:	2301      	movs	r3, #1
 8000c92:	60bb      	str	r3, [r7, #8]
            if (hpcd->Init.dma_enable == 1U)
 8000c94:	6923      	ldr	r3, [r4, #16]
 8000c96:	2b01      	cmp	r3, #1
 8000c98:	d0ba      	beq.n	8000c10 <HAL_PCD_IRQHandler+0x210>
            HAL_PCD_DataInStageCallback(hpcd, epnum);
 8000c9a:	9902      	ldr	r1, [sp, #8]
 8000c9c:	4620      	mov	r0, r4
 8000c9e:	f002 ff71 	bl	8003b84 <HAL_PCD_DataInStageCallback>
            if (hpcd->Init.dma_enable == 1U)
 8000ca2:	6923      	ldr	r3, [r4, #16]
 8000ca4:	2b01      	cmp	r3, #1
 8000ca6:	d1bb      	bne.n	8000c20 <HAL_PCD_IRQHandler+0x220>
              if((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8000ca8:	f1ba 0f00 	cmp.w	sl, #0
 8000cac:	d1b8      	bne.n	8000c20 <HAL_PCD_IRQHandler+0x220>
 8000cae:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8000cb0:	2b00      	cmp	r3, #0
 8000cb2:	d1b5      	bne.n	8000c20 <HAL_PCD_IRQHandler+0x220>
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8000cb4:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 8000cb8:	2101      	movs	r1, #1
 8000cba:	6820      	ldr	r0, [r4, #0]
 8000cbc:	f001 fbf6 	bl	80024ac <USB_EP0_OutStart>
 8000cc0:	e7ae      	b.n	8000c20 <HAL_PCD_IRQHandler+0x220>
  * @param  epnum  endpoint number   
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 8000cc2:	6823      	ldr	r3, [r4, #0]
 8000cc4:	4618      	mov	r0, r3
 8000cc6:	9304      	str	r3, [sp, #16]
 8000cc8:	4646      	mov	r6, r8
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 8000cca:	f8d8 504c 	ldr.w	r5, [r8, #76]	; 0x4c
 8000cce:	f8d8 2050 	ldr.w	r2, [r8, #80]	; 0x50
 8000cd2:	1aab      	subs	r3, r5, r2
 8000cd4:	f8d8 1040 	ldr.w	r1, [r8, #64]	; 0x40
 8000cd8:	428b      	cmp	r3, r1
 8000cda:	bf28      	it	cs
 8000cdc:	460b      	movcs	r3, r1
 8000cde:	9303      	str	r3, [sp, #12]
  }
  
  
  len32b = (len + 3U) / 4U;
 
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000ce0:	f500 6910 	add.w	r9, r0, #2304	; 0x900
 8000ce4:	eb09 194a 	add.w	r9, r9, sl, lsl #5
 8000ce8:	f8d9 1018 	ldr.w	r1, [r9, #24]
  len32b = (len + 3U) / 4U;
 8000cec:	3303      	adds	r3, #3
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000cee:	b289      	uxth	r1, r1
 8000cf0:	ebb1 0f93 	cmp.w	r1, r3, lsr #2
 8000cf4:	d922      	bls.n	8000d3c <HAL_PCD_IRQHandler+0x33c>
 8000cf6:	4295      	cmp	r5, r2
 8000cf8:	d920      	bls.n	8000d3c <HAL_PCD_IRQHandler+0x33c>
          (ep->xfer_count < ep->xfer_len) &&
 8000cfa:	b1fd      	cbz	r5, 8000d3c <HAL_PCD_IRQHandler+0x33c>
            (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 8000cfc:	1aad      	subs	r5, r5, r2
 8000cfe:	6c33      	ldr	r3, [r6, #64]	; 0x40
 8000d00:	429d      	cmp	r5, r3
 8000d02:	bf28      	it	cs
 8000d04:	461d      	movcs	r5, r3
 8000d06:	9503      	str	r5, [sp, #12]
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 8000d08:	7c23      	ldrb	r3, [r4, #16]
 8000d0a:	9300      	str	r3, [sp, #0]
 8000d0c:	b2ab      	uxth	r3, r5
 8000d0e:	9a02      	ldr	r2, [sp, #8]
 8000d10:	6c71      	ldr	r1, [r6, #68]	; 0x44
 8000d12:	9804      	ldr	r0, [sp, #16]
 8000d14:	f001 fad2 	bl	80022bc <USB_WritePacket>
    
    ep->xfer_buff  += len;
 8000d18:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8000d1a:	442b      	add	r3, r5
 8000d1c:	6473      	str	r3, [r6, #68]	; 0x44
    ep->xfer_count += len;
 8000d1e:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8000d20:	442a      	add	r2, r5
 8000d22:	6532      	str	r2, [r6, #80]	; 0x50
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000d24:	f8d9 3018 	ldr.w	r3, [r9, #24]
    len32b = (len + 3U) / 4U;
 8000d28:	3503      	adds	r5, #3
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000d2a:	b29b      	uxth	r3, r3
 8000d2c:	ebb3 0f95 	cmp.w	r3, r5, lsr #2
 8000d30:	d904      	bls.n	8000d3c <HAL_PCD_IRQHandler+0x33c>
          (ep->xfer_count < ep->xfer_len) &&
 8000d32:	6cf5      	ldr	r5, [r6, #76]	; 0x4c
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000d34:	4295      	cmp	r5, r2
 8000d36:	d901      	bls.n	8000d3c <HAL_PCD_IRQHandler+0x33c>
          (ep->xfer_count < ep->xfer_len) &&
 8000d38:	2d00      	cmp	r5, #0
 8000d3a:	d1df      	bne.n	8000cfc <HAL_PCD_IRQHandler+0x2fc>
  }
  
  if(len <= 0U)
 8000d3c:	9b03      	ldr	r3, [sp, #12]
 8000d3e:	2b00      	cmp	r3, #0
 8000d40:	d185      	bne.n	8000c4e <HAL_PCD_IRQHandler+0x24e>
  {
    fifoemptymsk = 0x1U << epnum;
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000d42:	9b04      	ldr	r3, [sp, #16]
 8000d44:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
    fifoemptymsk = 0x1U << epnum;
 8000d48:	2101      	movs	r1, #1
 8000d4a:	fa01 f10a 	lsl.w	r1, r1, sl
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000d4e:	ea22 0201 	bic.w	r2, r2, r1
 8000d52:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
 8000d56:	e77a      	b.n	8000c4e <HAL_PCD_IRQHandler+0x24e>
 8000d58:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8000d5c:	f8dd 901c 	ldr.w	r9, [sp, #28]
 8000d60:	e67a      	b.n	8000a58 <HAL_PCD_IRQHandler+0x58>
      epnum = 0U;
 8000d62:	4682      	mov	sl, r0
 8000d64:	e678      	b.n	8000a58 <HAL_PCD_IRQHandler+0x58>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8000d66:	f8d8 3804 	ldr.w	r3, [r8, #2052]	; 0x804
 8000d6a:	f023 0301 	bic.w	r3, r3, #1
 8000d6e:	f8c8 3804 	str.w	r3, [r8, #2052]	; 0x804
        HAL_PCD_ResumeCallback(hpcd);
 8000d72:	4620      	mov	r0, r4
 8000d74:	f002 ff3e 	bl	8003bf4 <HAL_PCD_ResumeCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8000d78:	6822      	ldr	r2, [r4, #0]
 8000d7a:	6953      	ldr	r3, [r2, #20]
 8000d7c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8000d80:	6153      	str	r3, [r2, #20]
 8000d82:	e66f      	b.n	8000a64 <HAL_PCD_IRQHandler+0x64>
        HAL_PCD_SuspendCallback(hpcd);
 8000d84:	4620      	mov	r0, r4
 8000d86:	f002 ff1d 	bl	8003bc4 <HAL_PCD_SuspendCallback>
 8000d8a:	e677      	b.n	8000a7c <HAL_PCD_IRQHandler+0x7c>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 8000d8c:	f508 6500 	add.w	r5, r8, #2048	; 0x800
 8000d90:	686b      	ldr	r3, [r5, #4]
 8000d92:	f023 0301 	bic.w	r3, r3, #1
 8000d96:	606b      	str	r3, [r5, #4]
      USB_FlushTxFifo(hpcd->Instance , 0x10U);
 8000d98:	2110      	movs	r1, #16
 8000d9a:	6820      	ldr	r0, [r4, #0]
 8000d9c:	f000 fffa 	bl	8001d94 <USB_FlushTxFifo>
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000da0:	6863      	ldr	r3, [r4, #4]
 8000da2:	b15b      	cbz	r3, 8000dbc <HAL_PCD_IRQHandler+0x3bc>
 8000da4:	f508 6310 	add.w	r3, r8, #2304	; 0x900
        USBx_INEP(i)->DIEPINT = 0xFFU;
 8000da8:	22ff      	movs	r2, #255	; 0xff
 8000daa:	609a      	str	r2, [r3, #8]
        USBx_OUTEP(i)->DOEPINT = 0xFFU;
 8000dac:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000db0:	f109 0901 	add.w	r9, r9, #1
 8000db4:	3320      	adds	r3, #32
 8000db6:	6861      	ldr	r1, [r4, #4]
 8000db8:	4549      	cmp	r1, r9
 8000dba:	d8f6      	bhi.n	8000daa <HAL_PCD_IRQHandler+0x3aa>
      USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8000dbc:	f04f 33ff 	mov.w	r3, #4294967295
 8000dc0:	61ab      	str	r3, [r5, #24]
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8000dc2:	69eb      	ldr	r3, [r5, #28]
 8000dc4:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8000dc8:	61eb      	str	r3, [r5, #28]
      if(hpcd->Init.use_dedicated_ep1)
 8000dca:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000dcc:	b1db      	cbz	r3, 8000e06 <HAL_PCD_IRQHandler+0x406>
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
 8000dce:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 8000dd2:	f043 030b 	orr.w	r3, r3, #11
 8000dd6:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
 8000dda:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8000ddc:	f043 030b 	orr.w	r3, r3, #11
 8000de0:	646b      	str	r3, [r5, #68]	; 0x44
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8000de2:	f8d8 3800 	ldr.w	r3, [r8, #2048]	; 0x800
 8000de6:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8000dea:	f8c8 3800 	str.w	r3, [r8, #2048]	; 0x800
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8000dee:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 8000df2:	7c21      	ldrb	r1, [r4, #16]
 8000df4:	6820      	ldr	r0, [r4, #0]
 8000df6:	f001 fb59 	bl	80024ac <USB_EP0_OutStart>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8000dfa:	6822      	ldr	r2, [r4, #0]
 8000dfc:	6953      	ldr	r3, [r2, #20]
 8000dfe:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000e02:	6153      	str	r3, [r2, #20]
 8000e04:	e646      	b.n	8000a94 <HAL_PCD_IRQHandler+0x94>
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 8000e06:	696b      	ldr	r3, [r5, #20]
 8000e08:	f043 030b 	orr.w	r3, r3, #11
 8000e0c:	616b      	str	r3, [r5, #20]
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 8000e0e:	692b      	ldr	r3, [r5, #16]
 8000e10:	f043 030b 	orr.w	r3, r3, #11
 8000e14:	612b      	str	r3, [r5, #16]
 8000e16:	e7e4      	b.n	8000de2 <HAL_PCD_IRQHandler+0x3e2>
      USB_ActivateSetup(hpcd->Instance);
 8000e18:	6820      	ldr	r0, [r4, #0]
 8000e1a:	f001 fb2b 	bl	8002474 <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8000e1e:	6822      	ldr	r2, [r4, #0]
 8000e20:	68d3      	ldr	r3, [r2, #12]
 8000e22:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8000e26:	60d3      	str	r3, [r2, #12]
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
 8000e28:	6820      	ldr	r0, [r4, #0]
 8000e2a:	f000 ffdc 	bl	8001de6 <USB_GetDevSpeed>
 8000e2e:	b990      	cbnz	r0, 8000e56 <HAL_PCD_IRQHandler+0x456>
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
 8000e30:	2300      	movs	r3, #0
 8000e32:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8000e34:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000e38:	6163      	str	r3, [r4, #20]
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000e3a:	6822      	ldr	r2, [r4, #0]
 8000e3c:	68d3      	ldr	r3, [r2, #12]
 8000e3e:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 8000e42:	60d3      	str	r3, [r2, #12]
      HAL_PCD_ResetCallback(hpcd);
 8000e44:	4620      	mov	r0, r4
 8000e46:	f002 feae 	bl	8003ba6 <HAL_PCD_ResetCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8000e4a:	6822      	ldr	r2, [r4, #0]
 8000e4c:	6953      	ldr	r3, [r2, #20]
 8000e4e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8000e52:	6153      	str	r3, [r2, #20]
 8000e54:	e625      	b.n	8000aa2 <HAL_PCD_IRQHandler+0xa2>
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 8000e56:	2303      	movs	r3, #3
 8000e58:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8000e5a:	2340      	movs	r3, #64	; 0x40
 8000e5c:	6163      	str	r3, [r4, #20]
        hclk = HAL_RCC_GetHCLKFreq();
 8000e5e:	f000 fd33 	bl	80018c8 <HAL_RCC_GetHCLKFreq>
        if((hclk >= 14200000U)&&(hclk < 15000000U))
 8000e62:	4b64      	ldr	r3, [pc, #400]	; (8000ff4 <HAL_PCD_IRQHandler+0x5f4>)
 8000e64:	4403      	add	r3, r0
 8000e66:	4a64      	ldr	r2, [pc, #400]	; (8000ff8 <HAL_PCD_IRQHandler+0x5f8>)
 8000e68:	4293      	cmp	r3, r2
 8000e6a:	d805      	bhi.n	8000e78 <HAL_PCD_IRQHandler+0x478>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xFU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000e6c:	6822      	ldr	r2, [r4, #0]
 8000e6e:	68d3      	ldr	r3, [r2, #12]
 8000e70:	f443 5370 	orr.w	r3, r3, #15360	; 0x3c00
 8000e74:	60d3      	str	r3, [r2, #12]
 8000e76:	e7e5      	b.n	8000e44 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 15000000U)&&(hclk < 16000000U))
 8000e78:	4b60      	ldr	r3, [pc, #384]	; (8000ffc <HAL_PCD_IRQHandler+0x5fc>)
 8000e7a:	4403      	add	r3, r0
 8000e7c:	4a60      	ldr	r2, [pc, #384]	; (8001000 <HAL_PCD_IRQHandler+0x600>)
 8000e7e:	4293      	cmp	r3, r2
 8000e80:	d805      	bhi.n	8000e8e <HAL_PCD_IRQHandler+0x48e>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xEU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000e82:	6822      	ldr	r2, [r4, #0]
 8000e84:	68d3      	ldr	r3, [r2, #12]
 8000e86:	f443 5360 	orr.w	r3, r3, #14336	; 0x3800
 8000e8a:	60d3      	str	r3, [r2, #12]
 8000e8c:	e7da      	b.n	8000e44 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 16000000U)&&(hclk < 17200000U))
 8000e8e:	f5a0 0374 	sub.w	r3, r0, #15990784	; 0xf40000
 8000e92:	f5a3 5310 	sub.w	r3, r3, #9216	; 0x2400
 8000e96:	4a5b      	ldr	r2, [pc, #364]	; (8001004 <HAL_PCD_IRQHandler+0x604>)
 8000e98:	4293      	cmp	r3, r2
 8000e9a:	d805      	bhi.n	8000ea8 <HAL_PCD_IRQHandler+0x4a8>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xDU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000e9c:	6822      	ldr	r2, [r4, #0]
 8000e9e:	68d3      	ldr	r3, [r2, #12]
 8000ea0:	f443 5350 	orr.w	r3, r3, #13312	; 0x3400
 8000ea4:	60d3      	str	r3, [r2, #12]
 8000ea6:	e7cd      	b.n	8000e44 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 17200000U)&&(hclk < 18500000U))
 8000ea8:	f1a0 7383 	sub.w	r3, r0, #17170432	; 0x1060000
 8000eac:	f5a3 43e7 	sub.w	r3, r3, #29568	; 0x7380
 8000eb0:	4a55      	ldr	r2, [pc, #340]	; (8001008 <HAL_PCD_IRQHandler+0x608>)
 8000eb2:	4293      	cmp	r3, r2
 8000eb4:	d805      	bhi.n	8000ec2 <HAL_PCD_IRQHandler+0x4c2>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xCU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000eb6:	6822      	ldr	r2, [r4, #0]
 8000eb8:	68d3      	ldr	r3, [r2, #12]
 8000eba:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 8000ebe:	60d3      	str	r3, [r2, #12]
 8000ec0:	e7c0      	b.n	8000e44 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 18500000U)&&(hclk < 20000000U))
 8000ec2:	4b52      	ldr	r3, [pc, #328]	; (800100c <HAL_PCD_IRQHandler+0x60c>)
 8000ec4:	4403      	add	r3, r0
 8000ec6:	4a52      	ldr	r2, [pc, #328]	; (8001010 <HAL_PCD_IRQHandler+0x610>)
 8000ec8:	4293      	cmp	r3, r2
 8000eca:	d805      	bhi.n	8000ed8 <HAL_PCD_IRQHandler+0x4d8>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xBU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000ecc:	6822      	ldr	r2, [r4, #0]
 8000ece:	68d3      	ldr	r3, [r2, #12]
 8000ed0:	f443 5330 	orr.w	r3, r3, #11264	; 0x2c00
 8000ed4:	60d3      	str	r3, [r2, #12]
 8000ed6:	e7b5      	b.n	8000e44 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 20000000U)&&(hclk < 21800000U))
 8000ed8:	4b4e      	ldr	r3, [pc, #312]	; (8001014 <HAL_PCD_IRQHandler+0x614>)
 8000eda:	4403      	add	r3, r0
 8000edc:	4a4e      	ldr	r2, [pc, #312]	; (8001018 <HAL_PCD_IRQHandler+0x618>)
 8000ede:	4293      	cmp	r3, r2
 8000ee0:	d805      	bhi.n	8000eee <HAL_PCD_IRQHandler+0x4ee>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xAU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000ee2:	6822      	ldr	r2, [r4, #0]
 8000ee4:	68d3      	ldr	r3, [r2, #12]
 8000ee6:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
 8000eea:	60d3      	str	r3, [r2, #12]
 8000eec:	e7aa      	b.n	8000e44 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 21800000U)&&(hclk < 24000000U))
 8000eee:	4b4b      	ldr	r3, [pc, #300]	; (800101c <HAL_PCD_IRQHandler+0x61c>)
 8000ef0:	4403      	add	r3, r0
 8000ef2:	4a4b      	ldr	r2, [pc, #300]	; (8001020 <HAL_PCD_IRQHandler+0x620>)
 8000ef4:	4293      	cmp	r3, r2
 8000ef6:	d805      	bhi.n	8000f04 <HAL_PCD_IRQHandler+0x504>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x9U << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000ef8:	6822      	ldr	r2, [r4, #0]
 8000efa:	68d3      	ldr	r3, [r2, #12]
 8000efc:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 8000f00:	60d3      	str	r3, [r2, #12]
 8000f02:	e79f      	b.n	8000e44 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 24000000U)&&(hclk < 27700000U))
 8000f04:	f1a0 73b7 	sub.w	r3, r0, #23986176	; 0x16e0000
 8000f08:	f5a3 5358 	sub.w	r3, r3, #13824	; 0x3600
 8000f0c:	4a45      	ldr	r2, [pc, #276]	; (8001024 <HAL_PCD_IRQHandler+0x624>)
 8000f0e:	4293      	cmp	r3, r2
 8000f10:	d805      	bhi.n	8000f1e <HAL_PCD_IRQHandler+0x51e>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x8U << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000f12:	6822      	ldr	r2, [r4, #0]
 8000f14:	68d3      	ldr	r3, [r2, #12]
 8000f16:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000f1a:	60d3      	str	r3, [r2, #12]
 8000f1c:	e792      	b.n	8000e44 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 27700000U)&&(hclk < 32000000U))
 8000f1e:	4b42      	ldr	r3, [pc, #264]	; (8001028 <HAL_PCD_IRQHandler+0x628>)
 8000f20:	4403      	add	r3, r0
 8000f22:	4a42      	ldr	r2, [pc, #264]	; (800102c <HAL_PCD_IRQHandler+0x62c>)
 8000f24:	4293      	cmp	r3, r2
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x7U << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000f26:	6822      	ldr	r2, [r4, #0]
 8000f28:	68d3      	ldr	r3, [r2, #12]
 8000f2a:	bf94      	ite	ls
 8000f2c:	f443 53e0 	orrls.w	r3, r3, #7168	; 0x1c00
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x6U << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000f30:	f443 53c0 	orrhi.w	r3, r3, #6144	; 0x1800
 8000f34:	60d3      	str	r3, [r2, #12]
 8000f36:	e785      	b.n	8000e44 <HAL_PCD_IRQHandler+0x444>
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 8000f38:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8000f3c:	421d      	tst	r5, r3
 8000f3e:	f43f adc7 	beq.w	8000ad0 <HAL_PCD_IRQHandler+0xd0>
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4U);
 8000f42:	092d      	lsrs	r5, r5, #4
 8000f44:	ea4f 09c6 	mov.w	r9, r6, lsl #3
 8000f48:	eba9 0706 	sub.w	r7, r9, r6
 8000f4c:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 8000f50:	f3c5 020a 	ubfx	r2, r5, #0, #11
 8000f54:	f8d7 1204 	ldr.w	r1, [r7, #516]	; 0x204
 8000f58:	4640      	mov	r0, r8
 8000f5a:	f001 f9c5 	bl	80022e8 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8000f5e:	f3c5 050a 	ubfx	r5, r5, #0, #11
 8000f62:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 8000f66:	442b      	add	r3, r5
 8000f68:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8000f6c:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 8000f70:	441d      	add	r5, r3
 8000f72:	f8c7 5210 	str.w	r5, [r7, #528]	; 0x210
 8000f76:	e5ab      	b.n	8000ad0 <HAL_PCD_IRQHandler+0xd0>
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8000f78:	2208      	movs	r2, #8
 8000f7a:	f504 716f 	add.w	r1, r4, #956	; 0x3bc
 8000f7e:	4640      	mov	r0, r8
 8000f80:	f001 f9b2 	bl	80022e8 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8000f84:	00f2      	lsls	r2, r6, #3
 8000f86:	1b91      	subs	r1, r2, r6
 8000f88:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8000f8c:	f3c5 130a 	ubfx	r3, r5, #4, #11
 8000f90:	f8d1 2210 	ldr.w	r2, [r1, #528]	; 0x210
 8000f94:	4413      	add	r3, r2
 8000f96:	f8c1 3210 	str.w	r3, [r1, #528]	; 0x210
 8000f9a:	e599      	b.n	8000ad0 <HAL_PCD_IRQHandler+0xd0>
      HAL_PCD_SOFCallback(hpcd);
 8000f9c:	4620      	mov	r0, r4
 8000f9e:	f002 fdfc 	bl	8003b9a <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8000fa2:	6822      	ldr	r2, [r4, #0]
 8000fa4:	6953      	ldr	r3, [r2, #20]
 8000fa6:	f003 0308 	and.w	r3, r3, #8
 8000faa:	6153      	str	r3, [r2, #20]
 8000fac:	e59c      	b.n	8000ae8 <HAL_PCD_IRQHandler+0xe8>
      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
 8000fae:	fa5f f18a 	uxtb.w	r1, sl
 8000fb2:	4620      	mov	r0, r4
 8000fb4:	f002 fe2a 	bl	8003c0c <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8000fb8:	6822      	ldr	r2, [r4, #0]
 8000fba:	6953      	ldr	r3, [r2, #20]
 8000fbc:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8000fc0:	6153      	str	r3, [r2, #20]
 8000fc2:	e598      	b.n	8000af6 <HAL_PCD_IRQHandler+0xf6>
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
 8000fc4:	fa5f f18a 	uxtb.w	r1, sl
 8000fc8:	4620      	mov	r0, r4
 8000fca:	f002 fe19 	bl	8003c00 <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8000fce:	6822      	ldr	r2, [r4, #0]
 8000fd0:	6953      	ldr	r3, [r2, #20]
 8000fd2:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8000fd6:	6153      	str	r3, [r2, #20]
 8000fd8:	e594      	b.n	8000b04 <HAL_PCD_IRQHandler+0x104>
      HAL_PCD_ConnectCallback(hpcd);
 8000fda:	4620      	mov	r0, r4
 8000fdc:	f002 fe1c 	bl	8003c18 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8000fe0:	6822      	ldr	r2, [r4, #0]
 8000fe2:	6953      	ldr	r3, [r2, #20]
 8000fe4:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8000fe8:	6153      	str	r3, [r2, #20]
 8000fea:	e592      	b.n	8000b12 <HAL_PCD_IRQHandler+0x112>
        HAL_PCD_DisconnectCallback(hpcd);
 8000fec:	4620      	mov	r0, r4
 8000fee:	f002 fe19 	bl	8003c24 <HAL_PCD_DisconnectCallback>
 8000ff2:	e59b      	b.n	8000b2c <HAL_PCD_IRQHandler+0x12c>
 8000ff4:	ff275340 	.word	0xff275340
 8000ff8:	000c34ff 	.word	0x000c34ff
 8000ffc:	ff1b1e40 	.word	0xff1b1e40
 8001000:	000f423f 	.word	0x000f423f
 8001004:	00124f7f 	.word	0x00124f7f
 8001008:	0013d61f 	.word	0x0013d61f
 800100c:	fee5b660 	.word	0xfee5b660
 8001010:	0016e35f 	.word	0x0016e35f
 8001014:	feced300 	.word	0xfeced300
 8001018:	001b773f 	.word	0x001b773f
 800101c:	feb35bc0 	.word	0xfeb35bc0
 8001020:	002191bf 	.word	0x002191bf
 8001024:	0038751f 	.word	0x0038751f
 8001028:	fe5954e0 	.word	0xfe5954e0
 800102c:	00419cdf 	.word	0x00419cdf

08001030 <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd); 
 8001030:	f890 33b8 	ldrb.w	r3, [r0, #952]	; 0x3b8
 8001034:	2b01      	cmp	r3, #1
 8001036:	d101      	bne.n	800103c <HAL_PCD_SetAddress+0xc>
 8001038:	2002      	movs	r0, #2
 800103a:	4770      	bx	lr
{
 800103c:	b510      	push	{r4, lr}
 800103e:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8001040:	2301      	movs	r3, #1
 8001042:	f880 33b8 	strb.w	r3, [r0, #952]	; 0x3b8
  USB_SetDevAddress(hpcd->Instance, address);
 8001046:	6800      	ldr	r0, [r0, #0]
 8001048:	f001 f9b8 	bl	80023bc <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);   
 800104c:	2000      	movs	r0, #0
 800104e:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 8001052:	bd10      	pop	{r4, pc}

08001054 <HAL_PCD_EP_Open>:
{
 8001054:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((ep_addr & 0x80) == 0x80)
 8001056:	f011 0f80 	tst.w	r1, #128	; 0x80
 800105a:	d11d      	bne.n	8001098 <HAL_PCD_EP_Open+0x44>
 800105c:	f001 047f 	and.w	r4, r1, #127	; 0x7f
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001060:	00e5      	lsls	r5, r4, #3
 8001062:	1b29      	subs	r1, r5, r4
 8001064:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8001068:	f501 71fc 	add.w	r1, r1, #504	; 0x1f8
  ep->num   = ep_addr & 0x7F;
 800106c:	1b2e      	subs	r6, r5, r4
 800106e:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8001072:	f886 41f8 	strb.w	r4, [r6, #504]	; 0x1f8
  ep->is_in = (0x80 & ep_addr) != 0;
 8001076:	2700      	movs	r7, #0
 8001078:	f886 71f9 	strb.w	r7, [r6, #505]	; 0x1f9
  ep->maxpacket = ep_mps;
 800107c:	f8c6 2200 	str.w	r2, [r6, #512]	; 0x200
  ep->type = ep_type;
 8001080:	f886 31fb 	strb.w	r3, [r6, #507]	; 0x1fb
  if (ep_type == EP_TYPE_BULK )
 8001084:	2b02      	cmp	r3, #2
    ep->data_pid_start = 0U;
 8001086:	bf04      	itt	eq
 8001088:	2300      	moveq	r3, #0
 800108a:	710b      	strbeq	r3, [r1, #4]
  __HAL_LOCK(hpcd); 
 800108c:	f890 33b8 	ldrb.w	r3, [r0, #952]	; 0x3b8
 8001090:	2b01      	cmp	r3, #1
 8001092:	d115      	bne.n	80010c0 <HAL_PCD_EP_Open+0x6c>
 8001094:	2002      	movs	r0, #2
}
 8001096:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001098:	f001 047f 	and.w	r4, r1, #127	; 0x7f
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 800109c:	00e5      	lsls	r5, r4, #3
 800109e:	1b29      	subs	r1, r5, r4
 80010a0:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 80010a4:	3138      	adds	r1, #56	; 0x38
  ep->num   = ep_addr & 0x7F;
 80010a6:	1b2e      	subs	r6, r5, r4
 80010a8:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 80010ac:	f886 4038 	strb.w	r4, [r6, #56]	; 0x38
  ep->is_in = (0x80 & ep_addr) != 0;
 80010b0:	2701      	movs	r7, #1
 80010b2:	f886 7039 	strb.w	r7, [r6, #57]	; 0x39
  ep->maxpacket = ep_mps;
 80010b6:	6432      	str	r2, [r6, #64]	; 0x40
  ep->type = ep_type;
 80010b8:	f886 303b 	strb.w	r3, [r6, #59]	; 0x3b
    ep->tx_fifo_num = ep->num;
 80010bc:	87f4      	strh	r4, [r6, #62]	; 0x3e
 80010be:	e7e1      	b.n	8001084 <HAL_PCD_EP_Open+0x30>
 80010c0:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 80010c2:	2301      	movs	r3, #1
 80010c4:	f880 33b8 	strb.w	r3, [r0, #952]	; 0x3b8
  USB_ActivateEndpoint(hpcd->Instance , ep);
 80010c8:	6800      	ldr	r0, [r0, #0]
 80010ca:	f000 feab 	bl	8001e24 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 80010ce:	2000      	movs	r0, #0
 80010d0:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return ret;
 80010d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080010d6 <HAL_PCD_EP_Close>:
  if ((ep_addr & 0x80) == 0x80)
 80010d6:	b24a      	sxtb	r2, r1
 80010d8:	2a00      	cmp	r2, #0
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 80010da:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 80010de:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80010e2:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80010e6:	bfb4      	ite	lt
 80010e8:	3338      	addlt	r3, #56	; 0x38
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 80010ea:	f503 73fc 	addge.w	r3, r3, #504	; 0x1f8
  ep->num   = ep_addr & 0x7F;
 80010ee:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 80010f2:	7019      	strb	r1, [r3, #0]
  ep->is_in = (0x80 & ep_addr) != 0;
 80010f4:	0fd2      	lsrs	r2, r2, #31
 80010f6:	705a      	strb	r2, [r3, #1]
  __HAL_LOCK(hpcd); 
 80010f8:	f890 23b8 	ldrb.w	r2, [r0, #952]	; 0x3b8
 80010fc:	2a01      	cmp	r2, #1
 80010fe:	d101      	bne.n	8001104 <HAL_PCD_EP_Close+0x2e>
 8001100:	2002      	movs	r0, #2
 8001102:	4770      	bx	lr
{  
 8001104:	b510      	push	{r4, lr}
 8001106:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8001108:	2201      	movs	r2, #1
 800110a:	f880 23b8 	strb.w	r2, [r0, #952]	; 0x3b8
  USB_DeactivateEndpoint(hpcd->Instance , ep);
 800110e:	4619      	mov	r1, r3
 8001110:	6800      	ldr	r0, [r0, #0]
 8001112:	f000 fecd 	bl	8001eb0 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 8001116:	2000      	movs	r0, #0
 8001118:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 800111c:	bd10      	pop	{r4, pc}

0800111e <HAL_PCD_EP_Receive>:
{
 800111e:	b538      	push	{r3, r4, r5, lr}
 8001120:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001124:	00ec      	lsls	r4, r5, #3
 8001126:	1b61      	subs	r1, r4, r5
 8001128:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 800112c:	f501 71fc 	add.w	r1, r1, #504	; 0x1f8
  ep->xfer_buff = pBuf;  
 8001130:	1b64      	subs	r4, r4, r5
 8001132:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8001136:	f8c4 2204 	str.w	r2, [r4, #516]	; 0x204
  ep->xfer_len = len;
 800113a:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
  ep->xfer_count = 0U;
 800113e:	2300      	movs	r3, #0
 8001140:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
  ep->is_in = 0U;
 8001144:	f884 31f9 	strb.w	r3, [r4, #505]	; 0x1f9
  ep->num = ep_addr & 0x7F;
 8001148:	f884 51f8 	strb.w	r5, [r4, #504]	; 0x1f8
  if (hpcd->Init.dma_enable == 1U)
 800114c:	6903      	ldr	r3, [r0, #16]
 800114e:	2b01      	cmp	r3, #1
 8001150:	d006      	beq.n	8001160 <HAL_PCD_EP_Receive+0x42>
  if ((ep_addr & 0x7F) == 0)
 8001152:	b165      	cbz	r5, 800116e <HAL_PCD_EP_Receive+0x50>
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001154:	b2da      	uxtb	r2, r3
 8001156:	6800      	ldr	r0, [r0, #0]
 8001158:	f000 ff10 	bl	8001f7c <USB_EPStartXfer>
}
 800115c:	2000      	movs	r0, #0
 800115e:	bd38      	pop	{r3, r4, r5, pc}
    ep->dma_addr = (uint32_t)pBuf;  
 8001160:	ebc5 04c5 	rsb	r4, r5, r5, lsl #3
 8001164:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8001168:	f8c4 2208 	str.w	r2, [r4, #520]	; 0x208
 800116c:	e7f1      	b.n	8001152 <HAL_PCD_EP_Receive+0x34>
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 800116e:	b2da      	uxtb	r2, r3
 8001170:	6800      	ldr	r0, [r0, #0]
 8001172:	f001 f809 	bl	8002188 <USB_EP0StartXfer>
 8001176:	e7f1      	b.n	800115c <HAL_PCD_EP_Receive+0x3e>

08001178 <HAL_PCD_EP_GetRxCount>:
  return hpcd->OUT_ep[ep_addr & 0xF].xfer_count;
 8001178:	f001 010f 	and.w	r1, r1, #15
 800117c:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8001180:	eb00 0181 	add.w	r1, r0, r1, lsl #2
}
 8001184:	f8b1 0210 	ldrh.w	r0, [r1, #528]	; 0x210
 8001188:	4770      	bx	lr

0800118a <HAL_PCD_EP_Transmit>:
{
 800118a:	b538      	push	{r3, r4, r5, lr}
 800118c:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001190:	00ec      	lsls	r4, r5, #3
 8001192:	1b61      	subs	r1, r4, r5
 8001194:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8001198:	3138      	adds	r1, #56	; 0x38
  ep->xfer_buff = pBuf;  
 800119a:	1b64      	subs	r4, r4, r5
 800119c:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 80011a0:	6462      	str	r2, [r4, #68]	; 0x44
  ep->xfer_len = len;
 80011a2:	64e3      	str	r3, [r4, #76]	; 0x4c
  ep->xfer_count = 0U;
 80011a4:	2300      	movs	r3, #0
 80011a6:	6523      	str	r3, [r4, #80]	; 0x50
  ep->is_in = 1U;
 80011a8:	2301      	movs	r3, #1
 80011aa:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  ep->num = ep_addr & 0x7F;
 80011ae:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
  if (hpcd->Init.dma_enable == 1U)
 80011b2:	6903      	ldr	r3, [r0, #16]
 80011b4:	2b01      	cmp	r3, #1
 80011b6:	d006      	beq.n	80011c6 <HAL_PCD_EP_Transmit+0x3c>
  if ((ep_addr & 0x7F) == 0)
 80011b8:	b15d      	cbz	r5, 80011d2 <HAL_PCD_EP_Transmit+0x48>
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 80011ba:	b2da      	uxtb	r2, r3
 80011bc:	6800      	ldr	r0, [r0, #0]
 80011be:	f000 fedd 	bl	8001f7c <USB_EPStartXfer>
}
 80011c2:	2000      	movs	r0, #0
 80011c4:	bd38      	pop	{r3, r4, r5, pc}
    ep->dma_addr = (uint32_t)pBuf;  
 80011c6:	ebc5 04c5 	rsb	r4, r5, r5, lsl #3
 80011ca:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 80011ce:	64a2      	str	r2, [r4, #72]	; 0x48
 80011d0:	e7f2      	b.n	80011b8 <HAL_PCD_EP_Transmit+0x2e>
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 80011d2:	b2da      	uxtb	r2, r3
 80011d4:	6800      	ldr	r0, [r0, #0]
 80011d6:	f000 ffd7 	bl	8002188 <USB_EP0StartXfer>
 80011da:	e7f2      	b.n	80011c2 <HAL_PCD_EP_Transmit+0x38>

080011dc <HAL_PCD_EP_SetStall>:
{
 80011dc:	b538      	push	{r3, r4, r5, lr}
  if ((0x80 & ep_addr) == 0x80)
 80011de:	b24a      	sxtb	r2, r1
 80011e0:	2a00      	cmp	r2, #0
 80011e2:	db12      	blt.n	800120a <HAL_PCD_EP_SetStall+0x2e>
    ep = &hpcd->OUT_ep[ep_addr];
 80011e4:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 80011e8:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80011ec:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
  ep->is_stall = 1U;
 80011f0:	2401      	movs	r4, #1
 80011f2:	709c      	strb	r4, [r3, #2]
  ep->num   = ep_addr & 0x7F;
 80011f4:	f001 047f 	and.w	r4, r1, #127	; 0x7f
 80011f8:	701c      	strb	r4, [r3, #0]
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 80011fa:	0fd2      	lsrs	r2, r2, #31
 80011fc:	705a      	strb	r2, [r3, #1]
  __HAL_LOCK(hpcd); 
 80011fe:	f890 23b8 	ldrb.w	r2, [r0, #952]	; 0x3b8
 8001202:	2a01      	cmp	r2, #1
 8001204:	d109      	bne.n	800121a <HAL_PCD_EP_SetStall+0x3e>
 8001206:	2002      	movs	r0, #2
}
 8001208:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 800120a:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 800120e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8001212:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8001216:	3338      	adds	r3, #56	; 0x38
 8001218:	e7ea      	b.n	80011f0 <HAL_PCD_EP_SetStall+0x14>
 800121a:	4605      	mov	r5, r0
  __HAL_LOCK(hpcd); 
 800121c:	2201      	movs	r2, #1
 800121e:	f880 23b8 	strb.w	r2, [r0, #952]	; 0x3b8
  USB_EPSetStall(hpcd->Instance , ep);
 8001222:	4619      	mov	r1, r3
 8001224:	6800      	ldr	r0, [r0, #0]
 8001226:	f001 f874 	bl	8002312 <USB_EPSetStall>
  if((ep_addr & 0x7F) == 0)
 800122a:	b11c      	cbz	r4, 8001234 <HAL_PCD_EP_SetStall+0x58>
  __HAL_UNLOCK(hpcd); 
 800122c:	2000      	movs	r0, #0
 800122e:	f885 03b8 	strb.w	r0, [r5, #952]	; 0x3b8
  return HAL_OK;
 8001232:	bd38      	pop	{r3, r4, r5, pc}
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8001234:	f505 726f 	add.w	r2, r5, #956	; 0x3bc
 8001238:	7c29      	ldrb	r1, [r5, #16]
 800123a:	6828      	ldr	r0, [r5, #0]
 800123c:	f001 f936 	bl	80024ac <USB_EP0_OutStart>
 8001240:	e7f4      	b.n	800122c <HAL_PCD_EP_SetStall+0x50>

08001242 <HAL_PCD_EP_ClrStall>:
{
 8001242:	b510      	push	{r4, lr}
  if ((0x80 & ep_addr) == 0x80)
 8001244:	b24a      	sxtb	r2, r1
 8001246:	2a00      	cmp	r2, #0
 8001248:	db12      	blt.n	8001270 <HAL_PCD_EP_ClrStall+0x2e>
    ep = &hpcd->OUT_ep[ep_addr];
 800124a:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 800124e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8001252:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
  ep->is_stall = 0U;
 8001256:	2400      	movs	r4, #0
 8001258:	709c      	strb	r4, [r3, #2]
  ep->num   = ep_addr & 0x7F;
 800125a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 800125e:	7019      	strb	r1, [r3, #0]
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8001260:	0fd2      	lsrs	r2, r2, #31
 8001262:	705a      	strb	r2, [r3, #1]
  __HAL_LOCK(hpcd); 
 8001264:	f890 23b8 	ldrb.w	r2, [r0, #952]	; 0x3b8
 8001268:	2a01      	cmp	r2, #1
 800126a:	d109      	bne.n	8001280 <HAL_PCD_EP_ClrStall+0x3e>
 800126c:	2002      	movs	r0, #2
}
 800126e:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001270:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8001274:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8001278:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800127c:	3338      	adds	r3, #56	; 0x38
 800127e:	e7ea      	b.n	8001256 <HAL_PCD_EP_ClrStall+0x14>
 8001280:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8001282:	2201      	movs	r2, #1
 8001284:	f880 23b8 	strb.w	r2, [r0, #952]	; 0x3b8
  USB_EPClearStall(hpcd->Instance , ep);
 8001288:	4619      	mov	r1, r3
 800128a:	6800      	ldr	r0, [r0, #0]
 800128c:	f001 f869 	bl	8002362 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd); 
 8001290:	2000      	movs	r0, #0
 8001292:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 8001296:	bd10      	pop	{r4, pc}

08001298 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8001298:	b430      	push	{r4, r5}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 800129a:	6805      	ldr	r5, [r0, #0]
 800129c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  
  if(fifo == 0)
 800129e:	b1e1      	cbz	r1, 80012da <HAL_PCDEx_SetTxFiFo+0x42>
 80012a0:	460b      	mov	r3, r1
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
 80012a2:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 80012a4:	eb04 4411 	add.w	r4, r4, r1, lsr #16
    for (i = 0; i < (fifo - 1); i++)
 80012a8:	1e59      	subs	r1, r3, #1
 80012aa:	2900      	cmp	r1, #0
 80012ac:	dd0c      	ble.n	80012c8 <HAL_PCDEx_SetTxFiFo+0x30>
 80012ae:	2300      	movs	r3, #0
 80012b0:	4618      	mov	r0, r3
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16U);
 80012b2:	3340      	adds	r3, #64	; 0x40
 80012b4:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80012b8:	685b      	ldr	r3, [r3, #4]
 80012ba:	eb04 4413 	add.w	r4, r4, r3, lsr #16
    for (i = 0; i < (fifo - 1); i++)
 80012be:	3001      	adds	r0, #1
 80012c0:	b2c0      	uxtb	r0, r0
 80012c2:	4603      	mov	r3, r0
 80012c4:	4288      	cmp	r0, r1
 80012c6:	dbf4      	blt.n	80012b2 <HAL_PCDEx_SetTxFiFo+0x1a>
    }
    
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1] = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);        
 80012c8:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80012cc:	3140      	adds	r1, #64	; 0x40
 80012ce:	eb05 0581 	add.w	r5, r5, r1, lsl #2
 80012d2:	606c      	str	r4, [r5, #4]
  }
  
  return HAL_OK;
}
 80012d4:	2000      	movs	r0, #0
 80012d6:	bc30      	pop	{r4, r5}
 80012d8:	4770      	bx	lr
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
 80012da:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80012de:	62ac      	str	r4, [r5, #40]	; 0x28
 80012e0:	e7f8      	b.n	80012d4 <HAL_PCDEx_SetTxFiFo+0x3c>

080012e2 <HAL_PCDEx_SetRxFiFo>:
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 80012e2:	6803      	ldr	r3, [r0, #0]
 80012e4:	6259      	str	r1, [r3, #36]	; 0x24
  
  return HAL_OK;
}
 80012e6:	2000      	movs	r0, #0
 80012e8:	4770      	bx	lr
	...

080012ec <HAL_RCC_OscConfig>:
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80012ec:	2800      	cmp	r0, #0
 80012ee:	f000 81bd 	beq.w	800166c <HAL_RCC_OscConfig+0x380>
{
 80012f2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80012f6:	b082      	sub	sp, #8
 80012f8:	4604      	mov	r4, r0
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80012fa:	6803      	ldr	r3, [r0, #0]
 80012fc:	f013 0f01 	tst.w	r3, #1
 8001300:	d03b      	beq.n	800137a <HAL_RCC_OscConfig+0x8e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8001302:	4ba8      	ldr	r3, [pc, #672]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 8001304:	689b      	ldr	r3, [r3, #8]
 8001306:	f003 030c 	and.w	r3, r3, #12
 800130a:	2b04      	cmp	r3, #4
 800130c:	d02c      	beq.n	8001368 <HAL_RCC_OscConfig+0x7c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800130e:	4ba5      	ldr	r3, [pc, #660]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 8001310:	689b      	ldr	r3, [r3, #8]
 8001312:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8001316:	2b08      	cmp	r3, #8
 8001318:	d021      	beq.n	800135e <HAL_RCC_OscConfig+0x72>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800131a:	6863      	ldr	r3, [r4, #4]
 800131c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001320:	d04f      	beq.n	80013c2 <HAL_RCC_OscConfig+0xd6>
 8001322:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8001326:	d052      	beq.n	80013ce <HAL_RCC_OscConfig+0xe2>
 8001328:	4b9e      	ldr	r3, [pc, #632]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 800132a:	681a      	ldr	r2, [r3, #0]
 800132c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001330:	601a      	str	r2, [r3, #0]
 8001332:	681a      	ldr	r2, [r3, #0]
 8001334:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001338:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800133a:	6863      	ldr	r3, [r4, #4]
 800133c:	2b00      	cmp	r3, #0
 800133e:	d050      	beq.n	80013e2 <HAL_RCC_OscConfig+0xf6>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001340:	f7ff f980 	bl	8000644 <HAL_GetTick>
 8001344:	4606      	mov	r6, r0

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001346:	4d97      	ldr	r5, [pc, #604]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 8001348:	682b      	ldr	r3, [r5, #0]
 800134a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800134e:	d114      	bne.n	800137a <HAL_RCC_OscConfig+0x8e>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001350:	f7ff f978 	bl	8000644 <HAL_GetTick>
 8001354:	1b80      	subs	r0, r0, r6
 8001356:	2864      	cmp	r0, #100	; 0x64
 8001358:	d9f6      	bls.n	8001348 <HAL_RCC_OscConfig+0x5c>
          {
            return HAL_TIMEOUT;
 800135a:	2003      	movs	r0, #3
 800135c:	e18b      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800135e:	4b91      	ldr	r3, [pc, #580]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 8001360:	685b      	ldr	r3, [r3, #4]
 8001362:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8001366:	d0d8      	beq.n	800131a <HAL_RCC_OscConfig+0x2e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001368:	4b8e      	ldr	r3, [pc, #568]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 800136a:	681b      	ldr	r3, [r3, #0]
 800136c:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001370:	d003      	beq.n	800137a <HAL_RCC_OscConfig+0x8e>
 8001372:	6863      	ldr	r3, [r4, #4]
 8001374:	2b00      	cmp	r3, #0
 8001376:	f000 817b 	beq.w	8001670 <HAL_RCC_OscConfig+0x384>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800137a:	6823      	ldr	r3, [r4, #0]
 800137c:	f013 0f02 	tst.w	r3, #2
 8001380:	d055      	beq.n	800142e <HAL_RCC_OscConfig+0x142>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8001382:	4b88      	ldr	r3, [pc, #544]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 8001384:	689b      	ldr	r3, [r3, #8]
 8001386:	f013 0f0c 	tst.w	r3, #12
 800138a:	d03e      	beq.n	800140a <HAL_RCC_OscConfig+0x11e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800138c:	4b85      	ldr	r3, [pc, #532]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 800138e:	689b      	ldr	r3, [r3, #8]
 8001390:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8001394:	2b08      	cmp	r3, #8
 8001396:	d033      	beq.n	8001400 <HAL_RCC_OscConfig+0x114>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8001398:	68e3      	ldr	r3, [r4, #12]
 800139a:	2b00      	cmp	r3, #0
 800139c:	d068      	beq.n	8001470 <HAL_RCC_OscConfig+0x184>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800139e:	2201      	movs	r2, #1
 80013a0:	4b81      	ldr	r3, [pc, #516]	; (80015a8 <HAL_RCC_OscConfig+0x2bc>)
 80013a2:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80013a4:	f7ff f94e 	bl	8000644 <HAL_GetTick>
 80013a8:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80013aa:	4d7e      	ldr	r5, [pc, #504]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 80013ac:	682b      	ldr	r3, [r5, #0]
 80013ae:	f013 0f02 	tst.w	r3, #2
 80013b2:	d154      	bne.n	800145e <HAL_RCC_OscConfig+0x172>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80013b4:	f7ff f946 	bl	8000644 <HAL_GetTick>
 80013b8:	1b80      	subs	r0, r0, r6
 80013ba:	2802      	cmp	r0, #2
 80013bc:	d9f6      	bls.n	80013ac <HAL_RCC_OscConfig+0xc0>
          {
            return HAL_TIMEOUT;
 80013be:	2003      	movs	r0, #3
 80013c0:	e159      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80013c2:	4a78      	ldr	r2, [pc, #480]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 80013c4:	6813      	ldr	r3, [r2, #0]
 80013c6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80013ca:	6013      	str	r3, [r2, #0]
 80013cc:	e7b5      	b.n	800133a <HAL_RCC_OscConfig+0x4e>
 80013ce:	4b75      	ldr	r3, [pc, #468]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 80013d0:	681a      	ldr	r2, [r3, #0]
 80013d2:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80013d6:	601a      	str	r2, [r3, #0]
 80013d8:	681a      	ldr	r2, [r3, #0]
 80013da:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80013de:	601a      	str	r2, [r3, #0]
 80013e0:	e7ab      	b.n	800133a <HAL_RCC_OscConfig+0x4e>
        tickstart = HAL_GetTick();
 80013e2:	f7ff f92f 	bl	8000644 <HAL_GetTick>
 80013e6:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80013e8:	4d6e      	ldr	r5, [pc, #440]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 80013ea:	682b      	ldr	r3, [r5, #0]
 80013ec:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80013f0:	d0c3      	beq.n	800137a <HAL_RCC_OscConfig+0x8e>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80013f2:	f7ff f927 	bl	8000644 <HAL_GetTick>
 80013f6:	1b80      	subs	r0, r0, r6
 80013f8:	2864      	cmp	r0, #100	; 0x64
 80013fa:	d9f6      	bls.n	80013ea <HAL_RCC_OscConfig+0xfe>
            return HAL_TIMEOUT;
 80013fc:	2003      	movs	r0, #3
 80013fe:	e13a      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001400:	4b68      	ldr	r3, [pc, #416]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 8001402:	685b      	ldr	r3, [r3, #4]
 8001404:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8001408:	d1c6      	bne.n	8001398 <HAL_RCC_OscConfig+0xac>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800140a:	4b66      	ldr	r3, [pc, #408]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 800140c:	681b      	ldr	r3, [r3, #0]
 800140e:	f013 0f02 	tst.w	r3, #2
 8001412:	d004      	beq.n	800141e <HAL_RCC_OscConfig+0x132>
 8001414:	68e3      	ldr	r3, [r4, #12]
 8001416:	2b01      	cmp	r3, #1
 8001418:	d001      	beq.n	800141e <HAL_RCC_OscConfig+0x132>
        return HAL_ERROR;
 800141a:	2001      	movs	r0, #1
 800141c:	e12b      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800141e:	4a61      	ldr	r2, [pc, #388]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 8001420:	6813      	ldr	r3, [r2, #0]
 8001422:	6921      	ldr	r1, [r4, #16]
 8001424:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001428:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800142c:	6013      	str	r3, [r2, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800142e:	6823      	ldr	r3, [r4, #0]
 8001430:	f013 0f08 	tst.w	r3, #8
 8001434:	d040      	beq.n	80014b8 <HAL_RCC_OscConfig+0x1cc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8001436:	6963      	ldr	r3, [r4, #20]
 8001438:	b363      	cbz	r3, 8001494 <HAL_RCC_OscConfig+0x1a8>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800143a:	2201      	movs	r2, #1
 800143c:	4b5b      	ldr	r3, [pc, #364]	; (80015ac <HAL_RCC_OscConfig+0x2c0>)
 800143e:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001440:	f7ff f900 	bl	8000644 <HAL_GetTick>
 8001444:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001446:	4d57      	ldr	r5, [pc, #348]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 8001448:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800144a:	f013 0f02 	tst.w	r3, #2
 800144e:	d133      	bne.n	80014b8 <HAL_RCC_OscConfig+0x1cc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001450:	f7ff f8f8 	bl	8000644 <HAL_GetTick>
 8001454:	1b80      	subs	r0, r0, r6
 8001456:	2802      	cmp	r0, #2
 8001458:	d9f6      	bls.n	8001448 <HAL_RCC_OscConfig+0x15c>
        {
          return HAL_TIMEOUT;
 800145a:	2003      	movs	r0, #3
 800145c:	e10b      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800145e:	4a51      	ldr	r2, [pc, #324]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 8001460:	6813      	ldr	r3, [r2, #0]
 8001462:	6921      	ldr	r1, [r4, #16]
 8001464:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001468:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800146c:	6013      	str	r3, [r2, #0]
 800146e:	e7de      	b.n	800142e <HAL_RCC_OscConfig+0x142>
        __HAL_RCC_HSI_DISABLE();
 8001470:	2200      	movs	r2, #0
 8001472:	4b4d      	ldr	r3, [pc, #308]	; (80015a8 <HAL_RCC_OscConfig+0x2bc>)
 8001474:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001476:	f7ff f8e5 	bl	8000644 <HAL_GetTick>
 800147a:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800147c:	4d49      	ldr	r5, [pc, #292]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 800147e:	682b      	ldr	r3, [r5, #0]
 8001480:	f013 0f02 	tst.w	r3, #2
 8001484:	d0d3      	beq.n	800142e <HAL_RCC_OscConfig+0x142>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001486:	f7ff f8dd 	bl	8000644 <HAL_GetTick>
 800148a:	1b80      	subs	r0, r0, r6
 800148c:	2802      	cmp	r0, #2
 800148e:	d9f6      	bls.n	800147e <HAL_RCC_OscConfig+0x192>
            return HAL_TIMEOUT;
 8001490:	2003      	movs	r0, #3
 8001492:	e0f0      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001494:	2200      	movs	r2, #0
 8001496:	4b45      	ldr	r3, [pc, #276]	; (80015ac <HAL_RCC_OscConfig+0x2c0>)
 8001498:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800149a:	f7ff f8d3 	bl	8000644 <HAL_GetTick>
 800149e:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80014a0:	4d40      	ldr	r5, [pc, #256]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 80014a2:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 80014a4:	f013 0f02 	tst.w	r3, #2
 80014a8:	d006      	beq.n	80014b8 <HAL_RCC_OscConfig+0x1cc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80014aa:	f7ff f8cb 	bl	8000644 <HAL_GetTick>
 80014ae:	1b80      	subs	r0, r0, r6
 80014b0:	2802      	cmp	r0, #2
 80014b2:	d9f6      	bls.n	80014a2 <HAL_RCC_OscConfig+0x1b6>
        {
          return HAL_TIMEOUT;
 80014b4:	2003      	movs	r0, #3
 80014b6:	e0de      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80014b8:	6823      	ldr	r3, [r4, #0]
 80014ba:	f013 0f04 	tst.w	r3, #4
 80014be:	d07a      	beq.n	80015b6 <HAL_RCC_OscConfig+0x2ca>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80014c0:	4b38      	ldr	r3, [pc, #224]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 80014c2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80014c4:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 80014c8:	d134      	bne.n	8001534 <HAL_RCC_OscConfig+0x248>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80014ca:	2300      	movs	r3, #0
 80014cc:	9301      	str	r3, [sp, #4]
 80014ce:	4b35      	ldr	r3, [pc, #212]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 80014d0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80014d2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80014d6:	641a      	str	r2, [r3, #64]	; 0x40
 80014d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80014da:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80014de:	9301      	str	r3, [sp, #4]
 80014e0:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80014e2:	2501      	movs	r5, #1
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80014e4:	4b32      	ldr	r3, [pc, #200]	; (80015b0 <HAL_RCC_OscConfig+0x2c4>)
 80014e6:	681b      	ldr	r3, [r3, #0]
 80014e8:	f413 7f80 	tst.w	r3, #256	; 0x100
 80014ec:	d024      	beq.n	8001538 <HAL_RCC_OscConfig+0x24c>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80014ee:	68a3      	ldr	r3, [r4, #8]
 80014f0:	2b01      	cmp	r3, #1
 80014f2:	d035      	beq.n	8001560 <HAL_RCC_OscConfig+0x274>
 80014f4:	2b05      	cmp	r3, #5
 80014f6:	d039      	beq.n	800156c <HAL_RCC_OscConfig+0x280>
 80014f8:	4b2a      	ldr	r3, [pc, #168]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 80014fa:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80014fc:	f022 0201 	bic.w	r2, r2, #1
 8001500:	671a      	str	r2, [r3, #112]	; 0x70
 8001502:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001504:	f022 0204 	bic.w	r2, r2, #4
 8001508:	671a      	str	r2, [r3, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800150a:	68a3      	ldr	r3, [r4, #8]
 800150c:	2b00      	cmp	r3, #0
 800150e:	d037      	beq.n	8001580 <HAL_RCC_OscConfig+0x294>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001510:	f7ff f898 	bl	8000644 <HAL_GetTick>
 8001514:	4680      	mov	r8, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001516:	4e23      	ldr	r6, [pc, #140]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001518:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800151c:	6f33      	ldr	r3, [r6, #112]	; 0x70
 800151e:	f013 0f02 	tst.w	r3, #2
 8001522:	d147      	bne.n	80015b4 <HAL_RCC_OscConfig+0x2c8>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001524:	f7ff f88e 	bl	8000644 <HAL_GetTick>
 8001528:	eba0 0008 	sub.w	r0, r0, r8
 800152c:	42b8      	cmp	r0, r7
 800152e:	d9f5      	bls.n	800151c <HAL_RCC_OscConfig+0x230>
        {
          return HAL_TIMEOUT;
 8001530:	2003      	movs	r0, #3
 8001532:	e0a0      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
    FlagStatus       pwrclkchanged = RESET;
 8001534:	2500      	movs	r5, #0
 8001536:	e7d5      	b.n	80014e4 <HAL_RCC_OscConfig+0x1f8>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8001538:	4a1d      	ldr	r2, [pc, #116]	; (80015b0 <HAL_RCC_OscConfig+0x2c4>)
 800153a:	6813      	ldr	r3, [r2, #0]
 800153c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001540:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 8001542:	f7ff f87f 	bl	8000644 <HAL_GetTick>
 8001546:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001548:	4e19      	ldr	r6, [pc, #100]	; (80015b0 <HAL_RCC_OscConfig+0x2c4>)
 800154a:	6833      	ldr	r3, [r6, #0]
 800154c:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001550:	d1cd      	bne.n	80014ee <HAL_RCC_OscConfig+0x202>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001552:	f7ff f877 	bl	8000644 <HAL_GetTick>
 8001556:	1bc0      	subs	r0, r0, r7
 8001558:	2802      	cmp	r0, #2
 800155a:	d9f6      	bls.n	800154a <HAL_RCC_OscConfig+0x25e>
          return HAL_TIMEOUT;
 800155c:	2003      	movs	r0, #3
 800155e:	e08a      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001560:	4a10      	ldr	r2, [pc, #64]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 8001562:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8001564:	f043 0301 	orr.w	r3, r3, #1
 8001568:	6713      	str	r3, [r2, #112]	; 0x70
 800156a:	e7ce      	b.n	800150a <HAL_RCC_OscConfig+0x21e>
 800156c:	4b0d      	ldr	r3, [pc, #52]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
 800156e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001570:	f042 0204 	orr.w	r2, r2, #4
 8001574:	671a      	str	r2, [r3, #112]	; 0x70
 8001576:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001578:	f042 0201 	orr.w	r2, r2, #1
 800157c:	671a      	str	r2, [r3, #112]	; 0x70
 800157e:	e7c4      	b.n	800150a <HAL_RCC_OscConfig+0x21e>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8001580:	f7ff f860 	bl	8000644 <HAL_GetTick>
 8001584:	4680      	mov	r8, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001586:	4e07      	ldr	r6, [pc, #28]	; (80015a4 <HAL_RCC_OscConfig+0x2b8>)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001588:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800158c:	6f33      	ldr	r3, [r6, #112]	; 0x70
 800158e:	f013 0f02 	tst.w	r3, #2
 8001592:	d00f      	beq.n	80015b4 <HAL_RCC_OscConfig+0x2c8>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001594:	f7ff f856 	bl	8000644 <HAL_GetTick>
 8001598:	eba0 0008 	sub.w	r0, r0, r8
 800159c:	42b8      	cmp	r0, r7
 800159e:	d9f5      	bls.n	800158c <HAL_RCC_OscConfig+0x2a0>
        {
          return HAL_TIMEOUT;
 80015a0:	2003      	movs	r0, #3
 80015a2:	e068      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
 80015a4:	40023800 	.word	0x40023800
 80015a8:	42470000 	.word	0x42470000
 80015ac:	42470e80 	.word	0x42470e80
 80015b0:	40007000 	.word	0x40007000
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 80015b4:	b9e5      	cbnz	r5, 80015f0 <HAL_RCC_OscConfig+0x304>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80015b6:	69a3      	ldr	r3, [r4, #24]
 80015b8:	2b00      	cmp	r3, #0
 80015ba:	d05b      	beq.n	8001674 <HAL_RCC_OscConfig+0x388>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80015bc:	4a30      	ldr	r2, [pc, #192]	; (8001680 <HAL_RCC_OscConfig+0x394>)
 80015be:	6892      	ldr	r2, [r2, #8]
 80015c0:	f002 020c 	and.w	r2, r2, #12
 80015c4:	2a08      	cmp	r2, #8
 80015c6:	d059      	beq.n	800167c <HAL_RCC_OscConfig+0x390>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80015c8:	2b02      	cmp	r3, #2
 80015ca:	d017      	beq.n	80015fc <HAL_RCC_OscConfig+0x310>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80015cc:	2200      	movs	r2, #0
 80015ce:	4b2d      	ldr	r3, [pc, #180]	; (8001684 <HAL_RCC_OscConfig+0x398>)
 80015d0:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80015d2:	f7ff f837 	bl	8000644 <HAL_GetTick>
 80015d6:	4605      	mov	r5, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80015d8:	4c29      	ldr	r4, [pc, #164]	; (8001680 <HAL_RCC_OscConfig+0x394>)
 80015da:	6823      	ldr	r3, [r4, #0]
 80015dc:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80015e0:	d042      	beq.n	8001668 <HAL_RCC_OscConfig+0x37c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80015e2:	f7ff f82f 	bl	8000644 <HAL_GetTick>
 80015e6:	1b40      	subs	r0, r0, r5
 80015e8:	2802      	cmp	r0, #2
 80015ea:	d9f6      	bls.n	80015da <HAL_RCC_OscConfig+0x2ee>
          {
            return HAL_TIMEOUT;
 80015ec:	2003      	movs	r0, #3
 80015ee:	e042      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
      __HAL_RCC_PWR_CLK_DISABLE();
 80015f0:	4a23      	ldr	r2, [pc, #140]	; (8001680 <HAL_RCC_OscConfig+0x394>)
 80015f2:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80015f4:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80015f8:	6413      	str	r3, [r2, #64]	; 0x40
 80015fa:	e7dc      	b.n	80015b6 <HAL_RCC_OscConfig+0x2ca>
        __HAL_RCC_PLL_DISABLE();
 80015fc:	2200      	movs	r2, #0
 80015fe:	4b21      	ldr	r3, [pc, #132]	; (8001684 <HAL_RCC_OscConfig+0x398>)
 8001600:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001602:	f7ff f81f 	bl	8000644 <HAL_GetTick>
 8001606:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001608:	4d1d      	ldr	r5, [pc, #116]	; (8001680 <HAL_RCC_OscConfig+0x394>)
 800160a:	682b      	ldr	r3, [r5, #0]
 800160c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001610:	d006      	beq.n	8001620 <HAL_RCC_OscConfig+0x334>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001612:	f7ff f817 	bl	8000644 <HAL_GetTick>
 8001616:	1b80      	subs	r0, r0, r6
 8001618:	2802      	cmp	r0, #2
 800161a:	d9f6      	bls.n	800160a <HAL_RCC_OscConfig+0x31e>
            return HAL_TIMEOUT;
 800161c:	2003      	movs	r0, #3
 800161e:	e02a      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8001620:	69e3      	ldr	r3, [r4, #28]
 8001622:	6a22      	ldr	r2, [r4, #32]
 8001624:	4313      	orrs	r3, r2
 8001626:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001628:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 800162c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800162e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001632:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001634:	0852      	lsrs	r2, r2, #1
 8001636:	3a01      	subs	r2, #1
 8001638:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800163c:	4a10      	ldr	r2, [pc, #64]	; (8001680 <HAL_RCC_OscConfig+0x394>)
 800163e:	6053      	str	r3, [r2, #4]
        __HAL_RCC_PLL_ENABLE();
 8001640:	2201      	movs	r2, #1
 8001642:	4b10      	ldr	r3, [pc, #64]	; (8001684 <HAL_RCC_OscConfig+0x398>)
 8001644:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001646:	f7fe fffd 	bl	8000644 <HAL_GetTick>
 800164a:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800164c:	4c0c      	ldr	r4, [pc, #48]	; (8001680 <HAL_RCC_OscConfig+0x394>)
 800164e:	6823      	ldr	r3, [r4, #0]
 8001650:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001654:	d106      	bne.n	8001664 <HAL_RCC_OscConfig+0x378>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001656:	f7fe fff5 	bl	8000644 <HAL_GetTick>
 800165a:	1b40      	subs	r0, r0, r5
 800165c:	2802      	cmp	r0, #2
 800165e:	d9f6      	bls.n	800164e <HAL_RCC_OscConfig+0x362>
            return HAL_TIMEOUT;
 8001660:	2003      	movs	r0, #3
 8001662:	e008      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8001664:	2000      	movs	r0, #0
 8001666:	e006      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
 8001668:	2000      	movs	r0, #0
 800166a:	e004      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
    return HAL_ERROR;
 800166c:	2001      	movs	r0, #1
 800166e:	4770      	bx	lr
        return HAL_ERROR;
 8001670:	2001      	movs	r0, #1
 8001672:	e000      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
  return HAL_OK;
 8001674:	2000      	movs	r0, #0
}
 8001676:	b002      	add	sp, #8
 8001678:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return HAL_ERROR;
 800167c:	2001      	movs	r0, #1
 800167e:	e7fa      	b.n	8001676 <HAL_RCC_OscConfig+0x38a>
 8001680:	40023800 	.word	0x40023800
 8001684:	42470060 	.word	0x42470060

08001688 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8001688:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800168a:	4b31      	ldr	r3, [pc, #196]	; (8001750 <HAL_RCC_GetSysClockFreq+0xc8>)
 800168c:	689b      	ldr	r3, [r3, #8]
 800168e:	f003 030c 	and.w	r3, r3, #12
 8001692:	2b04      	cmp	r3, #4
 8001694:	d003      	beq.n	800169e <HAL_RCC_GetSysClockFreq+0x16>
 8001696:	2b08      	cmp	r3, #8
 8001698:	d003      	beq.n	80016a2 <HAL_RCC_GetSysClockFreq+0x1a>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 800169a:	482e      	ldr	r0, [pc, #184]	; (8001754 <HAL_RCC_GetSysClockFreq+0xcc>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 800169c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      sysclockfreq = HSE_VALUE;
 800169e:	482e      	ldr	r0, [pc, #184]	; (8001758 <HAL_RCC_GetSysClockFreq+0xd0>)
 80016a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80016a2:	4b2b      	ldr	r3, [pc, #172]	; (8001750 <HAL_RCC_GetSysClockFreq+0xc8>)
 80016a4:	685a      	ldr	r2, [r3, #4]
 80016a6:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80016aa:	685b      	ldr	r3, [r3, #4]
 80016ac:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80016b0:	d02a      	beq.n	8001708 <HAL_RCC_GetSysClockFreq+0x80>
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80016b2:	4b27      	ldr	r3, [pc, #156]	; (8001750 <HAL_RCC_GetSysClockFreq+0xc8>)
 80016b4:	685b      	ldr	r3, [r3, #4]
 80016b6:	f3c3 1388 	ubfx	r3, r3, #6, #9
 80016ba:	461e      	mov	r6, r3
 80016bc:	2700      	movs	r7, #0
 80016be:	015c      	lsls	r4, r3, #5
 80016c0:	2500      	movs	r5, #0
 80016c2:	1ae4      	subs	r4, r4, r3
 80016c4:	eb65 0507 	sbc.w	r5, r5, r7
 80016c8:	01a9      	lsls	r1, r5, #6
 80016ca:	ea41 6194 	orr.w	r1, r1, r4, lsr #26
 80016ce:	01a0      	lsls	r0, r4, #6
 80016d0:	1b00      	subs	r0, r0, r4
 80016d2:	eb61 0105 	sbc.w	r1, r1, r5
 80016d6:	00cb      	lsls	r3, r1, #3
 80016d8:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 80016dc:	00c4      	lsls	r4, r0, #3
 80016de:	19a0      	adds	r0, r4, r6
 80016e0:	eb43 0107 	adc.w	r1, r3, r7
 80016e4:	024b      	lsls	r3, r1, #9
 80016e6:	ea43 53d0 	orr.w	r3, r3, r0, lsr #23
 80016ea:	0244      	lsls	r4, r0, #9
 80016ec:	4620      	mov	r0, r4
 80016ee:	4619      	mov	r1, r3
 80016f0:	2300      	movs	r3, #0
 80016f2:	f7fe fdd3 	bl	800029c <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 80016f6:	4b16      	ldr	r3, [pc, #88]	; (8001750 <HAL_RCC_GetSysClockFreq+0xc8>)
 80016f8:	685b      	ldr	r3, [r3, #4]
 80016fa:	f3c3 4301 	ubfx	r3, r3, #16, #2
 80016fe:	3301      	adds	r3, #1
 8001700:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 8001702:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
 8001706:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8001708:	4b11      	ldr	r3, [pc, #68]	; (8001750 <HAL_RCC_GetSysClockFreq+0xc8>)
 800170a:	685b      	ldr	r3, [r3, #4]
 800170c:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8001710:	461e      	mov	r6, r3
 8001712:	2700      	movs	r7, #0
 8001714:	015c      	lsls	r4, r3, #5
 8001716:	2500      	movs	r5, #0
 8001718:	1ae4      	subs	r4, r4, r3
 800171a:	eb65 0507 	sbc.w	r5, r5, r7
 800171e:	01a9      	lsls	r1, r5, #6
 8001720:	ea41 6194 	orr.w	r1, r1, r4, lsr #26
 8001724:	01a0      	lsls	r0, r4, #6
 8001726:	1b00      	subs	r0, r0, r4
 8001728:	eb61 0105 	sbc.w	r1, r1, r5
 800172c:	00cb      	lsls	r3, r1, #3
 800172e:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8001732:	00c4      	lsls	r4, r0, #3
 8001734:	19a0      	adds	r0, r4, r6
 8001736:	eb43 0107 	adc.w	r1, r3, r7
 800173a:	028b      	lsls	r3, r1, #10
 800173c:	ea43 5390 	orr.w	r3, r3, r0, lsr #22
 8001740:	0284      	lsls	r4, r0, #10
 8001742:	4620      	mov	r0, r4
 8001744:	4619      	mov	r1, r3
 8001746:	2300      	movs	r3, #0
 8001748:	f7fe fda8 	bl	800029c <__aeabi_uldivmod>
 800174c:	e7d3      	b.n	80016f6 <HAL_RCC_GetSysClockFreq+0x6e>
 800174e:	bf00      	nop
 8001750:	40023800 	.word	0x40023800
 8001754:	00f42400 	.word	0x00f42400
 8001758:	007a1200 	.word	0x007a1200

0800175c <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 800175c:	2800      	cmp	r0, #0
 800175e:	f000 80a5 	beq.w	80018ac <HAL_RCC_ClockConfig+0x150>
{
 8001762:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001766:	4604      	mov	r4, r0
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8001768:	4b53      	ldr	r3, [pc, #332]	; (80018b8 <HAL_RCC_ClockConfig+0x15c>)
 800176a:	681b      	ldr	r3, [r3, #0]
 800176c:	f003 030f 	and.w	r3, r3, #15
 8001770:	428b      	cmp	r3, r1
 8001772:	d20a      	bcs.n	800178a <HAL_RCC_ClockConfig+0x2e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001774:	b2cb      	uxtb	r3, r1
 8001776:	4a50      	ldr	r2, [pc, #320]	; (80018b8 <HAL_RCC_ClockConfig+0x15c>)
 8001778:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800177a:	6813      	ldr	r3, [r2, #0]
 800177c:	f003 030f 	and.w	r3, r3, #15
 8001780:	4299      	cmp	r1, r3
 8001782:	d002      	beq.n	800178a <HAL_RCC_ClockConfig+0x2e>
      return HAL_ERROR;
 8001784:	2001      	movs	r0, #1
 8001786:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800178a:	6823      	ldr	r3, [r4, #0]
 800178c:	f013 0f02 	tst.w	r3, #2
 8001790:	d017      	beq.n	80017c2 <HAL_RCC_ClockConfig+0x66>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001792:	f013 0f04 	tst.w	r3, #4
 8001796:	d004      	beq.n	80017a2 <HAL_RCC_ClockConfig+0x46>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8001798:	4a48      	ldr	r2, [pc, #288]	; (80018bc <HAL_RCC_ClockConfig+0x160>)
 800179a:	6893      	ldr	r3, [r2, #8]
 800179c:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 80017a0:	6093      	str	r3, [r2, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80017a2:	6823      	ldr	r3, [r4, #0]
 80017a4:	f013 0f08 	tst.w	r3, #8
 80017a8:	d004      	beq.n	80017b4 <HAL_RCC_ClockConfig+0x58>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80017aa:	4a44      	ldr	r2, [pc, #272]	; (80018bc <HAL_RCC_ClockConfig+0x160>)
 80017ac:	6893      	ldr	r3, [r2, #8]
 80017ae:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 80017b2:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80017b4:	4a41      	ldr	r2, [pc, #260]	; (80018bc <HAL_RCC_ClockConfig+0x160>)
 80017b6:	6893      	ldr	r3, [r2, #8]
 80017b8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80017bc:	68a0      	ldr	r0, [r4, #8]
 80017be:	4303      	orrs	r3, r0
 80017c0:	6093      	str	r3, [r2, #8]
 80017c2:	460d      	mov	r5, r1
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80017c4:	6823      	ldr	r3, [r4, #0]
 80017c6:	f013 0f01 	tst.w	r3, #1
 80017ca:	d036      	beq.n	800183a <HAL_RCC_ClockConfig+0xde>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80017cc:	6862      	ldr	r2, [r4, #4]
 80017ce:	2a01      	cmp	r2, #1
 80017d0:	d023      	beq.n	800181a <HAL_RCC_ClockConfig+0xbe>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80017d2:	1e93      	subs	r3, r2, #2
 80017d4:	2b01      	cmp	r3, #1
 80017d6:	d928      	bls.n	800182a <HAL_RCC_ClockConfig+0xce>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80017d8:	4b38      	ldr	r3, [pc, #224]	; (80018bc <HAL_RCC_ClockConfig+0x160>)
 80017da:	681b      	ldr	r3, [r3, #0]
 80017dc:	f013 0f02 	tst.w	r3, #2
 80017e0:	d066      	beq.n	80018b0 <HAL_RCC_ClockConfig+0x154>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80017e2:	4936      	ldr	r1, [pc, #216]	; (80018bc <HAL_RCC_ClockConfig+0x160>)
 80017e4:	688b      	ldr	r3, [r1, #8]
 80017e6:	f023 0303 	bic.w	r3, r3, #3
 80017ea:	4313      	orrs	r3, r2
 80017ec:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 80017ee:	f7fe ff29 	bl	8000644 <HAL_GetTick>
 80017f2:	4680      	mov	r8, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80017f4:	4e31      	ldr	r6, [pc, #196]	; (80018bc <HAL_RCC_ClockConfig+0x160>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80017f6:	f241 3788 	movw	r7, #5000	; 0x1388
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80017fa:	68b3      	ldr	r3, [r6, #8]
 80017fc:	f003 030c 	and.w	r3, r3, #12
 8001800:	6862      	ldr	r2, [r4, #4]
 8001802:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8001806:	d018      	beq.n	800183a <HAL_RCC_ClockConfig+0xde>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001808:	f7fe ff1c 	bl	8000644 <HAL_GetTick>
 800180c:	eba0 0008 	sub.w	r0, r0, r8
 8001810:	42b8      	cmp	r0, r7
 8001812:	d9f2      	bls.n	80017fa <HAL_RCC_ClockConfig+0x9e>
        return HAL_TIMEOUT;
 8001814:	2003      	movs	r0, #3
 8001816:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800181a:	4b28      	ldr	r3, [pc, #160]	; (80018bc <HAL_RCC_ClockConfig+0x160>)
 800181c:	681b      	ldr	r3, [r3, #0]
 800181e:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001822:	d1de      	bne.n	80017e2 <HAL_RCC_ClockConfig+0x86>
        return HAL_ERROR;
 8001824:	2001      	movs	r0, #1
 8001826:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800182a:	4b24      	ldr	r3, [pc, #144]	; (80018bc <HAL_RCC_ClockConfig+0x160>)
 800182c:	681b      	ldr	r3, [r3, #0]
 800182e:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001832:	d1d6      	bne.n	80017e2 <HAL_RCC_ClockConfig+0x86>
        return HAL_ERROR;
 8001834:	2001      	movs	r0, #1
 8001836:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800183a:	4b1f      	ldr	r3, [pc, #124]	; (80018b8 <HAL_RCC_ClockConfig+0x15c>)
 800183c:	681b      	ldr	r3, [r3, #0]
 800183e:	f003 030f 	and.w	r3, r3, #15
 8001842:	429d      	cmp	r5, r3
 8001844:	d20a      	bcs.n	800185c <HAL_RCC_ClockConfig+0x100>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001846:	b2ea      	uxtb	r2, r5
 8001848:	4b1b      	ldr	r3, [pc, #108]	; (80018b8 <HAL_RCC_ClockConfig+0x15c>)
 800184a:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800184c:	681b      	ldr	r3, [r3, #0]
 800184e:	f003 030f 	and.w	r3, r3, #15
 8001852:	429d      	cmp	r5, r3
 8001854:	d002      	beq.n	800185c <HAL_RCC_ClockConfig+0x100>
      return HAL_ERROR;
 8001856:	2001      	movs	r0, #1
}
 8001858:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800185c:	6823      	ldr	r3, [r4, #0]
 800185e:	f013 0f04 	tst.w	r3, #4
 8001862:	d006      	beq.n	8001872 <HAL_RCC_ClockConfig+0x116>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001864:	4a15      	ldr	r2, [pc, #84]	; (80018bc <HAL_RCC_ClockConfig+0x160>)
 8001866:	6893      	ldr	r3, [r2, #8]
 8001868:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 800186c:	68e1      	ldr	r1, [r4, #12]
 800186e:	430b      	orrs	r3, r1
 8001870:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001872:	6823      	ldr	r3, [r4, #0]
 8001874:	f013 0f08 	tst.w	r3, #8
 8001878:	d007      	beq.n	800188a <HAL_RCC_ClockConfig+0x12e>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800187a:	4a10      	ldr	r2, [pc, #64]	; (80018bc <HAL_RCC_ClockConfig+0x160>)
 800187c:	6893      	ldr	r3, [r2, #8]
 800187e:	6921      	ldr	r1, [r4, #16]
 8001880:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001884:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001888:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800188a:	f7ff fefd 	bl	8001688 <HAL_RCC_GetSysClockFreq>
 800188e:	4b0b      	ldr	r3, [pc, #44]	; (80018bc <HAL_RCC_ClockConfig+0x160>)
 8001890:	689b      	ldr	r3, [r3, #8]
 8001892:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8001896:	4a0a      	ldr	r2, [pc, #40]	; (80018c0 <HAL_RCC_ClockConfig+0x164>)
 8001898:	5cd3      	ldrb	r3, [r2, r3]
 800189a:	40d8      	lsrs	r0, r3
 800189c:	4b09      	ldr	r3, [pc, #36]	; (80018c4 <HAL_RCC_ClockConfig+0x168>)
 800189e:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 80018a0:	2000      	movs	r0, #0
 80018a2:	f7fe fe83 	bl	80005ac <HAL_InitTick>
  return HAL_OK;
 80018a6:	2000      	movs	r0, #0
 80018a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return HAL_ERROR;
 80018ac:	2001      	movs	r0, #1
 80018ae:	4770      	bx	lr
        return HAL_ERROR;
 80018b0:	2001      	movs	r0, #1
 80018b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80018b6:	bf00      	nop
 80018b8:	40023c00 	.word	0x40023c00
 80018bc:	40023800 	.word	0x40023800
 80018c0:	080091c4 	.word	0x080091c4
 80018c4:	20000100 	.word	0x20000100

080018c8 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 80018c8:	4b01      	ldr	r3, [pc, #4]	; (80018d0 <HAL_RCC_GetHCLKFreq+0x8>)
 80018ca:	6818      	ldr	r0, [r3, #0]
 80018cc:	4770      	bx	lr
 80018ce:	bf00      	nop
 80018d0:	20000100 	.word	0x20000100

080018d4 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80018d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80018d6:	b083      	sub	sp, #12
 80018d8:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 80018da:	6803      	ldr	r3, [r0, #0]
 80018dc:	f013 0f05 	tst.w	r3, #5
 80018e0:	d10e      	bne.n	8001900 <HAL_RCCEx_PeriphCLKConfig+0x2c>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 80018e2:	6823      	ldr	r3, [r4, #0]
 80018e4:	f013 0f02 	tst.w	r3, #2
 80018e8:	d138      	bne.n	800195c <HAL_RCCEx_PeriphCLKConfig+0x88>
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }
#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 80018ea:	6823      	ldr	r3, [r4, #0]
 80018ec:	f013 0f08 	tst.w	r3, #8
 80018f0:	f000 809b 	beq.w	8001a2a <HAL_RCCEx_PeriphCLKConfig+0x156>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 80018f4:	7d22      	ldrb	r2, [r4, #20]
 80018f6:	4b4e      	ldr	r3, [pc, #312]	; (8001a30 <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 80018f8:	601a      	str	r2, [r3, #0]
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 80018fa:	2000      	movs	r0, #0
}
 80018fc:	b003      	add	sp, #12
 80018fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_PLLI2S_DISABLE();
 8001900:	2200      	movs	r2, #0
 8001902:	4b4c      	ldr	r3, [pc, #304]	; (8001a34 <HAL_RCCEx_PeriphCLKConfig+0x160>)
 8001904:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8001906:	f7fe fe9d 	bl	8000644 <HAL_GetTick>
 800190a:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800190c:	4d4a      	ldr	r5, [pc, #296]	; (8001a38 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800190e:	682b      	ldr	r3, [r5, #0]
 8001910:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8001914:	d006      	beq.n	8001924 <HAL_RCCEx_PeriphCLKConfig+0x50>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8001916:	f7fe fe95 	bl	8000644 <HAL_GetTick>
 800191a:	1b80      	subs	r0, r0, r6
 800191c:	2802      	cmp	r0, #2
 800191e:	d9f6      	bls.n	800190e <HAL_RCCEx_PeriphCLKConfig+0x3a>
        return HAL_TIMEOUT;
 8001920:	2003      	movs	r0, #3
 8001922:	e7eb      	b.n	80018fc <HAL_RCCEx_PeriphCLKConfig+0x28>
    __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
 8001924:	68a2      	ldr	r2, [r4, #8]
 8001926:	68e3      	ldr	r3, [r4, #12]
 8001928:	071b      	lsls	r3, r3, #28
 800192a:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 800192e:	6862      	ldr	r2, [r4, #4]
 8001930:	4313      	orrs	r3, r2
 8001932:	4a41      	ldr	r2, [pc, #260]	; (8001a38 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001934:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 8001938:	2201      	movs	r2, #1
 800193a:	4b3e      	ldr	r3, [pc, #248]	; (8001a34 <HAL_RCCEx_PeriphCLKConfig+0x160>)
 800193c:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 800193e:	f7fe fe81 	bl	8000644 <HAL_GetTick>
 8001942:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8001944:	4d3c      	ldr	r5, [pc, #240]	; (8001a38 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001946:	682b      	ldr	r3, [r5, #0]
 8001948:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 800194c:	d1c9      	bne.n	80018e2 <HAL_RCCEx_PeriphCLKConfig+0xe>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 800194e:	f7fe fe79 	bl	8000644 <HAL_GetTick>
 8001952:	1b80      	subs	r0, r0, r6
 8001954:	2802      	cmp	r0, #2
 8001956:	d9f6      	bls.n	8001946 <HAL_RCCEx_PeriphCLKConfig+0x72>
        return HAL_TIMEOUT;
 8001958:	2003      	movs	r0, #3
 800195a:	e7cf      	b.n	80018fc <HAL_RCCEx_PeriphCLKConfig+0x28>
    __HAL_RCC_PWR_CLK_ENABLE();
 800195c:	2300      	movs	r3, #0
 800195e:	9301      	str	r3, [sp, #4]
 8001960:	4b35      	ldr	r3, [pc, #212]	; (8001a38 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001962:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001964:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001968:	641a      	str	r2, [r3, #64]	; 0x40
 800196a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800196c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001970:	9301      	str	r3, [sp, #4]
 8001972:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 8001974:	4a31      	ldr	r2, [pc, #196]	; (8001a3c <HAL_RCCEx_PeriphCLKConfig+0x168>)
 8001976:	6813      	ldr	r3, [r2, #0]
 8001978:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800197c:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 800197e:	f7fe fe61 	bl	8000644 <HAL_GetTick>
 8001982:	4606      	mov	r6, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8001984:	4d2d      	ldr	r5, [pc, #180]	; (8001a3c <HAL_RCCEx_PeriphCLKConfig+0x168>)
 8001986:	682b      	ldr	r3, [r5, #0]
 8001988:	f413 7f80 	tst.w	r3, #256	; 0x100
 800198c:	d106      	bne.n	800199c <HAL_RCCEx_PeriphCLKConfig+0xc8>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800198e:	f7fe fe59 	bl	8000644 <HAL_GetTick>
 8001992:	1b80      	subs	r0, r0, r6
 8001994:	2802      	cmp	r0, #2
 8001996:	d9f6      	bls.n	8001986 <HAL_RCCEx_PeriphCLKConfig+0xb2>
        return HAL_TIMEOUT;
 8001998:	2003      	movs	r0, #3
 800199a:	e7af      	b.n	80018fc <HAL_RCCEx_PeriphCLKConfig+0x28>
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 800199c:	4b26      	ldr	r3, [pc, #152]	; (8001a38 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800199e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 80019a0:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 80019a4:	d012      	beq.n	80019cc <HAL_RCCEx_PeriphCLKConfig+0xf8>
 80019a6:	6922      	ldr	r2, [r4, #16]
 80019a8:	f402 7240 	and.w	r2, r2, #768	; 0x300
 80019ac:	4293      	cmp	r3, r2
 80019ae:	d00d      	beq.n	80019cc <HAL_RCCEx_PeriphCLKConfig+0xf8>
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 80019b0:	4b21      	ldr	r3, [pc, #132]	; (8001a38 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 80019b2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80019b4:	f422 7240 	bic.w	r2, r2, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 80019b8:	4921      	ldr	r1, [pc, #132]	; (8001a40 <HAL_RCCEx_PeriphCLKConfig+0x16c>)
 80019ba:	2001      	movs	r0, #1
 80019bc:	6008      	str	r0, [r1, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 80019be:	2000      	movs	r0, #0
 80019c0:	6008      	str	r0, [r1, #0]
      RCC->BDCR = tmpreg1;
 80019c2:	671a      	str	r2, [r3, #112]	; 0x70
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 80019c4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80019c6:	f013 0f01 	tst.w	r3, #1
 80019ca:	d112      	bne.n	80019f2 <HAL_RCCEx_PeriphCLKConfig+0x11e>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80019cc:	6923      	ldr	r3, [r4, #16]
 80019ce:	f403 7240 	and.w	r2, r3, #768	; 0x300
 80019d2:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 80019d6:	d01d      	beq.n	8001a14 <HAL_RCCEx_PeriphCLKConfig+0x140>
 80019d8:	4a17      	ldr	r2, [pc, #92]	; (8001a38 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 80019da:	6893      	ldr	r3, [r2, #8]
 80019dc:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 80019e0:	6093      	str	r3, [r2, #8]
 80019e2:	4a15      	ldr	r2, [pc, #84]	; (8001a38 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 80019e4:	6f11      	ldr	r1, [r2, #112]	; 0x70
 80019e6:	6923      	ldr	r3, [r4, #16]
 80019e8:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80019ec:	430b      	orrs	r3, r1
 80019ee:	6713      	str	r3, [r2, #112]	; 0x70
 80019f0:	e77b      	b.n	80018ea <HAL_RCCEx_PeriphCLKConfig+0x16>
        tickstart = HAL_GetTick();
 80019f2:	f7fe fe27 	bl	8000644 <HAL_GetTick>
 80019f6:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80019f8:	4d0f      	ldr	r5, [pc, #60]	; (8001a38 <HAL_RCCEx_PeriphCLKConfig+0x164>)
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80019fa:	f241 3688 	movw	r6, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80019fe:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001a00:	f013 0f02 	tst.w	r3, #2
 8001a04:	d1e2      	bne.n	80019cc <HAL_RCCEx_PeriphCLKConfig+0xf8>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001a06:	f7fe fe1d 	bl	8000644 <HAL_GetTick>
 8001a0a:	1bc0      	subs	r0, r0, r7
 8001a0c:	42b0      	cmp	r0, r6
 8001a0e:	d9f6      	bls.n	80019fe <HAL_RCCEx_PeriphCLKConfig+0x12a>
            return HAL_TIMEOUT;
 8001a10:	2003      	movs	r0, #3
 8001a12:	e773      	b.n	80018fc <HAL_RCCEx_PeriphCLKConfig+0x28>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8001a14:	4908      	ldr	r1, [pc, #32]	; (8001a38 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001a16:	688a      	ldr	r2, [r1, #8]
 8001a18:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8001a1c:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8001a20:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001a24:	4313      	orrs	r3, r2
 8001a26:	608b      	str	r3, [r1, #8]
 8001a28:	e7db      	b.n	80019e2 <HAL_RCCEx_PeriphCLKConfig+0x10e>
  return HAL_OK;
 8001a2a:	2000      	movs	r0, #0
 8001a2c:	e766      	b.n	80018fc <HAL_RCCEx_PeriphCLKConfig+0x28>
 8001a2e:	bf00      	nop
 8001a30:	424711e0 	.word	0x424711e0
 8001a34:	42470068 	.word	0x42470068
 8001a38:	40023800 	.word	0x40023800
 8001a3c:	40007000 	.word	0x40007000
 8001a40:	42470e40 	.word	0x42470e40

08001a44 <HAL_RTC_WaitForSynchro>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
 8001a44:	b538      	push	{r3, r4, r5, lr}
 8001a46:	4604      	mov	r4, r0
  uint32_t tickstart = 0U;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8001a48:	6802      	ldr	r2, [r0, #0]
 8001a4a:	68d3      	ldr	r3, [r2, #12]
 8001a4c:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8001a50:	60d3      	str	r3, [r2, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 8001a52:	f7fe fdf7 	bl	8000644 <HAL_GetTick>
 8001a56:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8001a58:	6823      	ldr	r3, [r4, #0]
 8001a5a:	68db      	ldr	r3, [r3, #12]
 8001a5c:	f013 0f20 	tst.w	r3, #32
 8001a60:	d107      	bne.n	8001a72 <HAL_RTC_WaitForSynchro+0x2e>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8001a62:	f7fe fdef 	bl	8000644 <HAL_GetTick>
 8001a66:	1b40      	subs	r0, r0, r5
 8001a68:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001a6c:	d9f4      	bls.n	8001a58 <HAL_RTC_WaitForSynchro+0x14>
    {       
      return HAL_TIMEOUT;
 8001a6e:	2003      	movs	r0, #3
    } 
  }

  return HAL_OK;
}
 8001a70:	bd38      	pop	{r3, r4, r5, pc}
  return HAL_OK;
 8001a72:	2000      	movs	r0, #0
 8001a74:	bd38      	pop	{r3, r4, r5, pc}

08001a76 <RTC_EnterInitMode>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 8001a76:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0U; 
  
  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8001a78:	6803      	ldr	r3, [r0, #0]
 8001a7a:	68da      	ldr	r2, [r3, #12]
 8001a7c:	f012 0f40 	tst.w	r2, #64	; 0x40
 8001a80:	d001      	beq.n	8001a86 <RTC_EnterInitMode+0x10>
        return HAL_TIMEOUT;
      } 
    }
  }
  
  return HAL_OK;  
 8001a82:	2000      	movs	r0, #0
 8001a84:	bd38      	pop	{r3, r4, r5, pc}
 8001a86:	4604      	mov	r4, r0
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8001a88:	f04f 32ff 	mov.w	r2, #4294967295
 8001a8c:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 8001a8e:	f7fe fdd9 	bl	8000644 <HAL_GetTick>
 8001a92:	4605      	mov	r5, r0
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8001a94:	6823      	ldr	r3, [r4, #0]
 8001a96:	68db      	ldr	r3, [r3, #12]
 8001a98:	f013 0f40 	tst.w	r3, #64	; 0x40
 8001a9c:	d107      	bne.n	8001aae <RTC_EnterInitMode+0x38>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8001a9e:	f7fe fdd1 	bl	8000644 <HAL_GetTick>
 8001aa2:	1b40      	subs	r0, r0, r5
 8001aa4:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001aa8:	d9f4      	bls.n	8001a94 <RTC_EnterInitMode+0x1e>
        return HAL_TIMEOUT;
 8001aaa:	2003      	movs	r0, #3
}
 8001aac:	bd38      	pop	{r3, r4, r5, pc}
  return HAL_OK;  
 8001aae:	2000      	movs	r0, #0
 8001ab0:	bd38      	pop	{r3, r4, r5, pc}

08001ab2 <HAL_RTC_Init>:
{
 8001ab2:	b538      	push	{r3, r4, r5, lr}
  if(hrtc == NULL)
 8001ab4:	2800      	cmp	r0, #0
 8001ab6:	d05c      	beq.n	8001b72 <HAL_RTC_Init+0xc0>
 8001ab8:	4604      	mov	r4, r0
  if(hrtc->State == HAL_RTC_STATE_RESET)
 8001aba:	7f43      	ldrb	r3, [r0, #29]
 8001abc:	2b00      	cmp	r3, #0
 8001abe:	d041      	beq.n	8001b44 <HAL_RTC_Init+0x92>
  hrtc->State = HAL_RTC_STATE_BUSY;  
 8001ac0:	2302      	movs	r3, #2
 8001ac2:	7763      	strb	r3, [r4, #29]
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8001ac4:	6823      	ldr	r3, [r4, #0]
 8001ac6:	22ca      	movs	r2, #202	; 0xca
 8001ac8:	625a      	str	r2, [r3, #36]	; 0x24
 8001aca:	6823      	ldr	r3, [r4, #0]
 8001acc:	2253      	movs	r2, #83	; 0x53
 8001ace:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8001ad0:	4620      	mov	r0, r4
 8001ad2:	f7ff ffd0 	bl	8001a76 <RTC_EnterInitMode>
 8001ad6:	4605      	mov	r5, r0
 8001ad8:	2800      	cmp	r0, #0
 8001ada:	d137      	bne.n	8001b4c <HAL_RTC_Init+0x9a>
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8001adc:	6822      	ldr	r2, [r4, #0]
 8001ade:	6893      	ldr	r3, [r2, #8]
 8001ae0:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 8001ae4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001ae8:	6093      	str	r3, [r2, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8001aea:	6822      	ldr	r2, [r4, #0]
 8001aec:	6891      	ldr	r1, [r2, #8]
 8001aee:	6863      	ldr	r3, [r4, #4]
 8001af0:	6920      	ldr	r0, [r4, #16]
 8001af2:	4303      	orrs	r3, r0
 8001af4:	6960      	ldr	r0, [r4, #20]
 8001af6:	4303      	orrs	r3, r0
 8001af8:	430b      	orrs	r3, r1
 8001afa:	6093      	str	r3, [r2, #8]
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8001afc:	6823      	ldr	r3, [r4, #0]
 8001afe:	68e2      	ldr	r2, [r4, #12]
 8001b00:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 8001b02:	6822      	ldr	r2, [r4, #0]
 8001b04:	6913      	ldr	r3, [r2, #16]
 8001b06:	68a1      	ldr	r1, [r4, #8]
 8001b08:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8001b0c:	6113      	str	r3, [r2, #16]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT; 
 8001b0e:	6822      	ldr	r2, [r4, #0]
 8001b10:	68d3      	ldr	r3, [r2, #12]
 8001b12:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001b16:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8001b18:	6823      	ldr	r3, [r4, #0]
 8001b1a:	689b      	ldr	r3, [r3, #8]
 8001b1c:	f013 0f20 	tst.w	r3, #32
 8001b20:	d01b      	beq.n	8001b5a <HAL_RTC_Init+0xa8>
    hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
 8001b22:	6822      	ldr	r2, [r4, #0]
 8001b24:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8001b26:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001b2a:	6413      	str	r3, [r2, #64]	; 0x40
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType); 
 8001b2c:	6822      	ldr	r2, [r4, #0]
 8001b2e:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8001b30:	69a1      	ldr	r1, [r4, #24]
 8001b32:	430b      	orrs	r3, r1
 8001b34:	6413      	str	r3, [r2, #64]	; 0x40
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8001b36:	6823      	ldr	r3, [r4, #0]
 8001b38:	22ff      	movs	r2, #255	; 0xff
 8001b3a:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY;
 8001b3c:	2301      	movs	r3, #1
 8001b3e:	7763      	strb	r3, [r4, #29]
}
 8001b40:	4628      	mov	r0, r5
 8001b42:	bd38      	pop	{r3, r4, r5, pc}
    hrtc->Lock = HAL_UNLOCKED;
 8001b44:	7703      	strb	r3, [r0, #28]
    HAL_RTC_MspInit(hrtc);
 8001b46:	f001 ff63 	bl	8003a10 <HAL_RTC_MspInit>
 8001b4a:	e7b9      	b.n	8001ac0 <HAL_RTC_Init+0xe>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8001b4c:	6823      	ldr	r3, [r4, #0]
 8001b4e:	22ff      	movs	r2, #255	; 0xff
 8001b50:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8001b52:	2304      	movs	r3, #4
 8001b54:	7763      	strb	r3, [r4, #29]
    return HAL_ERROR;
 8001b56:	2501      	movs	r5, #1
 8001b58:	e7f2      	b.n	8001b40 <HAL_RTC_Init+0x8e>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8001b5a:	4620      	mov	r0, r4
 8001b5c:	f7ff ff72 	bl	8001a44 <HAL_RTC_WaitForSynchro>
 8001b60:	2800      	cmp	r0, #0
 8001b62:	d0de      	beq.n	8001b22 <HAL_RTC_Init+0x70>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8001b64:	6823      	ldr	r3, [r4, #0]
 8001b66:	22ff      	movs	r2, #255	; 0xff
 8001b68:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8001b6a:	2304      	movs	r3, #4
 8001b6c:	7763      	strb	r3, [r4, #29]
        return HAL_ERROR;
 8001b6e:	2501      	movs	r5, #1
 8001b70:	e7e6      	b.n	8001b40 <HAL_RTC_Init+0x8e>
     return HAL_ERROR;
 8001b72:	2501      	movs	r5, #1
 8001b74:	e7e4      	b.n	8001b40 <HAL_RTC_Init+0x8e>

08001b76 <USB_CoreInit>:
  * @param  cfg  pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8001b76:	b084      	sub	sp, #16
 8001b78:	b510      	push	{r4, lr}
 8001b7a:	4604      	mov	r4, r0
 8001b7c:	a803      	add	r0, sp, #12
 8001b7e:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001b82:	9b08      	ldr	r3, [sp, #32]
 8001b84:	2b01      	cmp	r3, #1
 8001b86:	d011      	beq.n	8001bac <USB_CoreInit+0x36>
    USB_CoreReset(USBx); 
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8001b88:	68e3      	ldr	r3, [r4, #12]
 8001b8a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001b8e:	60e3      	str	r3, [r4, #12]
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
 8001b90:	4620      	mov	r0, r4
 8001b92:	f000 fcaf 	bl	80024f4 <USB_CoreReset>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 8001b96:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001b9a:	63a3      	str	r3, [r4, #56]	; 0x38
  }
 
  if(cfg.dma_enable == ENABLE)
 8001b9c:	9b06      	ldr	r3, [sp, #24]
 8001b9e:	2b01      	cmp	r3, #1
 8001ba0:	d01e      	beq.n	8001be0 <USB_CoreInit+0x6a>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  }  

  return HAL_OK;
}
 8001ba2:	2000      	movs	r0, #0
 8001ba4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8001ba8:	b004      	add	sp, #16
 8001baa:	4770      	bx	lr
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8001bac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001bae:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001bb2:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8001bb4:	68e3      	ldr	r3, [r4, #12]
 8001bb6:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 8001bba:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001bbe:	60e3      	str	r3, [r4, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8001bc0:	68e3      	ldr	r3, [r4, #12]
 8001bc2:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8001bc6:	60e3      	str	r3, [r4, #12]
    if(cfg.use_external_vbus == 1U)
 8001bc8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8001bca:	2b01      	cmp	r3, #1
 8001bcc:	d003      	beq.n	8001bd6 <USB_CoreInit+0x60>
    USB_CoreReset(USBx); 
 8001bce:	4620      	mov	r0, r4
 8001bd0:	f000 fc90 	bl	80024f4 <USB_CoreReset>
 8001bd4:	e7e2      	b.n	8001b9c <USB_CoreInit+0x26>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8001bd6:	68e3      	ldr	r3, [r4, #12]
 8001bd8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001bdc:	60e3      	str	r3, [r4, #12]
 8001bde:	e7f6      	b.n	8001bce <USB_CoreInit+0x58>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8001be0:	68a3      	ldr	r3, [r4, #8]
 8001be2:	f043 0306 	orr.w	r3, r3, #6
 8001be6:	60a3      	str	r3, [r4, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8001be8:	68a3      	ldr	r3, [r4, #8]
 8001bea:	f043 0320 	orr.w	r3, r3, #32
 8001bee:	60a3      	str	r3, [r4, #8]
 8001bf0:	e7d7      	b.n	8001ba2 <USB_CoreInit+0x2c>

08001bf2 <USB_EnableGlobalInt>:
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8001bf2:	6883      	ldr	r3, [r0, #8]
 8001bf4:	f043 0301 	orr.w	r3, r3, #1
 8001bf8:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 8001bfa:	2000      	movs	r0, #0
 8001bfc:	4770      	bx	lr

08001bfe <USB_DisableGlobalInt>:
  * @param  USBx  Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8001bfe:	6883      	ldr	r3, [r0, #8]
 8001c00:	f023 0301 	bic.w	r3, r3, #1
 8001c04:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 8001c06:	2000      	movs	r0, #0
 8001c08:	4770      	bx	lr

08001c0a <USB_SetCurrentMode>:
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
 8001c0a:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 8001c0c:	68c3      	ldr	r3, [r0, #12]
 8001c0e:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8001c12:	60c3      	str	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 8001c14:	2901      	cmp	r1, #1
 8001c16:	d009      	beq.n	8001c2c <USB_SetCurrentMode+0x22>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
 8001c18:	b919      	cbnz	r1, 8001c22 <USB_SetCurrentMode+0x18>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
 8001c1a:	68c3      	ldr	r3, [r0, #12]
 8001c1c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8001c20:	60c3      	str	r3, [r0, #12]
  }
  HAL_Delay(50U);
 8001c22:	2032      	movs	r0, #50	; 0x32
 8001c24:	f7fe fd14 	bl	8000650 <HAL_Delay>
  
  return HAL_OK;
}
 8001c28:	2000      	movs	r0, #0
 8001c2a:	bd08      	pop	{r3, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
 8001c2c:	68c3      	ldr	r3, [r0, #12]
 8001c2e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8001c32:	60c3      	str	r3, [r0, #12]
 8001c34:	e7f5      	b.n	8001c22 <USB_SetCurrentMode+0x18>
	...

08001c38 <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8001c38:	b084      	sub	sp, #16
 8001c3a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001c3e:	4604      	mov	r4, r0
 8001c40:	a80b      	add	r0, sp, #44	; 0x2c
 8001c42:	e880 000e 	stmia.w	r0, {r1, r2, r3}
 8001c46:	4688      	mov	r8, r1
 8001c48:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
 8001c4c:	f8dd b054 	ldr.w	fp, [sp, #84]	; 0x54
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  if (cfg.vbus_sensing_enable == 0U)
 8001c50:	f1bb 0f00 	cmp.w	fp, #0
 8001c54:	d172      	bne.n	8001d3c <USB_DevInit+0x104>
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 8001c56:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001c58:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001c5c:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx || STM32F413xx || STM32F423xx  */
  
  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 8001c5e:	2300      	movs	r3, #0
 8001c60:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
  
  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8001c64:	f504 6500 	add.w	r5, r4, #2048	; 0x800
 8001c68:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 8001c6c:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 8001c70:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8001c72:	2b01      	cmp	r3, #1
 8001c74:	d067      	beq.n	8001d46 <USB_DevInit+0x10e>
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 8001c76:	2103      	movs	r1, #3
 8001c78:	4620      	mov	r0, r4
 8001c7a:	f000 f8ad 	bl	8001dd8 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 8001c7e:	2110      	movs	r1, #16
 8001c80:	4620      	mov	r0, r4
 8001c82:	f000 f887 	bl	8001d94 <USB_FlushTxFifo>
  USB_FlushRxFifo(USBx);
 8001c86:	4620      	mov	r0, r4
 8001c88:	f000 f896 	bl	8001db8 <USB_FlushRxFifo>
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 8001c8c:	2300      	movs	r3, #0
 8001c8e:	612b      	str	r3, [r5, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 8001c90:	616b      	str	r3, [r5, #20]
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8001c92:	f04f 32ff 	mov.w	r2, #4294967295
 8001c96:	61aa      	str	r2, [r5, #24]
  USBx_DEVICE->DAINTMSK = 0U;
 8001c98:	61eb      	str	r3, [r5, #28]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001c9a:	f1b8 0f00 	cmp.w	r8, #0
 8001c9e:	d028      	beq.n	8001cf2 <USB_DevInit+0xba>
 8001ca0:	f504 6310 	add.w	r3, r4, #2304	; 0x900
 8001ca4:	2200      	movs	r2, #0
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 8001ca6:	4616      	mov	r6, r2
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8001ca8:	f04f 4990 	mov.w	r9, #1207959552	; 0x48000000
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 8001cac:	27ff      	movs	r7, #255	; 0xff
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8001cae:	6818      	ldr	r0, [r3, #0]
 8001cb0:	2800      	cmp	r0, #0
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8001cb2:	bfb4      	ite	lt
 8001cb4:	f8c3 9000 	strlt.w	r9, [r3]
      USBx_INEP(i)->DIEPCTL = 0U;
 8001cb8:	601e      	strge	r6, [r3, #0]
    USBx_INEP(i)->DIEPTSIZ = 0U;
 8001cba:	611e      	str	r6, [r3, #16]
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 8001cbc:	609f      	str	r7, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001cbe:	3201      	adds	r2, #1
 8001cc0:	3320      	adds	r3, #32
 8001cc2:	4542      	cmp	r2, r8
 8001cc4:	d1f3      	bne.n	8001cae <USB_DevInit+0x76>
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001cc6:	b1a2      	cbz	r2, 8001cf2 <USB_DevInit+0xba>
 8001cc8:	f504 6330 	add.w	r3, r4, #2816	; 0xb00
 8001ccc:	2100      	movs	r1, #0
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8001cce:	460f      	mov	r7, r1
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8001cd0:	f04f 4990 	mov.w	r9, #1207959552	; 0x48000000
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 8001cd4:	f04f 08ff 	mov.w	r8, #255	; 0xff
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8001cd8:	681e      	ldr	r6, [r3, #0]
 8001cda:	2e00      	cmp	r6, #0
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8001cdc:	bfb4      	ite	lt
 8001cde:	f8c3 9000 	strlt.w	r9, [r3]
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8001ce2:	601f      	strge	r7, [r3, #0]
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8001ce4:	611f      	str	r7, [r3, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 8001ce6:	f8c3 8008 	str.w	r8, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001cea:	3101      	adds	r1, #1
 8001cec:	3320      	adds	r3, #32
 8001cee:	428a      	cmp	r2, r1
 8001cf0:	d1f2      	bne.n	8001cd8 <USB_DevInit+0xa0>
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8001cf2:	692b      	ldr	r3, [r5, #16]
 8001cf4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001cf8:	612b      	str	r3, [r5, #16]
  
  if (cfg.dma_enable == 1U)
 8001cfa:	f1ba 0f01 	cmp.w	sl, #1
 8001cfe:	d02e      	beq.n	8001d5e <USB_DevInit+0x126>
    
    i= USBx_DEVICE->DTHRCTL;
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 8001d00:	2300      	movs	r3, #0
 8001d02:	61a3      	str	r3, [r4, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 8001d04:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 8001d08:	6163      	str	r3, [r4, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 8001d0a:	f1ba 0f00 	cmp.w	sl, #0
 8001d0e:	d103      	bne.n	8001d18 <USB_DevInit+0xe0>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 8001d10:	69a3      	ldr	r3, [r4, #24]
 8001d12:	f043 0310 	orr.w	r3, r3, #16
 8001d16:	61a3      	str	r3, [r4, #24]
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 8001d18:	69a2      	ldr	r2, [r4, #24]
 8001d1a:	4b1c      	ldr	r3, [pc, #112]	; (8001d8c <USB_DevInit+0x154>)
 8001d1c:	4313      	orrs	r3, r2
 8001d1e:	61a3      	str	r3, [r4, #24]
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 8001d20:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8001d22:	b11b      	cbz	r3, 8001d2c <USB_DevInit+0xf4>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8001d24:	69a3      	ldr	r3, [r4, #24]
 8001d26:	f043 0308 	orr.w	r3, r3, #8
 8001d2a:	61a3      	str	r3, [r4, #24]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 8001d2c:	f1bb 0f01 	cmp.w	fp, #1
 8001d30:	d024      	beq.n	8001d7c <USB_DevInit+0x144>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
  }
  
  return HAL_OK;
}
 8001d32:	2000      	movs	r0, #0
 8001d34:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001d38:	b004      	add	sp, #16
 8001d3a:	4770      	bx	lr
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 8001d3c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001d3e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8001d42:	63a3      	str	r3, [r4, #56]	; 0x38
 8001d44:	e78b      	b.n	8001c5e <USB_DevInit+0x26>
    if(cfg.speed == USB_OTG_SPEED_HIGH)
 8001d46:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001d48:	b923      	cbnz	r3, 8001d54 <USB_DevInit+0x11c>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
 8001d4a:	2100      	movs	r1, #0
 8001d4c:	4620      	mov	r0, r4
 8001d4e:	f000 f843 	bl	8001dd8 <USB_SetDevSpeed>
 8001d52:	e794      	b.n	8001c7e <USB_DevInit+0x46>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
 8001d54:	2101      	movs	r1, #1
 8001d56:	4620      	mov	r0, r4
 8001d58:	f000 f83e 	bl	8001dd8 <USB_SetDevSpeed>
 8001d5c:	e78f      	b.n	8001c7e <USB_DevInit+0x46>
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 8001d5e:	4b0c      	ldr	r3, [pc, #48]	; (8001d90 <USB_DevInit+0x158>)
 8001d60:	632b      	str	r3, [r5, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 8001d62:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8001d64:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001d68:	f043 0303 	orr.w	r3, r3, #3
 8001d6c:	632b      	str	r3, [r5, #48]	; 0x30
    i= USBx_DEVICE->DTHRCTL;
 8001d6e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  USBx->GINTMSK = 0U;
 8001d70:	2300      	movs	r3, #0
 8001d72:	61a3      	str	r3, [r4, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 8001d74:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 8001d78:	6163      	str	r3, [r4, #20]
 8001d7a:	e7cd      	b.n	8001d18 <USB_DevInit+0xe0>
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 8001d7c:	69a3      	ldr	r3, [r4, #24]
 8001d7e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8001d82:	f043 0304 	orr.w	r3, r3, #4
 8001d86:	61a3      	str	r3, [r4, #24]
 8001d88:	e7d3      	b.n	8001d32 <USB_DevInit+0xfa>
 8001d8a:	bf00      	nop
 8001d8c:	803c3800 	.word	0x803c3800
 8001d90:	00800100 	.word	0x00800100

08001d94 <USB_FlushTxFifo>:
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 8001d94:	0189      	lsls	r1, r1, #6
 8001d96:	f041 0120 	orr.w	r1, r1, #32
 8001d9a:	6101      	str	r1, [r0, #16]
 8001d9c:	4b05      	ldr	r3, [pc, #20]	; (8001db4 <USB_FlushTxFifo+0x20>)
    if (++count > 200000)
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8001d9e:	6902      	ldr	r2, [r0, #16]
 8001da0:	f012 0f20 	tst.w	r2, #32
 8001da4:	d003      	beq.n	8001dae <USB_FlushTxFifo+0x1a>
    if (++count > 200000)
 8001da6:	3b01      	subs	r3, #1
 8001da8:	d1f9      	bne.n	8001d9e <USB_FlushTxFifo+0xa>
      return HAL_TIMEOUT;
 8001daa:	2003      	movs	r0, #3
  
  return HAL_OK;
}
 8001dac:	4770      	bx	lr
  return HAL_OK;
 8001dae:	2000      	movs	r0, #0
 8001db0:	4770      	bx	lr
 8001db2:	bf00      	nop
 8001db4:	00030d40 	.word	0x00030d40

08001db8 <USB_FlushRxFifo>:
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8001db8:	2310      	movs	r3, #16
 8001dba:	6103      	str	r3, [r0, #16]
 8001dbc:	4b05      	ldr	r3, [pc, #20]	; (8001dd4 <USB_FlushRxFifo+0x1c>)
    if (++count > 200000)
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8001dbe:	6902      	ldr	r2, [r0, #16]
 8001dc0:	f012 0f10 	tst.w	r2, #16
 8001dc4:	d003      	beq.n	8001dce <USB_FlushRxFifo+0x16>
    if (++count > 200000)
 8001dc6:	3b01      	subs	r3, #1
 8001dc8:	d1f9      	bne.n	8001dbe <USB_FlushRxFifo+0x6>
      return HAL_TIMEOUT;
 8001dca:	2003      	movs	r0, #3
  
  return HAL_OK;
}
 8001dcc:	4770      	bx	lr
  return HAL_OK;
 8001dce:	2000      	movs	r0, #0
 8001dd0:	4770      	bx	lr
 8001dd2:	bf00      	nop
 8001dd4:	00030d40 	.word	0x00030d40

08001dd8 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 8001dd8:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8001ddc:	4319      	orrs	r1, r3
 8001dde:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  return HAL_OK;
}
 8001de2:	2000      	movs	r0, #0
 8001de4:	4770      	bx	lr

08001de6 <USB_GetDevSpeed>:
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
  uint8_t speed = 0U;
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 8001de6:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8001dea:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 8001dee:	f013 0f06 	tst.w	r3, #6
 8001df2:	d011      	beq.n	8001e18 <USB_GetDevSpeed+0x32>
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8001df4:	6883      	ldr	r3, [r0, #8]
 8001df6:	f003 0306 	and.w	r3, r3, #6
 8001dfa:	2b02      	cmp	r3, #2
 8001dfc:	d00e      	beq.n	8001e1c <USB_GetDevSpeed+0x36>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
 8001dfe:	6883      	ldr	r3, [r0, #8]
 8001e00:	f003 0306 	and.w	r3, r3, #6
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8001e04:	2b06      	cmp	r3, #6
 8001e06:	d00b      	beq.n	8001e20 <USB_GetDevSpeed+0x3a>
  {
    speed = USB_OTG_SPEED_FULL;
  }
  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8001e08:	6883      	ldr	r3, [r0, #8]
 8001e0a:	f003 0306 	and.w	r3, r3, #6
  {
    speed = USB_OTG_SPEED_LOW;
 8001e0e:	2b04      	cmp	r3, #4
 8001e10:	bf14      	ite	ne
 8001e12:	2000      	movne	r0, #0
 8001e14:	2002      	moveq	r0, #2
 8001e16:	4770      	bx	lr
    speed = USB_OTG_SPEED_HIGH;
 8001e18:	2000      	movs	r0, #0
 8001e1a:	4770      	bx	lr
    speed = USB_OTG_SPEED_FULL;
 8001e1c:	2003      	movs	r0, #3
 8001e1e:	4770      	bx	lr
 8001e20:	2003      	movs	r0, #3
  }
  
  return speed;
}
 8001e22:	4770      	bx	lr

08001e24 <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8001e24:	b430      	push	{r4, r5}
  if (ep->is_in == 1U)
 8001e26:	784b      	ldrb	r3, [r1, #1]
 8001e28:	2b01      	cmp	r3, #1
 8001e2a:	d020      	beq.n	8001e6e <USB_ActivateEndpoint+0x4a>
        ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
    } 
  }
  else
  {
     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U);
 8001e2c:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 8001e30:	780d      	ldrb	r5, [r1, #0]
 8001e32:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001e36:	40ab      	lsls	r3, r5
 8001e38:	4323      	orrs	r3, r4
 8001e3a:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
     
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8001e3e:	780a      	ldrb	r2, [r1, #0]
 8001e40:	0152      	lsls	r2, r2, #5
 8001e42:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
 8001e46:	5813      	ldr	r3, [r2, r0]
 8001e48:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8001e4c:	d10c      	bne.n	8001e68 <USB_ActivateEndpoint+0x44>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\
 8001e4e:	5814      	ldr	r4, [r2, r0]
 8001e50:	688b      	ldr	r3, [r1, #8]
 8001e52:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8001e56:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001e5a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001e5e:	78c9      	ldrb	r1, [r1, #3]
 8001e60:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 8001e64:	4323      	orrs	r3, r4
 8001e66:	5013      	str	r3, [r2, r0]
       (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
    } 
  }
  return HAL_OK;
}
 8001e68:	2000      	movs	r0, #0
 8001e6a:	bc30      	pop	{r4, r5}
 8001e6c:	4770      	bx	lr
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
 8001e6e:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 8001e72:	780d      	ldrb	r5, [r1, #0]
 8001e74:	40ab      	lsls	r3, r5
 8001e76:	b29b      	uxth	r3, r3
 8001e78:	4323      	orrs	r3, r4
 8001e7a:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8001e7e:	780c      	ldrb	r4, [r1, #0]
 8001e80:	0162      	lsls	r2, r4, #5
 8001e82:	f500 6010 	add.w	r0, r0, #2304	; 0x900
 8001e86:	5813      	ldr	r3, [r2, r0]
 8001e88:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8001e8c:	d1ec      	bne.n	8001e68 <USB_ActivateEndpoint+0x44>
      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\
 8001e8e:	5815      	ldr	r5, [r2, r0]
 8001e90:	688b      	ldr	r3, [r1, #8]
 8001e92:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8001e96:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001e9a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001e9e:	78c9      	ldrb	r1, [r1, #3]
 8001ea0:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 8001ea4:	ea43 5384 	orr.w	r3, r3, r4, lsl #22
 8001ea8:	432b      	orrs	r3, r5
 8001eaa:	5013      	str	r3, [r2, r0]
 8001eac:	e7dc      	b.n	8001e68 <USB_ActivateEndpoint+0x44>
	...

08001eb0 <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8001eb0:	b538      	push	{r3, r4, r5, lr}
  uint32_t count = 0U;
  
  /* Disable the IN endpoint */
  if (ep->is_in == 1U)
 8001eb2:	784b      	ldrb	r3, [r1, #1]
 8001eb4:	2b01      	cmp	r3, #1
 8001eb6:	d01d      	beq.n	8001ef4 <USB_DeactivateEndpoint+0x44>
 8001eb8:	f500 6430 	add.w	r4, r0, #2816	; 0xb00
  
  }
  else /* Disable the OUT endpoint */
  {
    
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;  
 8001ebc:	780b      	ldrb	r3, [r1, #0]
 8001ebe:	015b      	lsls	r3, r3, #5
 8001ec0:	591a      	ldr	r2, [r3, r4]
 8001ec2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001ec6:	511a      	str	r2, [r3, r4]
    
    /* sets the NAK bit for the OUT endpoint */
    USBx_OUTEP(ep->num)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8001ec8:	780b      	ldrb	r3, [r1, #0]
 8001eca:	015b      	lsls	r3, r3, #5
 8001ecc:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001ed0:	511a      	str	r2, [r3, r4]
    
    /* Disable OUT endpoint */
    USBx_OUTEP(ep->num)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS;
 8001ed2:	780b      	ldrb	r3, [r1, #0]
 8001ed4:	015b      	lsls	r3, r3, #5
 8001ed6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001eda:	511a      	str	r2, [r3, r4]
        return HAL_TIMEOUT;
      }
    }
    
    /*Wait for  EPDISD endpoint disabled interrupt*/ 
    while ((USBx_OUTEP(ep->num)->DOEPINT & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS);
 8001edc:	780b      	ldrb	r3, [r1, #0]
 8001ede:	eb04 1443 	add.w	r4, r4, r3, lsl #5
 8001ee2:	4b25      	ldr	r3, [pc, #148]	; (8001f78 <USB_DeactivateEndpoint+0xc8>)
 8001ee4:	68a2      	ldr	r2, [r4, #8]
 8001ee6:	f012 0f10 	tst.w	r2, #16
 8001eea:	d032      	beq.n	8001f52 <USB_DeactivateEndpoint+0xa2>
      if (++count > 200000U)
 8001eec:	3b01      	subs	r3, #1
 8001eee:	d1f9      	bne.n	8001ee4 <USB_DeactivateEndpoint+0x34>
        return HAL_TIMEOUT;
 8001ef0:	2003      	movs	r0, #3
    
    /* Disable endpoint interrupts */
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));         
  }
  return HAL_OK;
}
 8001ef2:	bd38      	pop	{r3, r4, r5, pc}
 8001ef4:	f500 6410 	add.w	r4, r0, #2304	; 0x900
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_USBAEP;  
 8001ef8:	780b      	ldrb	r3, [r1, #0]
 8001efa:	015b      	lsls	r3, r3, #5
 8001efc:	591a      	ldr	r2, [r3, r4]
 8001efe:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001f02:	511a      	str	r2, [r3, r4]
    USBx_INEP(ep->num)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8001f04:	780b      	ldrb	r3, [r1, #0]
 8001f06:	015b      	lsls	r3, r3, #5
 8001f08:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001f0c:	511a      	str	r2, [r3, r4]
    USBx_INEP(ep->num)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS;
 8001f0e:	780b      	ldrb	r3, [r1, #0]
 8001f10:	015b      	lsls	r3, r3, #5
 8001f12:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001f16:	511a      	str	r2, [r3, r4]
    while ((USBx_INEP(ep->num)->DIEPINT & USB_OTG_DIEPCTL_EPDIS) == USB_OTG_DIEPCTL_EPDIS);
 8001f18:	780b      	ldrb	r3, [r1, #0]
 8001f1a:	eb04 1443 	add.w	r4, r4, r3, lsl #5
 8001f1e:	4b16      	ldr	r3, [pc, #88]	; (8001f78 <USB_DeactivateEndpoint+0xc8>)
 8001f20:	68a2      	ldr	r2, [r4, #8]
 8001f22:	f012 4f80 	tst.w	r2, #1073741824	; 0x40000000
 8001f26:	d003      	beq.n	8001f30 <USB_DeactivateEndpoint+0x80>
      if (++count > 200000U)
 8001f28:	3b01      	subs	r3, #1
 8001f2a:	d1f9      	bne.n	8001f20 <USB_DeactivateEndpoint+0x70>
        return HAL_TIMEOUT;
 8001f2c:	2003      	movs	r0, #3
 8001f2e:	bd38      	pop	{r3, r4, r5, pc}
 8001f30:	460d      	mov	r5, r1
 8001f32:	4604      	mov	r4, r0
    USB_FlushTxFifo(USBx , 0x10U);
 8001f34:	2110      	movs	r1, #16
 8001f36:	f7ff ff2d 	bl	8001d94 <USB_FlushTxFifo>
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));   
 8001f3a:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
 8001f3e:	7829      	ldrb	r1, [r5, #0]
 8001f40:	2301      	movs	r3, #1
 8001f42:	408b      	lsls	r3, r1
 8001f44:	b29b      	uxth	r3, r3
 8001f46:	ea22 0303 	bic.w	r3, r2, r3
 8001f4a:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
  return HAL_OK;
 8001f4e:	2000      	movs	r0, #0
 8001f50:	bd38      	pop	{r3, r4, r5, pc}
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 8001f52:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8001f56:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001f5a:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));         
 8001f5e:	f8d0 381c 	ldr.w	r3, [r0, #2076]	; 0x81c
 8001f62:	7809      	ldrb	r1, [r1, #0]
 8001f64:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001f68:	408a      	lsls	r2, r1
 8001f6a:	ea23 0302 	bic.w	r3, r3, r2
 8001f6e:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
  return HAL_OK;
 8001f72:	2000      	movs	r0, #0
 8001f74:	bd38      	pop	{r3, r4, r5, pc}
 8001f76:	bf00      	nop
 8001f78:	00030d40 	.word	0x00030d40

08001f7c <USB_EPStartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8001f7c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001f7e:	b083      	sub	sp, #12
  uint16_t pktcnt = 0U;
  
  /* IN endpoint */
  if (ep->is_in == 1U)
 8001f80:	784b      	ldrb	r3, [r1, #1]
 8001f82:	2b01      	cmp	r3, #1
 8001f84:	d035      	beq.n	8001ff2 <USB_EPStartXfer+0x76>
 8001f86:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */  
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8001f8a:	780d      	ldrb	r5, [r1, #0]
 8001f8c:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8001f90:	692c      	ldr	r4, [r5, #16]
 8001f92:	0ce4      	lsrs	r4, r4, #19
 8001f94:	04e4      	lsls	r4, r4, #19
 8001f96:	612c      	str	r4, [r5, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 8001f98:	780d      	ldrb	r5, [r1, #0]
 8001f9a:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8001f9e:	692c      	ldr	r4, [r5, #16]
 8001fa0:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 8001fa4:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 8001fa8:	612c      	str	r4, [r5, #16]

    if (ep->xfer_len == 0U)
 8001faa:	694c      	ldr	r4, [r1, #20]
 8001fac:	2c00      	cmp	r4, #0
 8001fae:	f040 80b8 	bne.w	8002122 <USB_EPStartXfer+0x1a6>
    {
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8001fb2:	780d      	ldrb	r5, [r1, #0]
 8001fb4:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8001fb8:	692e      	ldr	r6, [r5, #16]
 8001fba:	688c      	ldr	r4, [r1, #8]
 8001fbc:	f3c4 0412 	ubfx	r4, r4, #0, #19
 8001fc0:	4334      	orrs	r4, r6
 8001fc2:	612c      	str	r4, [r5, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8001fc4:	780c      	ldrb	r4, [r1, #0]
 8001fc6:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8001fca:	6925      	ldr	r5, [r4, #16]
 8001fcc:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 8001fd0:	6125      	str	r5, [r4, #16]
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));
    }

    if (dma == 1U)
 8001fd2:	2a01      	cmp	r2, #1
 8001fd4:	f000 80c0 	beq.w	8002158 <USB_EPStartXfer+0x1dc>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
    }
    
    if (ep->type == EP_TYPE_ISOC)
 8001fd8:	78ca      	ldrb	r2, [r1, #3]
 8001fda:	2a01      	cmp	r2, #1
 8001fdc:	f000 80c2 	beq.w	8002164 <USB_EPStartXfer+0x1e8>
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
      }
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8001fe0:	780a      	ldrb	r2, [r1, #0]
 8001fe2:	0152      	lsls	r2, r2, #5
 8001fe4:	58d1      	ldr	r1, [r2, r3]
 8001fe6:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 8001fea:	50d1      	str	r1, [r2, r3]
  }
  return HAL_OK;
}
 8001fec:	2000      	movs	r0, #0
 8001fee:	b003      	add	sp, #12
 8001ff0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (ep->xfer_len == 0U)
 8001ff2:	694b      	ldr	r3, [r1, #20]
 8001ff4:	bb4b      	cbnz	r3, 800204a <USB_EPStartXfer+0xce>
 8001ff6:	f500 6310 	add.w	r3, r0, #2304	; 0x900
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001ffa:	780d      	ldrb	r5, [r1, #0]
 8001ffc:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8002000:	692c      	ldr	r4, [r5, #16]
 8002002:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 8002006:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 800200a:	612c      	str	r4, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 800200c:	780c      	ldrb	r4, [r1, #0]
 800200e:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8002012:	6925      	ldr	r5, [r4, #16]
 8002014:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 8002018:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 800201a:	780c      	ldrb	r4, [r1, #0]
 800201c:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8002020:	691c      	ldr	r4, [r3, #16]
 8002022:	0ce4      	lsrs	r4, r4, #19
 8002024:	04e4      	lsls	r4, r4, #19
 8002026:	611c      	str	r4, [r3, #16]
    if (dma == 1U)
 8002028:	2a01      	cmp	r2, #1
 800202a:	d03d      	beq.n	80020a8 <USB_EPStartXfer+0x12c>
      if (ep->type != EP_TYPE_ISOC)
 800202c:	78cb      	ldrb	r3, [r1, #3]
 800202e:	2b01      	cmp	r3, #1
 8002030:	d066      	beq.n	8002100 <USB_EPStartXfer+0x184>
        if (ep->xfer_len > 0U)
 8002032:	694b      	ldr	r3, [r1, #20]
 8002034:	2b00      	cmp	r3, #0
 8002036:	d041      	beq.n	80020bc <USB_EPStartXfer+0x140>
          USBx_DEVICE->DIEPEMPMSK |= 1U << ep->num;
 8002038:	f8d0 5834 	ldr.w	r5, [r0, #2100]	; 0x834
 800203c:	780e      	ldrb	r6, [r1, #0]
 800203e:	2301      	movs	r3, #1
 8002040:	40b3      	lsls	r3, r6
 8002042:	432b      	orrs	r3, r5
 8002044:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
 8002048:	e035      	b.n	80020b6 <USB_EPStartXfer+0x13a>
 800204a:	f500 6410 	add.w	r4, r0, #2304	; 0x900
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800204e:	780d      	ldrb	r5, [r1, #0]
 8002050:	eb04 1545 	add.w	r5, r4, r5, lsl #5
 8002054:	692b      	ldr	r3, [r5, #16]
 8002056:	0cdb      	lsrs	r3, r3, #19
 8002058:	04db      	lsls	r3, r3, #19
 800205a:	612b      	str	r3, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 800205c:	780d      	ldrb	r5, [r1, #0]
 800205e:	eb04 1545 	add.w	r5, r4, r5, lsl #5
 8002062:	692b      	ldr	r3, [r5, #16]
 8002064:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 8002068:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 800206c:	612b      	str	r3, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;
 800206e:	780e      	ldrb	r6, [r1, #0]
 8002070:	eb04 1646 	add.w	r6, r4, r6, lsl #5
 8002074:	6937      	ldr	r7, [r6, #16]
 8002076:	688d      	ldr	r5, [r1, #8]
 8002078:	694b      	ldr	r3, [r1, #20]
 800207a:	442b      	add	r3, r5
 800207c:	3b01      	subs	r3, #1
 800207e:	fbb3 f3f5 	udiv	r3, r3, r5
 8002082:	4d40      	ldr	r5, [pc, #256]	; (8002184 <USB_EPStartXfer+0x208>)
 8002084:	ea05 43c3 	and.w	r3, r5, r3, lsl #19
 8002088:	433b      	orrs	r3, r7
 800208a:	6133      	str	r3, [r6, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 800208c:	780d      	ldrb	r5, [r1, #0]
 800208e:	eb04 1545 	add.w	r5, r4, r5, lsl #5
 8002092:	692e      	ldr	r6, [r5, #16]
 8002094:	694b      	ldr	r3, [r1, #20]
 8002096:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800209a:	4333      	orrs	r3, r6
 800209c:	612b      	str	r3, [r5, #16]
      if (ep->type == EP_TYPE_ISOC)
 800209e:	78cb      	ldrb	r3, [r1, #3]
 80020a0:	2b01      	cmp	r3, #1
 80020a2:	d01e      	beq.n	80020e2 <USB_EPStartXfer+0x166>
    if (dma == 1U)
 80020a4:	2a01      	cmp	r2, #1
 80020a6:	d1c4      	bne.n	8002032 <USB_EPStartXfer+0xb6>
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 80020a8:	780c      	ldrb	r4, [r1, #0]
 80020aa:	f500 6310 	add.w	r3, r0, #2304	; 0x900
 80020ae:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 80020b2:	690c      	ldr	r4, [r1, #16]
 80020b4:	615c      	str	r4, [r3, #20]
    if (ep->type == EP_TYPE_ISOC)
 80020b6:	78cb      	ldrb	r3, [r1, #3]
 80020b8:	2b01      	cmp	r3, #1
 80020ba:	d021      	beq.n	8002100 <USB_EPStartXfer+0x184>
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80020bc:	780b      	ldrb	r3, [r1, #0]
 80020be:	015b      	lsls	r3, r3, #5
 80020c0:	f500 6510 	add.w	r5, r0, #2304	; 0x900
 80020c4:	595c      	ldr	r4, [r3, r5]
 80020c6:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80020ca:	515c      	str	r4, [r3, r5]
    if (ep->type == EP_TYPE_ISOC)
 80020cc:	78cb      	ldrb	r3, [r1, #3]
 80020ce:	2b01      	cmp	r3, #1
 80020d0:	d18c      	bne.n	8001fec <USB_EPStartXfer+0x70>
 80020d2:	4614      	mov	r4, r2
      USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
 80020d4:	8a8b      	ldrh	r3, [r1, #20]
 80020d6:	780a      	ldrb	r2, [r1, #0]
 80020d8:	68c9      	ldr	r1, [r1, #12]
 80020da:	9400      	str	r4, [sp, #0]
 80020dc:	f000 f8ee 	bl	80022bc <USB_WritePacket>
 80020e0:	e784      	b.n	8001fec <USB_EPStartXfer+0x70>
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
 80020e2:	780b      	ldrb	r3, [r1, #0]
 80020e4:	eb04 1343 	add.w	r3, r4, r3, lsl #5
 80020e8:	691d      	ldr	r5, [r3, #16]
 80020ea:	f025 45c0 	bic.w	r5, r5, #1610612736	; 0x60000000
 80020ee:	611d      	str	r5, [r3, #16]
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); 
 80020f0:	780b      	ldrb	r3, [r1, #0]
 80020f2:	eb04 1443 	add.w	r4, r4, r3, lsl #5
 80020f6:	6923      	ldr	r3, [r4, #16]
 80020f8:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80020fc:	6123      	str	r3, [r4, #16]
 80020fe:	e793      	b.n	8002028 <USB_EPStartXfer+0xac>
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 8002100:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8002104:	f413 7f80 	tst.w	r3, #256	; 0x100
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8002108:	780b      	ldrb	r3, [r1, #0]
 800210a:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800210e:	f500 6510 	add.w	r5, r0, #2304	; 0x900
 8002112:	595c      	ldr	r4, [r3, r5]
 8002114:	bf0c      	ite	eq
 8002116:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 800211a:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
 800211e:	515c      	str	r4, [r3, r5]
 8002120:	e7cc      	b.n	80020bc <USB_EPStartXfer+0x140>
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
 8002122:	688d      	ldr	r5, [r1, #8]
 8002124:	442c      	add	r4, r5
 8002126:	3c01      	subs	r4, #1
 8002128:	fbb4 f4f5 	udiv	r4, r4, r5
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 800212c:	780e      	ldrb	r6, [r1, #0]
 800212e:	eb03 1646 	add.w	r6, r3, r6, lsl #5
 8002132:	6937      	ldr	r7, [r6, #16]
 8002134:	4d13      	ldr	r5, [pc, #76]	; (8002184 <USB_EPStartXfer+0x208>)
 8002136:	ea05 45c4 	and.w	r5, r5, r4, lsl #19
 800213a:	433d      	orrs	r5, r7
 800213c:	6135      	str	r5, [r6, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));
 800213e:	780e      	ldrb	r6, [r1, #0]
 8002140:	eb03 1646 	add.w	r6, r3, r6, lsl #5
 8002144:	6937      	ldr	r7, [r6, #16]
 8002146:	b2a4      	uxth	r4, r4
 8002148:	688d      	ldr	r5, [r1, #8]
 800214a:	fb05 f404 	mul.w	r4, r5, r4
 800214e:	f3c4 0412 	ubfx	r4, r4, #0, #19
 8002152:	433c      	orrs	r4, r7
 8002154:	6134      	str	r4, [r6, #16]
 8002156:	e73c      	b.n	8001fd2 <USB_EPStartXfer+0x56>
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
 8002158:	780a      	ldrb	r2, [r1, #0]
 800215a:	eb03 1242 	add.w	r2, r3, r2, lsl #5
 800215e:	68cc      	ldr	r4, [r1, #12]
 8002160:	6154      	str	r4, [r2, #20]
 8002162:	e739      	b.n	8001fd8 <USB_EPStartXfer+0x5c>
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 8002164:	f8d0 2808 	ldr.w	r2, [r0, #2056]	; 0x808
 8002168:	f412 7f80 	tst.w	r2, #256	; 0x100
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 800216c:	780a      	ldrb	r2, [r1, #0]
 800216e:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8002172:	58d0      	ldr	r0, [r2, r3]
 8002174:	bf0c      	ite	eq
 8002176:	f040 5000 	orreq.w	r0, r0, #536870912	; 0x20000000
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 800217a:	f040 5080 	orrne.w	r0, r0, #268435456	; 0x10000000
 800217e:	50d0      	str	r0, [r2, r3]
 8002180:	e72e      	b.n	8001fe0 <USB_EPStartXfer+0x64>
 8002182:	bf00      	nop
 8002184:	1ff80000 	.word	0x1ff80000

08002188 <USB_EP0StartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8002188:	b430      	push	{r4, r5}
  /* IN endpoint */
  if (ep->is_in == 1U)
 800218a:	784b      	ldrb	r3, [r1, #1]
 800218c:	2b01      	cmp	r3, #1
 800218e:	d030      	beq.n	80021f2 <USB_EP0StartXfer+0x6a>
 8002190:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8002194:	780c      	ldrb	r4, [r1, #0]
 8002196:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 800219a:	6923      	ldr	r3, [r4, #16]
 800219c:	0cdb      	lsrs	r3, r3, #19
 800219e:	04db      	lsls	r3, r3, #19
 80021a0:	6123      	str	r3, [r4, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 80021a2:	780c      	ldrb	r4, [r1, #0]
 80021a4:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 80021a8:	6923      	ldr	r3, [r4, #16]
 80021aa:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 80021ae:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 80021b2:	6123      	str	r3, [r4, #16]
      
    if (ep->xfer_len > 0U)
 80021b4:	694b      	ldr	r3, [r1, #20]
 80021b6:	b10b      	cbz	r3, 80021bc <USB_EP0StartXfer+0x34>
    {
      ep->xfer_len = ep->maxpacket;
 80021b8:	688b      	ldr	r3, [r1, #8]
 80021ba:	614b      	str	r3, [r1, #20]
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 80021bc:	780b      	ldrb	r3, [r1, #0]
 80021be:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 80021c2:	691c      	ldr	r4, [r3, #16]
 80021c4:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 80021c8:	611c      	str	r4, [r3, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 80021ca:	780c      	ldrb	r4, [r1, #0]
 80021cc:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 80021d0:	6925      	ldr	r5, [r4, #16]
 80021d2:	688b      	ldr	r3, [r1, #8]
 80021d4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80021d8:	432b      	orrs	r3, r5
 80021da:	6123      	str	r3, [r4, #16]
    

    if (dma == 1U)
 80021dc:	2a01      	cmp	r2, #1
 80021de:	d067      	beq.n	80022b0 <USB_EP0StartXfer+0x128>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
    }
    
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
 80021e0:	780b      	ldrb	r3, [r1, #0]
 80021e2:	015b      	lsls	r3, r3, #5
 80021e4:	581a      	ldr	r2, [r3, r0]
 80021e6:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80021ea:	501a      	str	r2, [r3, r0]
  }
  return HAL_OK;
}
 80021ec:	2000      	movs	r0, #0
 80021ee:	bc30      	pop	{r4, r5}
 80021f0:	4770      	bx	lr
    if (ep->xfer_len == 0U)
 80021f2:	694b      	ldr	r3, [r1, #20]
 80021f4:	bb73      	cbnz	r3, 8002254 <USB_EP0StartXfer+0xcc>
 80021f6:	f500 6310 	add.w	r3, r0, #2304	; 0x900
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 80021fa:	780d      	ldrb	r5, [r1, #0]
 80021fc:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8002200:	692c      	ldr	r4, [r5, #16]
 8002202:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 8002206:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 800220a:	612c      	str	r4, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 800220c:	780c      	ldrb	r4, [r1, #0]
 800220e:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8002212:	6925      	ldr	r5, [r4, #16]
 8002214:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 8002218:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 800221a:	780c      	ldrb	r4, [r1, #0]
 800221c:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8002220:	691c      	ldr	r4, [r3, #16]
 8002222:	0ce4      	lsrs	r4, r4, #19
 8002224:	04e4      	lsls	r4, r4, #19
 8002226:	611c      	str	r4, [r3, #16]
 8002228:	f500 6510 	add.w	r5, r0, #2304	; 0x900
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);     
 800222c:	780b      	ldrb	r3, [r1, #0]
 800222e:	015b      	lsls	r3, r3, #5
 8002230:	595c      	ldr	r4, [r3, r5]
 8002232:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 8002236:	515c      	str	r4, [r3, r5]
    if (dma == 1)
 8002238:	2a01      	cmp	r2, #1
 800223a:	d033      	beq.n	80022a4 <USB_EP0StartXfer+0x11c>
      if (ep->xfer_len > 0U)
 800223c:	694b      	ldr	r3, [r1, #20]
 800223e:	2b00      	cmp	r3, #0
 8002240:	d0d4      	beq.n	80021ec <USB_EP0StartXfer+0x64>
        USBx_DEVICE->DIEPEMPMSK |= 1U << (ep->num);
 8002242:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 8002246:	7809      	ldrb	r1, [r1, #0]
 8002248:	2301      	movs	r3, #1
 800224a:	408b      	lsls	r3, r1
 800224c:	4313      	orrs	r3, r2
 800224e:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
 8002252:	e7cb      	b.n	80021ec <USB_EP0StartXfer+0x64>
 8002254:	f500 6310 	add.w	r3, r0, #2304	; 0x900
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8002258:	780d      	ldrb	r5, [r1, #0]
 800225a:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 800225e:	692c      	ldr	r4, [r5, #16]
 8002260:	0ce4      	lsrs	r4, r4, #19
 8002262:	04e4      	lsls	r4, r4, #19
 8002264:	612c      	str	r4, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8002266:	780d      	ldrb	r5, [r1, #0]
 8002268:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 800226c:	692c      	ldr	r4, [r5, #16]
 800226e:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 8002272:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 8002276:	612c      	str	r4, [r5, #16]
      if(ep->xfer_len > ep->maxpacket)
 8002278:	688c      	ldr	r4, [r1, #8]
 800227a:	694d      	ldr	r5, [r1, #20]
 800227c:	42a5      	cmp	r5, r4
        ep->xfer_len = ep->maxpacket;
 800227e:	bf88      	it	hi
 8002280:	614c      	strhi	r4, [r1, #20]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8002282:	780c      	ldrb	r4, [r1, #0]
 8002284:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8002288:	6925      	ldr	r5, [r4, #16]
 800228a:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800228e:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8002290:	780c      	ldrb	r4, [r1, #0]
 8002292:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8002296:	691d      	ldr	r5, [r3, #16]
 8002298:	694c      	ldr	r4, [r1, #20]
 800229a:	f3c4 0412 	ubfx	r4, r4, #0, #19
 800229e:	432c      	orrs	r4, r5
 80022a0:	611c      	str	r4, [r3, #16]
 80022a2:	e7c1      	b.n	8002228 <USB_EP0StartXfer+0xa0>
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 80022a4:	780b      	ldrb	r3, [r1, #0]
 80022a6:	eb05 1543 	add.w	r5, r5, r3, lsl #5
 80022aa:	690b      	ldr	r3, [r1, #16]
 80022ac:	616b      	str	r3, [r5, #20]
 80022ae:	e79d      	b.n	80021ec <USB_EP0StartXfer+0x64>
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 80022b0:	780b      	ldrb	r3, [r1, #0]
 80022b2:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 80022b6:	68ca      	ldr	r2, [r1, #12]
 80022b8:	615a      	str	r2, [r3, #20]
 80022ba:	e791      	b.n	80021e0 <USB_EP0StartXfer+0x58>

080022bc <USB_WritePacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 80022bc:	b410      	push	{r4}
 80022be:	f89d 4004 	ldrb.w	r4, [sp, #4]
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
 80022c2:	b96c      	cbnz	r4, 80022e0 <USB_WritePacket+0x24>
  {
    count32b =  (len + 3U) / 4U;
 80022c4:	1cdc      	adds	r4, r3, #3
    for (i = 0U; i < count32b; i++, src += 4U)
 80022c6:	08a4      	lsrs	r4, r4, #2
 80022c8:	d00a      	beq.n	80022e0 <USB_WritePacket+0x24>
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 80022ca:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 80022ce:	eb00 3202 	add.w	r2, r0, r2, lsl #12
 80022d2:	2300      	movs	r3, #0
 80022d4:	f851 0b04 	ldr.w	r0, [r1], #4
 80022d8:	6010      	str	r0, [r2, #0]
    for (i = 0U; i < count32b; i++, src += 4U)
 80022da:	3301      	adds	r3, #1
 80022dc:	429c      	cmp	r4, r3
 80022de:	d1f9      	bne.n	80022d4 <USB_WritePacket+0x18>
    }
  }
  return HAL_OK;
}
 80022e0:	2000      	movs	r0, #0
 80022e2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80022e6:	4770      	bx	lr

080022e8 <USB_ReadPacket>:
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
  uint32_t i=0U;
  uint32_t count32b = (len + 3U) / 4U;
 80022e8:	3203      	adds	r2, #3
  
  for ( i = 0U; i < count32b; i++, dest += 4U )
 80022ea:	0892      	lsrs	r2, r2, #2
 80022ec:	d00f      	beq.n	800230e <USB_ReadPacket+0x26>
{
 80022ee:	b470      	push	{r4, r5, r6}
  for ( i = 0U; i < count32b; i++, dest += 4U )
 80022f0:	460c      	mov	r4, r1
 80022f2:	2300      	movs	r3, #0
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0U);
 80022f4:	f500 5680 	add.w	r6, r0, #4096	; 0x1000
 80022f8:	6835      	ldr	r5, [r6, #0]
 80022fa:	f844 5b04 	str.w	r5, [r4], #4
  for ( i = 0U; i < count32b; i++, dest += 4U )
 80022fe:	3301      	adds	r3, #1
 8002300:	429a      	cmp	r2, r3
 8002302:	d1f9      	bne.n	80022f8 <USB_ReadPacket+0x10>
 8002304:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    
  }
  return ((void *)dest);
}
 8002308:	4608      	mov	r0, r1
 800230a:	bc70      	pop	{r4, r5, r6}
 800230c:	4770      	bx	lr
 800230e:	4608      	mov	r0, r1
 8002310:	4770      	bx	lr

08002312 <USB_EPSetStall>:
  * @param  ep pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 8002312:	784b      	ldrb	r3, [r1, #1]
 8002314:	2b01      	cmp	r3, #1
 8002316:	d012      	beq.n	800233e <USB_EPSetStall+0x2c>
 8002318:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
    } 
    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0U)
 800231c:	780b      	ldrb	r3, [r1, #0]
 800231e:	015b      	lsls	r3, r3, #5
 8002320:	581a      	ldr	r2, [r3, r0]
 8002322:	2a00      	cmp	r2, #0
 8002324:	db03      	blt.n	800232e <USB_EPSetStall+0x1c>
    {
      USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
 8002326:	581a      	ldr	r2, [r3, r0]
 8002328:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 800232c:	501a      	str	r2, [r3, r0]
    } 
    USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 800232e:	780b      	ldrb	r3, [r1, #0]
 8002330:	015b      	lsls	r3, r3, #5
 8002332:	581a      	ldr	r2, [r3, r0]
 8002334:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8002338:	501a      	str	r2, [r3, r0]
  }
  return HAL_OK;
}
 800233a:	2000      	movs	r0, #0
 800233c:	4770      	bx	lr
 800233e:	f500 6010 	add.w	r0, r0, #2304	; 0x900
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0U)
 8002342:	780b      	ldrb	r3, [r1, #0]
 8002344:	015b      	lsls	r3, r3, #5
 8002346:	581a      	ldr	r2, [r3, r0]
 8002348:	2a00      	cmp	r2, #0
 800234a:	db03      	blt.n	8002354 <USB_EPSetStall+0x42>
      USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); 
 800234c:	581a      	ldr	r2, [r3, r0]
 800234e:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8002352:	501a      	str	r2, [r3, r0]
    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8002354:	780b      	ldrb	r3, [r1, #0]
 8002356:	015b      	lsls	r3, r3, #5
 8002358:	581a      	ldr	r2, [r3, r0]
 800235a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800235e:	501a      	str	r2, [r3, r0]
 8002360:	e7eb      	b.n	800233a <USB_EPSetStall+0x28>

08002362 <USB_EPClearStall>:
  * @param  ep pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 8002362:	784b      	ldrb	r3, [r1, #1]
 8002364:	2b01      	cmp	r3, #1
 8002366:	d00e      	beq.n	8002386 <USB_EPClearStall+0x24>
 8002368:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }    
  }
  else
  {
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 800236c:	780b      	ldrb	r3, [r1, #0]
 800236e:	015b      	lsls	r3, r3, #5
 8002370:	581a      	ldr	r2, [r3, r0]
 8002372:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002376:	501a      	str	r2, [r3, r0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8002378:	78cb      	ldrb	r3, [r1, #3]
 800237a:	3b02      	subs	r3, #2
 800237c:	b2db      	uxtb	r3, r3
 800237e:	2b01      	cmp	r3, #1
 8002380:	d915      	bls.n	80023ae <USB_EPClearStall+0x4c>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }    
  }
  return HAL_OK;
}
 8002382:	2000      	movs	r0, #0
 8002384:	4770      	bx	lr
 8002386:	f500 6010 	add.w	r0, r0, #2304	; 0x900
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800238a:	780b      	ldrb	r3, [r1, #0]
 800238c:	015b      	lsls	r3, r3, #5
 800238e:	581a      	ldr	r2, [r3, r0]
 8002390:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002394:	501a      	str	r2, [r3, r0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8002396:	78cb      	ldrb	r3, [r1, #3]
 8002398:	3b02      	subs	r3, #2
 800239a:	b2db      	uxtb	r3, r3
 800239c:	2b01      	cmp	r3, #1
 800239e:	d8f0      	bhi.n	8002382 <USB_EPClearStall+0x20>
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 80023a0:	780b      	ldrb	r3, [r1, #0]
 80023a2:	015b      	lsls	r3, r3, #5
 80023a4:	581a      	ldr	r2, [r3, r0]
 80023a6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80023aa:	501a      	str	r2, [r3, r0]
 80023ac:	e7e9      	b.n	8002382 <USB_EPClearStall+0x20>
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 80023ae:	780b      	ldrb	r3, [r1, #0]
 80023b0:	015b      	lsls	r3, r3, #5
 80023b2:	581a      	ldr	r2, [r3, r0]
 80023b4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80023b8:	501a      	str	r2, [r3, r0]
 80023ba:	e7e2      	b.n	8002382 <USB_EPClearStall+0x20>

080023bc <USB_SetDevAddress>:
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
  USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
 80023bc:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80023c0:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80023c4:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= (address << 4U) & USB_OTG_DCFG_DAD ;
 80023c8:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80023cc:	0109      	lsls	r1, r1, #4
 80023ce:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 80023d2:	4319      	orrs	r1, r3
 80023d4:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  
  return HAL_OK;  
}
 80023d8:	2000      	movs	r0, #0
 80023da:	4770      	bx	lr

080023dc <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
{
 80023dc:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
 80023de:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80023e2:	f023 0302 	bic.w	r3, r3, #2
 80023e6:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 80023ea:	2003      	movs	r0, #3
 80023ec:	f7fe f930 	bl	8000650 <HAL_Delay>
  
  return HAL_OK;  
}
 80023f0:	2000      	movs	r0, #0
 80023f2:	bd08      	pop	{r3, pc}

080023f4 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
 80023f4:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
 80023f6:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80023fa:	f043 0302 	orr.w	r3, r3, #2
 80023fe:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 8002402:	2003      	movs	r0, #3
 8002404:	f7fe f924 	bl	8000650 <HAL_Delay>
  
  return HAL_OK;  
}
 8002408:	2000      	movs	r0, #0
 800240a:	bd08      	pop	{r3, pc}

0800240c <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v = 0U;
  
  v = USBx->GINTSTS;
 800240c:	6942      	ldr	r2, [r0, #20]
  v &= USBx->GINTMSK;
 800240e:	6980      	ldr	r0, [r0, #24]
  return v;  
}
 8002410:	4010      	ands	r0, r2
 8002412:	4770      	bx	lr

08002414 <USB_ReadDevAllOutEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 8002414:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8002418:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  v &= USBx_DEVICE->DAINTMSK;
 800241c:	69c0      	ldr	r0, [r0, #28]
 800241e:	4018      	ands	r0, r3
  return ((v & 0xffff0000U) >> 16U);
}
 8002420:	0c00      	lsrs	r0, r0, #16
 8002422:	4770      	bx	lr

08002424 <USB_ReadDevAllInEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 8002424:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8002428:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  v &= USBx_DEVICE->DAINTMSK;
 800242c:	69c0      	ldr	r0, [r0, #28]
 800242e:	4018      	ands	r0, r3
  return ((v & 0xFFFFU));
}
 8002430:	b280      	uxth	r0, r0
 8002432:	4770      	bx	lr

08002434 <USB_ReadDevOutEPInterrupt>:
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 8002434:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 8002438:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 800243c:	688a      	ldr	r2, [r1, #8]
  v &= USBx_DEVICE->DOEPMSK;
 800243e:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 8002442:	6940      	ldr	r0, [r0, #20]
  return v;
}
 8002444:	4010      	ands	r0, r2
 8002446:	4770      	bx	lr

08002448 <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
 8002448:	b410      	push	{r4}
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
 800244a:	f8d0 4810 	ldr.w	r4, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 800244e:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  msk |= ((emp >> epnum) & 0x1U) << 7U;
  v = USBx_INEP(epnum)->DIEPINT & msk;
 8002452:	eb00 1041 	add.w	r0, r0, r1, lsl #5
 8002456:	f500 6010 	add.w	r0, r0, #2304	; 0x900
 800245a:	6880      	ldr	r0, [r0, #8]
  msk |= ((emp >> epnum) & 0x1U) << 7U;
 800245c:	40cb      	lsrs	r3, r1
 800245e:	01db      	lsls	r3, r3, #7
 8002460:	b2db      	uxtb	r3, r3
 8002462:	4323      	orrs	r3, r4
  return v;
}
 8002464:	4018      	ands	r0, r3
 8002466:	f85d 4b04 	ldr.w	r4, [sp], #4
 800246a:	4770      	bx	lr

0800246c <USB_GetMode>:
  *           0 : Host 
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
  return ((USBx->GINTSTS ) & 0x1U);
 800246c:	6940      	ldr	r0, [r0, #20]
}
 800246e:	f000 0001 	and.w	r0, r0, #1
 8002472:	4770      	bx	lr

08002474 <USB_ActivateSetup>:
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
{
  /* Set the MPS of the IN EP based on the enumeration speed */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8002474:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8002478:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 800247c:	f023 0307 	bic.w	r3, r3, #7
 8002480:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8002484:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8002488:	689a      	ldr	r2, [r3, #8]
 800248a:	f002 0206 	and.w	r2, r2, #6
 800248e:	2a04      	cmp	r2, #4
 8002490:	d005      	beq.n	800249e <USB_ActivateSetup+0x2a>
  {
    USBx_INEP(0U)->DIEPCTL |= 3U;
  }
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8002492:	685a      	ldr	r2, [r3, #4]
 8002494:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002498:	605a      	str	r2, [r3, #4]

  return HAL_OK;
}
 800249a:	2000      	movs	r0, #0
 800249c:	4770      	bx	lr
    USBx_INEP(0U)->DIEPCTL |= 3U;
 800249e:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 80024a2:	f042 0203 	orr.w	r2, r2, #3
 80024a6:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
 80024aa:	e7f2      	b.n	8002492 <USB_ActivateSetup+0x1e>

080024ac <USB_EP0_OutStart>:
  *           1 : DMA feature used  
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
 80024ac:	b410      	push	{r4}
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 80024ae:	2400      	movs	r4, #0
 80024b0:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
 80024b4:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 80024b8:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 80024bc:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 80024c0:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 80024c4:	f044 0418 	orr.w	r4, r4, #24
 80024c8:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 80024cc:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 80024d0:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
 80024d4:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1U)
 80024d8:	2901      	cmp	r1, #1
 80024da:	d003      	beq.n	80024e4 <USB_EP0_OutStart+0x38>
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
  }
  
  return HAL_OK;  
}
 80024dc:	2000      	movs	r0, #0
 80024de:	f85d 4b04 	ldr.w	r4, [sp], #4
 80024e2:	4770      	bx	lr
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 80024e4:	f8c0 2b14 	str.w	r2, [r0, #2836]	; 0xb14
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
 80024e8:	f04f 2380 	mov.w	r3, #2147516416	; 0x80008000
 80024ec:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 80024f0:	e7f4      	b.n	80024dc <USB_EP0_OutStart+0x30>
	...

080024f4 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 80024f4:	4b0b      	ldr	r3, [pc, #44]	; (8002524 <USB_CoreReset+0x30>)
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80024f6:	6902      	ldr	r2, [r0, #16]
 80024f8:	2a00      	cmp	r2, #0
 80024fa:	db03      	blt.n	8002504 <USB_CoreReset+0x10>
    if (++count > 200000U)
 80024fc:	3b01      	subs	r3, #1
 80024fe:	d1fa      	bne.n	80024f6 <USB_CoreReset+0x2>
      return HAL_TIMEOUT;
 8002500:	2003      	movs	r0, #3
 8002502:	4770      	bx	lr
  
  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8002504:	6903      	ldr	r3, [r0, #16]
 8002506:	f043 0301 	orr.w	r3, r3, #1
 800250a:	6103      	str	r3, [r0, #16]
 800250c:	4b05      	ldr	r3, [pc, #20]	; (8002524 <USB_CoreReset+0x30>)
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800250e:	6902      	ldr	r2, [r0, #16]
 8002510:	f012 0f01 	tst.w	r2, #1
 8002514:	d003      	beq.n	800251e <USB_CoreReset+0x2a>
    if (++count > 200000U)
 8002516:	3b01      	subs	r3, #1
 8002518:	d1f9      	bne.n	800250e <USB_CoreReset+0x1a>
      return HAL_TIMEOUT;
 800251a:	2003      	movs	r0, #3
  
  return HAL_OK;
}
 800251c:	4770      	bx	lr
  return HAL_OK;
 800251e:	2000      	movs	r0, #0
 8002520:	4770      	bx	lr
 8002522:	bf00      	nop
 8002524:	00030d40 	.word	0x00030d40

08002528 <USBD_CDC_GetFSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetFSCfgDesc (uint16_t *length)
{
    *length = sizeof(USBD_CDC_CfgFSDesc);
 8002528:	234b      	movs	r3, #75	; 0x4b
 800252a:	8003      	strh	r3, [r0, #0]
    USBD_CDC_CfgFSDesc[2] = sizeof(USBD_CDC_CfgFSDesc) & 0xFF;
 800252c:	4802      	ldr	r0, [pc, #8]	; (8002538 <USBD_CDC_GetFSCfgDesc+0x10>)
 800252e:	7083      	strb	r3, [r0, #2]
    USBD_CDC_CfgFSDesc[3] = (sizeof(USBD_CDC_CfgFSDesc) >> 8) & 0xFF;
 8002530:	2300      	movs	r3, #0
 8002532:	70c3      	strb	r3, [r0, #3]
    return USBD_CDC_CfgFSDesc;
}
 8002534:	4770      	bx	lr
 8002536:	bf00      	nop
 8002538:	20000040 	.word	0x20000040

0800253c <rndis_iso_out_incomplete>:
{
 800253c:	b508      	push	{r3, lr}
	USBD_LL_PrepareReceive(pdev, RNDIS_DATA_OUT_EP, (uint8_t*)usb_rx_buffer, RNDIS_DATA_OUT_SZ);
 800253e:	2340      	movs	r3, #64	; 0x40
 8002540:	4a02      	ldr	r2, [pc, #8]	; (800254c <rndis_iso_out_incomplete+0x10>)
 8002542:	2103      	movs	r1, #3
 8002544:	f001 fc23 	bl	8003d8e <USBD_LL_PrepareReceive>
}
 8002548:	2000      	movs	r0, #0
 800254a:	bd08      	pop	{r3, pc}
 800254c:	20007890 	.word	0x20007890

08002550 <USBD_CDC_DataIn>:
	if (epnum == (RNDIS_DATA_IN_EP & 0x0F))
 8002550:	f001 010f 	and.w	r1, r1, #15
 8002554:	2902      	cmp	r1, #2
 8002556:	d001      	beq.n	800255c <USBD_CDC_DataIn+0xc>
}
 8002558:	2000      	movs	r0, #0
 800255a:	4770      	bx	lr
{
 800255c:	b570      	push	{r4, r5, r6, lr}
		rndis_first_tx = false;
 800255e:	2500      	movs	r5, #0
 8002560:	4b0f      	ldr	r3, [pc, #60]	; (80025a0 <USBD_CDC_DataIn+0x50>)
 8002562:	701d      	strb	r5, [r3, #0]
		rndis_sended += sended;
 8002564:	4c0f      	ldr	r4, [pc, #60]	; (80025a4 <USBD_CDC_DataIn+0x54>)
 8002566:	6821      	ldr	r1, [r4, #0]
 8002568:	4a0f      	ldr	r2, [pc, #60]	; (80025a8 <USBD_CDC_DataIn+0x58>)
 800256a:	6813      	ldr	r3, [r2, #0]
 800256c:	440b      	add	r3, r1
 800256e:	6013      	str	r3, [r2, #0]
		rndis_tx_size -= sended;
 8002570:	4a0e      	ldr	r2, [pc, #56]	; (80025ac <USBD_CDC_DataIn+0x5c>)
 8002572:	6813      	ldr	r3, [r2, #0]
 8002574:	1a5b      	subs	r3, r3, r1
 8002576:	6013      	str	r3, [r2, #0]
		rndis_tx_ptr += sended;
 8002578:	4e0d      	ldr	r6, [pc, #52]	; (80025b0 <USBD_CDC_DataIn+0x60>)
 800257a:	6832      	ldr	r2, [r6, #0]
 800257c:	440a      	add	r2, r1
 800257e:	6032      	str	r2, [r6, #0]
		sended = 0;
 8002580:	6025      	str	r5, [r4, #0]
	if (sended != 0 || rndis_tx_ptr == NULL || rndis_tx_size <= 0) return USBD_OK;
 8002582:	b15a      	cbz	r2, 800259c <USBD_CDC_DataIn+0x4c>
 8002584:	42ab      	cmp	r3, r5
 8002586:	dd09      	ble.n	800259c <USBD_CDC_DataIn+0x4c>
 8002588:	2b40      	cmp	r3, #64	; 0x40
 800258a:	bfa8      	it	ge
 800258c:	2340      	movge	r3, #64	; 0x40
 800258e:	461c      	mov	r4, r3
		USBD_LL_Transmit(pdev,
 8002590:	b29b      	uxth	r3, r3
 8002592:	2182      	movs	r1, #130	; 0x82
 8002594:	f001 fbee 	bl	8003d74 <USBD_LL_Transmit>
		sended = n;
 8002598:	4b02      	ldr	r3, [pc, #8]	; (80025a4 <USBD_CDC_DataIn+0x54>)
 800259a:	601c      	str	r4, [r3, #0]
}
 800259c:	2000      	movs	r0, #0
 800259e:	bd70      	pop	{r4, r5, r6, pc}
 80025a0:	2000008b 	.word	0x2000008b
 80025a4:	200001cc 	.word	0x200001cc
 80025a8:	200001c0 	.word	0x200001c0
 80025ac:	200001c8 	.word	0x200001c8
 80025b0:	200001c4 	.word	0x200001c4

080025b4 <USBD_CDC_DataOut>:
{
 80025b4:	b570      	push	{r4, r5, r6, lr}
 80025b6:	4606      	mov	r6, r0
 80025b8:	460c      	mov	r4, r1
	 uint32_t receivedLenght = USBD_LL_GetRxDataSize (pdev, epnum);
 80025ba:	f001 fbf5 	bl	8003da8 <USBD_LL_GetRxDataSize>
		if (epnum == RNDIS_DATA_OUT_EP)
 80025be:	2c03      	cmp	r4, #3
 80025c0:	d001      	beq.n	80025c6 <USBD_CDC_DataOut+0x12>
}
 80025c2:	2000      	movs	r0, #0
 80025c4:	bd70      	pop	{r4, r5, r6, pc}
 80025c6:	4605      	mov	r5, r0
			if (rndis_received + receivedLenght > RNDIS_RX_BUFFER_SIZE)
 80025c8:	4b22      	ldr	r3, [pc, #136]	; (8002654 <USBD_CDC_DataOut+0xa0>)
 80025ca:	681b      	ldr	r3, [r3, #0]
 80025cc:	18c4      	adds	r4, r0, r3
 80025ce:	f240 6216 	movw	r2, #1558	; 0x616
 80025d2:	4294      	cmp	r4, r2
 80025d4:	d90d      	bls.n	80025f2 <USBD_CDC_DataOut+0x3e>
				usb_eth_stat.rxbad++;
 80025d6:	4a20      	ldr	r2, [pc, #128]	; (8002658 <USBD_CDC_DataOut+0xa4>)
 80025d8:	68d3      	ldr	r3, [r2, #12]
 80025da:	3301      	adds	r3, #1
 80025dc:	60d3      	str	r3, [r2, #12]
				rndis_received = 0;
 80025de:	2200      	movs	r2, #0
 80025e0:	4b1c      	ldr	r3, [pc, #112]	; (8002654 <USBD_CDC_DataOut+0xa0>)
 80025e2:	601a      	str	r2, [r3, #0]
			USBD_LL_PrepareReceive(pdev,
 80025e4:	2340      	movs	r3, #64	; 0x40
 80025e6:	4a1d      	ldr	r2, [pc, #116]	; (800265c <USBD_CDC_DataOut+0xa8>)
 80025e8:	2103      	movs	r1, #3
 80025ea:	4630      	mov	r0, r6
 80025ec:	f001 fbcf 	bl	8003d8e <USBD_LL_PrepareReceive>
 80025f0:	e7e7      	b.n	80025c2 <USBD_CDC_DataOut+0xe>
					memcpy(&rndis_rx_buffer[rndis_received], usb_rx_buffer, receivedLenght);
 80025f2:	4602      	mov	r2, r0
 80025f4:	4919      	ldr	r1, [pc, #100]	; (800265c <USBD_CDC_DataOut+0xa8>)
 80025f6:	481a      	ldr	r0, [pc, #104]	; (8002660 <USBD_CDC_DataOut+0xac>)
 80025f8:	4418      	add	r0, r3
 80025fa:	f006 fd78 	bl	80090ee <memcpy>
					rndis_received += receivedLenght;
 80025fe:	4b15      	ldr	r3, [pc, #84]	; (8002654 <USBD_CDC_DataOut+0xa0>)
 8002600:	601c      	str	r4, [r3, #0]
					if (receivedLenght != RNDIS_DATA_OUT_SZ)
 8002602:	2d40      	cmp	r5, #64	; 0x40
 8002604:	d0ee      	beq.n	80025e4 <USBD_CDC_DataOut+0x30>
	if (size < sizeof(rndis_data_packet_t)) return;
 8002606:	2c2b      	cmp	r4, #43	; 0x2b
 8002608:	d903      	bls.n	8002612 <USBD_CDC_DataOut+0x5e>
	if (p->MessageType != REMOTE_NDIS_PACKET_MSG || p->MessageLength != size) return;
 800260a:	4b15      	ldr	r3, [pc, #84]	; (8002660 <USBD_CDC_DataOut+0xac>)
 800260c:	681b      	ldr	r3, [r3, #0]
 800260e:	2b01      	cmp	r3, #1
 8002610:	d003      	beq.n	800261a <USBD_CDC_DataOut+0x66>
						rndis_received = 0;
 8002612:	2200      	movs	r2, #0
 8002614:	4b0f      	ldr	r3, [pc, #60]	; (8002654 <USBD_CDC_DataOut+0xa0>)
 8002616:	601a      	str	r2, [r3, #0]
 8002618:	e7e4      	b.n	80025e4 <USBD_CDC_DataOut+0x30>
	if (p->MessageType != REMOTE_NDIS_PACKET_MSG || p->MessageLength != size) return;
 800261a:	4b11      	ldr	r3, [pc, #68]	; (8002660 <USBD_CDC_DataOut+0xac>)
 800261c:	685b      	ldr	r3, [r3, #4]
 800261e:	429c      	cmp	r4, r3
 8002620:	d1f7      	bne.n	8002612 <USBD_CDC_DataOut+0x5e>
	if (p->DataOffset + offsetof(rndis_data_packet_t, DataOffset) + p->DataLength != size)
 8002622:	4b0f      	ldr	r3, [pc, #60]	; (8002660 <USBD_CDC_DataOut+0xac>)
 8002624:	689a      	ldr	r2, [r3, #8]
 8002626:	68d9      	ldr	r1, [r3, #12]
 8002628:	1853      	adds	r3, r2, r1
 800262a:	3308      	adds	r3, #8
 800262c:	429c      	cmp	r4, r3
 800262e:	d004      	beq.n	800263a <USBD_CDC_DataOut+0x86>
		usb_eth_stat.rxbad++;
 8002630:	4a09      	ldr	r2, [pc, #36]	; (8002658 <USBD_CDC_DataOut+0xa4>)
 8002632:	68d3      	ldr	r3, [r2, #12]
 8002634:	3301      	adds	r3, #1
 8002636:	60d3      	str	r3, [r2, #12]
 8002638:	e7eb      	b.n	8002612 <USBD_CDC_DataOut+0x5e>
	usb_eth_stat.rxok++;
 800263a:	4807      	ldr	r0, [pc, #28]	; (8002658 <USBD_CDC_DataOut+0xa4>)
 800263c:	6843      	ldr	r3, [r0, #4]
 800263e:	3301      	adds	r3, #1
 8002640:	6043      	str	r3, [r0, #4]
	if (rndis_rxproc != NULL)
 8002642:	4b08      	ldr	r3, [pc, #32]	; (8002664 <USBD_CDC_DataOut+0xb0>)
 8002644:	681b      	ldr	r3, [r3, #0]
 8002646:	2b00      	cmp	r3, #0
 8002648:	d0e3      	beq.n	8002612 <USBD_CDC_DataOut+0x5e>
		rndis_rxproc(&rndis_rx_buffer[p->DataOffset + offsetof(rndis_data_packet_t, DataOffset)], p->DataLength);
 800264a:	4807      	ldr	r0, [pc, #28]	; (8002668 <USBD_CDC_DataOut+0xb4>)
 800264c:	4410      	add	r0, r2
 800264e:	4798      	blx	r3
 8002650:	e7df      	b.n	8002612 <USBD_CDC_DataOut+0x5e>
 8002652:	bf00      	nop
 8002654:	200001b8 	.word	0x200001b8
 8002658:	200001d0 	.word	0x200001d0
 800265c:	20007890 	.word	0x20007890
 8002660:	200078d0 	.word	0x200078d0
 8002664:	200001bc 	.word	0x200001bc
 8002668:	200078d8 	.word	0x200078d8

0800266c <USBD_CDC_Setup>:
{
 800266c:	b508      	push	{r3, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800266e:	780b      	ldrb	r3, [r1, #0]
 8002670:	f003 0260 	and.w	r2, r3, #96	; 0x60
 8002674:	2a20      	cmp	r2, #32
 8002676:	d107      	bne.n	8002688 <USBD_CDC_Setup+0x1c>
    if (req->wLength)
 8002678:	88ca      	ldrh	r2, [r1, #6]
 800267a:	b12a      	cbz	r2, 8002688 <USBD_CDC_Setup+0x1c>
      if (req->bmRequest & 0x80)
 800267c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8002680:	d104      	bne.n	800268c <USBD_CDC_Setup+0x20>
        USBD_CtlPrepareRx(pdev, encapsulated_buffer, req->wLength);
 8002682:	4905      	ldr	r1, [pc, #20]	; (8002698 <USBD_CDC_Setup+0x2c>)
 8002684:	f000 ff38 	bl	80034f8 <USBD_CtlPrepareRx>
}
 8002688:	2000      	movs	r0, #0
 800268a:	bd08      	pop	{r3, pc}
			USBD_CtlSendData(pdev, encapsulated_buffer, ((rndis_generic_msg_t *)encapsulated_buffer)->MessageLength);
 800268c:	4902      	ldr	r1, [pc, #8]	; (8002698 <USBD_CDC_Setup+0x2c>)
 800268e:	684a      	ldr	r2, [r1, #4]
 8002690:	b292      	uxth	r2, r2
 8002692:	f000 ff1c 	bl	80034ce <USBD_CtlSendData>
 8002696:	e7f7      	b.n	8002688 <USBD_CDC_Setup+0x1c>
 8002698:	20007ee8 	.word	0x20007ee8

0800269c <USBD_CDC_DeInit>:
{
 800269c:	b510      	push	{r4, lr}
 800269e:	4604      	mov	r4, r0
  USBD_LL_CloseEP(pdev,
 80026a0:	2181      	movs	r1, #129	; 0x81
 80026a2:	f001 fb1c 	bl	8003cde <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev,
 80026a6:	2182      	movs	r1, #130	; 0x82
 80026a8:	4620      	mov	r0, r4
 80026aa:	f001 fb18 	bl	8003cde <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev,
 80026ae:	2103      	movs	r1, #3
 80026b0:	4620      	mov	r0, r4
 80026b2:	f001 fb14 	bl	8003cde <USBD_LL_CloseEP>
}
 80026b6:	2000      	movs	r0, #0
 80026b8:	bd10      	pop	{r4, pc}
	...

080026bc <USBD_CDC_Init>:
{
 80026bc:	b510      	push	{r4, lr}
 80026be:	4604      	mov	r4, r0
    USBD_LL_OpenEP(pdev,
 80026c0:	2308      	movs	r3, #8
 80026c2:	2203      	movs	r2, #3
 80026c4:	2181      	movs	r1, #129	; 0x81
 80026c6:	f001 fafa 	bl	8003cbe <USBD_LL_OpenEP>
    USBD_LL_OpenEP(pdev,
 80026ca:	2340      	movs	r3, #64	; 0x40
 80026cc:	2202      	movs	r2, #2
 80026ce:	2182      	movs	r1, #130	; 0x82
 80026d0:	4620      	mov	r0, r4
 80026d2:	f001 faf4 	bl	8003cbe <USBD_LL_OpenEP>
    USBD_LL_OpenEP(pdev,
 80026d6:	2340      	movs	r3, #64	; 0x40
 80026d8:	2202      	movs	r2, #2
 80026da:	2103      	movs	r1, #3
 80026dc:	4620      	mov	r0, r4
 80026de:	f001 faee 	bl	8003cbe <USBD_LL_OpenEP>
    USBD_LL_PrepareReceive(pdev,
 80026e2:	2340      	movs	r3, #64	; 0x40
 80026e4:	4a03      	ldr	r2, [pc, #12]	; (80026f4 <USBD_CDC_Init+0x38>)
 80026e6:	2103      	movs	r1, #3
 80026e8:	4620      	mov	r0, r4
 80026ea:	f001 fb50 	bl	8003d8e <USBD_LL_PrepareReceive>
}
 80026ee:	2000      	movs	r0, #0
 80026f0:	bd10      	pop	{r4, pc}
 80026f2:	bf00      	nop
 80026f4:	20007890 	.word	0x20007890

080026f8 <rndis_iso_in_incomplete>:
{
 80026f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (sended != 0 || rndis_tx_ptr == NULL || rndis_tx_size <= 0) return USBD_OK;
 80026fa:	4b21      	ldr	r3, [pc, #132]	; (8002780 <rndis_iso_in_incomplete+0x88>)
 80026fc:	681b      	ldr	r3, [r3, #0]
 80026fe:	b9a3      	cbnz	r3, 800272a <rndis_iso_in_incomplete+0x32>
 8002700:	4b20      	ldr	r3, [pc, #128]	; (8002784 <rndis_iso_in_incomplete+0x8c>)
 8002702:	681e      	ldr	r6, [r3, #0]
 8002704:	b18e      	cbz	r6, 800272a <rndis_iso_in_incomplete+0x32>
 8002706:	4b20      	ldr	r3, [pc, #128]	; (8002788 <rndis_iso_in_incomplete+0x90>)
 8002708:	681c      	ldr	r4, [r3, #0]
 800270a:	2c00      	cmp	r4, #0
 800270c:	dd0d      	ble.n	800272a <rndis_iso_in_incomplete+0x32>
 800270e:	4605      	mov	r5, r0
	if (rndis_first_tx)
 8002710:	4b1e      	ldr	r3, [pc, #120]	; (800278c <rndis_iso_in_incomplete+0x94>)
 8002712:	781b      	ldrb	r3, [r3, #0]
 8002714:	b95b      	cbnz	r3, 800272e <rndis_iso_in_incomplete+0x36>
 8002716:	2c40      	cmp	r4, #64	; 0x40
 8002718:	bfa8      	it	ge
 800271a:	2440      	movge	r4, #64	; 0x40
		USBD_LL_Transmit(pdev,
 800271c:	b2a3      	uxth	r3, r4
 800271e:	4632      	mov	r2, r6
 8002720:	2182      	movs	r1, #130	; 0x82
 8002722:	f001 fb27 	bl	8003d74 <USBD_LL_Transmit>
		sended = n;
 8002726:	4b16      	ldr	r3, [pc, #88]	; (8002780 <rndis_iso_in_incomplete+0x88>)
 8002728:	601c      	str	r4, [r3, #0]
}
 800272a:	2000      	movs	r0, #0
 800272c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		memset(hdr, 0, sizeof(rndis_data_packet_t));
 800272e:	4f18      	ldr	r7, [pc, #96]	; (8002790 <rndis_iso_in_incomplete+0x98>)
 8002730:	222c      	movs	r2, #44	; 0x2c
 8002732:	2100      	movs	r1, #0
 8002734:	4638      	mov	r0, r7
 8002736:	f006 fce5 	bl	8009104 <memset>
		hdr->MessageType = REMOTE_NDIS_PACKET_MSG;
 800273a:	2301      	movs	r3, #1
 800273c:	603b      	str	r3, [r7, #0]
		hdr->MessageLength = sizeof(rndis_data_packet_t) + rndis_tx_size;
 800273e:	f104 032c 	add.w	r3, r4, #44	; 0x2c
 8002742:	607b      	str	r3, [r7, #4]
		hdr->DataOffset = sizeof(rndis_data_packet_t) - offsetof(rndis_data_packet_t, DataOffset);
 8002744:	2324      	movs	r3, #36	; 0x24
 8002746:	60bb      	str	r3, [r7, #8]
		hdr->DataLength = rndis_tx_size;
 8002748:	60fc      	str	r4, [r7, #12]
		if (sended > rndis_tx_size) sended = rndis_tx_size;
 800274a:	2c13      	cmp	r4, #19
 800274c:	dc13      	bgt.n	8002776 <rndis_iso_in_incomplete+0x7e>
 800274e:	4b0c      	ldr	r3, [pc, #48]	; (8002780 <rndis_iso_in_incomplete+0x88>)
 8002750:	601c      	str	r4, [r3, #0]
		memcpy(first + sizeof(rndis_data_packet_t), rndis_tx_ptr, sended);
 8002752:	4b0b      	ldr	r3, [pc, #44]	; (8002780 <rndis_iso_in_incomplete+0x88>)
 8002754:	681c      	ldr	r4, [r3, #0]
 8002756:	4f0e      	ldr	r7, [pc, #56]	; (8002790 <rndis_iso_in_incomplete+0x98>)
 8002758:	4622      	mov	r2, r4
 800275a:	4631      	mov	r1, r6
 800275c:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8002760:	f006 fcc5 	bl	80090ee <memcpy>
		USBD_LL_Transmit(pdev,
 8002764:	f104 032c 	add.w	r3, r4, #44	; 0x2c
 8002768:	b29b      	uxth	r3, r3
 800276a:	463a      	mov	r2, r7
 800276c:	2182      	movs	r1, #130	; 0x82
 800276e:	4628      	mov	r0, r5
 8002770:	f001 fb00 	bl	8003d74 <USBD_LL_Transmit>
 8002774:	e7d9      	b.n	800272a <rndis_iso_in_incomplete+0x32>
		sended = RNDIS_DATA_IN_SZ - sizeof(rndis_data_packet_t);
 8002776:	2214      	movs	r2, #20
 8002778:	4b01      	ldr	r3, [pc, #4]	; (8002780 <rndis_iso_in_incomplete+0x88>)
 800277a:	601a      	str	r2, [r3, #0]
 800277c:	e7e9      	b.n	8002752 <rndis_iso_in_incomplete+0x5a>
 800277e:	bf00      	nop
 8002780:	200001cc 	.word	0x200001cc
 8002784:	200001c4 	.word	0x200001c4
 8002788:	200001c8 	.word	0x200001c8
 800278c:	2000008b 	.word	0x2000008b
 8002790:	20000174 	.word	0x20000174

08002794 <usbd_rndis_sof>:
{
 8002794:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (sended != 0 || rndis_tx_ptr == NULL || rndis_tx_size <= 0) return USBD_OK;
 8002796:	4b21      	ldr	r3, [pc, #132]	; (800281c <usbd_rndis_sof+0x88>)
 8002798:	681b      	ldr	r3, [r3, #0]
 800279a:	b9a3      	cbnz	r3, 80027c6 <usbd_rndis_sof+0x32>
 800279c:	4b20      	ldr	r3, [pc, #128]	; (8002820 <usbd_rndis_sof+0x8c>)
 800279e:	681e      	ldr	r6, [r3, #0]
 80027a0:	b18e      	cbz	r6, 80027c6 <usbd_rndis_sof+0x32>
 80027a2:	4b20      	ldr	r3, [pc, #128]	; (8002824 <usbd_rndis_sof+0x90>)
 80027a4:	681c      	ldr	r4, [r3, #0]
 80027a6:	2c00      	cmp	r4, #0
 80027a8:	dd0d      	ble.n	80027c6 <usbd_rndis_sof+0x32>
 80027aa:	4605      	mov	r5, r0
	if (rndis_first_tx)
 80027ac:	4b1e      	ldr	r3, [pc, #120]	; (8002828 <usbd_rndis_sof+0x94>)
 80027ae:	781b      	ldrb	r3, [r3, #0]
 80027b0:	b95b      	cbnz	r3, 80027ca <usbd_rndis_sof+0x36>
 80027b2:	2c40      	cmp	r4, #64	; 0x40
 80027b4:	bfa8      	it	ge
 80027b6:	2440      	movge	r4, #64	; 0x40
		USBD_LL_Transmit(pdev,
 80027b8:	b2a3      	uxth	r3, r4
 80027ba:	4632      	mov	r2, r6
 80027bc:	2182      	movs	r1, #130	; 0x82
 80027be:	f001 fad9 	bl	8003d74 <USBD_LL_Transmit>
		sended = n;
 80027c2:	4b16      	ldr	r3, [pc, #88]	; (800281c <usbd_rndis_sof+0x88>)
 80027c4:	601c      	str	r4, [r3, #0]
}
 80027c6:	2000      	movs	r0, #0
 80027c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		memset(hdr, 0, sizeof(rndis_data_packet_t));
 80027ca:	4f18      	ldr	r7, [pc, #96]	; (800282c <usbd_rndis_sof+0x98>)
 80027cc:	222c      	movs	r2, #44	; 0x2c
 80027ce:	2100      	movs	r1, #0
 80027d0:	4638      	mov	r0, r7
 80027d2:	f006 fc97 	bl	8009104 <memset>
		hdr->MessageType = REMOTE_NDIS_PACKET_MSG;
 80027d6:	2301      	movs	r3, #1
 80027d8:	603b      	str	r3, [r7, #0]
		hdr->MessageLength = sizeof(rndis_data_packet_t) + rndis_tx_size;
 80027da:	f104 032c 	add.w	r3, r4, #44	; 0x2c
 80027de:	607b      	str	r3, [r7, #4]
		hdr->DataOffset = sizeof(rndis_data_packet_t) - offsetof(rndis_data_packet_t, DataOffset);
 80027e0:	2324      	movs	r3, #36	; 0x24
 80027e2:	60bb      	str	r3, [r7, #8]
		hdr->DataLength = rndis_tx_size;
 80027e4:	60fc      	str	r4, [r7, #12]
		if (sended > rndis_tx_size) sended = rndis_tx_size;
 80027e6:	2c13      	cmp	r4, #19
 80027e8:	dc13      	bgt.n	8002812 <usbd_rndis_sof+0x7e>
 80027ea:	4b0c      	ldr	r3, [pc, #48]	; (800281c <usbd_rndis_sof+0x88>)
 80027ec:	601c      	str	r4, [r3, #0]
		memcpy(first + sizeof(rndis_data_packet_t), rndis_tx_ptr, sended);
 80027ee:	4b0b      	ldr	r3, [pc, #44]	; (800281c <usbd_rndis_sof+0x88>)
 80027f0:	681c      	ldr	r4, [r3, #0]
 80027f2:	4f0e      	ldr	r7, [pc, #56]	; (800282c <usbd_rndis_sof+0x98>)
 80027f4:	4622      	mov	r2, r4
 80027f6:	4631      	mov	r1, r6
 80027f8:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 80027fc:	f006 fc77 	bl	80090ee <memcpy>
		USBD_LL_Transmit(pdev,
 8002800:	f104 032c 	add.w	r3, r4, #44	; 0x2c
 8002804:	b29b      	uxth	r3, r3
 8002806:	463a      	mov	r2, r7
 8002808:	2182      	movs	r1, #130	; 0x82
 800280a:	4628      	mov	r0, r5
 800280c:	f001 fab2 	bl	8003d74 <USBD_LL_Transmit>
 8002810:	e7d9      	b.n	80027c6 <usbd_rndis_sof+0x32>
		sended = RNDIS_DATA_IN_SZ - sizeof(rndis_data_packet_t);
 8002812:	2214      	movs	r2, #20
 8002814:	4b01      	ldr	r3, [pc, #4]	; (800281c <usbd_rndis_sof+0x88>)
 8002816:	601a      	str	r2, [r3, #0]
 8002818:	e7e9      	b.n	80027ee <usbd_rndis_sof+0x5a>
 800281a:	bf00      	nop
 800281c:	200001cc 	.word	0x200001cc
 8002820:	200001c4 	.word	0x200001c4
 8002824:	200001c8 	.word	0x200001c8
 8002828:	2000008b 	.word	0x2000008b
 800282c:	20000174 	.word	0x20000174

08002830 <rndis_query_cmplt32>:
{
 8002830:	b538      	push	{r3, r4, r5, lr}
	c->MessageType = REMOTE_NDIS_QUERY_CMPLT;
 8002832:	4b10      	ldr	r3, [pc, #64]	; (8002874 <rndis_query_cmplt32+0x44>)
 8002834:	2200      	movs	r2, #0
 8002836:	2404      	movs	r4, #4
 8002838:	701c      	strb	r4, [r3, #0]
 800283a:	705a      	strb	r2, [r3, #1]
 800283c:	709a      	strb	r2, [r3, #2]
 800283e:	f06f 057f 	mvn.w	r5, #127	; 0x7f
 8002842:	70dd      	strb	r5, [r3, #3]
	c->MessageLength = sizeof(rndis_query_cmplt_t) + 4;
 8002844:	251c      	movs	r5, #28
 8002846:	711d      	strb	r5, [r3, #4]
 8002848:	715a      	strb	r2, [r3, #5]
 800284a:	719a      	strb	r2, [r3, #6]
 800284c:	71da      	strb	r2, [r3, #7]
	c->InformationBufferLength = 4;
 800284e:	741c      	strb	r4, [r3, #16]
 8002850:	745a      	strb	r2, [r3, #17]
 8002852:	749a      	strb	r2, [r3, #18]
 8002854:	74da      	strb	r2, [r3, #19]
	c->InformationBufferOffset = 16;
 8002856:	2410      	movs	r4, #16
 8002858:	751c      	strb	r4, [r3, #20]
 800285a:	755a      	strb	r2, [r3, #21]
 800285c:	759a      	strb	r2, [r3, #22]
 800285e:	75da      	strb	r2, [r3, #23]
	c->Status = status;
 8002860:	60d8      	str	r0, [r3, #12]
	*(uint32_t *)(c + 1) = data;
 8002862:	6199      	str	r1, [r3, #24]
	USBD_LL_Transmit(&hUsbDeviceFS,
 8002864:	2308      	movs	r3, #8
 8002866:	4a04      	ldr	r2, [pc, #16]	; (8002878 <rndis_query_cmplt32+0x48>)
 8002868:	2181      	movs	r1, #129	; 0x81
 800286a:	4804      	ldr	r0, [pc, #16]	; (800287c <rndis_query_cmplt32+0x4c>)
 800286c:	f001 fa82 	bl	8003d74 <USBD_LL_Transmit>
 8002870:	bd38      	pop	{r3, r4, r5, pc}
 8002872:	bf00      	nop
 8002874:	20007ee8 	.word	0x20007ee8
 8002878:	0800912c 	.word	0x0800912c
 800287c:	20007fb8 	.word	0x20007fb8

08002880 <rndis_query_cmplt>:
{
 8002880:	b570      	push	{r4, r5, r6, lr}
	c->MessageType = REMOTE_NDIS_QUERY_CMPLT;
 8002882:	4b0f      	ldr	r3, [pc, #60]	; (80028c0 <rndis_query_cmplt+0x40>)
 8002884:	2400      	movs	r4, #0
 8002886:	2604      	movs	r6, #4
 8002888:	701e      	strb	r6, [r3, #0]
 800288a:	705c      	strb	r4, [r3, #1]
 800288c:	709c      	strb	r4, [r3, #2]
 800288e:	f06f 067f 	mvn.w	r6, #127	; 0x7f
 8002892:	70de      	strb	r6, [r3, #3]
	c->MessageLength = sizeof(rndis_query_cmplt_t) + size;
 8002894:	f102 0618 	add.w	r6, r2, #24
 8002898:	605e      	str	r6, [r3, #4]
	c->InformationBufferLength = size;
 800289a:	611a      	str	r2, [r3, #16]
	c->InformationBufferOffset = 16;
 800289c:	2510      	movs	r5, #16
 800289e:	751d      	strb	r5, [r3, #20]
 80028a0:	755c      	strb	r4, [r3, #21]
 80028a2:	759c      	strb	r4, [r3, #22]
 80028a4:	75dc      	strb	r4, [r3, #23]
	c->Status = status;
 80028a6:	60d8      	str	r0, [r3, #12]
	memcpy(c + 1, data, size);
 80028a8:	f103 0018 	add.w	r0, r3, #24
 80028ac:	f006 fc1f 	bl	80090ee <memcpy>
	USBD_LL_Transmit(&hUsbDeviceFS,
 80028b0:	2308      	movs	r3, #8
 80028b2:	4a04      	ldr	r2, [pc, #16]	; (80028c4 <rndis_query_cmplt+0x44>)
 80028b4:	2181      	movs	r1, #129	; 0x81
 80028b6:	4804      	ldr	r0, [pc, #16]	; (80028c8 <rndis_query_cmplt+0x48>)
 80028b8:	f001 fa5c 	bl	8003d74 <USBD_LL_Transmit>
 80028bc:	bd70      	pop	{r4, r5, r6, pc}
 80028be:	bf00      	nop
 80028c0:	20007ee8 	.word	0x20007ee8
 80028c4:	0800912c 	.word	0x0800912c
 80028c8:	20007fb8 	.word	0x20007fb8

080028cc <rndis_query>:
{
 80028cc:	b508      	push	{r3, lr}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 80028ce:	4b87      	ldr	r3, [pc, #540]	; (8002aec <rndis_query+0x220>)
 80028d0:	68db      	ldr	r3, [r3, #12]
 80028d2:	4a87      	ldr	r2, [pc, #540]	; (8002af0 <rndis_query+0x224>)
 80028d4:	4293      	cmp	r3, r2
 80028d6:	f000 8090 	beq.w	80029fa <rndis_query+0x12e>
 80028da:	d919      	bls.n	8002910 <rndis_query+0x44>
 80028dc:	f1b3 3f01 	cmp.w	r3, #16843009	; 0x1010101
 80028e0:	f000 8091 	beq.w	8002a06 <rndis_query+0x13a>
 80028e4:	d867      	bhi.n	80029b6 <rndis_query+0xea>
 80028e6:	4a83      	ldr	r2, [pc, #524]	; (8002af4 <rndis_query+0x228>)
 80028e8:	4293      	cmp	r3, r2
 80028ea:	f000 80ed 	beq.w	8002ac8 <rndis_query+0x1fc>
 80028ee:	d854      	bhi.n	800299a <rndis_query+0xce>
 80028f0:	4a81      	ldr	r2, [pc, #516]	; (8002af8 <rndis_query+0x22c>)
 80028f2:	4293      	cmp	r3, r2
 80028f4:	f000 80bf 	beq.w	8002a76 <rndis_query+0x1aa>
 80028f8:	4a80      	ldr	r2, [pc, #512]	; (8002afc <rndis_query+0x230>)
 80028fa:	4293      	cmp	r3, r2
 80028fc:	f000 80de 	beq.w	8002abc <rndis_query+0x1f0>
 8002900:	4a7f      	ldr	r2, [pc, #508]	; (8002b00 <rndis_query+0x234>)
 8002902:	4293      	cmp	r3, r2
 8002904:	d128      	bne.n	8002958 <rndis_query+0x8c>
		case OID_GEN_PHYSICAL_MEDIUM:        rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, NDIS_MEDIUM_802_3); return;
 8002906:	2100      	movs	r1, #0
 8002908:	4608      	mov	r0, r1
 800290a:	f7ff ff91 	bl	8002830 <rndis_query_cmplt32>
 800290e:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 8002910:	3a0c      	subs	r2, #12
 8002912:	4293      	cmp	r3, r2
 8002914:	f000 80a4 	beq.w	8002a60 <rndis_query+0x194>
 8002918:	d910      	bls.n	800293c <rndis_query+0x70>
 800291a:	4a7a      	ldr	r2, [pc, #488]	; (8002b04 <rndis_query+0x238>)
 800291c:	4293      	cmp	r3, r2
 800291e:	f000 8093 	beq.w	8002a48 <rndis_query+0x17c>
 8002922:	d82a      	bhi.n	800297a <rndis_query+0xae>
 8002924:	3a02      	subs	r2, #2
 8002926:	4293      	cmp	r3, r2
 8002928:	f000 8082 	beq.w	8002a30 <rndis_query+0x164>
 800292c:	f200 8086 	bhi.w	8002a3c <rndis_query+0x170>
		case OID_GEN_RECEIVE_BLOCK_SIZE:     rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, ETH_MAX_PACKET_SIZE); return;
 8002930:	f240 51ea 	movw	r1, #1514	; 0x5ea
 8002934:	2000      	movs	r0, #0
 8002936:	f7ff ff7b 	bl	8002830 <rndis_query_cmplt32>
 800293a:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 800293c:	3a07      	subs	r2, #7
 800293e:	4293      	cmp	r3, r2
 8002940:	d067      	beq.n	8002a12 <rndis_query+0x146>
 8002942:	d90f      	bls.n	8002964 <rndis_query+0x98>
 8002944:	4a70      	ldr	r2, [pc, #448]	; (8002b08 <rndis_query+0x23c>)
 8002946:	4293      	cmp	r3, r2
 8002948:	f000 8084 	beq.w	8002a54 <rndis_query+0x188>
 800294c:	3201      	adds	r2, #1
 800294e:	4293      	cmp	r3, r2
 8002950:	d069      	beq.n	8002a26 <rndis_query+0x15a>
 8002952:	3a03      	subs	r2, #3
 8002954:	4293      	cmp	r3, r2
 8002956:	d061      	beq.n	8002a1c <rndis_query+0x150>
		default:                             rndis_query_cmplt(RNDIS_STATUS_FAILURE, NULL, 0); return;
 8002958:	2200      	movs	r2, #0
 800295a:	4611      	mov	r1, r2
 800295c:	486b      	ldr	r0, [pc, #428]	; (8002b0c <rndis_query+0x240>)
 800295e:	f7ff ff8f 	bl	8002880 <rndis_query_cmplt>
 8002962:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 8002964:	3a02      	subs	r2, #2
 8002966:	4293      	cmp	r3, r2
 8002968:	d041      	beq.n	80029ee <rndis_query+0x122>
 800296a:	3201      	adds	r2, #1
 800296c:	4293      	cmp	r3, r2
 800296e:	d1f3      	bne.n	8002958 <rndis_query+0x8c>
		case OID_GEN_HARDWARE_STATUS:        rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0); return;
 8002970:	2100      	movs	r1, #0
 8002972:	4608      	mov	r0, r1
 8002974:	f7ff ff5c 	bl	8002830 <rndis_query_cmplt32>
 8002978:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 800297a:	4a65      	ldr	r2, [pc, #404]	; (8002b10 <rndis_query+0x244>)
 800297c:	4293      	cmp	r3, r2
 800297e:	f000 808e 	beq.w	8002a9e <rndis_query+0x1d2>
 8002982:	3201      	adds	r2, #1
 8002984:	4293      	cmp	r3, r2
 8002986:	d071      	beq.n	8002a6c <rndis_query+0x1a0>
 8002988:	3a03      	subs	r2, #3
 800298a:	4293      	cmp	r3, r2
 800298c:	d1e4      	bne.n	8002958 <rndis_query+0x8c>
		case OID_GEN_MAXIMUM_TOTAL_SIZE:     rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, ETH_MAX_PACKET_SIZE); return;
 800298e:	f240 51ea 	movw	r1, #1514	; 0x5ea
 8002992:	2000      	movs	r0, #0
 8002994:	f7ff ff4c 	bl	8002830 <rndis_query_cmplt32>
 8002998:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 800299a:	4a5e      	ldr	r2, [pc, #376]	; (8002b14 <rndis_query+0x248>)
 800299c:	4293      	cmp	r3, r2
 800299e:	f000 8099 	beq.w	8002ad4 <rndis_query+0x208>
 80029a2:	f0c0 809d 	bcc.w	8002ae0 <rndis_query+0x214>
 80029a6:	3201      	adds	r2, #1
 80029a8:	4293      	cmp	r3, r2
 80029aa:	d1d5      	bne.n	8002958 <rndis_query+0x8c>
		case OID_GEN_RCV_NO_BUFFER:          rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0); return;
 80029ac:	2100      	movs	r1, #0
 80029ae:	4608      	mov	r0, r1
 80029b0:	f7ff ff3e 	bl	8002830 <rndis_query_cmplt32>
 80029b4:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 80029b6:	4a58      	ldr	r2, [pc, #352]	; (8002b18 <rndis_query+0x24c>)
 80029b8:	4293      	cmp	r3, r2
 80029ba:	d06b      	beq.n	8002a94 <rndis_query+0x1c8>
 80029bc:	d809      	bhi.n	80029d2 <rndis_query+0x106>
 80029be:	3a02      	subs	r2, #2
 80029c0:	4293      	cmp	r3, r2
 80029c2:	d062      	beq.n	8002a8a <rndis_query+0x1be>
 80029c4:	d85c      	bhi.n	8002a80 <rndis_query+0x1b4>
		case OID_802_3_CURRENT_ADDRESS:      rndis_query_cmplt(RNDIS_STATUS_SUCCESS, &station_hwaddr, 6); return;
 80029c6:	2206      	movs	r2, #6
 80029c8:	4954      	ldr	r1, [pc, #336]	; (8002b1c <rndis_query+0x250>)
 80029ca:	2000      	movs	r0, #0
 80029cc:	f7ff ff58 	bl	8002880 <rndis_query_cmplt>
 80029d0:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 80029d2:	4a53      	ldr	r2, [pc, #332]	; (8002b20 <rndis_query+0x254>)
 80029d4:	4293      	cmp	r3, r2
 80029d6:	d067      	beq.n	8002aa8 <rndis_query+0x1dc>
 80029d8:	3201      	adds	r2, #1
 80029da:	4293      	cmp	r3, r2
 80029dc:	d069      	beq.n	8002ab2 <rndis_query+0x1e6>
 80029de:	3a02      	subs	r2, #2
 80029e0:	4293      	cmp	r3, r2
 80029e2:	d1b9      	bne.n	8002958 <rndis_query+0x8c>
		case OID_802_3_RCV_ERROR_ALIGNMENT:  rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0); return;
 80029e4:	2100      	movs	r1, #0
 80029e6:	4608      	mov	r0, r1
 80029e8:	f7ff ff22 	bl	8002830 <rndis_query_cmplt32>
 80029ec:	bd08      	pop	{r3, pc}
		case OID_GEN_SUPPORTED_LIST:         rndis_query_cmplt(RNDIS_STATUS_SUCCESS, OIDSupportedList, 4 * OID_LIST_LENGTH); return;
 80029ee:	2258      	movs	r2, #88	; 0x58
 80029f0:	494c      	ldr	r1, [pc, #304]	; (8002b24 <rndis_query+0x258>)
 80029f2:	2000      	movs	r0, #0
 80029f4:	f7ff ff44 	bl	8002880 <rndis_query_cmplt>
 80029f8:	bd08      	pop	{r3, pc}
		case OID_GEN_VENDOR_DRIVER_VERSION:  rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0x00001000);  return;
 80029fa:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80029fe:	2000      	movs	r0, #0
 8002a00:	f7ff ff16 	bl	8002830 <rndis_query_cmplt32>
 8002a04:	bd08      	pop	{r3, pc}
		case OID_802_3_PERMANENT_ADDRESS:    rndis_query_cmplt(RNDIS_STATUS_SUCCESS, &permanent_hwaddr, 6); return;
 8002a06:	2206      	movs	r2, #6
 8002a08:	4947      	ldr	r1, [pc, #284]	; (8002b28 <rndis_query+0x25c>)
 8002a0a:	2000      	movs	r0, #0
 8002a0c:	f7ff ff38 	bl	8002880 <rndis_query_cmplt>
 8002a10:	bd08      	pop	{r3, pc}
		case OID_GEN_MEDIA_SUPPORTED:        rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, NDIS_MEDIUM_802_3); return;
 8002a12:	2100      	movs	r1, #0
 8002a14:	4608      	mov	r0, r1
 8002a16:	f7ff ff0b 	bl	8002830 <rndis_query_cmplt32>
 8002a1a:	bd08      	pop	{r3, pc}
		case OID_GEN_MEDIA_IN_USE:           rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, NDIS_MEDIUM_802_3); return;
 8002a1c:	2100      	movs	r1, #0
 8002a1e:	4608      	mov	r0, r1
 8002a20:	f7ff ff06 	bl	8002830 <rndis_query_cmplt32>
 8002a24:	bd08      	pop	{r3, pc}
		case OID_GEN_LINK_SPEED:             rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, RNDIS_LINK_SPEED / 100); return;
 8002a26:	4941      	ldr	r1, [pc, #260]	; (8002b2c <rndis_query+0x260>)
 8002a28:	2000      	movs	r0, #0
 8002a2a:	f7ff ff01 	bl	8002830 <rndis_query_cmplt32>
 8002a2e:	bd08      	pop	{r3, pc}
		case OID_GEN_VENDOR_ID:              rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0x00FFFFFF); return;
 8002a30:	f06f 417f 	mvn.w	r1, #4278190080	; 0xff000000
 8002a34:	2000      	movs	r0, #0
 8002a36:	f7ff fefb 	bl	8002830 <rndis_query_cmplt32>
 8002a3a:	bd08      	pop	{r3, pc}
		case OID_GEN_VENDOR_DESCRIPTION:     rndis_query_cmplt(RNDIS_STATUS_SUCCESS, rndis_vendor, strlen(rndis_vendor) + 1); return;
 8002a3c:	2208      	movs	r2, #8
 8002a3e:	493c      	ldr	r1, [pc, #240]	; (8002b30 <rndis_query+0x264>)
 8002a40:	2000      	movs	r0, #0
 8002a42:	f7ff ff1d 	bl	8002880 <rndis_query_cmplt>
 8002a46:	bd08      	pop	{r3, pc}
		case OID_GEN_CURRENT_PACKET_FILTER:  rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, oid_packet_filter); return;
 8002a48:	4b3a      	ldr	r3, [pc, #232]	; (8002b34 <rndis_query+0x268>)
 8002a4a:	6819      	ldr	r1, [r3, #0]
 8002a4c:	2000      	movs	r0, #0
 8002a4e:	f7ff feef 	bl	8002830 <rndis_query_cmplt32>
 8002a52:	bd08      	pop	{r3, pc}
		case OID_GEN_MAXIMUM_FRAME_SIZE:     rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, ETH_MAX_PACKET_SIZE - ETH_HEADER_SIZE); return;
 8002a54:	f240 51dc 	movw	r1, #1500	; 0x5dc
 8002a58:	2000      	movs	r0, #0
 8002a5a:	f7ff fee9 	bl	8002830 <rndis_query_cmplt32>
 8002a5e:	bd08      	pop	{r3, pc}
		case OID_GEN_TRANSMIT_BLOCK_SIZE:    rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, ETH_MAX_PACKET_SIZE); return;
 8002a60:	f240 51ea 	movw	r1, #1514	; 0x5ea
 8002a64:	2000      	movs	r0, #0
 8002a66:	f7ff fee3 	bl	8002830 <rndis_query_cmplt32>
 8002a6a:	bd08      	pop	{r3, pc}
		case OID_GEN_MEDIA_CONNECT_STATUS:   rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, NDIS_MEDIA_STATE_CONNECTED); return;
 8002a6c:	2100      	movs	r1, #0
 8002a6e:	4608      	mov	r0, r1
 8002a70:	f7ff fede 	bl	8002830 <rndis_query_cmplt32>
 8002a74:	bd08      	pop	{r3, pc}
		case OID_GEN_RNDIS_CONFIG_PARAMETER: rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0); return;
 8002a76:	2100      	movs	r1, #0
 8002a78:	4608      	mov	r0, r1
 8002a7a:	f7ff fed9 	bl	8002830 <rndis_query_cmplt32>
 8002a7e:	bd08      	pop	{r3, pc}
		case OID_802_3_MAXIMUM_LIST_SIZE:    rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 1); return;
 8002a80:	2101      	movs	r1, #1
 8002a82:	2000      	movs	r0, #0
 8002a84:	f7ff fed4 	bl	8002830 <rndis_query_cmplt32>
 8002a88:	bd08      	pop	{r3, pc}
		case OID_802_3_MULTICAST_LIST:       rndis_query_cmplt32(RNDIS_STATUS_NOT_SUPPORTED, 0); return;
 8002a8a:	2100      	movs	r1, #0
 8002a8c:	482a      	ldr	r0, [pc, #168]	; (8002b38 <rndis_query+0x26c>)
 8002a8e:	f7ff fecf 	bl	8002830 <rndis_query_cmplt32>
 8002a92:	bd08      	pop	{r3, pc}
		case OID_802_3_MAC_OPTIONS:          rndis_query_cmplt32(RNDIS_STATUS_NOT_SUPPORTED, 0); return;
 8002a94:	2100      	movs	r1, #0
 8002a96:	4828      	ldr	r0, [pc, #160]	; (8002b38 <rndis_query+0x26c>)
 8002a98:	f7ff feca 	bl	8002830 <rndis_query_cmplt32>
 8002a9c:	bd08      	pop	{r3, pc}
		case OID_GEN_MAC_OPTIONS:            rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, /*MAC_OPT*/ 0); return;
 8002a9e:	2100      	movs	r1, #0
 8002aa0:	4608      	mov	r0, r1
 8002aa2:	f7ff fec5 	bl	8002830 <rndis_query_cmplt32>
 8002aa6:	bd08      	pop	{r3, pc}
		case OID_802_3_XMIT_ONE_COLLISION:   rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0); return;
 8002aa8:	2100      	movs	r1, #0
 8002aaa:	4608      	mov	r0, r1
 8002aac:	f7ff fec0 	bl	8002830 <rndis_query_cmplt32>
 8002ab0:	bd08      	pop	{r3, pc}
		case OID_802_3_XMIT_MORE_COLLISIONS: rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0); return;
 8002ab2:	2100      	movs	r1, #0
 8002ab4:	4608      	mov	r0, r1
 8002ab6:	f7ff febb 	bl	8002830 <rndis_query_cmplt32>
 8002aba:	bd08      	pop	{r3, pc}
		case OID_GEN_XMIT_OK:                rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, usb_eth_stat.txok); return;
 8002abc:	4b1f      	ldr	r3, [pc, #124]	; (8002b3c <rndis_query+0x270>)
 8002abe:	6819      	ldr	r1, [r3, #0]
 8002ac0:	2000      	movs	r0, #0
 8002ac2:	f7ff feb5 	bl	8002830 <rndis_query_cmplt32>
 8002ac6:	bd08      	pop	{r3, pc}
		case OID_GEN_RCV_OK:                 rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, usb_eth_stat.rxok); return;
 8002ac8:	4b1c      	ldr	r3, [pc, #112]	; (8002b3c <rndis_query+0x270>)
 8002aca:	6859      	ldr	r1, [r3, #4]
 8002acc:	2000      	movs	r0, #0
 8002ace:	f7ff feaf 	bl	8002830 <rndis_query_cmplt32>
 8002ad2:	bd08      	pop	{r3, pc}
		case OID_GEN_RCV_ERROR:              rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, usb_eth_stat.rxbad); return;
 8002ad4:	4b19      	ldr	r3, [pc, #100]	; (8002b3c <rndis_query+0x270>)
 8002ad6:	68d9      	ldr	r1, [r3, #12]
 8002ad8:	2000      	movs	r0, #0
 8002ada:	f7ff fea9 	bl	8002830 <rndis_query_cmplt32>
 8002ade:	bd08      	pop	{r3, pc}
		case OID_GEN_XMIT_ERROR:             rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, usb_eth_stat.txbad); return;
 8002ae0:	4b16      	ldr	r3, [pc, #88]	; (8002b3c <rndis_query+0x270>)
 8002ae2:	6899      	ldr	r1, [r3, #8]
 8002ae4:	2000      	movs	r0, #0
 8002ae6:	f7ff fea3 	bl	8002830 <rndis_query_cmplt32>
 8002aea:	bd08      	pop	{r3, pc}
 8002aec:	20007ee8 	.word	0x20007ee8
 8002af0:	00010116 	.word	0x00010116
 8002af4:	00020102 	.word	0x00020102
 8002af8:	0001021b 	.word	0x0001021b
 8002afc:	00020101 	.word	0x00020101
 8002b00:	00010202 	.word	0x00010202
 8002b04:	0001010e 	.word	0x0001010e
 8002b08:	00010106 	.word	0x00010106
 8002b0c:	c0000001 	.word	0xc0000001
 8002b10:	00010113 	.word	0x00010113
 8002b14:	00020104 	.word	0x00020104
 8002b18:	01010105 	.word	0x01010105
 8002b1c:	080091a8 	.word	0x080091a8
 8002b20:	01020102 	.word	0x01020102
 8002b24:	08009140 	.word	0x08009140
 8002b28:	08009198 	.word	0x08009198
 8002b2c:	0001d4c0 	.word	0x0001d4c0
 8002b30:	080091a0 	.word	0x080091a0
 8002b34:	200001b4 	.word	0x200001b4
 8002b38:	c00000bb 	.word	0xc00000bb
 8002b3c:	200001d0 	.word	0x200001d0

08002b40 <rndis_handle_set_msg>:
{
 8002b40:	b510      	push	{r4, lr}
	oid = m->Oid;
 8002b42:	4b21      	ldr	r3, [pc, #132]	; (8002bc8 <rndis_handle_set_msg+0x88>)
 8002b44:	68d9      	ldr	r1, [r3, #12]
	c->MessageType = REMOTE_NDIS_SET_CMPLT;
 8002b46:	2200      	movs	r2, #0
 8002b48:	2405      	movs	r4, #5
 8002b4a:	701c      	strb	r4, [r3, #0]
 8002b4c:	705a      	strb	r2, [r3, #1]
 8002b4e:	709a      	strb	r2, [r3, #2]
 8002b50:	f06f 047f 	mvn.w	r4, #127	; 0x7f
 8002b54:	70dc      	strb	r4, [r3, #3]
	c->MessageLength = sizeof(rndis_set_cmplt_t);
 8002b56:	2410      	movs	r4, #16
 8002b58:	711c      	strb	r4, [r3, #4]
 8002b5a:	715a      	strb	r2, [r3, #5]
 8002b5c:	719a      	strb	r2, [r3, #6]
 8002b5e:	71da      	strb	r2, [r3, #7]
	c->Status = RNDIS_STATUS_SUCCESS;
 8002b60:	731a      	strb	r2, [r3, #12]
 8002b62:	735a      	strb	r2, [r3, #13]
 8002b64:	739a      	strb	r2, [r3, #14]
 8002b66:	73da      	strb	r2, [r3, #15]
	switch (oid)
 8002b68:	4b18      	ldr	r3, [pc, #96]	; (8002bcc <rndis_handle_set_msg+0x8c>)
 8002b6a:	4299      	cmp	r1, r3
 8002b6c:	d01a      	beq.n	8002ba4 <rndis_handle_set_msg+0x64>
 8002b6e:	d81f      	bhi.n	8002bb0 <rndis_handle_set_msg+0x70>
 8002b70:	3b04      	subs	r3, #4
 8002b72:	4299      	cmp	r1, r3
 8002b74:	d10a      	bne.n	8002b8c <rndis_handle_set_msg+0x4c>
			oid_packet_filter = *INFBUF;
 8002b76:	4b14      	ldr	r3, [pc, #80]	; (8002bc8 <rndis_handle_set_msg+0x88>)
 8002b78:	695a      	ldr	r2, [r3, #20]
 8002b7a:	3308      	adds	r3, #8
 8002b7c:	58d3      	ldr	r3, [r2, r3]
 8002b7e:	4a14      	ldr	r2, [pc, #80]	; (8002bd0 <rndis_handle_set_msg+0x90>)
 8002b80:	6013      	str	r3, [r2, #0]
			if (oid_packet_filter)
 8002b82:	b1e3      	cbz	r3, 8002bbe <rndis_handle_set_msg+0x7e>
				rndis_state = rndis_data_initialized;
 8002b84:	2202      	movs	r2, #2
 8002b86:	4b13      	ldr	r3, [pc, #76]	; (8002bd4 <rndis_handle_set_msg+0x94>)
 8002b88:	701a      	strb	r2, [r3, #0]
 8002b8a:	e00b      	b.n	8002ba4 <rndis_handle_set_msg+0x64>
	switch (oid)
 8002b8c:	3301      	adds	r3, #1
 8002b8e:	4299      	cmp	r1, r3
 8002b90:	d008      	beq.n	8002ba4 <rndis_handle_set_msg+0x64>
			c->Status = RNDIS_STATUS_FAILURE;
 8002b92:	4b0d      	ldr	r3, [pc, #52]	; (8002bc8 <rndis_handle_set_msg+0x88>)
 8002b94:	2200      	movs	r2, #0
 8002b96:	2101      	movs	r1, #1
 8002b98:	7319      	strb	r1, [r3, #12]
 8002b9a:	735a      	strb	r2, [r3, #13]
 8002b9c:	739a      	strb	r2, [r3, #14]
 8002b9e:	f06f 023f 	mvn.w	r2, #63	; 0x3f
 8002ba2:	73da      	strb	r2, [r3, #15]
	USBD_LL_Transmit(pdev,
 8002ba4:	2308      	movs	r3, #8
 8002ba6:	4a0c      	ldr	r2, [pc, #48]	; (8002bd8 <rndis_handle_set_msg+0x98>)
 8002ba8:	2181      	movs	r1, #129	; 0x81
 8002baa:	f001 f8e3 	bl	8003d74 <USBD_LL_Transmit>
 8002bae:	bd10      	pop	{r4, pc}
	switch (oid)
 8002bb0:	4b0a      	ldr	r3, [pc, #40]	; (8002bdc <rndis_handle_set_msg+0x9c>)
 8002bb2:	4299      	cmp	r1, r3
 8002bb4:	d0f6      	beq.n	8002ba4 <rndis_handle_set_msg+0x64>
 8002bb6:	4b0a      	ldr	r3, [pc, #40]	; (8002be0 <rndis_handle_set_msg+0xa0>)
 8002bb8:	4299      	cmp	r1, r3
 8002bba:	d1ea      	bne.n	8002b92 <rndis_handle_set_msg+0x52>
 8002bbc:	e7f2      	b.n	8002ba4 <rndis_handle_set_msg+0x64>
				rndis_state = rndis_initialized;
 8002bbe:	2201      	movs	r2, #1
 8002bc0:	4b04      	ldr	r3, [pc, #16]	; (8002bd4 <rndis_handle_set_msg+0x94>)
 8002bc2:	701a      	strb	r2, [r3, #0]
 8002bc4:	e7ee      	b.n	8002ba4 <rndis_handle_set_msg+0x64>
 8002bc6:	bf00      	nop
 8002bc8:	20007ee8 	.word	0x20007ee8
 8002bcc:	00010112 	.word	0x00010112
 8002bd0:	200001b4 	.word	0x200001b4
 8002bd4:	20007f60 	.word	0x20007f60
 8002bd8:	0800912c 	.word	0x0800912c
 8002bdc:	0001021b 	.word	0x0001021b
 8002be0:	01010103 	.word	0x01010103

08002be4 <USBD_CDC_EP0_RxReady>:
{
 8002be4:	b508      	push	{r3, lr}
  switch (((rndis_generic_msg_t *)encapsulated_buffer)->MessageType)
 8002be6:	4b4f      	ldr	r3, [pc, #316]	; (8002d24 <USBD_CDC_EP0_RxReady+0x140>)
 8002be8:	681b      	ldr	r3, [r3, #0]
 8002bea:	3b02      	subs	r3, #2
 8002bec:	2b06      	cmp	r3, #6
 8002bee:	d85a      	bhi.n	8002ca6 <USBD_CDC_EP0_RxReady+0xc2>
 8002bf0:	e8df f003 	tbb	[pc, r3]
 8002bf4:	5e5b5904 	.word	0x5e5b5904
 8002bf8:	5961      	.short	0x5961
 8002bfa:	80          	.byte	0x80
 8002bfb:	00          	.byte	0x00
  				m->MessageType = REMOTE_NDIS_INITIALIZE_CMPLT;
 8002bfc:	4b49      	ldr	r3, [pc, #292]	; (8002d24 <USBD_CDC_EP0_RxReady+0x140>)
 8002bfe:	2200      	movs	r2, #0
 8002c00:	2102      	movs	r1, #2
 8002c02:	7019      	strb	r1, [r3, #0]
 8002c04:	705a      	strb	r2, [r3, #1]
 8002c06:	709a      	strb	r2, [r3, #2]
 8002c08:	f06f 017f 	mvn.w	r1, #127	; 0x7f
 8002c0c:	70d9      	strb	r1, [r3, #3]
  				m->MessageLength = sizeof(rndis_initialize_cmplt_t);
 8002c0e:	2134      	movs	r1, #52	; 0x34
 8002c10:	7119      	strb	r1, [r3, #4]
 8002c12:	715a      	strb	r2, [r3, #5]
 8002c14:	719a      	strb	r2, [r3, #6]
 8002c16:	71da      	strb	r2, [r3, #7]
  				m->MajorVersion = RNDIS_MAJOR_VERSION;
 8002c18:	2101      	movs	r1, #1
 8002c1a:	7419      	strb	r1, [r3, #16]
 8002c1c:	745a      	strb	r2, [r3, #17]
 8002c1e:	749a      	strb	r2, [r3, #18]
 8002c20:	74da      	strb	r2, [r3, #19]
  				m->MinorVersion = RNDIS_MINOR_VERSION;
 8002c22:	751a      	strb	r2, [r3, #20]
 8002c24:	755a      	strb	r2, [r3, #21]
 8002c26:	759a      	strb	r2, [r3, #22]
 8002c28:	75da      	strb	r2, [r3, #23]
  				m->Status = RNDIS_STATUS_SUCCESS;
 8002c2a:	731a      	strb	r2, [r3, #12]
 8002c2c:	735a      	strb	r2, [r3, #13]
 8002c2e:	739a      	strb	r2, [r3, #14]
 8002c30:	73da      	strb	r2, [r3, #15]
  				m->DeviceFlags = RNDIS_DF_CONNECTIONLESS;
 8002c32:	7619      	strb	r1, [r3, #24]
 8002c34:	765a      	strb	r2, [r3, #25]
 8002c36:	769a      	strb	r2, [r3, #26]
 8002c38:	76da      	strb	r2, [r3, #27]
  				m->Medium = RNDIS_MEDIUM_802_3;
 8002c3a:	771a      	strb	r2, [r3, #28]
 8002c3c:	775a      	strb	r2, [r3, #29]
 8002c3e:	779a      	strb	r2, [r3, #30]
 8002c40:	77da      	strb	r2, [r3, #31]
  				m->MaxPacketsPerTransfer = 1;
 8002c42:	f883 1020 	strb.w	r1, [r3, #32]
 8002c46:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 8002c4a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8002c4e:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
  				m->MaxTransferSize = RNDIS_RX_BUFFER_SIZE;
 8002c52:	2116      	movs	r1, #22
 8002c54:	f883 1024 	strb.w	r1, [r3, #36]	; 0x24
 8002c58:	2106      	movs	r1, #6
 8002c5a:	f883 1025 	strb.w	r1, [r3, #37]	; 0x25
 8002c5e:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
 8002c62:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
  				m->PacketAlignmentFactor = 0;
 8002c66:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 8002c6a:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 8002c6e:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
 8002c72:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
  				m->AfListOffset = 0;
 8002c76:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
 8002c7a:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
 8002c7e:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
 8002c82:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
  				m->AfListSize = 0;
 8002c86:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
 8002c8a:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
 8002c8e:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
 8002c92:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
  				rndis_state = rndis_initialized;
 8002c96:	2201      	movs	r2, #1
 8002c98:	4b23      	ldr	r3, [pc, #140]	; (8002d28 <USBD_CDC_EP0_RxReady+0x144>)
 8002c9a:	701a      	strb	r2, [r3, #0]
  				USBD_LL_Transmit(pdev,
 8002c9c:	2308      	movs	r3, #8
 8002c9e:	4a23      	ldr	r2, [pc, #140]	; (8002d2c <USBD_CDC_EP0_RxReady+0x148>)
 8002ca0:	2181      	movs	r1, #129	; 0x81
 8002ca2:	f001 f867 	bl	8003d74 <USBD_LL_Transmit>
}
 8002ca6:	2000      	movs	r0, #0
 8002ca8:	bd08      	pop	{r3, pc}
  			rndis_query(pdev);
 8002caa:	f7ff fe0f 	bl	80028cc <rndis_query>
  			break;
 8002cae:	e7fa      	b.n	8002ca6 <USBD_CDC_EP0_RxReady+0xc2>
  			rndis_handle_set_msg(pdev);
 8002cb0:	f7ff ff46 	bl	8002b40 <rndis_handle_set_msg>
  			break;
 8002cb4:	e7f7      	b.n	8002ca6 <USBD_CDC_EP0_RxReady+0xc2>
  				rndis_state = rndis_uninitialized;
 8002cb6:	2200      	movs	r2, #0
 8002cb8:	4b1b      	ldr	r3, [pc, #108]	; (8002d28 <USBD_CDC_EP0_RxReady+0x144>)
 8002cba:	701a      	strb	r2, [r3, #0]
  				m->MessageType = REMOTE_NDIS_RESET_CMPLT;
 8002cbc:	4b19      	ldr	r3, [pc, #100]	; (8002d24 <USBD_CDC_EP0_RxReady+0x140>)
 8002cbe:	2106      	movs	r1, #6
 8002cc0:	7019      	strb	r1, [r3, #0]
 8002cc2:	705a      	strb	r2, [r3, #1]
 8002cc4:	709a      	strb	r2, [r3, #2]
 8002cc6:	f06f 017f 	mvn.w	r1, #127	; 0x7f
 8002cca:	70d9      	strb	r1, [r3, #3]
  				m->MessageLength = sizeof(rndis_reset_cmplt_t);
 8002ccc:	2110      	movs	r1, #16
 8002cce:	7119      	strb	r1, [r3, #4]
 8002cd0:	715a      	strb	r2, [r3, #5]
 8002cd2:	719a      	strb	r2, [r3, #6]
 8002cd4:	71da      	strb	r2, [r3, #7]
  				m->Status = RNDIS_STATUS_SUCCESS;
 8002cd6:	721a      	strb	r2, [r3, #8]
 8002cd8:	725a      	strb	r2, [r3, #9]
 8002cda:	729a      	strb	r2, [r3, #10]
 8002cdc:	72da      	strb	r2, [r3, #11]
  				m->AddressingReset = 1; /* Make it look like we did something */
 8002cde:	2101      	movs	r1, #1
 8002ce0:	7319      	strb	r1, [r3, #12]
 8002ce2:	735a      	strb	r2, [r3, #13]
 8002ce4:	739a      	strb	r2, [r3, #14]
 8002ce6:	73da      	strb	r2, [r3, #15]
  				USBD_LL_Transmit(pdev,
 8002ce8:	2308      	movs	r3, #8
 8002cea:	4a10      	ldr	r2, [pc, #64]	; (8002d2c <USBD_CDC_EP0_RxReady+0x148>)
 8002cec:	2181      	movs	r1, #129	; 0x81
 8002cee:	f001 f841 	bl	8003d74 <USBD_LL_Transmit>
  			break;
 8002cf2:	e7d8      	b.n	8002ca6 <USBD_CDC_EP0_RxReady+0xc2>
  				m->MessageType = REMOTE_NDIS_KEEPALIVE_CMPLT;
 8002cf4:	4b0b      	ldr	r3, [pc, #44]	; (8002d24 <USBD_CDC_EP0_RxReady+0x140>)
 8002cf6:	2200      	movs	r2, #0
 8002cf8:	2108      	movs	r1, #8
 8002cfa:	7019      	strb	r1, [r3, #0]
 8002cfc:	705a      	strb	r2, [r3, #1]
 8002cfe:	709a      	strb	r2, [r3, #2]
 8002d00:	f06f 017f 	mvn.w	r1, #127	; 0x7f
 8002d04:	70d9      	strb	r1, [r3, #3]
  				m->MessageLength = sizeof(rndis_keepalive_cmplt_t);
 8002d06:	2110      	movs	r1, #16
 8002d08:	7119      	strb	r1, [r3, #4]
 8002d0a:	715a      	strb	r2, [r3, #5]
 8002d0c:	719a      	strb	r2, [r3, #6]
 8002d0e:	71da      	strb	r2, [r3, #7]
  				m->Status = RNDIS_STATUS_SUCCESS;
 8002d10:	731a      	strb	r2, [r3, #12]
 8002d12:	735a      	strb	r2, [r3, #13]
 8002d14:	739a      	strb	r2, [r3, #14]
 8002d16:	73da      	strb	r2, [r3, #15]
  			USBD_LL_Transmit(pdev,
 8002d18:	2308      	movs	r3, #8
 8002d1a:	4a04      	ldr	r2, [pc, #16]	; (8002d2c <USBD_CDC_EP0_RxReady+0x148>)
 8002d1c:	2181      	movs	r1, #129	; 0x81
 8002d1e:	f001 f829 	bl	8003d74 <USBD_LL_Transmit>
  			break;
 8002d22:	e7c0      	b.n	8002ca6 <USBD_CDC_EP0_RxReady+0xc2>
 8002d24:	20007ee8 	.word	0x20007ee8
 8002d28:	20007f60 	.word	0x20007f60
 8002d2c:	0800912c 	.word	0x0800912c

08002d30 <rndis_can_send>:

bool rndis_can_send(void)
{
	return rndis_tx_size <= 0;
 8002d30:	4b03      	ldr	r3, [pc, #12]	; (8002d40 <rndis_can_send+0x10>)
 8002d32:	6818      	ldr	r0, [r3, #0]
}
 8002d34:	2800      	cmp	r0, #0
 8002d36:	bfcc      	ite	gt
 8002d38:	2000      	movgt	r0, #0
 8002d3a:	2001      	movle	r0, #1
 8002d3c:	4770      	bx	lr
 8002d3e:	bf00      	nop
 8002d40:	200001c8 	.word	0x200001c8

08002d44 <rndis_send>:

bool rndis_send(const void *data, int size)
{
	if (size <= 0 ||
 8002d44:	1e4a      	subs	r2, r1, #1
 8002d46:	f240 53e9 	movw	r3, #1513	; 0x5e9
 8002d4a:	429a      	cmp	r2, r3
 8002d4c:	d813      	bhi.n	8002d76 <rndis_send+0x32>
		size > ETH_MAX_PACKET_SIZE ||
		rndis_tx_size > 0) return false;
 8002d4e:	4b0b      	ldr	r3, [pc, #44]	; (8002d7c <rndis_send+0x38>)
		size > ETH_MAX_PACKET_SIZE ||
 8002d50:	681b      	ldr	r3, [r3, #0]
 8002d52:	2b00      	cmp	r3, #0
 8002d54:	dd01      	ble.n	8002d5a <rndis_send+0x16>
		rndis_tx_size > 0) return false;
 8002d56:	2000      	movs	r0, #0
	rndis_tx_size = size;
	rndis_sended = 0;
	__enable_irq();

	return true;
}
 8002d58:	4770      	bx	lr
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002d5a:	b672      	cpsid	i
	rndis_first_tx = true;
 8002d5c:	2301      	movs	r3, #1
 8002d5e:	4a08      	ldr	r2, [pc, #32]	; (8002d80 <rndis_send+0x3c>)
 8002d60:	7013      	strb	r3, [r2, #0]
	rndis_tx_ptr = (uint8_t *)data;
 8002d62:	4a08      	ldr	r2, [pc, #32]	; (8002d84 <rndis_send+0x40>)
 8002d64:	6010      	str	r0, [r2, #0]
	rndis_tx_size = size;
 8002d66:	4a05      	ldr	r2, [pc, #20]	; (8002d7c <rndis_send+0x38>)
 8002d68:	6011      	str	r1, [r2, #0]
	rndis_sended = 0;
 8002d6a:	2100      	movs	r1, #0
 8002d6c:	4a06      	ldr	r2, [pc, #24]	; (8002d88 <rndis_send+0x44>)
 8002d6e:	6011      	str	r1, [r2, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8002d70:	b662      	cpsie	i
	return true;
 8002d72:	4618      	mov	r0, r3
 8002d74:	4770      	bx	lr
		rndis_tx_size > 0) return false;
 8002d76:	2000      	movs	r0, #0
 8002d78:	4770      	bx	lr
 8002d7a:	bf00      	nop
 8002d7c:	200001c8 	.word	0x200001c8
 8002d80:	2000008b 	.word	0x2000008b
 8002d84:	200001c4 	.word	0x200001c4
 8002d88:	200001c0 	.word	0x200001c0

08002d8c <USBD_CDC_RegisterInterface>:
uint8_t  USBD_CDC_RegisterInterface  (USBD_HandleTypeDef   *pdev,
                                      USBD_CDC_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;

  if(fops != NULL)
 8002d8c:	b119      	cbz	r1, 8002d96 <USBD_CDC_RegisterInterface+0xa>
  {
    pdev->pUserData= fops;
 8002d8e:	f8c0 121c 	str.w	r1, [r0, #540]	; 0x21c
    ret = USBD_OK;
 8002d92:	2000      	movs	r0, #0
 8002d94:	4770      	bx	lr
  uint8_t  ret = USBD_FAIL;
 8002d96:	2002      	movs	r0, #2
  }

  return ret;
}
 8002d98:	4770      	bx	lr

08002d9a <USBD_Init>:
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 8002d9a:	b198      	cbz	r0, 8002dc4 <USBD_Init+0x2a>
{
 8002d9c:	b508      	push	{r3, lr}
 8002d9e:	4603      	mov	r3, r0
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 8002da0:	f8d0 0214 	ldr.w	r0, [r0, #532]	; 0x214
 8002da4:	b110      	cbz	r0, 8002dac <USBD_Init+0x12>
  {
    pdev->pClass = NULL;
 8002da6:	2000      	movs	r0, #0
 8002da8:	f8c3 0214 	str.w	r0, [r3, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 8002dac:	b109      	cbz	r1, 8002db2 <USBD_Init+0x18>
  {
    pdev->pDesc = pdesc;
 8002dae:	f8c3 1210 	str.w	r1, [r3, #528]	; 0x210
 8002db2:	4618      	mov	r0, r3
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 8002db4:	2301      	movs	r3, #1
 8002db6:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  pdev->id = id;
 8002dba:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 8002dbc:	f000 ff38 	bl	8003c30 <USBD_LL_Init>
  
  return USBD_OK; 
 8002dc0:	2000      	movs	r0, #0
 8002dc2:	bd08      	pop	{r3, pc}
    return USBD_FAIL; 
 8002dc4:	2002      	movs	r0, #2
 8002dc6:	4770      	bx	lr

08002dc8 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 8002dc8:	b119      	cbz	r1, 8002dd2 <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 8002dca:	f8c0 1214 	str.w	r1, [r0, #532]	; 0x214
    status = USBD_OK;
 8002dce:	2000      	movs	r0, #0
 8002dd0:	4770      	bx	lr
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 8002dd2:	2002      	movs	r0, #2
  }
  
  return status;
}
 8002dd4:	4770      	bx	lr

08002dd6 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 8002dd6:	b508      	push	{r3, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 8002dd8:	f000 ff64 	bl	8003ca4 <USBD_LL_Start>
  
  return USBD_OK;  
}
 8002ddc:	2000      	movs	r0, #0
 8002dde:	bd08      	pop	{r3, pc}

08002de0 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8002de0:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
 8002de2:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002de6:	b133      	cbz	r3, 8002df6 <USBD_SetClassConfig+0x16>
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 8002de8:	681b      	ldr	r3, [r3, #0]
 8002dea:	4798      	blx	r3
 8002dec:	2800      	cmp	r0, #0
    {
      ret = USBD_OK;
 8002dee:	bf14      	ite	ne
 8002df0:	2002      	movne	r0, #2
 8002df2:	2000      	moveq	r0, #0
 8002df4:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef   ret = USBD_FAIL;
 8002df6:	2002      	movs	r0, #2
    }
  }
  return ret; 
}
 8002df8:	bd08      	pop	{r3, pc}

08002dfa <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8002dfa:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 8002dfc:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002e00:	685b      	ldr	r3, [r3, #4]
 8002e02:	4798      	blx	r3
  return USBD_OK;
}
 8002e04:	2000      	movs	r0, #0
 8002e06:	bd08      	pop	{r3, pc}

08002e08 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8002e08:	b538      	push	{r3, r4, r5, lr}
 8002e0a:	4604      	mov	r4, r0

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8002e0c:	f500 7502 	add.w	r5, r0, #520	; 0x208
 8002e10:	4628      	mov	r0, r5
 8002e12:	f000 f904 	bl	800301e <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 8002e16:	2301      	movs	r3, #1
 8002e18:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 8002e1c:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
 8002e20:	f8c4 31f8 	str.w	r3, [r4, #504]	; 0x1f8
  
  switch (pdev->request.bmRequest & 0x1F) 
 8002e24:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
 8002e28:	f001 031f 	and.w	r3, r1, #31
 8002e2c:	2b01      	cmp	r3, #1
 8002e2e:	d00e      	beq.n	8002e4e <USBD_LL_SetupStage+0x46>
 8002e30:	b13b      	cbz	r3, 8002e42 <USBD_LL_SetupStage+0x3a>
 8002e32:	2b02      	cmp	r3, #2
 8002e34:	d010      	beq.n	8002e58 <USBD_LL_SetupStage+0x50>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 8002e36:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8002e3a:	4620      	mov	r0, r4
 8002e3c:	f000 ff5c 	bl	8003cf8 <USBD_LL_StallEP>
    break;
 8002e40:	e003      	b.n	8002e4a <USBD_LL_SetupStage+0x42>
    USBD_StdDevReq (pdev, &pdev->request);
 8002e42:	4629      	mov	r1, r5
 8002e44:	4620      	mov	r0, r4
 8002e46:	f000 f909 	bl	800305c <USBD_StdDevReq>
  }  
  return USBD_OK;  
}
 8002e4a:	2000      	movs	r0, #0
 8002e4c:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdItfReq(pdev, &pdev->request);
 8002e4e:	4629      	mov	r1, r5
 8002e50:	4620      	mov	r0, r4
 8002e52:	f000 fa7b 	bl	800334c <USBD_StdItfReq>
    break;
 8002e56:	e7f8      	b.n	8002e4a <USBD_LL_SetupStage+0x42>
    USBD_StdEPReq(pdev, &pdev->request);   
 8002e58:	4629      	mov	r1, r5
 8002e5a:	4620      	mov	r0, r4
 8002e5c:	f000 fa92 	bl	8003384 <USBD_StdEPReq>
    break;
 8002e60:	e7f3      	b.n	8002e4a <USBD_LL_SetupStage+0x42>

08002e62 <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 8002e62:	b510      	push	{r4, lr}
 8002e64:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 8002e66:	bb19      	cbnz	r1, 8002eb0 <USBD_LL_DataOutStage+0x4e>
 8002e68:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 8002e6a:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 8002e6e:	2a03      	cmp	r2, #3
 8002e70:	d127      	bne.n	8002ec2 <USBD_LL_DataOutStage+0x60>
    {
      if(pep->rem_length > pep->maxpacket)
 8002e72:	f8d0 110c 	ldr.w	r1, [r0, #268]	; 0x10c
 8002e76:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
 8002e7a:	4291      	cmp	r1, r2
 8002e7c:	d80b      	bhi.n	8002e96 <USBD_LL_DataOutStage+0x34>
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
      }
      else
      {
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8002e7e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002e82:	691b      	ldr	r3, [r3, #16]
 8002e84:	b11b      	cbz	r3, 8002e8e <USBD_LL_DataOutStage+0x2c>
 8002e86:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8002e8a:	2a03      	cmp	r2, #3
 8002e8c:	d00e      	beq.n	8002eac <USBD_LL_DataOutStage+0x4a>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
        {
          pdev->pClass->EP0_RxReady(pdev); 
        }
        USBD_CtlSendStatus(pdev);
 8002e8e:	4620      	mov	r0, r4
 8002e90:	f000 fb49 	bl	8003526 <USBD_CtlSendStatus>
 8002e94:	e015      	b.n	8002ec2 <USBD_LL_DataOutStage+0x60>
        pep->rem_length -=  pep->maxpacket;
 8002e96:	1a89      	subs	r1, r1, r2
 8002e98:	f8c0 110c 	str.w	r1, [r0, #268]	; 0x10c
                            MIN(pep->rem_length ,pep->maxpacket));
 8002e9c:	428a      	cmp	r2, r1
 8002e9e:	bf28      	it	cs
 8002ea0:	460a      	movcs	r2, r1
        USBD_CtlContinueRx (pdev, 
 8002ea2:	b292      	uxth	r2, r2
 8002ea4:	4619      	mov	r1, r3
 8002ea6:	f000 fb36 	bl	8003516 <USBD_CtlContinueRx>
 8002eaa:	e00a      	b.n	8002ec2 <USBD_LL_DataOutStage+0x60>
          pdev->pClass->EP0_RxReady(pdev); 
 8002eac:	4798      	blx	r3
 8002eae:	e7ee      	b.n	8002e8e <USBD_LL_DataOutStage+0x2c>
 8002eb0:	460a      	mov	r2, r1
      }
    }
  }
  else if((pdev->pClass->DataOut != NULL)&&
 8002eb2:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002eb6:	699b      	ldr	r3, [r3, #24]
 8002eb8:	b11b      	cbz	r3, 8002ec2 <USBD_LL_DataOutStage+0x60>
 8002eba:	f890 11fc 	ldrb.w	r1, [r0, #508]	; 0x1fc
 8002ebe:	2903      	cmp	r1, #3
 8002ec0:	d001      	beq.n	8002ec6 <USBD_LL_DataOutStage+0x64>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 8002ec2:	2000      	movs	r0, #0
 8002ec4:	bd10      	pop	{r4, pc}
    pdev->pClass->DataOut(pdev, epnum); 
 8002ec6:	4611      	mov	r1, r2
 8002ec8:	4798      	blx	r3
 8002eca:	e7fa      	b.n	8002ec2 <USBD_LL_DataOutStage+0x60>

08002ecc <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 8002ecc:	b510      	push	{r4, lr}
 8002ece:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 8002ed0:	2900      	cmp	r1, #0
 8002ed2:	d147      	bne.n	8002f64 <USBD_LL_DataInStage+0x98>
 8002ed4:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 8002ed6:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 8002eda:	2a02      	cmp	r2, #2
 8002edc:	d005      	beq.n	8002eea <USBD_LL_DataInStage+0x1e>
          }          
          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 8002ede:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8002ee2:	2b01      	cmp	r3, #1
 8002ee4:	d03a      	beq.n	8002f5c <USBD_LL_DataInStage+0x90>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 8002ee6:	2000      	movs	r0, #0
 8002ee8:	bd10      	pop	{r4, pc}
      if(pep->rem_length > pep->maxpacket)
 8002eea:	69c1      	ldr	r1, [r0, #28]
 8002eec:	6a02      	ldr	r2, [r0, #32]
 8002eee:	4291      	cmp	r1, r2
 8002ef0:	d817      	bhi.n	8002f22 <USBD_LL_DataInStage+0x56>
        if((pep->total_length % pep->maxpacket == 0) &&
 8002ef2:	6981      	ldr	r1, [r0, #24]
 8002ef4:	fbb1 f3f2 	udiv	r3, r1, r2
 8002ef8:	fb02 1313 	mls	r3, r2, r3, r1
 8002efc:	b92b      	cbnz	r3, 8002f0a <USBD_LL_DataInStage+0x3e>
 8002efe:	428a      	cmp	r2, r1
 8002f00:	d803      	bhi.n	8002f0a <USBD_LL_DataInStage+0x3e>
           (pep->total_length >= pep->maxpacket) &&
 8002f02:	f8d0 31f8 	ldr.w	r3, [r0, #504]	; 0x1f8
 8002f06:	4299      	cmp	r1, r3
 8002f08:	d318      	bcc.n	8002f3c <USBD_LL_DataInStage+0x70>
          if((pdev->pClass->EP0_TxSent != NULL)&&
 8002f0a:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8002f0e:	68db      	ldr	r3, [r3, #12]
 8002f10:	b11b      	cbz	r3, 8002f1a <USBD_LL_DataInStage+0x4e>
 8002f12:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 8002f16:	2a03      	cmp	r2, #3
 8002f18:	d01d      	beq.n	8002f56 <USBD_LL_DataInStage+0x8a>
          USBD_CtlReceiveStatus(pdev);
 8002f1a:	4620      	mov	r0, r4
 8002f1c:	f000 fb0e 	bl	800353c <USBD_CtlReceiveStatus>
 8002f20:	e7dd      	b.n	8002ede <USBD_LL_DataInStage+0x12>
        pep->rem_length -=  pep->maxpacket;
 8002f22:	1a8a      	subs	r2, r1, r2
 8002f24:	61c2      	str	r2, [r0, #28]
        USBD_CtlContinueSendData (pdev, 
 8002f26:	b292      	uxth	r2, r2
 8002f28:	4619      	mov	r1, r3
 8002f2a:	f000 fadd 	bl	80034e8 <USBD_CtlContinueSendData>
        USBD_LL_PrepareReceive (pdev,
 8002f2e:	2300      	movs	r3, #0
 8002f30:	461a      	mov	r2, r3
 8002f32:	4619      	mov	r1, r3
 8002f34:	4620      	mov	r0, r4
 8002f36:	f000 ff2a 	bl	8003d8e <USBD_LL_PrepareReceive>
 8002f3a:	e7d0      	b.n	8002ede <USBD_LL_DataInStage+0x12>
          USBD_CtlContinueSendData(pdev , NULL, 0);
 8002f3c:	2200      	movs	r2, #0
 8002f3e:	4611      	mov	r1, r2
 8002f40:	f000 fad2 	bl	80034e8 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 8002f44:	2100      	movs	r1, #0
 8002f46:	f8c4 11f8 	str.w	r1, [r4, #504]	; 0x1f8
        USBD_LL_PrepareReceive (pdev,
 8002f4a:	460b      	mov	r3, r1
 8002f4c:	460a      	mov	r2, r1
 8002f4e:	4620      	mov	r0, r4
 8002f50:	f000 ff1d 	bl	8003d8e <USBD_LL_PrepareReceive>
 8002f54:	e7c3      	b.n	8002ede <USBD_LL_DataInStage+0x12>
            pdev->pClass->EP0_TxSent(pdev); 
 8002f56:	4620      	mov	r0, r4
 8002f58:	4798      	blx	r3
 8002f5a:	e7de      	b.n	8002f1a <USBD_LL_DataInStage+0x4e>
      pdev->dev_test_mode = 0;
 8002f5c:	2300      	movs	r3, #0
 8002f5e:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
 8002f62:	e7c0      	b.n	8002ee6 <USBD_LL_DataInStage+0x1a>
 8002f64:	460a      	mov	r2, r1
  else if((pdev->pClass->DataIn != NULL)&& 
 8002f66:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002f6a:	695b      	ldr	r3, [r3, #20]
 8002f6c:	2b00      	cmp	r3, #0
 8002f6e:	d0ba      	beq.n	8002ee6 <USBD_LL_DataInStage+0x1a>
 8002f70:	f890 11fc 	ldrb.w	r1, [r0, #508]	; 0x1fc
 8002f74:	2903      	cmp	r1, #3
 8002f76:	d1b6      	bne.n	8002ee6 <USBD_LL_DataInStage+0x1a>
    pdev->pClass->DataIn(pdev, epnum); 
 8002f78:	4611      	mov	r1, r2
 8002f7a:	4798      	blx	r3
 8002f7c:	e7b3      	b.n	8002ee6 <USBD_LL_DataInStage+0x1a>

08002f7e <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8002f7e:	b538      	push	{r3, r4, r5, lr}
 8002f80:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 8002f82:	2340      	movs	r3, #64	; 0x40
 8002f84:	2200      	movs	r2, #0
 8002f86:	4611      	mov	r1, r2
 8002f88:	f000 fe99 	bl	8003cbe <USBD_LL_OpenEP>
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8002f8c:	2540      	movs	r5, #64	; 0x40
 8002f8e:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 8002f92:	462b      	mov	r3, r5
 8002f94:	2200      	movs	r2, #0
 8002f96:	2180      	movs	r1, #128	; 0x80
 8002f98:	4620      	mov	r0, r4
 8002f9a:	f000 fe90 	bl	8003cbe <USBD_LL_OpenEP>
              0x80,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8002f9e:	6225      	str	r5, [r4, #32]
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8002fa0:	2301      	movs	r3, #1
 8002fa2:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 8002fa6:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 8002faa:	b12b      	cbz	r3, 8002fb8 <USBD_LL_Reset+0x3a>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8002fac:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8002fb0:	685b      	ldr	r3, [r3, #4]
 8002fb2:	7921      	ldrb	r1, [r4, #4]
 8002fb4:	4620      	mov	r0, r4
 8002fb6:	4798      	blx	r3
 
  
  return USBD_OK;
}
 8002fb8:	2000      	movs	r0, #0
 8002fba:	bd38      	pop	{r3, r4, r5, pc}

08002fbc <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 8002fbc:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 8002fbe:	2000      	movs	r0, #0
 8002fc0:	4770      	bx	lr

08002fc2 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8002fc2:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002fc6:	f880 31fd 	strb.w	r3, [r0, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8002fca:	2304      	movs	r3, #4
 8002fcc:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8002fd0:	2000      	movs	r0, #0
 8002fd2:	4770      	bx	lr

08002fd4 <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;  
 8002fd4:	f890 31fd 	ldrb.w	r3, [r0, #509]	; 0x1fd
 8002fd8:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8002fdc:	2000      	movs	r0, #0
 8002fde:	4770      	bx	lr

08002fe0 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 8002fe0:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8002fe2:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002fe6:	2b03      	cmp	r3, #3
 8002fe8:	d001      	beq.n	8002fee <USBD_LL_SOF+0xe>
    {
      pdev->pClass->SOF(pdev);
    }
  }
  return USBD_OK;
}
 8002fea:	2000      	movs	r0, #0
 8002fec:	bd08      	pop	{r3, pc}
    if(pdev->pClass->SOF != NULL)
 8002fee:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002ff2:	69db      	ldr	r3, [r3, #28]
 8002ff4:	2b00      	cmp	r3, #0
 8002ff6:	d0f8      	beq.n	8002fea <USBD_LL_SOF+0xa>
      pdev->pClass->SOF(pdev);
 8002ff8:	4798      	blx	r3
 8002ffa:	e7f6      	b.n	8002fea <USBD_LL_SOF+0xa>

08002ffc <USBD_LL_IsoINIncomplete>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 8002ffc:	2000      	movs	r0, #0
 8002ffe:	4770      	bx	lr

08003000 <USBD_LL_IsoOUTIncomplete>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 8003000:	2000      	movs	r0, #0
 8003002:	4770      	bx	lr

08003004 <USBD_LL_DevConnected>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev)
{
  return USBD_OK;
}
 8003004:	2000      	movs	r0, #0
 8003006:	4770      	bx	lr

08003008 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
 8003008:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800300a:	2201      	movs	r2, #1
 800300c:	f880 21fc 	strb.w	r2, [r0, #508]	; 0x1fc
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8003010:	f8d0 2214 	ldr.w	r2, [r0, #532]	; 0x214
 8003014:	6852      	ldr	r2, [r2, #4]
 8003016:	7901      	ldrb	r1, [r0, #4]
 8003018:	4790      	blx	r2
   
  return USBD_OK;
}
 800301a:	2000      	movs	r0, #0
 800301c:	bd08      	pop	{r3, pc}

0800301e <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
 800301e:	780b      	ldrb	r3, [r1, #0]
 8003020:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 8003022:	784b      	ldrb	r3, [r1, #1]
 8003024:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8003026:	78ca      	ldrb	r2, [r1, #3]
 8003028:	788b      	ldrb	r3, [r1, #2]
 800302a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 800302e:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8003030:	794a      	ldrb	r2, [r1, #5]
 8003032:	790b      	ldrb	r3, [r1, #4]
 8003034:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8003038:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 800303a:	79ca      	ldrb	r2, [r1, #7]
 800303c:	798b      	ldrb	r3, [r1, #6]
 800303e:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8003042:	80c3      	strh	r3, [r0, #6]
 8003044:	4770      	bx	lr

08003046 <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 8003046:	b510      	push	{r4, lr}
 8003048:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
 800304a:	2180      	movs	r1, #128	; 0x80
 800304c:	f000 fe54 	bl	8003cf8 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 8003050:	2100      	movs	r1, #0
 8003052:	4620      	mov	r0, r4
 8003054:	f000 fe50 	bl	8003cf8 <USBD_LL_StallEP>
 8003058:	bd10      	pop	{r4, pc}
	...

0800305c <USBD_StdDevReq>:
{
 800305c:	b570      	push	{r4, r5, r6, lr}
 800305e:	b082      	sub	sp, #8
 8003060:	4605      	mov	r5, r0
 8003062:	460c      	mov	r4, r1
  switch (req->bRequest) 
 8003064:	784b      	ldrb	r3, [r1, #1]
 8003066:	2b09      	cmp	r3, #9
 8003068:	f200 8168 	bhi.w	800333c <USBD_StdDevReq+0x2e0>
 800306c:	e8df f013 	tbh	[pc, r3, lsl #1]
 8003070:	0150012d 	.word	0x0150012d
 8003074:	01430166 	.word	0x01430166
 8003078:	00a00166 	.word	0x00a00166
 800307c:	0166000a 	.word	0x0166000a
 8003080:	00c40111 	.word	0x00c40111
  switch (req->wValue >> 8)
 8003084:	884a      	ldrh	r2, [r1, #2]
 8003086:	0a13      	lsrs	r3, r2, #8
 8003088:	3b01      	subs	r3, #1
 800308a:	2b06      	cmp	r3, #6
 800308c:	f200 808c 	bhi.w	80031a8 <USBD_StdDevReq+0x14c>
 8003090:	e8df f003 	tbb	[pc, r3]
 8003094:	8a321e04 	.word	0x8a321e04
 8003098:	6e8a      	.short	0x6e8a
 800309a:	7b          	.byte	0x7b
 800309b:	00          	.byte	0x00
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 800309c:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 80030a0:	681b      	ldr	r3, [r3, #0]
 80030a2:	f10d 0106 	add.w	r1, sp, #6
 80030a6:	7c00      	ldrb	r0, [r0, #16]
 80030a8:	4798      	blx	r3
  if((len != 0)&& (req->wLength != 0))
 80030aa:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 80030ae:	2a00      	cmp	r2, #0
 80030b0:	f000 8146 	beq.w	8003340 <USBD_StdDevReq+0x2e4>
 80030b4:	88e3      	ldrh	r3, [r4, #6]
 80030b6:	2b00      	cmp	r3, #0
 80030b8:	f000 8142 	beq.w	8003340 <USBD_StdDevReq+0x2e4>
    len = MIN(len , req->wLength);
 80030bc:	429a      	cmp	r2, r3
 80030be:	bf28      	it	cs
 80030c0:	461a      	movcs	r2, r3
 80030c2:	f8ad 2006 	strh.w	r2, [sp, #6]
    USBD_CtlSendData (pdev, 
 80030c6:	4601      	mov	r1, r0
 80030c8:	4628      	mov	r0, r5
 80030ca:	f000 fa00 	bl	80034ce <USBD_CtlSendData>
 80030ce:	e137      	b.n	8003340 <USBD_StdDevReq+0x2e4>
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 80030d0:	7c03      	ldrb	r3, [r0, #16]
 80030d2:	b943      	cbnz	r3, 80030e6 <USBD_StdDevReq+0x8a>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 80030d4:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80030d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80030da:	f10d 0006 	add.w	r0, sp, #6
 80030de:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 80030e0:	2302      	movs	r3, #2
 80030e2:	7043      	strb	r3, [r0, #1]
 80030e4:	e7e1      	b.n	80030aa <USBD_StdDevReq+0x4e>
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 80030e6:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80030ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80030ec:	f10d 0006 	add.w	r0, sp, #6
 80030f0:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 80030f2:	2302      	movs	r3, #2
 80030f4:	7043      	strb	r3, [r0, #1]
 80030f6:	e7d8      	b.n	80030aa <USBD_StdDevReq+0x4e>
    switch ((uint8_t)(req->wValue))
 80030f8:	b2d2      	uxtb	r2, r2
 80030fa:	2a05      	cmp	r2, #5
 80030fc:	d834      	bhi.n	8003168 <USBD_StdDevReq+0x10c>
 80030fe:	e8df f002 	tbb	[pc, r2]
 8003102:	0b03      	.short	0x0b03
 8003104:	2b231b13 	.word	0x2b231b13
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 8003108:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800310c:	685b      	ldr	r3, [r3, #4]
 800310e:	f10d 0106 	add.w	r1, sp, #6
 8003112:	7c00      	ldrb	r0, [r0, #16]
 8003114:	4798      	blx	r3
 8003116:	e7c8      	b.n	80030aa <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8003118:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800311c:	689b      	ldr	r3, [r3, #8]
 800311e:	f10d 0106 	add.w	r1, sp, #6
 8003122:	7c00      	ldrb	r0, [r0, #16]
 8003124:	4798      	blx	r3
 8003126:	e7c0      	b.n	80030aa <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8003128:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800312c:	68db      	ldr	r3, [r3, #12]
 800312e:	f10d 0106 	add.w	r1, sp, #6
 8003132:	7c00      	ldrb	r0, [r0, #16]
 8003134:	4798      	blx	r3
 8003136:	e7b8      	b.n	80030aa <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8003138:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800313c:	691b      	ldr	r3, [r3, #16]
 800313e:	f10d 0106 	add.w	r1, sp, #6
 8003142:	7c00      	ldrb	r0, [r0, #16]
 8003144:	4798      	blx	r3
 8003146:	e7b0      	b.n	80030aa <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8003148:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800314c:	695b      	ldr	r3, [r3, #20]
 800314e:	f10d 0106 	add.w	r1, sp, #6
 8003152:	7c00      	ldrb	r0, [r0, #16]
 8003154:	4798      	blx	r3
 8003156:	e7a8      	b.n	80030aa <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8003158:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800315c:	699b      	ldr	r3, [r3, #24]
 800315e:	f10d 0106 	add.w	r1, sp, #6
 8003162:	7c00      	ldrb	r0, [r0, #16]
 8003164:	4798      	blx	r3
 8003166:	e7a0      	b.n	80030aa <USBD_StdDevReq+0x4e>
       USBD_CtlError(pdev , req);
 8003168:	4621      	mov	r1, r4
 800316a:	f7ff ff6c 	bl	8003046 <USBD_CtlError>
 800316e:	e0e7      	b.n	8003340 <USBD_StdDevReq+0x2e4>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8003170:	7c03      	ldrb	r3, [r0, #16]
 8003172:	b933      	cbnz	r3, 8003182 <USBD_StdDevReq+0x126>
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8003174:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003178:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800317a:	f10d 0006 	add.w	r0, sp, #6
 800317e:	4798      	blx	r3
 8003180:	e793      	b.n	80030aa <USBD_StdDevReq+0x4e>
      USBD_CtlError(pdev , req);
 8003182:	4621      	mov	r1, r4
 8003184:	f7ff ff5f 	bl	8003046 <USBD_CtlError>
 8003188:	e0da      	b.n	8003340 <USBD_StdDevReq+0x2e4>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 800318a:	7c03      	ldrb	r3, [r0, #16]
 800318c:	b943      	cbnz	r3, 80031a0 <USBD_StdDevReq+0x144>
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 800318e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003192:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003194:	f10d 0006 	add.w	r0, sp, #6
 8003198:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 800319a:	2307      	movs	r3, #7
 800319c:	7043      	strb	r3, [r0, #1]
 800319e:	e784      	b.n	80030aa <USBD_StdDevReq+0x4e>
      USBD_CtlError(pdev , req);
 80031a0:	4621      	mov	r1, r4
 80031a2:	f7ff ff50 	bl	8003046 <USBD_CtlError>
 80031a6:	e0cb      	b.n	8003340 <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);
 80031a8:	4621      	mov	r1, r4
 80031aa:	f7ff ff4c 	bl	8003046 <USBD_CtlError>
 80031ae:	e0c7      	b.n	8003340 <USBD_StdDevReq+0x2e4>
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 80031b0:	888b      	ldrh	r3, [r1, #4]
 80031b2:	b9e3      	cbnz	r3, 80031ee <USBD_StdDevReq+0x192>
 80031b4:	88cb      	ldrh	r3, [r1, #6]
 80031b6:	b9d3      	cbnz	r3, 80031ee <USBD_StdDevReq+0x192>
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 80031b8:	788e      	ldrb	r6, [r1, #2]
 80031ba:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 80031be:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80031c2:	2b03      	cmp	r3, #3
 80031c4:	d00c      	beq.n	80031e0 <USBD_StdDevReq+0x184>
      pdev->dev_address = dev_addr;
 80031c6:	f880 61fe 	strb.w	r6, [r0, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 80031ca:	4631      	mov	r1, r6
 80031cc:	f000 fdc5 	bl	8003d5a <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 80031d0:	4628      	mov	r0, r5
 80031d2:	f000 f9a8 	bl	8003526 <USBD_CtlSendStatus>
      if (dev_addr != 0) 
 80031d6:	b136      	cbz	r6, 80031e6 <USBD_StdDevReq+0x18a>
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 80031d8:	2302      	movs	r3, #2
 80031da:	f885 31fc 	strb.w	r3, [r5, #508]	; 0x1fc
 80031de:	e0af      	b.n	8003340 <USBD_StdDevReq+0x2e4>
      USBD_CtlError(pdev , req);
 80031e0:	f7ff ff31 	bl	8003046 <USBD_CtlError>
 80031e4:	e0ac      	b.n	8003340 <USBD_StdDevReq+0x2e4>
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 80031e6:	2301      	movs	r3, #1
 80031e8:	f885 31fc 	strb.w	r3, [r5, #508]	; 0x1fc
 80031ec:	e0a8      	b.n	8003340 <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);                        
 80031ee:	4621      	mov	r1, r4
 80031f0:	4628      	mov	r0, r5
 80031f2:	f7ff ff28 	bl	8003046 <USBD_CtlError>
 80031f6:	e0a3      	b.n	8003340 <USBD_StdDevReq+0x2e4>
  cfgidx = (uint8_t)(req->wValue);                 
 80031f8:	7889      	ldrb	r1, [r1, #2]
 80031fa:	4b53      	ldr	r3, [pc, #332]	; (8003348 <USBD_StdDevReq+0x2ec>)
 80031fc:	7019      	strb	r1, [r3, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 80031fe:	2901      	cmp	r1, #1
 8003200:	d809      	bhi.n	8003216 <USBD_StdDevReq+0x1ba>
    switch (pdev->dev_state) 
 8003202:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003206:	2b02      	cmp	r3, #2
 8003208:	d009      	beq.n	800321e <USBD_StdDevReq+0x1c2>
 800320a:	2b03      	cmp	r3, #3
 800320c:	d01c      	beq.n	8003248 <USBD_StdDevReq+0x1ec>
       USBD_CtlError(pdev , req);                     
 800320e:	4621      	mov	r1, r4
 8003210:	f7ff ff19 	bl	8003046 <USBD_CtlError>
 8003214:	e094      	b.n	8003340 <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);                              
 8003216:	4621      	mov	r1, r4
 8003218:	f7ff ff15 	bl	8003046 <USBD_CtlError>
 800321c:	e090      	b.n	8003340 <USBD_StdDevReq+0x2e4>
      if (cfgidx) 
 800321e:	b181      	cbz	r1, 8003242 <USBD_StdDevReq+0x1e6>
        pdev->dev_config = cfgidx;
 8003220:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8003222:	2303      	movs	r3, #3
 8003224:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8003228:	f7ff fdda 	bl	8002de0 <USBD_SetClassConfig>
 800322c:	2802      	cmp	r0, #2
 800322e:	d003      	beq.n	8003238 <USBD_StdDevReq+0x1dc>
        USBD_CtlSendStatus(pdev);
 8003230:	4628      	mov	r0, r5
 8003232:	f000 f978 	bl	8003526 <USBD_CtlSendStatus>
 8003236:	e083      	b.n	8003340 <USBD_StdDevReq+0x2e4>
          USBD_CtlError(pdev , req);  
 8003238:	4621      	mov	r1, r4
 800323a:	4628      	mov	r0, r5
 800323c:	f7ff ff03 	bl	8003046 <USBD_CtlError>
 8003240:	e07e      	b.n	8003340 <USBD_StdDevReq+0x2e4>
         USBD_CtlSendStatus(pdev);
 8003242:	f000 f970 	bl	8003526 <USBD_CtlSendStatus>
 8003246:	e07b      	b.n	8003340 <USBD_StdDevReq+0x2e4>
      if (cfgidx == 0) 
 8003248:	b189      	cbz	r1, 800326e <USBD_StdDevReq+0x212>
      else  if (cfgidx != pdev->dev_config) 
 800324a:	6843      	ldr	r3, [r0, #4]
 800324c:	4299      	cmp	r1, r3
 800324e:	d01d      	beq.n	800328c <USBD_StdDevReq+0x230>
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 8003250:	b2d9      	uxtb	r1, r3
 8003252:	f7ff fdd2 	bl	8002dfa <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 8003256:	4b3c      	ldr	r3, [pc, #240]	; (8003348 <USBD_StdDevReq+0x2ec>)
 8003258:	7819      	ldrb	r1, [r3, #0]
 800325a:	6069      	str	r1, [r5, #4]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 800325c:	4628      	mov	r0, r5
 800325e:	f7ff fdbf 	bl	8002de0 <USBD_SetClassConfig>
 8003262:	2802      	cmp	r0, #2
 8003264:	d00d      	beq.n	8003282 <USBD_StdDevReq+0x226>
        USBD_CtlSendStatus(pdev);
 8003266:	4628      	mov	r0, r5
 8003268:	f000 f95d 	bl	8003526 <USBD_CtlSendStatus>
 800326c:	e068      	b.n	8003340 <USBD_StdDevReq+0x2e4>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800326e:	2302      	movs	r3, #2
 8003270:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
 8003274:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
 8003276:	f7ff fdc0 	bl	8002dfa <USBD_ClrClassConfig>
        USBD_CtlSendStatus(pdev);
 800327a:	4628      	mov	r0, r5
 800327c:	f000 f953 	bl	8003526 <USBD_CtlSendStatus>
 8003280:	e05e      	b.n	8003340 <USBD_StdDevReq+0x2e4>
          USBD_CtlError(pdev , req);  
 8003282:	4621      	mov	r1, r4
 8003284:	4628      	mov	r0, r5
 8003286:	f7ff fede 	bl	8003046 <USBD_CtlError>
 800328a:	e059      	b.n	8003340 <USBD_StdDevReq+0x2e4>
        USBD_CtlSendStatus(pdev);
 800328c:	f000 f94b 	bl	8003526 <USBD_CtlSendStatus>
 8003290:	e056      	b.n	8003340 <USBD_StdDevReq+0x2e4>
  if (req->wLength != 1) 
 8003292:	88cb      	ldrh	r3, [r1, #6]
 8003294:	2b01      	cmp	r3, #1
 8003296:	d108      	bne.n	80032aa <USBD_StdDevReq+0x24e>
    switch (pdev->dev_state )  
 8003298:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800329c:	2b02      	cmp	r3, #2
 800329e:	d007      	beq.n	80032b0 <USBD_StdDevReq+0x254>
 80032a0:	2b03      	cmp	r3, #3
 80032a2:	d00d      	beq.n	80032c0 <USBD_StdDevReq+0x264>
       USBD_CtlError(pdev , req);
 80032a4:	f7ff fecf 	bl	8003046 <USBD_CtlError>
 80032a8:	e04a      	b.n	8003340 <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);
 80032aa:	f7ff fecc 	bl	8003046 <USBD_CtlError>
 80032ae:	e047      	b.n	8003340 <USBD_StdDevReq+0x2e4>
      pdev->dev_default_config = 0;
 80032b0:	4601      	mov	r1, r0
 80032b2:	2300      	movs	r3, #0
 80032b4:	f841 3f08 	str.w	r3, [r1, #8]!
      USBD_CtlSendData (pdev, 
 80032b8:	2201      	movs	r2, #1
 80032ba:	f000 f908 	bl	80034ce <USBD_CtlSendData>
 80032be:	e03f      	b.n	8003340 <USBD_StdDevReq+0x2e4>
      USBD_CtlSendData (pdev, 
 80032c0:	2201      	movs	r2, #1
 80032c2:	1d01      	adds	r1, r0, #4
 80032c4:	f000 f903 	bl	80034ce <USBD_CtlSendData>
 80032c8:	e03a      	b.n	8003340 <USBD_StdDevReq+0x2e4>
  switch (pdev->dev_state) 
 80032ca:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80032ce:	3b02      	subs	r3, #2
 80032d0:	2b01      	cmp	r3, #1
 80032d2:	d80d      	bhi.n	80032f0 <USBD_StdDevReq+0x294>
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 80032d4:	2301      	movs	r3, #1
 80032d6:	60c3      	str	r3, [r0, #12]
    if (pdev->dev_remote_wakeup) 
 80032d8:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
 80032dc:	b10b      	cbz	r3, 80032e2 <USBD_StdDevReq+0x286>
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 80032de:	2303      	movs	r3, #3
 80032e0:	60c3      	str	r3, [r0, #12]
    USBD_CtlSendData (pdev, 
 80032e2:	2202      	movs	r2, #2
 80032e4:	f105 010c 	add.w	r1, r5, #12
 80032e8:	4628      	mov	r0, r5
 80032ea:	f000 f8f0 	bl	80034ce <USBD_CtlSendData>
 80032ee:	e027      	b.n	8003340 <USBD_StdDevReq+0x2e4>
    USBD_CtlError(pdev , req);                        
 80032f0:	f7ff fea9 	bl	8003046 <USBD_CtlError>
 80032f4:	e024      	b.n	8003340 <USBD_StdDevReq+0x2e4>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80032f6:	884b      	ldrh	r3, [r1, #2]
 80032f8:	2b01      	cmp	r3, #1
 80032fa:	d121      	bne.n	8003340 <USBD_StdDevReq+0x2e4>
    pdev->dev_remote_wakeup = 1;  
 80032fc:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
    pdev->pClass->Setup (pdev, req);   
 8003300:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003304:	689b      	ldr	r3, [r3, #8]
 8003306:	4798      	blx	r3
    USBD_CtlSendStatus(pdev);
 8003308:	4628      	mov	r0, r5
 800330a:	f000 f90c 	bl	8003526 <USBD_CtlSendStatus>
 800330e:	e017      	b.n	8003340 <USBD_StdDevReq+0x2e4>
  switch (pdev->dev_state)
 8003310:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003314:	3b02      	subs	r3, #2
 8003316:	2b01      	cmp	r3, #1
 8003318:	d80d      	bhi.n	8003336 <USBD_StdDevReq+0x2da>
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 800331a:	884b      	ldrh	r3, [r1, #2]
 800331c:	2b01      	cmp	r3, #1
 800331e:	d10f      	bne.n	8003340 <USBD_StdDevReq+0x2e4>
      pdev->dev_remote_wakeup = 0; 
 8003320:	2300      	movs	r3, #0
 8003322:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 8003326:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800332a:	689b      	ldr	r3, [r3, #8]
 800332c:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 800332e:	4628      	mov	r0, r5
 8003330:	f000 f8f9 	bl	8003526 <USBD_CtlSendStatus>
 8003334:	e004      	b.n	8003340 <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);
 8003336:	f7ff fe86 	bl	8003046 <USBD_CtlError>
 800333a:	e001      	b.n	8003340 <USBD_StdDevReq+0x2e4>
    USBD_CtlError(pdev , req);
 800333c:	f7ff fe83 	bl	8003046 <USBD_CtlError>
}
 8003340:	2000      	movs	r0, #0
 8003342:	b002      	add	sp, #8
 8003344:	bd70      	pop	{r4, r5, r6, pc}
 8003346:	bf00      	nop
 8003348:	200001e0 	.word	0x200001e0

0800334c <USBD_StdItfReq>:
{
 800334c:	b538      	push	{r3, r4, r5, lr}
 800334e:	4604      	mov	r4, r0
 8003350:	460d      	mov	r5, r1
  switch (pdev->dev_state) 
 8003352:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003356:	2b03      	cmp	r3, #3
 8003358:	d111      	bne.n	800337e <USBD_StdItfReq+0x32>
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 800335a:	790b      	ldrb	r3, [r1, #4]
 800335c:	2b01      	cmp	r3, #1
 800335e:	d903      	bls.n	8003368 <USBD_StdItfReq+0x1c>
       USBD_CtlError(pdev , req);
 8003360:	f7ff fe71 	bl	8003046 <USBD_CtlError>
}
 8003364:	2000      	movs	r0, #0
 8003366:	bd38      	pop	{r3, r4, r5, pc}
      pdev->pClass->Setup (pdev, req); 
 8003368:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800336c:	689b      	ldr	r3, [r3, #8]
 800336e:	4798      	blx	r3
      if((req->wLength == 0)&& (ret == USBD_OK))
 8003370:	88eb      	ldrh	r3, [r5, #6]
 8003372:	2b00      	cmp	r3, #0
 8003374:	d1f6      	bne.n	8003364 <USBD_StdItfReq+0x18>
         USBD_CtlSendStatus(pdev);
 8003376:	4620      	mov	r0, r4
 8003378:	f000 f8d5 	bl	8003526 <USBD_CtlSendStatus>
 800337c:	e7f2      	b.n	8003364 <USBD_StdItfReq+0x18>
     USBD_CtlError(pdev , req);
 800337e:	f7ff fe62 	bl	8003046 <USBD_CtlError>
    break;
 8003382:	e7ef      	b.n	8003364 <USBD_StdItfReq+0x18>

08003384 <USBD_StdEPReq>:
{
 8003384:	b538      	push	{r3, r4, r5, lr}
 8003386:	4605      	mov	r5, r0
 8003388:	460c      	mov	r4, r1
  ep_addr  = LOBYTE(req->wIndex);   
 800338a:	888a      	ldrh	r2, [r1, #4]
  if ((req->bmRequest & 0x60) == 0x20)
 800338c:	780b      	ldrb	r3, [r1, #0]
 800338e:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8003392:	2b20      	cmp	r3, #32
 8003394:	d011      	beq.n	80033ba <USBD_StdEPReq+0x36>
 8003396:	b2d1      	uxtb	r1, r2
  switch (req->bRequest) 
 8003398:	7863      	ldrb	r3, [r4, #1]
 800339a:	2b01      	cmp	r3, #1
 800339c:	d02a      	beq.n	80033f4 <USBD_StdEPReq+0x70>
 800339e:	2b00      	cmp	r3, #0
 80033a0:	d04b      	beq.n	800343a <USBD_StdEPReq+0xb6>
 80033a2:	2b03      	cmp	r3, #3
 80033a4:	d10d      	bne.n	80033c2 <USBD_StdEPReq+0x3e>
    switch (pdev->dev_state) 
 80033a6:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80033aa:	2b02      	cmp	r3, #2
 80033ac:	d00b      	beq.n	80033c6 <USBD_StdEPReq+0x42>
 80033ae:	2b03      	cmp	r3, #3
 80033b0:	d00f      	beq.n	80033d2 <USBD_StdEPReq+0x4e>
      USBD_CtlError(pdev , req);
 80033b2:	4621      	mov	r1, r4
 80033b4:	f7ff fe47 	bl	8003046 <USBD_CtlError>
      break;    
 80033b8:	e003      	b.n	80033c2 <USBD_StdEPReq+0x3e>
    pdev->pClass->Setup (pdev, req);
 80033ba:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80033be:	689b      	ldr	r3, [r3, #8]
 80033c0:	4798      	blx	r3
}
 80033c2:	2000      	movs	r0, #0
 80033c4:	bd38      	pop	{r3, r4, r5, pc}
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80033c6:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 80033ca:	d0fa      	beq.n	80033c2 <USBD_StdEPReq+0x3e>
        USBD_LL_StallEP(pdev , ep_addr);
 80033cc:	f000 fc94 	bl	8003cf8 <USBD_LL_StallEP>
 80033d0:	e7f7      	b.n	80033c2 <USBD_StdEPReq+0x3e>
      if (req->wValue == USB_FEATURE_EP_HALT)
 80033d2:	8863      	ldrh	r3, [r4, #2]
 80033d4:	b923      	cbnz	r3, 80033e0 <USBD_StdEPReq+0x5c>
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80033d6:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 80033da:	d001      	beq.n	80033e0 <USBD_StdEPReq+0x5c>
          USBD_LL_StallEP(pdev , ep_addr);
 80033dc:	f000 fc8c 	bl	8003cf8 <USBD_LL_StallEP>
      pdev->pClass->Setup (pdev, req);   
 80033e0:	f8d5 3214 	ldr.w	r3, [r5, #532]	; 0x214
 80033e4:	689b      	ldr	r3, [r3, #8]
 80033e6:	4621      	mov	r1, r4
 80033e8:	4628      	mov	r0, r5
 80033ea:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 80033ec:	4628      	mov	r0, r5
 80033ee:	f000 f89a 	bl	8003526 <USBD_CtlSendStatus>
      break;
 80033f2:	e7e6      	b.n	80033c2 <USBD_StdEPReq+0x3e>
    switch (pdev->dev_state) 
 80033f4:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80033f8:	2b02      	cmp	r3, #2
 80033fa:	d005      	beq.n	8003408 <USBD_StdEPReq+0x84>
 80033fc:	2b03      	cmp	r3, #3
 80033fe:	d009      	beq.n	8003414 <USBD_StdEPReq+0x90>
      USBD_CtlError(pdev , req);
 8003400:	4621      	mov	r1, r4
 8003402:	f7ff fe20 	bl	8003046 <USBD_CtlError>
      break;    
 8003406:	e7dc      	b.n	80033c2 <USBD_StdEPReq+0x3e>
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8003408:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 800340c:	d0d9      	beq.n	80033c2 <USBD_StdEPReq+0x3e>
        USBD_LL_StallEP(pdev , ep_addr);
 800340e:	f000 fc73 	bl	8003cf8 <USBD_LL_StallEP>
 8003412:	e7d6      	b.n	80033c2 <USBD_StdEPReq+0x3e>
      if (req->wValue == USB_FEATURE_EP_HALT)
 8003414:	8863      	ldrh	r3, [r4, #2]
 8003416:	2b00      	cmp	r3, #0
 8003418:	d1d3      	bne.n	80033c2 <USBD_StdEPReq+0x3e>
        if ((ep_addr & 0x7F) != 0x00) 
 800341a:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 800341e:	d103      	bne.n	8003428 <USBD_StdEPReq+0xa4>
        USBD_CtlSendStatus(pdev);
 8003420:	4628      	mov	r0, r5
 8003422:	f000 f880 	bl	8003526 <USBD_CtlSendStatus>
 8003426:	e7cc      	b.n	80033c2 <USBD_StdEPReq+0x3e>
          USBD_LL_ClearStallEP(pdev , ep_addr);
 8003428:	f000 fc73 	bl	8003d12 <USBD_LL_ClearStallEP>
          pdev->pClass->Setup (pdev, req);
 800342c:	f8d5 3214 	ldr.w	r3, [r5, #532]	; 0x214
 8003430:	689b      	ldr	r3, [r3, #8]
 8003432:	4621      	mov	r1, r4
 8003434:	4628      	mov	r0, r5
 8003436:	4798      	blx	r3
 8003438:	e7f2      	b.n	8003420 <USBD_StdEPReq+0x9c>
    switch (pdev->dev_state) 
 800343a:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800343e:	2b02      	cmp	r3, #2
 8003440:	d005      	beq.n	800344e <USBD_StdEPReq+0xca>
 8003442:	2b03      	cmp	r3, #3
 8003444:	d009      	beq.n	800345a <USBD_StdEPReq+0xd6>
      USBD_CtlError(pdev , req);
 8003446:	4621      	mov	r1, r4
 8003448:	f7ff fdfd 	bl	8003046 <USBD_CtlError>
      break;
 800344c:	e7b9      	b.n	80033c2 <USBD_StdEPReq+0x3e>
      if ((ep_addr & 0x7F) != 0x00) 
 800344e:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 8003452:	d0b6      	beq.n	80033c2 <USBD_StdEPReq+0x3e>
        USBD_LL_StallEP(pdev , ep_addr);
 8003454:	f000 fc50 	bl	8003cf8 <USBD_LL_StallEP>
 8003458:	e7b3      	b.n	80033c2 <USBD_StdEPReq+0x3e>
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 800345a:	f012 0f80 	tst.w	r2, #128	; 0x80
 800345e:	f001 047f 	and.w	r4, r1, #127	; 0x7f
 8003462:	eb00 1404 	add.w	r4, r0, r4, lsl #4
 8003466:	bf14      	ite	ne
 8003468:	3414      	addne	r4, #20
 800346a:	f504 7482 	addeq.w	r4, r4, #260	; 0x104
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 800346e:	f000 fc5d 	bl	8003d2c <USBD_LL_IsStallEP>
 8003472:	b138      	cbz	r0, 8003484 <USBD_StdEPReq+0x100>
        pep->status = 0x0001;     
 8003474:	2301      	movs	r3, #1
 8003476:	6023      	str	r3, [r4, #0]
      USBD_CtlSendData (pdev,
 8003478:	2202      	movs	r2, #2
 800347a:	4621      	mov	r1, r4
 800347c:	4628      	mov	r0, r5
 800347e:	f000 f826 	bl	80034ce <USBD_CtlSendData>
      break;
 8003482:	e79e      	b.n	80033c2 <USBD_StdEPReq+0x3e>
        pep->status = 0x0000;  
 8003484:	2300      	movs	r3, #0
 8003486:	6023      	str	r3, [r4, #0]
 8003488:	e7f6      	b.n	8003478 <USBD_StdEPReq+0xf4>

0800348a <USBD_GetString>:
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
 800348a:	b1f8      	cbz	r0, 80034cc <USBD_GetString+0x42>
{
 800348c:	b430      	push	{r4, r5}
 800348e:	4604      	mov	r4, r0
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 8003490:	7803      	ldrb	r3, [r0, #0]
 8003492:	b133      	cbz	r3, 80034a2 <USBD_GetString+0x18>
 8003494:	2300      	movs	r3, #0
    {
        len++;
 8003496:	3301      	adds	r3, #1
 8003498:	b2db      	uxtb	r3, r3
    while (*buf != '\0') 
 800349a:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 800349e:	2d00      	cmp	r5, #0
 80034a0:	d1f9      	bne.n	8003496 <USBD_GetString+0xc>
    *len =  USBD_GetLen(desc) * 2 + 2;    
 80034a2:	005b      	lsls	r3, r3, #1
 80034a4:	3302      	adds	r3, #2
 80034a6:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
 80034a8:	700b      	strb	r3, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 80034aa:	2303      	movs	r3, #3
 80034ac:	704b      	strb	r3, [r1, #1]
    while (*desc != '\0') 
 80034ae:	7820      	ldrb	r0, [r4, #0]
 80034b0:	b158      	cbz	r0, 80034ca <USBD_GetString+0x40>
 80034b2:	2302      	movs	r3, #2
      unicode[idx++] =  0x00;
 80034b4:	2500      	movs	r5, #0
      unicode[idx++] = *desc++;
 80034b6:	1c5a      	adds	r2, r3, #1
 80034b8:	b2d2      	uxtb	r2, r2
 80034ba:	54c8      	strb	r0, [r1, r3]
      unicode[idx++] =  0x00;
 80034bc:	3302      	adds	r3, #2
 80034be:	b2db      	uxtb	r3, r3
 80034c0:	548d      	strb	r5, [r1, r2]
    while (*desc != '\0') 
 80034c2:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 80034c6:	2800      	cmp	r0, #0
 80034c8:	d1f5      	bne.n	80034b6 <USBD_GetString+0x2c>
}
 80034ca:	bc30      	pop	{r4, r5}
 80034cc:	4770      	bx	lr

080034ce <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 80034ce:	b510      	push	{r4, lr}
 80034d0:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 80034d2:	2202      	movs	r2, #2
 80034d4:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
 80034d8:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
 80034da:	61c3      	str	r3, [r0, #28]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 80034dc:	460a      	mov	r2, r1
 80034de:	2100      	movs	r1, #0
 80034e0:	f000 fc48 	bl	8003d74 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 80034e4:	2000      	movs	r0, #0
 80034e6:	bd10      	pop	{r4, pc}

080034e8 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 80034e8:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 80034ea:	4613      	mov	r3, r2
 80034ec:	460a      	mov	r2, r1
 80034ee:	2100      	movs	r1, #0
 80034f0:	f000 fc40 	bl	8003d74 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 80034f4:	2000      	movs	r0, #0
 80034f6:	bd08      	pop	{r3, pc}

080034f8 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlPrepareRx (USBD_HandleTypeDef  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 80034f8:	b510      	push	{r4, lr}
 80034fa:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
 80034fc:	2203      	movs	r2, #3
 80034fe:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_out[0].total_length = len;
 8003502:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  pdev->ep_out[0].rem_length   = len;
 8003506:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev,
 800350a:	460a      	mov	r2, r1
 800350c:	2100      	movs	r1, #0
 800350e:	f000 fc3e 	bl	8003d8e <USBD_LL_PrepareReceive>
                          0,
                          pbuf,
                         len);
  
  return USBD_OK;
}
 8003512:	2000      	movs	r0, #0
 8003514:	bd10      	pop	{r4, pc}

08003516 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8003516:	b508      	push	{r3, lr}

  USBD_LL_PrepareReceive (pdev,
 8003518:	4613      	mov	r3, r2
 800351a:	460a      	mov	r2, r1
 800351c:	2100      	movs	r1, #0
 800351e:	f000 fc36 	bl	8003d8e <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
 8003522:	2000      	movs	r0, #0
 8003524:	bd08      	pop	{r3, pc}

08003526 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 8003526:	b508      	push	{r3, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8003528:	2304      	movs	r3, #4
 800352a:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 800352e:	2300      	movs	r3, #0
 8003530:	461a      	mov	r2, r3
 8003532:	4619      	mov	r1, r3
 8003534:	f000 fc1e 	bl	8003d74 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8003538:	2000      	movs	r0, #0
 800353a:	bd08      	pop	{r3, pc}

0800353c <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 800353c:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 800353e:	2305      	movs	r3, #5
 8003540:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 8003544:	2300      	movs	r3, #0
 8003546:	461a      	mov	r2, r3
 8003548:	4619      	mov	r1, r3
 800354a:	f000 fc20 	bl	8003d8e <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}
 800354e:	2000      	movs	r0, #0
 8003550:	bd08      	pop	{r3, pc}
	...

08003554 <netif_init_cb>:
    return ERR_OK;
}


err_t netif_init_cb(struct netif *netif)
{
 8003554:	4603      	mov	r3, r0
    LWIP_ASSERT("netif != NULL", (netif != NULL));
    netif->mtu = RNDIS_MTU;
 8003556:	f240 52dc 	movw	r2, #1500	; 0x5dc
 800355a:	8402      	strh	r2, [r0, #32]
    netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP | NETIF_FLAG_UP;
 800355c:	2233      	movs	r2, #51	; 0x33
 800355e:	f880 2029 	strb.w	r2, [r0, #41]	; 0x29
    netif->state = NULL;
 8003562:	2000      	movs	r0, #0
 8003564:	61d8      	str	r0, [r3, #28]
    netif->name[0] = 'E';
 8003566:	2245      	movs	r2, #69	; 0x45
 8003568:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
    netif->name[1] = 'X';
 800356c:	2258      	movs	r2, #88	; 0x58
 800356e:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
    netif->linkoutput = linkoutput_fn;
 8003572:	4a02      	ldr	r2, [pc, #8]	; (800357c <netif_init_cb+0x28>)
 8003574:	619a      	str	r2, [r3, #24]
    netif->output = output_fn;
 8003576:	4a02      	ldr	r2, [pc, #8]	; (8003580 <netif_init_cb+0x2c>)
 8003578:	615a      	str	r2, [r3, #20]
    return ERR_OK;
}
 800357a:	4770      	bx	lr
 800357c:	080036f5 	.word	0x080036f5
 8003580:	080035a9 	.word	0x080035a9

08003584 <tcp_timer_proc>:
{
 8003584:	b508      	push	{r3, lr}
    tcp_tmr();
 8003586:	f002 ff73 	bl	8006470 <tcp_tmr>
 800358a:	bd08      	pop	{r3, pc}

0800358c <on_packet>:
{
 800358c:	b510      	push	{r4, lr}
 800358e:	460c      	mov	r4, r1
    memcpy(received, data, size);
 8003590:	460a      	mov	r2, r1
 8003592:	4601      	mov	r1, r0
 8003594:	4802      	ldr	r0, [pc, #8]	; (80035a0 <on_packet+0x14>)
 8003596:	f005 fdaa 	bl	80090ee <memcpy>
    recvSize = size;
 800359a:	4b02      	ldr	r3, [pc, #8]	; (80035a4 <on_packet+0x18>)
 800359c:	601c      	str	r4, [r3, #0]
 800359e:	bd10      	pop	{r4, pc}
 80035a0:	200007dc 	.word	0x200007dc
 80035a4:	20000dc8 	.word	0x20000dc8

080035a8 <output_fn>:
{
 80035a8:	b508      	push	{r3, lr}
    return etharp_output(netif, p, ipaddr);
 80035aa:	f005 fbc5 	bl	8008d38 <etharp_output>
}
 80035ae:	bd08      	pop	{r3, pc}

080035b0 <dns_query_proc>:

    stmr_add(&tcp_timer);
}

bool dns_query_proc(const char *name, ip_addr_t *addr)
{
 80035b0:	b538      	push	{r3, r4, r5, lr}
 80035b2:	4605      	mov	r5, r0
 80035b4:	460c      	mov	r4, r1
    if (strcmp(name, "run.stm") == 0 || strcmp(name, "www.run.stm") == 0)
 80035b6:	4908      	ldr	r1, [pc, #32]	; (80035d8 <dns_query_proc+0x28>)
 80035b8:	f7fc fe0e 	bl	80001d8 <strcmp>
 80035bc:	b120      	cbz	r0, 80035c8 <dns_query_proc+0x18>
 80035be:	4907      	ldr	r1, [pc, #28]	; (80035dc <dns_query_proc+0x2c>)
 80035c0:	4628      	mov	r0, r5
 80035c2:	f7fc fe09 	bl	80001d8 <strcmp>
 80035c6:	b920      	cbnz	r0, 80035d2 <dns_query_proc+0x22>
    {
        addr->addr = *(uint32_t *)ipaddr;
 80035c8:	4b05      	ldr	r3, [pc, #20]	; (80035e0 <dns_query_proc+0x30>)
 80035ca:	681b      	ldr	r3, [r3, #0]
 80035cc:	6023      	str	r3, [r4, #0]
        return true;
 80035ce:	2001      	movs	r0, #1
 80035d0:	bd38      	pop	{r3, r4, r5, pc}
    }
    return false;
 80035d2:	2000      	movs	r0, #0
}
 80035d4:	bd38      	pop	{r3, r4, r5, pc}
 80035d6:	bf00      	nop
 80035d8:	080091b4 	.word	0x080091b4
 80035dc:	080091b0 	.word	0x080091b0
 80035e0:	200000e0 	.word	0x200000e0

080035e4 <usb_polling>:
  __ASM volatile ("cpsid i" : : : "memory");
 80035e4:	b672      	cpsid	i
    if (recvSize == 0)
 80035e6:	4b11      	ldr	r3, [pc, #68]	; (800362c <usb_polling+0x48>)
 80035e8:	6819      	ldr	r1, [r3, #0]
 80035ea:	b909      	cbnz	r1, 80035f0 <usb_polling+0xc>
  __ASM volatile ("cpsie i" : : : "memory");
 80035ec:	b662      	cpsie	i
 80035ee:	4770      	bx	lr
{
 80035f0:	b570      	push	{r4, r5, r6, lr}
    frame = pbuf_alloc(PBUF_RAW, recvSize, PBUF_POOL);
 80035f2:	2203      	movs	r2, #3
 80035f4:	b289      	uxth	r1, r1
 80035f6:	4610      	mov	r0, r2
 80035f8:	f002 f99c 	bl	8005934 <pbuf_alloc>
    if (frame == NULL)
 80035fc:	4604      	mov	r4, r0
 80035fe:	b190      	cbz	r0, 8003626 <usb_polling+0x42>
    memcpy(frame->payload, received, recvSize);
 8003600:	4d0a      	ldr	r5, [pc, #40]	; (800362c <usb_polling+0x48>)
 8003602:	682e      	ldr	r6, [r5, #0]
 8003604:	4632      	mov	r2, r6
 8003606:	490a      	ldr	r1, [pc, #40]	; (8003630 <usb_polling+0x4c>)
 8003608:	6840      	ldr	r0, [r0, #4]
 800360a:	f005 fd70 	bl	80090ee <memcpy>
    frame->len = recvSize;
 800360e:	8166      	strh	r6, [r4, #10]
    recvSize = 0;
 8003610:	2300      	movs	r3, #0
 8003612:	602b      	str	r3, [r5, #0]
 8003614:	b662      	cpsie	i
    ethernet_input(frame, &netif_data);
 8003616:	4907      	ldr	r1, [pc, #28]	; (8003634 <usb_polling+0x50>)
 8003618:	4620      	mov	r0, r4
 800361a:	f005 fc1f 	bl	8008e5c <ethernet_input>
    pbuf_free(frame);
 800361e:	4620      	mov	r0, r4
 8003620:	f002 f959 	bl	80058d6 <pbuf_free>
 8003624:	bd70      	pop	{r4, r5, r6, pc}
 8003626:	b662      	cpsie	i
 8003628:	bd70      	pop	{r4, r5, r6, pc}
 800362a:	bf00      	nop
 800362c:	20000dc8 	.word	0x20000dc8
 8003630:	200007dc 	.word	0x200007dc
 8003634:	20007f88 	.word	0x20007f88

08003638 <SysTick_Handler>:

    }
}

void SysTick_Handler(void)
{
 8003638:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800363a:	f7fc fff7 	bl	800062c <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
 800363e:	f7fd f88c 	bl	800075a <HAL_SYSTICK_IRQHandler>
  /* USER CODE BEGIN SysTick_IRQn 1 */
  usAddition += 1000;
 8003642:	4905      	ldr	r1, [pc, #20]	; (8003658 <SysTick_Handler+0x20>)
 8003644:	e9d1 2300 	ldrd	r2, r3, [r1]
 8003648:	f512 727a 	adds.w	r2, r2, #1000	; 0x3e8
 800364c:	f143 0300 	adc.w	r3, r3, #0
 8003650:	e9c1 2300 	strd	r2, r3, [r1]
 8003654:	bd08      	pop	{r3, pc}
 8003656:	bf00      	nop
 8003658:	20000de0 	.word	0x20000de0

0800365c <utime>:
  /* USER CODE END SysTick_IRQn 1 */
}

int64_t utime(void)
{
 800365c:	b5d0      	push	{r4, r6, r7, lr}
    uint32_t ctrl;
    static int64_t res;
    uint32_t ticks;

    ctrl = SysTick->CTRL;
 800365e:	4b10      	ldr	r3, [pc, #64]	; (80036a0 <utime+0x44>)
 8003660:	681b      	ldr	r3, [r3, #0]

read:
    ticks = SysTick->VAL;
    res = usAddition;
 8003662:	4b10      	ldr	r3, [pc, #64]	; (80036a4 <utime+0x48>)
 8003664:	e9d3 6700 	ldrd	r6, r7, [r3]
    ticks = SysTick->VAL;
 8003668:	4b0d      	ldr	r3, [pc, #52]	; (80036a0 <utime+0x44>)
    res = usAddition;
 800366a:	490f      	ldr	r1, [pc, #60]	; (80036a8 <utime+0x4c>)
    ticks = SysTick->VAL;
 800366c:	689c      	ldr	r4, [r3, #8]
    res = usAddition;
 800366e:	e9c1 6700 	strd	r6, r7, [r1]
    ctrl = SysTick->CTRL;
 8003672:	681a      	ldr	r2, [r3, #0]
    if (ctrl & SysTick_CTRL_COUNTFLAG_Msk)
 8003674:	f412 3f80 	tst.w	r2, #65536	; 0x10000
 8003678:	d1f8      	bne.n	800366c <utime+0x10>
        goto read;

    #define ticksPerUs (HAL_RCC_GetHCLKFreq()/1000000)
    res += 1000 - ticks / ticksPerUs;
 800367a:	f7fe f925 	bl	80018c8 <HAL_RCC_GetHCLKFreq>
 800367e:	4b0b      	ldr	r3, [pc, #44]	; (80036ac <utime+0x50>)
 8003680:	fba3 3000 	umull	r3, r0, r3, r0
 8003684:	0c80      	lsrs	r0, r0, #18
 8003686:	fbb4 f4f0 	udiv	r4, r4, r0
 800368a:	f5c4 747a 	rsb	r4, r4, #1000	; 0x3e8
 800368e:	4b06      	ldr	r3, [pc, #24]	; (80036a8 <utime+0x4c>)
 8003690:	e9d3 0100 	ldrd	r0, r1, [r3]
 8003694:	1900      	adds	r0, r0, r4
 8003696:	f141 0100 	adc.w	r1, r1, #0
 800369a:	e9c3 0100 	strd	r0, r1, [r3]
    #undef usecPerTick

    return res;
}
 800369e:	bdd0      	pop	{r4, r6, r7, pc}
 80036a0:	e000e010 	.word	0xe000e010
 80036a4:	20000de0 	.word	0x20000de0
 80036a8:	20000dd0 	.word	0x20000dd0
 80036ac:	431bde83 	.word	0x431bde83

080036b0 <mtime>:
    if (m != NULL) *m = time.Minutes;
    if (s != NULL) *s = time.Seconds;
}

int64_t mtime(void)
{
 80036b0:	b508      	push	{r3, lr}
    return utime() / 1000;
 80036b2:	f7ff ffd3 	bl	800365c <utime>
 80036b6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80036ba:	2300      	movs	r3, #0
 80036bc:	f7fc fd9e 	bl	80001fc <__aeabi_ldivmod>
}
 80036c0:	bd08      	pop	{r3, pc}

080036c2 <sys_now>:
{
 80036c2:	b508      	push	{r3, lr}
    return (uint32_t)mtime();
 80036c4:	f7ff fff4 	bl	80036b0 <mtime>
}
 80036c8:	bd08      	pop	{r3, pc}

080036ca <usleep>:

void usleep(int us)
{
 80036ca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80036cc:	4606      	mov	r6, r0
    uint64_t t = utime();
 80036ce:	f7ff ffc5 	bl	800365c <utime>
 80036d2:	4604      	mov	r4, r0
 80036d4:	460d      	mov	r5, r1
    while (true)
    {
        uint64_t t1 = utime();
        if (t1 - t >= us) break;
 80036d6:	17f7      	asrs	r7, r6, #31
        uint64_t t1 = utime();
 80036d8:	f7ff ffc0 	bl	800365c <utime>
        if (t1 - t >= us) break;
 80036dc:	1b02      	subs	r2, r0, r4
 80036de:	eb61 0305 	sbc.w	r3, r1, r5
 80036e2:	42bb      	cmp	r3, r7
 80036e4:	bf08      	it	eq
 80036e6:	42b2      	cmpeq	r2, r6
 80036e8:	d203      	bcs.n	80036f2 <usleep+0x28>
        if (t1 < t) break; /* overflow */
 80036ea:	42a9      	cmp	r1, r5
 80036ec:	bf08      	it	eq
 80036ee:	42a0      	cmpeq	r0, r4
 80036f0:	d2f2      	bcs.n	80036d8 <usleep+0xe>
 80036f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080036f4 <linkoutput_fn>:
{
 80036f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80036f6:	460c      	mov	r4, r1
 80036f8:	25c8      	movs	r5, #200	; 0xc8
        msleep(1);
 80036fa:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
        if (rndis_can_send()) break;
 80036fe:	f7ff fb17 	bl	8002d30 <rndis_can_send>
 8003702:	b920      	cbnz	r0, 800370e <linkoutput_fn+0x1a>
        msleep(1);
 8003704:	4630      	mov	r0, r6
 8003706:	f7ff ffe0 	bl	80036ca <usleep>
    for (i = 0; i < 200; i++)
 800370a:	3d01      	subs	r5, #1
 800370c:	d1f7      	bne.n	80036fe <linkoutput_fn+0xa>
    for(q = p; q != NULL; q = q->next)
 800370e:	b1b4      	cbz	r4, 800373e <linkoutput_fn+0x4a>
        if (size + q->len > RNDIS_MTU + 14)
 8003710:	8962      	ldrh	r2, [r4, #10]
 8003712:	f240 53ea 	movw	r3, #1514	; 0x5ea
 8003716:	429a      	cmp	r2, r3
 8003718:	dc21      	bgt.n	800375e <linkoutput_fn+0x6a>
 800371a:	2500      	movs	r5, #0
        memcpy(data + size, (char *)q->payload, q->len);
 800371c:	4e13      	ldr	r6, [pc, #76]	; (800376c <linkoutput_fn+0x78>)
        if (size + q->len > RNDIS_MTU + 14)
 800371e:	461f      	mov	r7, r3
        memcpy(data + size, (char *)q->payload, q->len);
 8003720:	6861      	ldr	r1, [r4, #4]
 8003722:	1970      	adds	r0, r6, r5
 8003724:	f005 fce3 	bl	80090ee <memcpy>
        size += q->len;
 8003728:	8963      	ldrh	r3, [r4, #10]
 800372a:	441d      	add	r5, r3
    for(q = p; q != NULL; q = q->next)
 800372c:	6824      	ldr	r4, [r4, #0]
 800372e:	b13c      	cbz	r4, 8003740 <linkoutput_fn+0x4c>
        if (size + q->len > RNDIS_MTU + 14)
 8003730:	8962      	ldrh	r2, [r4, #10]
 8003732:	1953      	adds	r3, r2, r5
 8003734:	42bb      	cmp	r3, r7
 8003736:	ddf3      	ble.n	8003720 <linkoutput_fn+0x2c>
            return ERR_ARG;
 8003738:	f06f 000d 	mvn.w	r0, #13
 800373c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    for(q = p; q != NULL; q = q->next)
 800373e:	2500      	movs	r5, #0
    buffStatus = rndis_can_send();
 8003740:	f7ff faf6 	bl	8002d30 <rndis_can_send>
 8003744:	4b0a      	ldr	r3, [pc, #40]	; (8003770 <linkoutput_fn+0x7c>)
 8003746:	7018      	strb	r0, [r3, #0]
    if (!buffStatus)
 8003748:	b160      	cbz	r0, 8003764 <linkoutput_fn+0x70>
    rndis_send(data, size);
 800374a:	4629      	mov	r1, r5
 800374c:	4807      	ldr	r0, [pc, #28]	; (800376c <linkoutput_fn+0x78>)
 800374e:	f7ff faf9 	bl	8002d44 <rndis_send>
    outputs++;
 8003752:	4a08      	ldr	r2, [pc, #32]	; (8003774 <linkoutput_fn+0x80>)
 8003754:	6813      	ldr	r3, [r2, #0]
 8003756:	3301      	adds	r3, #1
 8003758:	6013      	str	r3, [r2, #0]
    return ERR_OK;
 800375a:	2000      	movs	r0, #0
 800375c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return ERR_ARG;
 800375e:	f06f 000d 	mvn.w	r0, #13
 8003762:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return ERR_USE;
 8003764:	f06f 0007 	mvn.w	r0, #7
}
 8003768:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800376a:	bf00      	nop
 800376c:	200001e4 	.word	0x200001e4
 8003770:	20007f64 	.word	0x20007f64
 8003774:	200007d8 	.word	0x200007d8

08003778 <stmr>:
    }
}

void stmr(void)
{
 8003778:	b570      	push	{r4, r5, r6, lr}
    stmr_t *tmr;
    uint32_t time;
    time = utime();
 800377a:	f7ff ff6f 	bl	800365c <utime>
 800377e:	4606      	mov	r6, r0
    tmr = stmrs;
 8003780:	4b0b      	ldr	r3, [pc, #44]	; (80037b0 <stmr+0x38>)
 8003782:	681c      	ldr	r4, [r3, #0]
    while (tmr != NULL)
 8003784:	b91c      	cbnz	r4, 800378e <stmr+0x16>
 8003786:	bd70      	pop	{r4, r5, r6, pc}
 8003788:	462c      	mov	r4, r5
 800378a:	2d00      	cmp	r5, #0
 800378c:	d0fb      	beq.n	8003786 <stmr+0xe>
    {
        stmr_t *t;
        uint32_t elapsed;
        t = tmr;
        tmr = tmr->next;
 800378e:	6965      	ldr	r5, [r4, #20]
        if ((t->flags & STMR_ACTIVE) == 0)
 8003790:	68a3      	ldr	r3, [r4, #8]
 8003792:	f013 0f01 	tst.w	r3, #1
 8003796:	d0f7      	beq.n	8003788 <stmr+0x10>
            continue;
        elapsed = time;
        elapsed -= t->event;
 8003798:	6863      	ldr	r3, [r4, #4]
 800379a:	1af3      	subs	r3, r6, r3
        if (elapsed < t->period)
 800379c:	6822      	ldr	r2, [r4, #0]
 800379e:	4293      	cmp	r3, r2
 80037a0:	d3f2      	bcc.n	8003788 <stmr+0x10>
            continue;
        t->proc(t);
 80037a2:	6923      	ldr	r3, [r4, #16]
 80037a4:	4620      	mov	r0, r4
 80037a6:	4798      	blx	r3
        t->event = utime();
 80037a8:	f7ff ff58 	bl	800365c <utime>
 80037ac:	6060      	str	r0, [r4, #4]
 80037ae:	e7eb      	b.n	8003788 <stmr+0x10>
 80037b0:	20000dd8 	.word	0x20000dd8

080037b4 <stmr_add>:
    stmrs = tmr;
}

void stmr_add(stmr_t *tmr)
{
    tmr->next = stmrs;
 80037b4:	4b02      	ldr	r3, [pc, #8]	; (80037c0 <stmr_add+0xc>)
 80037b6:	681a      	ldr	r2, [r3, #0]
 80037b8:	6142      	str	r2, [r0, #20]
    stmrs = tmr;
 80037ba:	6018      	str	r0, [r3, #0]
 80037bc:	4770      	bx	lr
 80037be:	bf00      	nop
 80037c0:	20000dd8 	.word	0x20000dd8

080037c4 <init_lwip>:
{
 80037c4:	b510      	push	{r4, lr}
 80037c6:	b084      	sub	sp, #16
    lwip_init();
 80037c8:	f000 fe24 	bl	8004414 <lwip_init>
    netif->hwaddr_len = 6;
 80037cc:	4c0e      	ldr	r4, [pc, #56]	; (8003808 <init_lwip+0x44>)
 80037ce:	2306      	movs	r3, #6
 80037d0:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
    memcpy(netif->hwaddr, hwaddr, 6);
 80037d4:	4b0d      	ldr	r3, [pc, #52]	; (800380c <init_lwip+0x48>)
 80037d6:	6818      	ldr	r0, [r3, #0]
 80037d8:	f8c4 0023 	str.w	r0, [r4, #35]	; 0x23
 80037dc:	889b      	ldrh	r3, [r3, #4]
 80037de:	f8a4 3027 	strh.w	r3, [r4, #39]	; 0x27
    netif = netif_add(netif, PADDR(ipaddr), PADDR(netmask), PADDR(gateway), NULL, netif_init_cb, ip_input);
 80037e2:	4b0b      	ldr	r3, [pc, #44]	; (8003810 <init_lwip+0x4c>)
 80037e4:	9302      	str	r3, [sp, #8]
 80037e6:	4b0b      	ldr	r3, [pc, #44]	; (8003814 <init_lwip+0x50>)
 80037e8:	9301      	str	r3, [sp, #4]
 80037ea:	2300      	movs	r3, #0
 80037ec:	9300      	str	r3, [sp, #0]
 80037ee:	4b0a      	ldr	r3, [pc, #40]	; (8003818 <init_lwip+0x54>)
 80037f0:	4a0a      	ldr	r2, [pc, #40]	; (800381c <init_lwip+0x58>)
 80037f2:	490b      	ldr	r1, [pc, #44]	; (8003820 <init_lwip+0x5c>)
 80037f4:	4620      	mov	r0, r4
 80037f6:	f001 ffd7 	bl	80057a8 <netif_add>
    netif_set_default(netif);
 80037fa:	f001 fff9 	bl	80057f0 <netif_set_default>
    stmr_add(&tcp_timer);
 80037fe:	4809      	ldr	r0, [pc, #36]	; (8003824 <init_lwip+0x60>)
 8003800:	f7ff ffd8 	bl	80037b4 <stmr_add>
}
 8003804:	b004      	add	sp, #16
 8003806:	bd10      	pop	{r4, pc}
 8003808:	20007f88 	.word	0x20007f88
 800380c:	080091bc 	.word	0x080091bc
 8003810:	08004855 	.word	0x08004855
 8003814:	08003555 	.word	0x08003555
 8003818:	200007d4 	.word	0x200007d4
 800381c:	200000e4 	.word	0x200000e4
 8003820:	200000e0 	.word	0x200000e0
 8003824:	200000e8 	.word	0x200000e8

08003828 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8003828:	b500      	push	{lr}
 800382a:	b09b      	sub	sp, #108	; 0x6c
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;

    /**Configure the main internal regulator output voltage 
    */
  __HAL_RCC_PWR_CLK_ENABLE();
 800382c:	2100      	movs	r1, #0
 800382e:	9101      	str	r1, [sp, #4]
 8003830:	4b2c      	ldr	r3, [pc, #176]	; (80038e4 <SystemClock_Config+0xbc>)
 8003832:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8003834:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003838:	641a      	str	r2, [r3, #64]	; 0x40
 800383a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800383c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003840:	9301      	str	r3, [sp, #4]
 8003842:	9b01      	ldr	r3, [sp, #4]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8003844:	9102      	str	r1, [sp, #8]
 8003846:	4b28      	ldr	r3, [pc, #160]	; (80038e8 <SystemClock_Config+0xc0>)
 8003848:	681a      	ldr	r2, [r3, #0]
 800384a:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 800384e:	601a      	str	r2, [r3, #0]
 8003850:	681b      	ldr	r3, [r3, #0]
 8003852:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8003856:	9302      	str	r3, [sp, #8]
 8003858:	9b02      	ldr	r3, [sp, #8]

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 800385a:	2309      	movs	r3, #9
 800385c:	930e      	str	r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800385e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8003862:	920f      	str	r2, [sp, #60]	; 0x3c
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8003864:	2201      	movs	r2, #1
 8003866:	9213      	str	r2, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8003868:	2202      	movs	r2, #2
 800386a:	9214      	str	r2, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800386c:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8003870:	9215      	str	r2, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLM = 4;
 8003872:	2204      	movs	r2, #4
 8003874:	9216      	str	r2, [sp, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLN = 216;
 8003876:	22d8      	movs	r2, #216	; 0xd8
 8003878:	9217      	str	r2, [sp, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV6;
 800387a:	2206      	movs	r2, #6
 800387c:	9218      	str	r2, [sp, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLQ = 9;
 800387e:	9319      	str	r3, [sp, #100]	; 0x64
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8003880:	a80e      	add	r0, sp, #56	; 0x38
 8003882:	f7fd fd33 	bl	80012ec <HAL_RCC_OscConfig>
 8003886:	bb50      	cbnz	r0, 80038de <SystemClock_Config+0xb6>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8003888:	230f      	movs	r3, #15
 800388a:	9309      	str	r3, [sp, #36]	; 0x24
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800388c:	2102      	movs	r1, #2
 800388e:	910a      	str	r1, [sp, #40]	; 0x28
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8003890:	2300      	movs	r3, #0
 8003892:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8003894:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8003898:	920c      	str	r2, [sp, #48]	; 0x30
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800389a:	930d      	str	r3, [sp, #52]	; 0x34

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 800389c:	a809      	add	r0, sp, #36	; 0x24
 800389e:	f7fd ff5d 	bl	800175c <HAL_RCC_ClockConfig>
 80038a2:	b9e8      	cbnz	r0, 80038e0 <SystemClock_Config+0xb8>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 80038a4:	2302      	movs	r3, #2
 80038a6:	9303      	str	r3, [sp, #12]
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 80038a8:	f44f 7300 	mov.w	r3, #512	; 0x200
 80038ac:	9307      	str	r3, [sp, #28]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80038ae:	a803      	add	r0, sp, #12
 80038b0:	f7fe f810 	bl	80018d4 <HAL_RCCEx_PeriphCLKConfig>
 80038b4:	b9a8      	cbnz	r0, 80038e2 <SystemClock_Config+0xba>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure the Systick interrupt time 
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 80038b6:	f7fe f807 	bl	80018c8 <HAL_RCC_GetHCLKFreq>
 80038ba:	4b0c      	ldr	r3, [pc, #48]	; (80038ec <SystemClock_Config+0xc4>)
 80038bc:	fba3 3000 	umull	r3, r0, r3, r0
 80038c0:	0980      	lsrs	r0, r0, #6
 80038c2:	f7fc ff27 	bl	8000714 <HAL_SYSTICK_Config>

    /**Configure the Systick 
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 80038c6:	2004      	movs	r0, #4
 80038c8:	f7fc ff3a 	bl	8000740 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80038cc:	2200      	movs	r2, #0
 80038ce:	4611      	mov	r1, r2
 80038d0:	f04f 30ff 	mov.w	r0, #4294967295
 80038d4:	f7fc fee2 	bl	800069c <HAL_NVIC_SetPriority>
}
 80038d8:	b01b      	add	sp, #108	; 0x6c
 80038da:	f85d fb04 	ldr.w	pc, [sp], #4
 80038de:	e7fe      	b.n	80038de <SystemClock_Config+0xb6>
 80038e0:	e7fe      	b.n	80038e0 <SystemClock_Config+0xb8>
 80038e2:	e7fe      	b.n	80038e2 <SystemClock_Config+0xba>
 80038e4:	40023800 	.word	0x40023800
 80038e8:	40007000 	.word	0x40007000
 80038ec:	10624dd3 	.word	0x10624dd3

080038f0 <main>:
{
 80038f0:	b500      	push	{lr}
 80038f2:	b083      	sub	sp, #12
  HAL_Init();
 80038f4:	f7fc fe80 	bl	80005f8 <HAL_Init>
  SystemClock_Config();
 80038f8:	f7ff ff96 	bl	8003828 <SystemClock_Config>
*/
static void MX_GPIO_Init(void)
{

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80038fc:	2400      	movs	r4, #0
 80038fe:	9400      	str	r4, [sp, #0]
 8003900:	4b22      	ldr	r3, [pc, #136]	; (800398c <main+0x9c>)
 8003902:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003904:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003908:	631a      	str	r2, [r3, #48]	; 0x30
 800390a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800390c:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8003910:	9200      	str	r2, [sp, #0]
 8003912:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8003914:	9401      	str	r4, [sp, #4]
 8003916:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003918:	f042 0201 	orr.w	r2, r2, #1
 800391c:	631a      	str	r2, [r3, #48]	; 0x30
 800391e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003920:	f003 0301 	and.w	r3, r3, #1
 8003924:	9301      	str	r3, [sp, #4]
 8003926:	9b01      	ldr	r3, [sp, #4]
  MX_USB_DEVICE_Init();
 8003928:	f000 f8b6 	bl	8003a98 <MX_USB_DEVICE_Init>
  hrtc.Instance = RTC;
 800392c:	4818      	ldr	r0, [pc, #96]	; (8003990 <main+0xa0>)
 800392e:	4b19      	ldr	r3, [pc, #100]	; (8003994 <main+0xa4>)
 8003930:	6003      	str	r3, [r0, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 8003932:	6044      	str	r4, [r0, #4]
  hrtc.Init.AsynchPrediv = 127;
 8003934:	237f      	movs	r3, #127	; 0x7f
 8003936:	6083      	str	r3, [r0, #8]
  hrtc.Init.SynchPrediv = 255;
 8003938:	23ff      	movs	r3, #255	; 0xff
 800393a:	60c3      	str	r3, [r0, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 800393c:	6104      	str	r4, [r0, #16]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 800393e:	6144      	str	r4, [r0, #20]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 8003940:	6184      	str	r4, [r0, #24]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8003942:	f7fe f8b6 	bl	8001ab2 <HAL_RTC_Init>
 8003946:	bb00      	cbnz	r0, 800398a <main+0x9a>
  rndis_rxproc = on_packet;
 8003948:	4a13      	ldr	r2, [pc, #76]	; (8003998 <main+0xa8>)
 800394a:	4b14      	ldr	r3, [pc, #80]	; (800399c <main+0xac>)
 800394c:	601a      	str	r2, [r3, #0]
  init_lwip();
 800394e:	f7ff ff39 	bl	80037c4 <init_lwip>
	while (!netif_is_up(&netif_data)) ;
 8003952:	4b13      	ldr	r3, [pc, #76]	; (80039a0 <main+0xb0>)
 8003954:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8003958:	f003 0301 	and.w	r3, r3, #1
 800395c:	2b00      	cmp	r3, #0
 800395e:	d0fd      	beq.n	800395c <main+0x6c>
	while (dhserv_init(&dhcp_config) != ERR_OK) ;
 8003960:	4c10      	ldr	r4, [pc, #64]	; (80039a4 <main+0xb4>)
 8003962:	4620      	mov	r0, r4
 8003964:	f000 fc2a 	bl	80041bc <dhserv_init>
 8003968:	2800      	cmp	r0, #0
 800396a:	d1fa      	bne.n	8003962 <main+0x72>
	while (dnserv_init(PADDR(ipaddr), 53, dns_query_proc) != ERR_OK) ;
 800396c:	4e0e      	ldr	r6, [pc, #56]	; (80039a8 <main+0xb8>)
 800396e:	4d0f      	ldr	r5, [pc, #60]	; (80039ac <main+0xbc>)
 8003970:	2435      	movs	r4, #53	; 0x35
 8003972:	4632      	mov	r2, r6
 8003974:	4621      	mov	r1, r4
 8003976:	4628      	mov	r0, r5
 8003978:	f000 fd08 	bl	800438c <dnserv_init>
 800397c:	2800      	cmp	r0, #0
 800397e:	d1f8      	bne.n	8003972 <main+0x82>
  	  usb_polling();     /* usb device polling */
 8003980:	f7ff fe30 	bl	80035e4 <usb_polling>
  	  stmr();            /* call software timers */
 8003984:	f7ff fef8 	bl	8003778 <stmr>
 8003988:	e7fa      	b.n	8003980 <main+0x90>
 800398a:	e7fe      	b.n	800398a <main+0x9a>
 800398c:	40023800 	.word	0x40023800
 8003990:	20007f68 	.word	0x20007f68
 8003994:	40002800 	.word	0x40002800
 8003998:	0800358d 	.word	0x0800358d
 800399c:	200001bc 	.word	0x200001bc
 80039a0:	20007f88 	.word	0x20007f88
 80039a4:	2000008c 	.word	0x2000008c
 80039a8:	080035b1 	.word	0x080035b1
 80039ac:	200000e0 	.word	0x200000e0

080039b0 <_Error_Handler>:
  * @param  file: The file name as string.
  * @param  line: The line in file as a number.
  * @retval None
  */
void _Error_Handler(char *file, int line)
{
 80039b0:	e7fe      	b.n	80039b0 <_Error_Handler>

080039b2 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80039b2:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80039b4:	2003      	movs	r0, #3
 80039b6:	f7fc fe5f 	bl	8000678 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 80039ba:	2200      	movs	r2, #0
 80039bc:	4611      	mov	r1, r2
 80039be:	f06f 000b 	mvn.w	r0, #11
 80039c2:	f7fc fe6b 	bl	800069c <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 80039c6:	2200      	movs	r2, #0
 80039c8:	4611      	mov	r1, r2
 80039ca:	f06f 000a 	mvn.w	r0, #10
 80039ce:	f7fc fe65 	bl	800069c <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 80039d2:	2200      	movs	r2, #0
 80039d4:	4611      	mov	r1, r2
 80039d6:	f06f 0009 	mvn.w	r0, #9
 80039da:	f7fc fe5f 	bl	800069c <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 80039de:	2200      	movs	r2, #0
 80039e0:	4611      	mov	r1, r2
 80039e2:	f06f 0004 	mvn.w	r0, #4
 80039e6:	f7fc fe59 	bl	800069c <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 80039ea:	2200      	movs	r2, #0
 80039ec:	4611      	mov	r1, r2
 80039ee:	f06f 0003 	mvn.w	r0, #3
 80039f2:	f7fc fe53 	bl	800069c <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 80039f6:	2200      	movs	r2, #0
 80039f8:	4611      	mov	r1, r2
 80039fa:	f06f 0001 	mvn.w	r0, #1
 80039fe:	f7fc fe4d 	bl	800069c <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8003a02:	2200      	movs	r2, #0
 8003a04:	4611      	mov	r1, r2
 8003a06:	f04f 30ff 	mov.w	r0, #4294967295
 8003a0a:	f7fc fe47 	bl	800069c <HAL_NVIC_SetPriority>
 8003a0e:	bd08      	pop	{r3, pc}

08003a10 <HAL_RTC_MspInit>:
}

void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{

  if(hrtc->Instance==RTC)
 8003a10:	6802      	ldr	r2, [r0, #0]
 8003a12:	4b04      	ldr	r3, [pc, #16]	; (8003a24 <HAL_RTC_MspInit+0x14>)
 8003a14:	429a      	cmp	r2, r3
 8003a16:	d000      	beq.n	8003a1a <HAL_RTC_MspInit+0xa>
 8003a18:	4770      	bx	lr
  {
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 8003a1a:	2201      	movs	r2, #1
 8003a1c:	4b02      	ldr	r3, [pc, #8]	; (8003a28 <HAL_RTC_MspInit+0x18>)
 8003a1e:	601a      	str	r2, [r3, #0]
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }

}
 8003a20:	e7fa      	b.n	8003a18 <HAL_RTC_MspInit+0x8>
 8003a22:	bf00      	nop
 8003a24:	40002800 	.word	0x40002800
 8003a28:	42470e3c 	.word	0x42470e3c

08003a2c <NMI_Handler>:

/**
* @brief This function handles Non maskable interrupt.
*/
void NMI_Handler(void)
{
 8003a2c:	4770      	bx	lr

08003a2e <HardFault_Handler>:

/**
* @brief This function handles Hard fault interrupt.
*/
void HardFault_Handler(void)
{
 8003a2e:	e7fe      	b.n	8003a2e <HardFault_Handler>

08003a30 <MemManage_Handler>:

/**
* @brief This function handles Memory management fault.
*/
void MemManage_Handler(void)
{
 8003a30:	e7fe      	b.n	8003a30 <MemManage_Handler>

08003a32 <BusFault_Handler>:

/**
* @brief This function handles Pre-fetch fault, memory access fault.
*/
void BusFault_Handler(void)
{
 8003a32:	e7fe      	b.n	8003a32 <BusFault_Handler>

08003a34 <UsageFault_Handler>:

/**
* @brief This function handles Undefined instruction or illegal state.
*/
void UsageFault_Handler(void)
{
 8003a34:	e7fe      	b.n	8003a34 <UsageFault_Handler>

08003a36 <SVC_Handler>:

/**
* @brief This function handles System service call via SWI instruction.
*/
void SVC_Handler(void)
{
 8003a36:	4770      	bx	lr

08003a38 <DebugMon_Handler>:

/**
* @brief This function handles Debug monitor.
*/
void DebugMon_Handler(void)
{
 8003a38:	4770      	bx	lr

08003a3a <PendSV_Handler>:

/**
* @brief This function handles Pendable request for system service.
*/
void PendSV_Handler(void)
{
 8003a3a:	4770      	bx	lr

08003a3c <OTG_FS_IRQHandler>:

/**
* @brief This function handles USB On The Go FS global interrupt.
*/
void OTG_FS_IRQHandler(void)
{
 8003a3c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8003a3e:	4802      	ldr	r0, [pc, #8]	; (8003a48 <OTG_FS_IRQHandler+0xc>)
 8003a40:	f7fc ffde 	bl	8000a00 <HAL_PCD_IRQHandler>
 8003a44:	bd08      	pop	{r3, pc}
 8003a46:	bf00      	nop
 8003a48:	200081dc 	.word	0x200081dc

08003a4c <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8003a4c:	490f      	ldr	r1, [pc, #60]	; (8003a8c <SystemInit+0x40>)
 8003a4e:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8003a52:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8003a56:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8003a5a:	4b0d      	ldr	r3, [pc, #52]	; (8003a90 <SystemInit+0x44>)
 8003a5c:	681a      	ldr	r2, [r3, #0]
 8003a5e:	f042 0201 	orr.w	r2, r2, #1
 8003a62:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8003a64:	2000      	movs	r0, #0
 8003a66:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8003a68:	681a      	ldr	r2, [r3, #0]
 8003a6a:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8003a6e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003a72:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8003a74:	4a07      	ldr	r2, [pc, #28]	; (8003a94 <SystemInit+0x48>)
 8003a76:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003a78:	681a      	ldr	r2, [r3, #0]
 8003a7a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003a7e:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8003a80:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8003a82:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003a86:	608b      	str	r3, [r1, #8]
 8003a88:	4770      	bx	lr
 8003a8a:	bf00      	nop
 8003a8c:	e000ed00 	.word	0xe000ed00
 8003a90:	40023800 	.word	0x40023800
 8003a94:	24003010 	.word	0x24003010

08003a98 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 8003a98:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PreTreatment */
  
  /* Init Device Library, add supported class and start the library. */
  USBD_Init(&hUsbDeviceFS, &USR_desc, DEVICE_FS);
 8003a9a:	4c09      	ldr	r4, [pc, #36]	; (8003ac0 <MX_USB_DEVICE_Init+0x28>)
 8003a9c:	2200      	movs	r2, #0
 8003a9e:	4909      	ldr	r1, [pc, #36]	; (8003ac4 <MX_USB_DEVICE_Init+0x2c>)
 8003aa0:	4620      	mov	r0, r4
 8003aa2:	f7ff f97a 	bl	8002d9a <USBD_Init>

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC);
 8003aa6:	4908      	ldr	r1, [pc, #32]	; (8003ac8 <MX_USB_DEVICE_Init+0x30>)
 8003aa8:	4620      	mov	r0, r4
 8003aaa:	f7ff f98d 	bl	8002dc8 <USBD_RegisterClass>

  USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS);
 8003aae:	4907      	ldr	r1, [pc, #28]	; (8003acc <MX_USB_DEVICE_Init+0x34>)
 8003ab0:	4620      	mov	r0, r4
 8003ab2:	f7ff f96b 	bl	8002d8c <USBD_CDC_RegisterInterface>

  USBD_Start(&hUsbDeviceFS);
 8003ab6:	4620      	mov	r0, r4
 8003ab8:	f7ff f98d 	bl	8002dd6 <USBD_Start>
 8003abc:	bd10      	pop	{r4, pc}
 8003abe:	bf00      	nop
 8003ac0:	20007fb8 	.word	0x20007fb8
 8003ac4:	2000012c 	.word	0x2000012c
 8003ac8:	20000008 	.word	0x20000008
 8003acc:	20000104 	.word	0x20000104

08003ad0 <CDC_Init_FS>:
{
  /* USER CODE BEGIN 3 */
  /* Set Application Buffers */
  /* USER CODE END 3 */
	return (USBD_OK);
}
 8003ad0:	2000      	movs	r0, #0
 8003ad2:	4770      	bx	lr

08003ad4 <CDC_DeInit_FS>:
static int8_t CDC_DeInit_FS(void)
{
	  return (USBD_OK);


}
 8003ad4:	2000      	movs	r0, #0
 8003ad6:	4770      	bx	lr

08003ad8 <CDC_Control_FS>:
  */
static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
	  return (USBD_OK);

}
 8003ad8:	2000      	movs	r0, #0
 8003ada:	4770      	bx	lr

08003adc <CDC_Receive_FS>:
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
  /* USER CODE END 6 */
	  return (USBD_OK);

}
 8003adc:	2000      	movs	r0, #0
 8003ade:	4770      	bx	lr

08003ae0 <HAL_PCD_MspInit>:
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 8003ae0:	6803      	ldr	r3, [r0, #0]
 8003ae2:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8003ae6:	d000      	beq.n	8003aea <HAL_PCD_MspInit+0xa>
 8003ae8:	4770      	bx	lr
{
 8003aea:	b530      	push	{r4, r5, lr}
 8003aec:	b087      	sub	sp, #28
    PA8     ------> USB_OTG_FS_SOF
    PA9     ------> USB_OTG_FS_VBUS
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12;
 8003aee:	f44f 53c8 	mov.w	r3, #6400	; 0x1900
 8003af2:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8003af4:	2302      	movs	r3, #2
 8003af6:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003af8:	2400      	movs	r4, #0
 8003afa:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8003afc:	2303      	movs	r3, #3
 8003afe:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8003b00:	230a      	movs	r3, #10
 8003b02:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003b04:	4d13      	ldr	r5, [pc, #76]	; (8003b54 <HAL_PCD_MspInit+0x74>)
 8003b06:	a901      	add	r1, sp, #4
 8003b08:	4628      	mov	r0, r5
 8003b0a:	f7fc fe2b 	bl	8000764 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9;
 8003b0e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003b12:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8003b14:	9402      	str	r4, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003b16:	9403      	str	r4, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003b18:	a901      	add	r1, sp, #4
 8003b1a:	4628      	mov	r0, r5
 8003b1c:	f7fc fe22 	bl	8000764 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8003b20:	4b0d      	ldr	r3, [pc, #52]	; (8003b58 <HAL_PCD_MspInit+0x78>)
 8003b22:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003b24:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003b28:	635a      	str	r2, [r3, #52]	; 0x34
 8003b2a:	9400      	str	r4, [sp, #0]
 8003b2c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003b2e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8003b32:	645a      	str	r2, [r3, #68]	; 0x44
 8003b34:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003b36:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8003b3a:	9300      	str	r3, [sp, #0]
 8003b3c:	9b00      	ldr	r3, [sp, #0]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 8003b3e:	4622      	mov	r2, r4
 8003b40:	4621      	mov	r1, r4
 8003b42:	2043      	movs	r0, #67	; 0x43
 8003b44:	f7fc fdaa 	bl	800069c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8003b48:	2043      	movs	r0, #67	; 0x43
 8003b4a:	f7fc fdd7 	bl	80006fc <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8003b4e:	b007      	add	sp, #28
 8003b50:	bd30      	pop	{r4, r5, pc}
 8003b52:	bf00      	nop
 8003b54:	40020000 	.word	0x40020000
 8003b58:	40023800 	.word	0x40023800

08003b5c <HAL_PCD_SetupStageCallback>:
  * @brief  Setup stage callback
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
 8003b5c:	b508      	push	{r3, lr}
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8003b5e:	f500 716f 	add.w	r1, r0, #956	; 0x3bc
 8003b62:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003b66:	f7ff f94f 	bl	8002e08 <USBD_LL_SetupStage>
 8003b6a:	bd08      	pop	{r3, pc}

08003b6c <HAL_PCD_DataOutStageCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8003b6c:	b508      	push	{r3, lr}
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8003b6e:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8003b72:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8003b76:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8003b7a:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003b7e:	f7ff f970 	bl	8002e62 <USBD_LL_DataOutStage>
 8003b82:	bd08      	pop	{r3, pc}

08003b84 <HAL_PCD_DataInStageCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8003b84:	b508      	push	{r3, lr}
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8003b86:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8003b8a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8003b8e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003b90:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003b94:	f7ff f99a 	bl	8002ecc <USBD_LL_DataInStage>
 8003b98:	bd08      	pop	{r3, pc}

08003b9a <HAL_PCD_SOFCallback>:
  * @brief  SOF callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
 8003b9a:	b508      	push	{r3, lr}
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8003b9c:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003ba0:	f7ff fa1e 	bl	8002fe0 <USBD_LL_SOF>
 8003ba4:	bd08      	pop	{r3, pc}

08003ba6 <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 8003ba6:	b510      	push	{r4, lr}
 8003ba8:	4604      	mov	r4, r0
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  /* Set USB current speed. */
  switch (hpcd->Init.speed)
 8003baa:	68c1      	ldr	r1, [r0, #12]
	
  default:
    speed = USBD_SPEED_FULL;
    break;    
  }
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8003bac:	3100      	adds	r1, #0
 8003bae:	bf18      	it	ne
 8003bb0:	2101      	movne	r1, #1
 8003bb2:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003bb6:	f7ff fa01 	bl	8002fbc <USBD_LL_SetSpeed>
  
  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8003bba:	f8d4 03ec 	ldr.w	r0, [r4, #1004]	; 0x3ec
 8003bbe:	f7ff f9de 	bl	8002f7e <USBD_LL_Reset>
 8003bc2:	bd10      	pop	{r4, pc}

08003bc4 <HAL_PCD_SuspendCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
 8003bc4:	b510      	push	{r4, lr}
 8003bc6:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8003bc8:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003bcc:	f7ff f9f9 	bl	8002fc2 <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8003bd0:	6822      	ldr	r2, [r4, #0]
 8003bd2:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 8003bd6:	f043 0301 	orr.w	r3, r3, #1
 8003bda:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8003bde:	6a23      	ldr	r3, [r4, #32]
 8003be0:	b123      	cbz	r3, 8003bec <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8003be2:	4a03      	ldr	r2, [pc, #12]	; (8003bf0 <HAL_PCD_SuspendCallback+0x2c>)
 8003be4:	6913      	ldr	r3, [r2, #16]
 8003be6:	f043 0306 	orr.w	r3, r3, #6
 8003bea:	6113      	str	r3, [r2, #16]
 8003bec:	bd10      	pop	{r4, pc}
 8003bee:	bf00      	nop
 8003bf0:	e000ed00 	.word	0xe000ed00

08003bf4 <HAL_PCD_ResumeCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
 8003bf4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8003bf6:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003bfa:	f7ff f9eb 	bl	8002fd4 <USBD_LL_Resume>
 8003bfe:	bd08      	pop	{r3, pc}

08003c00 <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8003c00:	b508      	push	{r3, lr}
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8003c02:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003c06:	f7ff f9fb 	bl	8003000 <USBD_LL_IsoOUTIncomplete>
 8003c0a:	bd08      	pop	{r3, pc}

08003c0c <HAL_PCD_ISOINIncompleteCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8003c0c:	b508      	push	{r3, lr}
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8003c0e:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003c12:	f7ff f9f3 	bl	8002ffc <USBD_LL_IsoINIncomplete>
 8003c16:	bd08      	pop	{r3, pc}

08003c18 <HAL_PCD_ConnectCallback>:
  * @brief  Connect callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
 8003c18:	b508      	push	{r3, lr}
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 8003c1a:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003c1e:	f7ff f9f1 	bl	8003004 <USBD_LL_DevConnected>
 8003c22:	bd08      	pop	{r3, pc}

08003c24 <HAL_PCD_DisconnectCallback>:
  * @brief  Disconnect callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
 8003c24:	b508      	push	{r3, lr}
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 8003c26:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003c2a:	f7ff f9ed 	bl	8003008 <USBD_LL_DevDisconnected>
 8003c2e:	bd08      	pop	{r3, pc}

08003c30 <USBD_LL_Init>:
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 8003c30:	7803      	ldrb	r3, [r0, #0]
 8003c32:	b10b      	cbz	r3, 8003c38 <USBD_LL_Init+0x8>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
  }
  return USBD_OK;
}
 8003c34:	2000      	movs	r0, #0
 8003c36:	4770      	bx	lr
{
 8003c38:	b510      	push	{r4, lr}
 8003c3a:	4603      	mov	r3, r0
  hpcd_USB_OTG_FS.pData = pdev;
 8003c3c:	4817      	ldr	r0, [pc, #92]	; (8003c9c <USBD_LL_Init+0x6c>)
 8003c3e:	f8c0 33ec 	str.w	r3, [r0, #1004]	; 0x3ec
  pdev->pData = &hpcd_USB_OTG_FS;
 8003c42:	f8c3 0220 	str.w	r0, [r3, #544]	; 0x220
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8003c46:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8003c4a:	6003      	str	r3, [r0, #0]
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 8003c4c:	2304      	movs	r3, #4
 8003c4e:	6043      	str	r3, [r0, #4]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8003c50:	2202      	movs	r2, #2
 8003c52:	60c2      	str	r2, [r0, #12]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 8003c54:	2300      	movs	r3, #0
 8003c56:	6103      	str	r3, [r0, #16]
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 8003c58:	6143      	str	r3, [r0, #20]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8003c5a:	6182      	str	r2, [r0, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = ENABLE;
 8003c5c:	2201      	movs	r2, #1
 8003c5e:	61c2      	str	r2, [r0, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8003c60:	6203      	str	r3, [r0, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8003c62:	6243      	str	r3, [r0, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 8003c64:	62c2      	str	r2, [r0, #44]	; 0x2c
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 8003c66:	6303      	str	r3, [r0, #48]	; 0x30
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8003c68:	f7fc fe4a 	bl	8000900 <HAL_PCD_Init>
 8003c6c:	b980      	cbnz	r0, 8003c90 <USBD_LL_Init+0x60>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 8003c6e:	4c0b      	ldr	r4, [pc, #44]	; (8003c9c <USBD_LL_Init+0x6c>)
 8003c70:	2180      	movs	r1, #128	; 0x80
 8003c72:	4620      	mov	r0, r4
 8003c74:	f7fd fb35 	bl	80012e2 <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8003c78:	2240      	movs	r2, #64	; 0x40
 8003c7a:	2100      	movs	r1, #0
 8003c7c:	4620      	mov	r0, r4
 8003c7e:	f7fd fb0b 	bl	8001298 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 8003c82:	2280      	movs	r2, #128	; 0x80
 8003c84:	2101      	movs	r1, #1
 8003c86:	4620      	mov	r0, r4
 8003c88:	f7fd fb06 	bl	8001298 <HAL_PCDEx_SetTxFiFo>
}
 8003c8c:	2000      	movs	r0, #0
 8003c8e:	bd10      	pop	{r4, pc}
    _Error_Handler(__FILE__, __LINE__);
 8003c90:	f240 1153 	movw	r1, #339	; 0x153
 8003c94:	4802      	ldr	r0, [pc, #8]	; (8003ca0 <USBD_LL_Init+0x70>)
 8003c96:	f7ff fe8b 	bl	80039b0 <_Error_Handler>
 8003c9a:	e7e8      	b.n	8003c6e <USBD_LL_Init+0x3e>
 8003c9c:	200081dc 	.word	0x200081dc
 8003ca0:	080091d4 	.word	0x080091d4

08003ca4 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver. 
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8003ca4:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
 
  hal_status = HAL_PCD_Start(pdev->pData);
 8003ca6:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003caa:	f7fc fe93 	bl	80009d4 <HAL_PCD_Start>
     
  switch (hal_status) {
 8003cae:	b120      	cbz	r0, 8003cba <USBD_LL_Start+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003cb0:	2802      	cmp	r0, #2
 8003cb2:	bf0c      	ite	eq
 8003cb4:	2001      	moveq	r0, #1
 8003cb6:	2002      	movne	r0, #2
 8003cb8:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003cba:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003cbc:	bd08      	pop	{r3, pc}

08003cbe <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8003cbe:	b510      	push	{r4, lr}
 8003cc0:	461c      	mov	r4, r3
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8003cc2:	4613      	mov	r3, r2
 8003cc4:	4622      	mov	r2, r4
 8003cc6:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003cca:	f7fd f9c3 	bl	8001054 <HAL_PCD_EP_Open>

  switch (hal_status) {
 8003cce:	b120      	cbz	r0, 8003cda <USBD_LL_OpenEP+0x1c>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003cd0:	2802      	cmp	r0, #2
 8003cd2:	bf0c      	ite	eq
 8003cd4:	2001      	moveq	r0, #1
 8003cd6:	2002      	movne	r0, #2
 8003cd8:	bd10      	pop	{r4, pc}
      usb_status = USBD_OK;
 8003cda:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003cdc:	bd10      	pop	{r4, pc}

08003cde <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003cde:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8003ce0:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003ce4:	f7fd f9f7 	bl	80010d6 <HAL_PCD_EP_Close>
      
  switch (hal_status) {
 8003ce8:	b120      	cbz	r0, 8003cf4 <USBD_LL_CloseEP+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003cea:	2802      	cmp	r0, #2
 8003cec:	bf0c      	ite	eq
 8003cee:	2001      	moveq	r0, #1
 8003cf0:	2002      	movne	r0, #2
 8003cf2:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003cf4:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 8003cf6:	bd08      	pop	{r3, pc}

08003cf8 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003cf8:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8003cfa:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003cfe:	f7fd fa6d 	bl	80011dc <HAL_PCD_EP_SetStall>

  switch (hal_status) {
 8003d02:	b120      	cbz	r0, 8003d0e <USBD_LL_StallEP+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003d04:	2802      	cmp	r0, #2
 8003d06:	bf0c      	ite	eq
 8003d08:	2001      	moveq	r0, #1
 8003d0a:	2002      	movne	r0, #2
 8003d0c:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003d0e:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 8003d10:	bd08      	pop	{r3, pc}

08003d12 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003d12:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 8003d14:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003d18:	f7fd fa93 	bl	8001242 <HAL_PCD_EP_ClrStall>
     
  switch (hal_status) {
 8003d1c:	b120      	cbz	r0, 8003d28 <USBD_LL_ClearStallEP+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003d1e:	2802      	cmp	r0, #2
 8003d20:	bf0c      	ite	eq
 8003d22:	2001      	moveq	r0, #1
 8003d24:	2002      	movne	r0, #2
 8003d26:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003d28:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status; 
}
 8003d2a:	bd08      	pop	{r3, pc}

08003d2c <USBD_LL_IsStallEP>:
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8003d2c:	f8d0 2220 	ldr.w	r2, [r0, #544]	; 0x220
  
  if((ep_addr & 0x80) == 0x80)
 8003d30:	f011 0f80 	tst.w	r1, #128	; 0x80
 8003d34:	d108      	bne.n	8003d48 <USBD_LL_IsStallEP+0x1c>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8003d36:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8003d3a:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8003d3e:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8003d42:	f891 01fa 	ldrb.w	r0, [r1, #506]	; 0x1fa
  }
}
 8003d46:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8003d48:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8003d4c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8003d50:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8003d54:	f893 003a 	ldrb.w	r0, [r3, #58]	; 0x3a
 8003d58:	4770      	bx	lr

08003d5a <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8003d5a:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8003d5c:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003d60:	f7fd f966 	bl	8001030 <HAL_PCD_SetAddress>
     
  switch (hal_status) {
 8003d64:	b120      	cbz	r0, 8003d70 <USBD_LL_SetUSBAddress+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003d66:	2802      	cmp	r0, #2
 8003d68:	bf0c      	ite	eq
 8003d6a:	2001      	moveq	r0, #1
 8003d6c:	2002      	movne	r0, #2
 8003d6e:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003d70:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 8003d72:	bd08      	pop	{r3, pc}

08003d74 <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size    
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8003d74:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8003d76:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003d7a:	f7fd fa06 	bl	800118a <HAL_PCD_EP_Transmit>
     
  switch (hal_status) {
 8003d7e:	b120      	cbz	r0, 8003d8a <USBD_LL_Transmit+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003d80:	2802      	cmp	r0, #2
 8003d82:	bf0c      	ite	eq
 8003d84:	2001      	moveq	r0, #1
 8003d86:	2002      	movne	r0, #2
 8003d88:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003d8a:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;    
}
 8003d8c:	bd08      	pop	{r3, pc}

08003d8e <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8003d8e:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8003d90:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003d94:	f7fd f9c3 	bl	800111e <HAL_PCD_EP_Receive>
     
  switch (hal_status) {
 8003d98:	b120      	cbz	r0, 8003da4 <USBD_LL_PrepareReceive+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003d9a:	2802      	cmp	r0, #2
 8003d9c:	bf0c      	ite	eq
 8003d9e:	2001      	moveq	r0, #1
 8003da0:	2002      	movne	r0, #2
 8003da2:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003da4:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status; 
}
 8003da6:	bd08      	pop	{r3, pc}

08003da8 <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003da8:	b508      	push	{r3, lr}
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 8003daa:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003dae:	f7fd f9e3 	bl	8001178 <HAL_PCD_EP_GetRxCount>
}
 8003db2:	bd08      	pop	{r3, pc}

08003db4 <USBD_USR_DeviceDescriptor>:
     HIBYTE(USBD_LANGID_STRING),
};

uint8_t *USBD_USR_DeviceDescriptor(uint8_t speed , uint16_t *length)
{
    *length = sizeof(USBD_DeviceDesc);
 8003db4:	2312      	movs	r3, #18
 8003db6:	800b      	strh	r3, [r1, #0]
    return USBD_DeviceDesc;
}
 8003db8:	4800      	ldr	r0, [pc, #0]	; (8003dbc <USBD_USR_DeviceDescriptor+0x8>)
 8003dba:	4770      	bx	lr
 8003dbc:	20000114 	.word	0x20000114

08003dc0 <USBD_USR_LangIDStrDescriptor>:

uint8_t *USBD_USR_LangIDStrDescriptor(uint8_t speed , uint16_t *length)
{
    *length =  sizeof(USBD_LangIDDesc);
 8003dc0:	2304      	movs	r3, #4
 8003dc2:	800b      	strh	r3, [r1, #0]
    return USBD_LangIDDesc;
}
 8003dc4:	4800      	ldr	r0, [pc, #0]	; (8003dc8 <USBD_USR_LangIDStrDescriptor+0x8>)
 8003dc6:	4770      	bx	lr
 8003dc8:	20000128 	.word	0x20000128

08003dcc <USBD_USR_ProductStrDescriptor>:

uint8_t *USBD_USR_ProductStrDescriptor(uint8_t speed , uint16_t *length)
{
 8003dcc:	b508      	push	{r3, lr}
 8003dce:	460a      	mov	r2, r1
    {
        USBD_GetString((uint8_t *)USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
    }
    else
    {
        USBD_GetString((uint8_t *)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);
 8003dd0:	4902      	ldr	r1, [pc, #8]	; (8003ddc <USBD_USR_ProductStrDescriptor+0x10>)
 8003dd2:	4803      	ldr	r0, [pc, #12]	; (8003de0 <USBD_USR_ProductStrDescriptor+0x14>)
 8003dd4:	f7ff fb59 	bl	800348a <USBD_GetString>
    }
    return USBD_StrDesc;
}
 8003dd8:	4800      	ldr	r0, [pc, #0]	; (8003ddc <USBD_USR_ProductStrDescriptor+0x10>)
 8003dda:	bd08      	pop	{r3, pc}
 8003ddc:	200085cc 	.word	0x200085cc
 8003de0:	08009218 	.word	0x08009218

08003de4 <USBD_USR_ManufacturerStrDescriptor>:

uint8_t *USBD_USR_ManufacturerStrDescriptor( uint8_t speed , uint16_t *length)
{
 8003de4:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8003de6:	4c04      	ldr	r4, [pc, #16]	; (8003df8 <USBD_USR_ManufacturerStrDescriptor+0x14>)
 8003de8:	460a      	mov	r2, r1
 8003dea:	4621      	mov	r1, r4
 8003dec:	4803      	ldr	r0, [pc, #12]	; (8003dfc <USBD_USR_ManufacturerStrDescriptor+0x18>)
 8003dee:	f7ff fb4c 	bl	800348a <USBD_GetString>
    return USBD_StrDesc;
}
 8003df2:	4620      	mov	r0, r4
 8003df4:	bd10      	pop	{r4, pc}
 8003df6:	bf00      	nop
 8003df8:	200085cc 	.word	0x200085cc
 8003dfc:	08009208 	.word	0x08009208

08003e00 <USBD_USR_SerialStrDescriptor>:

uint8_t *USBD_USR_SerialStrDescriptor( uint8_t speed , uint16_t *length)
{
 8003e00:	b508      	push	{r3, lr}
 8003e02:	460a      	mov	r2, r1
    if(speed  == USB_OTG_SPEED_HIGH)
 8003e04:	b128      	cbz	r0, 8003e12 <USBD_USR_SerialStrDescriptor+0x12>
    {
        USBD_GetString((uint8_t *)USBD_SERIALNUMBER_HS_STRING, USBD_StrDesc, length);
    }
    else
    {
        USBD_GetString((uint8_t *)USBD_SERIALNUMBER_FS_STRING, USBD_StrDesc, length);
 8003e06:	4905      	ldr	r1, [pc, #20]	; (8003e1c <USBD_USR_SerialStrDescriptor+0x1c>)
 8003e08:	4805      	ldr	r0, [pc, #20]	; (8003e20 <USBD_USR_SerialStrDescriptor+0x20>)
 8003e0a:	f7ff fb3e 	bl	800348a <USBD_GetString>
    }
    return USBD_StrDesc;
}
 8003e0e:	4803      	ldr	r0, [pc, #12]	; (8003e1c <USBD_USR_SerialStrDescriptor+0x1c>)
 8003e10:	bd08      	pop	{r3, pc}
        USBD_GetString((uint8_t *)USBD_SERIALNUMBER_HS_STRING, USBD_StrDesc, length);
 8003e12:	4902      	ldr	r1, [pc, #8]	; (8003e1c <USBD_USR_SerialStrDescriptor+0x1c>)
 8003e14:	4803      	ldr	r0, [pc, #12]	; (8003e24 <USBD_USR_SerialStrDescriptor+0x24>)
 8003e16:	f7ff fb38 	bl	800348a <USBD_GetString>
 8003e1a:	e7f8      	b.n	8003e0e <USBD_USR_SerialStrDescriptor+0xe>
 8003e1c:	200085cc 	.word	0x200085cc
 8003e20:	08009238 	.word	0x08009238
 8003e24:	08009228 	.word	0x08009228

08003e28 <USBD_USR_ConfigStrDescriptor>:

uint8_t *USBD_USR_ConfigStrDescriptor( uint8_t speed , uint16_t *length)
{
 8003e28:	b508      	push	{r3, lr}
 8003e2a:	460a      	mov	r2, r1
    {
        USBD_GetString((uint8_t *)USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
    }
    else
    {
        USBD_GetString((uint8_t *)USBD_CONFIGURATION_FS_STRING, USBD_StrDesc, length);
 8003e2c:	4902      	ldr	r1, [pc, #8]	; (8003e38 <USBD_USR_ConfigStrDescriptor+0x10>)
 8003e2e:	4803      	ldr	r0, [pc, #12]	; (8003e3c <USBD_USR_ConfigStrDescriptor+0x14>)
 8003e30:	f7ff fb2b 	bl	800348a <USBD_GetString>
    }
    return USBD_StrDesc;
}
 8003e34:	4800      	ldr	r0, [pc, #0]	; (8003e38 <USBD_USR_ConfigStrDescriptor+0x10>)
 8003e36:	bd08      	pop	{r3, pc}
 8003e38:	200085cc 	.word	0x200085cc
 8003e3c:	080091e8 	.word	0x080091e8

08003e40 <USBD_USR_InterfaceStrDescriptor>:

uint8_t *USBD_USR_InterfaceStrDescriptor( uint8_t speed , uint16_t *length)
{
 8003e40:	b508      	push	{r3, lr}
 8003e42:	460a      	mov	r2, r1
    {
        USBD_GetString((uint8_t *)USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
    }
    else
    {
        USBD_GetString((uint8_t *)USBD_INTERFACE_FS_STRING, USBD_StrDesc, length);
 8003e44:	4902      	ldr	r1, [pc, #8]	; (8003e50 <USBD_USR_InterfaceStrDescriptor+0x10>)
 8003e46:	4803      	ldr	r0, [pc, #12]	; (8003e54 <USBD_USR_InterfaceStrDescriptor+0x14>)
 8003e48:	f7ff fb1f 	bl	800348a <USBD_GetString>
    }
    return USBD_StrDesc;
}
 8003e4c:	4800      	ldr	r0, [pc, #0]	; (8003e50 <USBD_USR_InterfaceStrDescriptor+0x10>)
 8003e4e:	bd08      	pop	{r3, pc}
 8003e50:	200085cc 	.word	0x200085cc
 8003e54:	080091f8 	.word	0x080091f8

08003e58 <entry_by_mac>:
			return &config->entries[i];
	return NULL;
}

static dhcp_entry_t *entry_by_mac(uint8_t *mac)
{
 8003e58:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int i;
	for (i = 0; i < config->num_entry; i++)
 8003e5c:	4b0e      	ldr	r3, [pc, #56]	; (8003e98 <entry_by_mac+0x40>)
 8003e5e:	681b      	ldr	r3, [r3, #0]
 8003e60:	f8d3 8010 	ldr.w	r8, [r3, #16]
 8003e64:	f1b8 0f00 	cmp.w	r8, #0
 8003e68:	dd13      	ble.n	8003e92 <entry_by_mac+0x3a>
 8003e6a:	4606      	mov	r6, r0
 8003e6c:	695c      	ldr	r4, [r3, #20]
		if (memcmp(config->entries[i].mac, mac, 6) == 0)
 8003e6e:	2500      	movs	r5, #0
 8003e70:	f04f 0906 	mov.w	r9, #6
 8003e74:	4627      	mov	r7, r4
 8003e76:	464a      	mov	r2, r9
 8003e78:	4631      	mov	r1, r6
 8003e7a:	4620      	mov	r0, r4
 8003e7c:	f005 f928 	bl	80090d0 <memcmp>
 8003e80:	b120      	cbz	r0, 8003e8c <entry_by_mac+0x34>
	for (i = 0; i < config->num_entry; i++)
 8003e82:	3501      	adds	r5, #1
 8003e84:	3414      	adds	r4, #20
 8003e86:	4545      	cmp	r5, r8
 8003e88:	d1f4      	bne.n	8003e74 <entry_by_mac+0x1c>
			return &config->entries[i];
	return NULL;
 8003e8a:	2700      	movs	r7, #0
}
 8003e8c:	4638      	mov	r0, r7
 8003e8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return NULL;
 8003e92:	2700      	movs	r7, #0
 8003e94:	e7fa      	b.n	8003e8c <entry_by_mac+0x34>
 8003e96:	bf00      	nop
 8003e98:	20000de8 	.word	0x20000de8

08003e9c <find_dhcp_option>:
{
	memset(entry->mac, 0, 6);
}

uint8_t *find_dhcp_option(uint8_t *attrs, int size, uint8_t attr)
{
 8003e9c:	b430      	push	{r4, r5}
	int i = 0;
 8003e9e:	2300      	movs	r3, #0
	while ((i + 1) < size)
 8003ea0:	1c5c      	adds	r4, r3, #1
 8003ea2:	428c      	cmp	r4, r1
 8003ea4:	da0b      	bge.n	8003ebe <find_dhcp_option+0x22>
	{
		int next = i + attrs[i + 1] + 2;
 8003ea6:	461c      	mov	r4, r3
 8003ea8:	18c5      	adds	r5, r0, r3
 8003eaa:	786d      	ldrb	r5, [r5, #1]
 8003eac:	442b      	add	r3, r5
 8003eae:	3302      	adds	r3, #2
		if (next > size) return NULL;
 8003eb0:	4299      	cmp	r1, r3
 8003eb2:	db08      	blt.n	8003ec6 <find_dhcp_option+0x2a>
		if (attrs[i] == attr)
 8003eb4:	1905      	adds	r5, r0, r4
 8003eb6:	5d04      	ldrb	r4, [r0, r4]
 8003eb8:	4294      	cmp	r4, r2
 8003eba:	d1f1      	bne.n	8003ea0 <find_dhcp_option+0x4>
 8003ebc:	e000      	b.n	8003ec0 <find_dhcp_option+0x24>
			return attrs + i;
		i = next;
	}
	return NULL;
 8003ebe:	2500      	movs	r5, #0
}
 8003ec0:	4628      	mov	r0, r5
 8003ec2:	bc30      	pop	{r4, r5}
 8003ec4:	4770      	bx	lr
		if (next > size) return NULL;
 8003ec6:	2500      	movs	r5, #0
 8003ec8:	e7fa      	b.n	8003ec0 <find_dhcp_option+0x24>

08003eca <fill_options>:
	uint32_t dns,
	int lease_time,
	uint32_t serverid,
	uint32_t router,
	uint32_t subnet)
{
 8003eca:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003ece:	4604      	mov	r4, r0
 8003ed0:	4617      	mov	r7, r2
 8003ed2:	4698      	mov	r8, r3
 8003ed4:	9b08      	ldr	r3, [sp, #32]
 8003ed6:	9d0a      	ldr	r5, [sp, #40]	; 0x28
	uint8_t *ptr = (uint8_t *)dest;
	/* ACK message type */
	*ptr++ = 53;
 8003ed8:	2235      	movs	r2, #53	; 0x35
 8003eda:	7002      	strb	r2, [r0, #0]
	*ptr++ = 1;
 8003edc:	2001      	movs	r0, #1
 8003ede:	7060      	strb	r0, [r4, #1]
	*ptr++ = msg_type;
 8003ee0:	70a1      	strb	r1, [r4, #2]

	/* dhcp server identifier */
	*ptr++ = DHCP_SERVERID;
 8003ee2:	2236      	movs	r2, #54	; 0x36
 8003ee4:	70e2      	strb	r2, [r4, #3]
	*ptr++ = 4;
 8003ee6:	2204      	movs	r2, #4
 8003ee8:	7122      	strb	r2, [r4, #4]
	*(uint32_t *)ptr = serverid;
 8003eea:	9909      	ldr	r1, [sp, #36]	; 0x24
 8003eec:	f8c4 1005 	str.w	r1, [r4, #5]
	ptr += 4;

	/* lease time */
	*ptr++ = DHCP_LEASETIME;
 8003ef0:	2133      	movs	r1, #51	; 0x33
 8003ef2:	7261      	strb	r1, [r4, #9]
	*ptr++ = 4;
 8003ef4:	72a2      	strb	r2, [r4, #10]
	*ptr++ = (lease_time >> 24) & 0xFF;
 8003ef6:	0e19      	lsrs	r1, r3, #24
 8003ef8:	72e1      	strb	r1, [r4, #11]
	*ptr++ = (lease_time >> 16) & 0xFF;
 8003efa:	1419      	asrs	r1, r3, #16
 8003efc:	7321      	strb	r1, [r4, #12]
	*ptr++ = (lease_time >> 8) & 0xFF;
 8003efe:	1219      	asrs	r1, r3, #8
 8003f00:	7361      	strb	r1, [r4, #13]
	*ptr++ = (lease_time >> 0) & 0xFF;
 8003f02:	73a3      	strb	r3, [r4, #14]

	/* subnet mask */
	*ptr++ = DHCP_SUBNETMASK;
 8003f04:	73e0      	strb	r0, [r4, #15]
	*ptr++ = 4;
 8003f06:	7422      	strb	r2, [r4, #16]
	*(uint32_t *)ptr = subnet;
 8003f08:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8003f0a:	f8c4 3011 	str.w	r3, [r4, #17]
	ptr += 4;

	/* router */
	if (router != 0)
 8003f0e:	bb15      	cbnz	r5, 8003f56 <fill_options+0x8c>
	ptr += 4;
 8003f10:	f104 0515 	add.w	r5, r4, #21
		*(uint32_t *)ptr = router;
		ptr += 4;
	}

	/* domain name */
	if (domain != NULL)
 8003f14:	b17f      	cbz	r7, 8003f36 <fill_options+0x6c>
	{
		int len = strlen(domain);
 8003f16:	4638      	mov	r0, r7
 8003f18:	f7fc f968 	bl	80001ec <strlen>
 8003f1c:	4681      	mov	r9, r0
		*ptr++ = DHCP_DNSDOMAIN;
 8003f1e:	462e      	mov	r6, r5
 8003f20:	230f      	movs	r3, #15
 8003f22:	f806 3b02 	strb.w	r3, [r6], #2
		*ptr++ = len;
 8003f26:	7068      	strb	r0, [r5, #1]
		memcpy(ptr, domain, len);
 8003f28:	4602      	mov	r2, r0
 8003f2a:	4639      	mov	r1, r7
 8003f2c:	4630      	mov	r0, r6
 8003f2e:	f005 f8de 	bl	80090ee <memcpy>
		ptr += len;
 8003f32:	eb06 0509 	add.w	r5, r6, r9
	}

	/* domain name server (DNS) */
	if (dns != 0)
 8003f36:	f1b8 0f00 	cmp.w	r8, #0
 8003f3a:	d006      	beq.n	8003f4a <fill_options+0x80>
	{
		*ptr++ = DHCP_DNSSERVER;
 8003f3c:	2306      	movs	r3, #6
 8003f3e:	702b      	strb	r3, [r5, #0]
		*ptr++ = 4;
 8003f40:	2304      	movs	r3, #4
 8003f42:	706b      	strb	r3, [r5, #1]
		*(uint32_t *)ptr = dns;
 8003f44:	f8c5 8002 	str.w	r8, [r5, #2]
		ptr += 4;
 8003f48:	3506      	adds	r5, #6
	}

	/* end */
	*ptr++ = DHCP_END;
 8003f4a:	23ff      	movs	r3, #255	; 0xff
 8003f4c:	f805 3b01 	strb.w	r3, [r5], #1
	return ptr - (uint8_t *)dest;
}
 8003f50:	1b28      	subs	r0, r5, r4
 8003f52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		*ptr++ = DHCP_ROUTER;
 8003f56:	2303      	movs	r3, #3
 8003f58:	7563      	strb	r3, [r4, #21]
		*ptr++ = 4;
 8003f5a:	2304      	movs	r3, #4
 8003f5c:	75a3      	strb	r3, [r4, #22]
		*(uint32_t *)ptr = router;
 8003f5e:	f8c4 5017 	str.w	r5, [r4, #23]
		ptr += 4;
 8003f62:	f104 051b 	add.w	r5, r4, #27
 8003f66:	e7d5      	b.n	8003f14 <fill_options+0x4a>

08003f68 <udp_recv_proc>:

static void udp_recv_proc(void *arg, struct udp_pcb *upcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
 8003f68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003f6c:	b087      	sub	sp, #28
 8003f6e:	460d      	mov	r5, r1
 8003f70:	4614      	mov	r4, r2
 8003f72:	f8bd 6040 	ldrh.w	r6, [sp, #64]	; 0x40
	dhcp_entry_t *entry;
	struct pbuf *pp;

	int n = p->len;
	if (n > sizeof(dhcp_data)) n = sizeof(dhcp_data);
	memcpy(&dhcp_data, p->payload, n);
 8003f76:	4f84      	ldr	r7, [pc, #528]	; (8004188 <udp_recv_proc+0x220>)
 8003f78:	8952      	ldrh	r2, [r2, #10]
 8003f7a:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
 8003f7e:	bf28      	it	cs
 8003f80:	f44f 7201 	movcs.w	r2, #516	; 0x204
 8003f84:	6861      	ldr	r1, [r4, #4]
 8003f86:	4638      	mov	r0, r7
 8003f88:	f005 f8b1 	bl	80090ee <memcpy>
	switch (dhcp_data.dp_options[2])
 8003f8c:	f897 30f2 	ldrb.w	r3, [r7, #242]	; 0xf2
 8003f90:	2b01      	cmp	r3, #1
 8003f92:	d007      	beq.n	8003fa4 <udp_recv_proc+0x3c>
 8003f94:	2b03      	cmp	r3, #3
 8003f96:	d070      	beq.n	800407a <udp_recv_proc+0x112>
			break;

		default:
				break;
	}
	pbuf_free(p);
 8003f98:	4620      	mov	r0, r4
 8003f9a:	f001 fc9c 	bl	80058d6 <pbuf_free>
}
 8003f9e:	b007      	add	sp, #28
 8003fa0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			entry = entry_by_mac(dhcp_data.dp_chaddr);
 8003fa4:	4879      	ldr	r0, [pc, #484]	; (800418c <udp_recv_proc+0x224>)
 8003fa6:	f7ff ff57 	bl	8003e58 <entry_by_mac>
			if (entry == NULL) entry = vacant_address();
 8003faa:	4681      	mov	r9, r0
 8003fac:	2800      	cmp	r0, #0
 8003fae:	d043      	beq.n	8004038 <udp_recv_proc+0xd0>
			dhcp_data.dp_op = 2; /* reply */
 8003fb0:	4f75      	ldr	r7, [pc, #468]	; (8004188 <udp_recv_proc+0x220>)
 8003fb2:	f04f 0a02 	mov.w	sl, #2
 8003fb6:	f887 a000 	strb.w	sl, [r7]
			dhcp_data.dp_secs = 0;
 8003fba:	f04f 0800 	mov.w	r8, #0
 8003fbe:	f8a7 8008 	strh.w	r8, [r7, #8]
			dhcp_data.dp_flags = 0;
 8003fc2:	f8a7 800a 	strh.w	r8, [r7, #10]
			*(uint32_t *)dhcp_data.dp_yiaddr = *(uint32_t *)entry->addr;
 8003fc6:	f8d9 3006 	ldr.w	r3, [r9, #6]
 8003fca:	613b      	str	r3, [r7, #16]
			memcpy(dhcp_data.dp_magic, magic_cookie, 4);
 8003fcc:	4b70      	ldr	r3, [pc, #448]	; (8004190 <udp_recv_proc+0x228>)
 8003fce:	681b      	ldr	r3, [r3, #0]
 8003fd0:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
			memset(dhcp_data.dp_options, 0, sizeof(dhcp_data.dp_options));
 8003fd4:	37f0      	adds	r7, #240	; 0xf0
 8003fd6:	f240 1213 	movw	r2, #275	; 0x113
 8003fda:	4641      	mov	r1, r8
 8003fdc:	4638      	mov	r0, r7
 8003fde:	f005 f891 	bl	8009104 <memset>
				config->domain,
 8003fe2:	4b6c      	ldr	r3, [pc, #432]	; (8004194 <udp_recv_proc+0x22c>)
 8003fe4:	681a      	ldr	r2, [r3, #0]
			fill_options(dhcp_data.dp_options,
 8003fe6:	6811      	ldr	r1, [r2, #0]
 8003fe8:	f8d2 3006 	ldr.w	r3, [r2, #6]
 8003fec:	68d2      	ldr	r2, [r2, #12]
 8003fee:	f8d9 000a 	ldr.w	r0, [r9, #10]
 8003ff2:	9003      	str	r0, [sp, #12]
 8003ff4:	9102      	str	r1, [sp, #8]
 8003ff6:	9101      	str	r1, [sp, #4]
 8003ff8:	f8d9 1010 	ldr.w	r1, [r9, #16]
 8003ffc:	9100      	str	r1, [sp, #0]
 8003ffe:	4651      	mov	r1, sl
 8004000:	4638      	mov	r0, r7
 8004002:	f7ff ff62 	bl	8003eca <fill_options>
			pp = pbuf_alloc(PBUF_TRANSPORT, sizeof(dhcp_data), PBUF_POOL);
 8004006:	2203      	movs	r2, #3
 8004008:	f44f 7101 	mov.w	r1, #516	; 0x204
 800400c:	4640      	mov	r0, r8
 800400e:	f001 fc91 	bl	8005934 <pbuf_alloc>
			if (pp == NULL) break;
 8004012:	4607      	mov	r7, r0
 8004014:	2800      	cmp	r0, #0
 8004016:	d0bf      	beq.n	8003f98 <udp_recv_proc+0x30>
			memcpy(pp->payload, &dhcp_data, sizeof(dhcp_data));
 8004018:	f44f 7201 	mov.w	r2, #516	; 0x204
 800401c:	495a      	ldr	r1, [pc, #360]	; (8004188 <udp_recv_proc+0x220>)
 800401e:	6840      	ldr	r0, [r0, #4]
 8004020:	f005 f865 	bl	80090ee <memcpy>
			udp_sendto(upcb, pp, IP_ADDR_BROADCAST, port);
 8004024:	4633      	mov	r3, r6
 8004026:	4a5c      	ldr	r2, [pc, #368]	; (8004198 <udp_recv_proc+0x230>)
 8004028:	4639      	mov	r1, r7
 800402a:	4628      	mov	r0, r5
 800402c:	f004 fbd4 	bl	80087d8 <udp_sendto>
			pbuf_free(pp);
 8004030:	4638      	mov	r0, r7
 8004032:	f001 fc50 	bl	80058d6 <pbuf_free>
			break;
 8004036:	e7af      	b.n	8003f98 <udp_recv_proc+0x30>
	for (i = 0; i < config->num_entry; i++)
 8004038:	4b56      	ldr	r3, [pc, #344]	; (8004194 <udp_recv_proc+0x22c>)
 800403a:	681b      	ldr	r3, [r3, #0]
 800403c:	f8d3 9010 	ldr.w	r9, [r3, #16]
 8004040:	f1b9 0f00 	cmp.w	r9, #0
 8004044:	dda8      	ble.n	8003f98 <udp_recv_proc+0x30>
		if (is_vacant(config->entries + i))
 8004046:	695b      	ldr	r3, [r3, #20]
 8004048:	9305      	str	r3, [sp, #20]
 800404a:	461f      	mov	r7, r3
 800404c:	f04f 0800 	mov.w	r8, #0
	return memcmp("\0\0\0\0\0", entry->mac, 6) == 0;
 8004050:	f8df b14c 	ldr.w	fp, [pc, #332]	; 80041a0 <udp_recv_proc+0x238>
 8004054:	f04f 0a06 	mov.w	sl, #6
 8004058:	4652      	mov	r2, sl
 800405a:	4639      	mov	r1, r7
 800405c:	4658      	mov	r0, fp
 800405e:	f005 f837 	bl	80090d0 <memcmp>
		if (is_vacant(config->entries + i))
 8004062:	b128      	cbz	r0, 8004070 <udp_recv_proc+0x108>
	for (i = 0; i < config->num_entry; i++)
 8004064:	f108 0801 	add.w	r8, r8, #1
 8004068:	3714      	adds	r7, #20
 800406a:	45c1      	cmp	r9, r8
 800406c:	d1f4      	bne.n	8004058 <udp_recv_proc+0xf0>
 800406e:	e793      	b.n	8003f98 <udp_recv_proc+0x30>
			if (entry == NULL) break;
 8004070:	9b05      	ldr	r3, [sp, #20]
 8004072:	f113 0914 	adds.w	r9, r3, #20
 8004076:	d08f      	beq.n	8003f98 <udp_recv_proc+0x30>
 8004078:	e79a      	b.n	8003fb0 <udp_recv_proc+0x48>
			ptr = find_dhcp_option(dhcp_data.dp_options, sizeof(dhcp_data.dp_options), DHCP_IPADDRESS);
 800407a:	2232      	movs	r2, #50	; 0x32
 800407c:	f240 1113 	movw	r1, #275	; 0x113
 8004080:	4846      	ldr	r0, [pc, #280]	; (800419c <udp_recv_proc+0x234>)
 8004082:	f7ff ff0b 	bl	8003e9c <find_dhcp_option>
			if (ptr == NULL) break;
 8004086:	4607      	mov	r7, r0
 8004088:	2800      	cmp	r0, #0
 800408a:	d085      	beq.n	8003f98 <udp_recv_proc+0x30>
			if (ptr[1] != 4) break;
 800408c:	7843      	ldrb	r3, [r0, #1]
 800408e:	2b04      	cmp	r3, #4
 8004090:	d182      	bne.n	8003f98 <udp_recv_proc+0x30>
			entry = entry_by_mac(dhcp_data.dp_chaddr);
 8004092:	483e      	ldr	r0, [pc, #248]	; (800418c <udp_recv_proc+0x224>)
 8004094:	f7ff fee0 	bl	8003e58 <entry_by_mac>
			if (entry != NULL) free_entry(entry);
 8004098:	b110      	cbz	r0, 80040a0 <udp_recv_proc+0x138>
	memset(entry->mac, 0, 6);
 800409a:	2200      	movs	r2, #0
 800409c:	6002      	str	r2, [r0, #0]
 800409e:	8082      	strh	r2, [r0, #4]
			entry = entry_by_ip(*(uint32_t *)ptr);
 80040a0:	f8d7 8002 	ldr.w	r8, [r7, #2]
	for (i = 0; i < config->num_entry; i++)
 80040a4:	4b3b      	ldr	r3, [pc, #236]	; (8004194 <udp_recv_proc+0x22c>)
 80040a6:	f8d3 9000 	ldr.w	r9, [r3]
 80040aa:	f8d9 0010 	ldr.w	r0, [r9, #16]
 80040ae:	2800      	cmp	r0, #0
 80040b0:	f77f af72 	ble.w	8003f98 <udp_recv_proc+0x30>
		if (*(uint32_t *)config->entries[i].addr == ip)
 80040b4:	f8d9 7014 	ldr.w	r7, [r9, #20]
 80040b8:	f8d7 3006 	ldr.w	r3, [r7, #6]
 80040bc:	4598      	cmp	r8, r3
 80040be:	d00c      	beq.n	80040da <udp_recv_proc+0x172>
 80040c0:	f107 0314 	add.w	r3, r7, #20
 80040c4:	2200      	movs	r2, #0
	for (i = 0; i < config->num_entry; i++)
 80040c6:	3201      	adds	r2, #1
 80040c8:	4282      	cmp	r2, r0
 80040ca:	f43f af65 	beq.w	8003f98 <udp_recv_proc+0x30>
		if (*(uint32_t *)config->entries[i].addr == ip)
 80040ce:	461f      	mov	r7, r3
 80040d0:	3314      	adds	r3, #20
 80040d2:	f853 1c0e 	ldr.w	r1, [r3, #-14]
 80040d6:	4588      	cmp	r8, r1
 80040d8:	d1f5      	bne.n	80040c6 <udp_recv_proc+0x15e>
			if (entry == NULL) break;
 80040da:	2f00      	cmp	r7, #0
 80040dc:	f43f af5c 	beq.w	8003f98 <udp_recv_proc+0x30>
	return memcmp("\0\0\0\0\0", entry->mac, 6) == 0;
 80040e0:	46ba      	mov	sl, r7
 80040e2:	2206      	movs	r2, #6
 80040e4:	4639      	mov	r1, r7
 80040e6:	482e      	ldr	r0, [pc, #184]	; (80041a0 <udp_recv_proc+0x238>)
 80040e8:	f004 fff2 	bl	80090d0 <memcmp>
			if (!is_vacant(entry)) break;
 80040ec:	2800      	cmp	r0, #0
 80040ee:	f47f af53 	bne.w	8003f98 <udp_recv_proc+0x30>
			memcpy(dhcp_data.dp_yiaddr, ptr, 4);
 80040f2:	4825      	ldr	r0, [pc, #148]	; (8004188 <udp_recv_proc+0x220>)
 80040f4:	f8c0 8010 	str.w	r8, [r0, #16]
			dhcp_data.dp_op = 2; /* reply */
 80040f8:	2302      	movs	r3, #2
 80040fa:	7003      	strb	r3, [r0, #0]
			dhcp_data.dp_secs = 0;
 80040fc:	f04f 0800 	mov.w	r8, #0
 8004100:	f8a0 8008 	strh.w	r8, [r0, #8]
			dhcp_data.dp_flags = 0;
 8004104:	f8a0 800a 	strh.w	r8, [r0, #10]
			memcpy(dhcp_data.dp_magic, magic_cookie, 4);
 8004108:	4b21      	ldr	r3, [pc, #132]	; (8004190 <udp_recv_proc+0x228>)
 800410a:	681b      	ldr	r3, [r3, #0]
 800410c:	f8c0 30ec 	str.w	r3, [r0, #236]	; 0xec
			memset(dhcp_data.dp_options, 0, sizeof(dhcp_data.dp_options));
 8004110:	f100 0bf0 	add.w	fp, r0, #240	; 0xf0
 8004114:	f240 1213 	movw	r2, #275	; 0x113
 8004118:	4641      	mov	r1, r8
 800411a:	4658      	mov	r0, fp
 800411c:	f004 fff2 	bl	8009104 <memset>
			fill_options(dhcp_data.dp_options,
 8004120:	f8d9 1000 	ldr.w	r1, [r9]
 8004124:	f8d9 3006 	ldr.w	r3, [r9, #6]
 8004128:	f8d9 200c 	ldr.w	r2, [r9, #12]
 800412c:	f8d7 000a 	ldr.w	r0, [r7, #10]
 8004130:	9003      	str	r0, [sp, #12]
 8004132:	9102      	str	r1, [sp, #8]
 8004134:	9101      	str	r1, [sp, #4]
 8004136:	6939      	ldr	r1, [r7, #16]
 8004138:	9100      	str	r1, [sp, #0]
 800413a:	2105      	movs	r1, #5
 800413c:	4658      	mov	r0, fp
 800413e:	f7ff fec4 	bl	8003eca <fill_options>
			pp = pbuf_alloc(PBUF_TRANSPORT, sizeof(dhcp_data), PBUF_POOL);
 8004142:	2203      	movs	r2, #3
 8004144:	f44f 7101 	mov.w	r1, #516	; 0x204
 8004148:	4640      	mov	r0, r8
 800414a:	f001 fbf3 	bl	8005934 <pbuf_alloc>
			if (pp == NULL) break;
 800414e:	4607      	mov	r7, r0
 8004150:	2800      	cmp	r0, #0
 8004152:	f43f af21 	beq.w	8003f98 <udp_recv_proc+0x30>
			memcpy(entry->mac, dhcp_data.dp_chaddr, 6);
 8004156:	f1ab 01d4 	sub.w	r1, fp, #212	; 0xd4
 800415a:	6808      	ldr	r0, [r1, #0]
 800415c:	f8ca 0000 	str.w	r0, [sl]
 8004160:	888b      	ldrh	r3, [r1, #4]
 8004162:	f8aa 3004 	strh.w	r3, [sl, #4]
			memcpy(pp->payload, &dhcp_data, sizeof(dhcp_data));
 8004166:	f44f 7201 	mov.w	r2, #516	; 0x204
 800416a:	391c      	subs	r1, #28
 800416c:	6878      	ldr	r0, [r7, #4]
 800416e:	f004 ffbe 	bl	80090ee <memcpy>
			udp_sendto(upcb, pp, IP_ADDR_BROADCAST, port);
 8004172:	4633      	mov	r3, r6
 8004174:	4a08      	ldr	r2, [pc, #32]	; (8004198 <udp_recv_proc+0x230>)
 8004176:	4639      	mov	r1, r7
 8004178:	4628      	mov	r0, r5
 800417a:	f004 fb2d 	bl	80087d8 <udp_sendto>
			pbuf_free(pp);
 800417e:	4638      	mov	r0, r7
 8004180:	f001 fba9 	bl	80058d6 <pbuf_free>
			break;
 8004184:	e708      	b.n	8003f98 <udp_recv_proc+0x30>
 8004186:	bf00      	nop
 8004188:	200087cc 	.word	0x200087cc
 800418c:	200087e8 	.word	0x200087e8
 8004190:	20000148 	.word	0x20000148
 8004194:	20000de8 	.word	0x20000de8
 8004198:	0800924c 	.word	0x0800924c
 800419c:	200088bc 	.word	0x200088bc
 80041a0:	08009138 	.word	0x08009138

080041a4 <dhserv_free>:
	config = c;
	return ERR_OK;
}

void dhserv_free(void)
{
 80041a4:	b508      	push	{r3, lr}
	if (pcb == NULL) return;
 80041a6:	4b04      	ldr	r3, [pc, #16]	; (80041b8 <dhserv_free+0x14>)
 80041a8:	6818      	ldr	r0, [r3, #0]
 80041aa:	b120      	cbz	r0, 80041b6 <dhserv_free+0x12>
	udp_remove(pcb);
 80041ac:	f004 fb36 	bl	800881c <udp_remove>
	pcb = NULL;
 80041b0:	2200      	movs	r2, #0
 80041b2:	4b01      	ldr	r3, [pc, #4]	; (80041b8 <dhserv_free+0x14>)
 80041b4:	601a      	str	r2, [r3, #0]
 80041b6:	bd08      	pop	{r3, pc}
 80041b8:	20000dec 	.word	0x20000dec

080041bc <dhserv_init>:
{
 80041bc:	b538      	push	{r3, r4, r5, lr}
 80041be:	4604      	mov	r4, r0
	udp_init();
 80041c0:	f004 f914 	bl	80083ec <udp_init>
	dhserv_free();
 80041c4:	f7ff ffee 	bl	80041a4 <dhserv_free>
	pcb = udp_new();
 80041c8:	f004 fb44 	bl	8008854 <udp_new>
 80041cc:	4b0c      	ldr	r3, [pc, #48]	; (8004200 <dhserv_init+0x44>)
 80041ce:	6018      	str	r0, [r3, #0]
	if (pcb == NULL)
 80041d0:	b190      	cbz	r0, 80041f8 <dhserv_init+0x3c>
	err = udp_bind(pcb, IP_ADDR_ANY, c->port);
 80041d2:	88a2      	ldrh	r2, [r4, #4]
 80041d4:	490b      	ldr	r1, [pc, #44]	; (8004204 <dhserv_init+0x48>)
 80041d6:	f004 fa11 	bl	80085fc <udp_bind>
	if (err != ERR_OK)
 80041da:	4605      	mov	r5, r0
 80041dc:	b948      	cbnz	r0, 80041f2 <dhserv_init+0x36>
	udp_recv(pcb, udp_recv_proc, NULL);
 80041de:	2200      	movs	r2, #0
 80041e0:	4909      	ldr	r1, [pc, #36]	; (8004208 <dhserv_init+0x4c>)
 80041e2:	4b07      	ldr	r3, [pc, #28]	; (8004200 <dhserv_init+0x44>)
 80041e4:	6818      	ldr	r0, [r3, #0]
 80041e6:	f004 fb15 	bl	8008814 <udp_recv>
	config = c;
 80041ea:	4b08      	ldr	r3, [pc, #32]	; (800420c <dhserv_init+0x50>)
 80041ec:	601c      	str	r4, [r3, #0]
}
 80041ee:	4628      	mov	r0, r5
 80041f0:	bd38      	pop	{r3, r4, r5, pc}
		dhserv_free();
 80041f2:	f7ff ffd7 	bl	80041a4 <dhserv_free>
		return err;
 80041f6:	e7fa      	b.n	80041ee <dhserv_init+0x32>
		return ERR_MEM;
 80041f8:	f04f 35ff 	mov.w	r5, #4294967295
 80041fc:	e7f7      	b.n	80041ee <dhserv_init+0x32>
 80041fe:	bf00      	nop
 8004200:	20000dec 	.word	0x20000dec
 8004204:	08009248 	.word	0x08009248
 8004208:	08003f69 	.word	0x08003f69
 800420c:	20000de8 	.word	0x20000de8

08004210 <udp_recv_proc>:
	ptr += 2;
	return ptr - (uint8_t *)data;
}

static void udp_recv_proc(void *arg, struct udp_pcb *upcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
 8004210:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004214:	b087      	sub	sp, #28
 8004216:	9101      	str	r1, [sp, #4]
 8004218:	4617      	mov	r7, r2
 800421a:	9302      	str	r3, [sp, #8]
	static dns_query_t query;
	struct pbuf *out;
	ip_addr_t host_addr;
	dns_answer_t *answer;

	if (p->len <= sizeof(dns_header_t)) goto error;
 800421c:	8953      	ldrh	r3, [r2, #10]
 800421e:	2b0c      	cmp	r3, #12
 8004220:	d909      	bls.n	8004236 <udp_recv_proc+0x26>
	header = (dns_header_t *)p->payload;
 8004222:	6855      	ldr	r5, [r2, #4]
	if (header->flags.qr != 0) goto error;
 8004224:	f995 3002 	ldrsb.w	r3, [r5, #2]
 8004228:	2b00      	cmp	r3, #0
 800422a:	db04      	blt.n	8004236 <udp_recv_proc+0x26>
	if (ntohs(header->n_record[0]) != 1) goto error;
 800422c:	88a8      	ldrh	r0, [r5, #4]
 800422e:	f000 f8dc 	bl	80043ea <lwip_ntohs>
 8004232:	2801      	cmp	r0, #1
 8004234:	d005      	beq.n	8004242 <udp_recv_proc+0x32>
	
	udp_sendto(upcb, out, addr, port);
	pbuf_free(out);

error:
	pbuf_free(p);
 8004236:	4638      	mov	r0, r7
 8004238:	f001 fb4d 	bl	80058d6 <pbuf_free>
}
 800423c:	b007      	add	sp, #28
 800423e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	len = parse_next_query(header + 1, p->len - sizeof(dns_header_t), &query);
 8004242:	f105 030c 	add.w	r3, r5, #12
 8004246:	9303      	str	r3, [sp, #12]
 8004248:	897c      	ldrh	r4, [r7, #10]
 800424a:	3c0c      	subs	r4, #12
		if (size <= 0) return -1;
 800424c:	2c00      	cmp	r4, #0
 800424e:	ddf2      	ble.n	8004236 <udp_recv_proc+0x26>
		lable_len = *ptr++;
 8004250:	f105 0a0d 	add.w	sl, r5, #13
 8004254:	7b2e      	ldrb	r6, [r5, #12]
		size--;
 8004256:	3c01      	subs	r4, #1
		if (lable_len == 0) break;
 8004258:	b35e      	cbz	r6, 80042b2 <udp_recv_proc+0xa2>
 800425a:	f04f 0900 	mov.w	r9, #0
 800425e:	4648      	mov	r0, r9
		memcpy(&query->name[len], ptr, lable_len);
 8004260:	f8df b108 	ldr.w	fp, [pc, #264]	; 800436c <udp_recv_proc+0x15c>
 8004264:	e000      	b.n	8004268 <udp_recv_proc+0x58>
		if (len + lable_len >= DNS_MAX_HOST_NAME_LEN) return -2;
 8004266:	4640      	mov	r0, r8
		if (lable_len > size) return -1;
 8004268:	42a6      	cmp	r6, r4
 800426a:	dce4      	bgt.n	8004236 <udp_recv_proc+0x26>
		if (len + lable_len >= DNS_MAX_HOST_NAME_LEN) return -2;
 800426c:	eb06 0800 	add.w	r8, r6, r0
 8004270:	f1b8 0f7f 	cmp.w	r8, #127	; 0x7f
 8004274:	dcdf      	bgt.n	8004236 <udp_recv_proc+0x26>
		memcpy(&query->name[len], ptr, lable_len);
 8004276:	4632      	mov	r2, r6
 8004278:	4651      	mov	r1, sl
 800427a:	4458      	add	r0, fp
 800427c:	f004 ff37 	bl	80090ee <memcpy>
		ptr += lable_len;
 8004280:	eb0a 0306 	add.w	r3, sl, r6
		size -= lable_len;
 8004284:	1ba4      	subs	r4, r4, r6
		lables++;
 8004286:	f109 0901 	add.w	r9, r9, #1
		if (size <= 0) return -1;
 800428a:	2c00      	cmp	r4, #0
 800428c:	ddd3      	ble.n	8004236 <udp_recv_proc+0x26>
		lable_len = *ptr++;
 800428e:	f103 0a01 	add.w	sl, r3, #1
 8004292:	781e      	ldrb	r6, [r3, #0]
		size--;
 8004294:	3c01      	subs	r4, #1
		if (lable_len == 0) break;
 8004296:	b17e      	cbz	r6, 80042b8 <udp_recv_proc+0xa8>
		if (lables > 0)
 8004298:	f1b9 0f00 	cmp.w	r9, #0
 800429c:	dde3      	ble.n	8004266 <udp_recv_proc+0x56>
			if (len == DNS_MAX_HOST_NAME_LEN) return -2;
 800429e:	f1b8 0f80 	cmp.w	r8, #128	; 0x80
 80042a2:	d0c8      	beq.n	8004236 <udp_recv_proc+0x26>
			query->name[len++] = '.';
 80042a4:	f108 0001 	add.w	r0, r8, #1
 80042a8:	f04f 032e 	mov.w	r3, #46	; 0x2e
 80042ac:	f80b 3008 	strb.w	r3, [fp, r8]
 80042b0:	e7da      	b.n	8004268 <udp_recv_proc+0x58>
	ptr = (uint8_t *)data;
 80042b2:	9b03      	ldr	r3, [sp, #12]
	len = 0;
 80042b4:	f04f 0800 	mov.w	r8, #0
	if (size < 4) return -1;
 80042b8:	2c03      	cmp	r4, #3
 80042ba:	ddbc      	ble.n	8004236 <udp_recv_proc+0x26>
	query->name[len] = 0;
 80042bc:	4a2b      	ldr	r2, [pc, #172]	; (800436c <udp_recv_proc+0x15c>)
 80042be:	2100      	movs	r1, #0
 80042c0:	f802 1008 	strb.w	r1, [r2, r8]
	query->type = *(uint16_t *)ptr;
 80042c4:	f8b3 1001 	ldrh.w	r1, [r3, #1]
 80042c8:	f8a2 1080 	strh.w	r1, [r2, #128]	; 0x80
	query->Class = *(uint16_t *)ptr;
 80042cc:	f8b3 1003 	ldrh.w	r1, [r3, #3]
 80042d0:	f8a2 1082 	strh.w	r1, [r2, #130]	; 0x82
	ptr += 2;
 80042d4:	3305      	adds	r3, #5
	if (len < 0) goto error;
 80042d6:	9a03      	ldr	r2, [sp, #12]
 80042d8:	1a9c      	subs	r4, r3, r2
 80042da:	d4ac      	bmi.n	8004236 <udp_recv_proc+0x26>
	if (!query_proc(query.name, &host_addr)) goto error;
 80042dc:	4b24      	ldr	r3, [pc, #144]	; (8004370 <udp_recv_proc+0x160>)
 80042de:	681b      	ldr	r3, [r3, #0]
 80042e0:	a905      	add	r1, sp, #20
 80042e2:	4822      	ldr	r0, [pc, #136]	; (800436c <udp_recv_proc+0x15c>)
 80042e4:	4798      	blx	r3
 80042e6:	2800      	cmp	r0, #0
 80042e8:	d0a5      	beq.n	8004236 <udp_recv_proc+0x26>
	out = pbuf_alloc(PBUF_TRANSPORT, len + 16, PBUF_POOL);
 80042ea:	f104 011c 	add.w	r1, r4, #28
	len += sizeof(dns_header_t);
 80042ee:	340c      	adds	r4, #12
	out = pbuf_alloc(PBUF_TRANSPORT, len + 16, PBUF_POOL);
 80042f0:	2203      	movs	r2, #3
 80042f2:	b289      	uxth	r1, r1
 80042f4:	2000      	movs	r0, #0
 80042f6:	f001 fb1d 	bl	8005934 <pbuf_alloc>
	if (out == NULL) goto error;
 80042fa:	4605      	mov	r5, r0
 80042fc:	2800      	cmp	r0, #0
 80042fe:	d09a      	beq.n	8004236 <udp_recv_proc+0x26>
	memcpy(out->payload, p->payload, len);
 8004300:	4622      	mov	r2, r4
 8004302:	6879      	ldr	r1, [r7, #4]
 8004304:	6840      	ldr	r0, [r0, #4]
 8004306:	f004 fef2 	bl	80090ee <memcpy>
	header = (dns_header_t *)out->payload;
 800430a:	686e      	ldr	r6, [r5, #4]
	header->flags.qr = 1;
 800430c:	78b3      	ldrb	r3, [r6, #2]
 800430e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004312:	70b3      	strb	r3, [r6, #2]
	header->n_record[1] = htons(1);
 8004314:	2001      	movs	r0, #1
 8004316:	f000 f863 	bl	80043e0 <lwip_htons>
 800431a:	80f0      	strh	r0, [r6, #6]
	answer = (struct dns_answer *)((uint8_t *)out->payload + len);
 800431c:	f8d5 8004 	ldr.w	r8, [r5, #4]
 8004320:	eb08 0604 	add.w	r6, r8, r4
	answer->name = htons(0xC00C);
 8004324:	f24c 000c 	movw	r0, #49164	; 0xc00c
 8004328:	f000 f85a 	bl	80043e0 <lwip_htons>
 800432c:	f828 0004 	strh.w	r0, [r8, r4]
	answer->type = htons(1);
 8004330:	2001      	movs	r0, #1
 8004332:	f000 f855 	bl	80043e0 <lwip_htons>
 8004336:	8070      	strh	r0, [r6, #2]
	answer->Class = htons(1);
 8004338:	2001      	movs	r0, #1
 800433a:	f000 f851 	bl	80043e0 <lwip_htons>
 800433e:	80b0      	strh	r0, [r6, #4]
	answer->ttl = htonl(32);
 8004340:	2020      	movs	r0, #32
 8004342:	f000 f857 	bl	80043f4 <lwip_htonl>
 8004346:	f8c6 0006 	str.w	r0, [r6, #6]
	answer->len = htons(4);
 800434a:	2004      	movs	r0, #4
 800434c:	f000 f848 	bl	80043e0 <lwip_htons>
 8004350:	8170      	strh	r0, [r6, #10]
	answer->addr = host_addr.addr;
 8004352:	9b05      	ldr	r3, [sp, #20]
 8004354:	60f3      	str	r3, [r6, #12]
	udp_sendto(upcb, out, addr, port);
 8004356:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
 800435a:	9a02      	ldr	r2, [sp, #8]
 800435c:	4629      	mov	r1, r5
 800435e:	9801      	ldr	r0, [sp, #4]
 8004360:	f004 fa3a 	bl	80087d8 <udp_sendto>
	pbuf_free(out);
 8004364:	4628      	mov	r0, r5
 8004366:	f001 fab6 	bl	80058d6 <pbuf_free>
 800436a:	e764      	b.n	8004236 <udp_recv_proc+0x26>
 800436c:	20000df4 	.word	0x20000df4
 8004370:	20000e78 	.word	0x20000e78

08004374 <dnserv_free>:
	query_proc = qp;
	return ERR_OK;
}

void dnserv_free()
{
 8004374:	b508      	push	{r3, lr}
	if (pcb == NULL) return;
 8004376:	4b04      	ldr	r3, [pc, #16]	; (8004388 <dnserv_free+0x14>)
 8004378:	6818      	ldr	r0, [r3, #0]
 800437a:	b120      	cbz	r0, 8004386 <dnserv_free+0x12>
	udp_remove(pcb);
 800437c:	f004 fa4e 	bl	800881c <udp_remove>
	pcb = NULL;
 8004380:	2200      	movs	r2, #0
 8004382:	4b01      	ldr	r3, [pc, #4]	; (8004388 <dnserv_free+0x14>)
 8004384:	601a      	str	r2, [r3, #0]
 8004386:	bd08      	pop	{r3, pc}
 8004388:	20000df0 	.word	0x20000df0

0800438c <dnserv_init>:
{
 800438c:	b570      	push	{r4, r5, r6, lr}
 800438e:	4604      	mov	r4, r0
 8004390:	460d      	mov	r5, r1
 8004392:	4616      	mov	r6, r2
	udp_init();
 8004394:	f004 f82a 	bl	80083ec <udp_init>
	dnserv_free();
 8004398:	f7ff ffec 	bl	8004374 <dnserv_free>
	pcb = udp_new();
 800439c:	f004 fa5a 	bl	8008854 <udp_new>
 80043a0:	4b0c      	ldr	r3, [pc, #48]	; (80043d4 <dnserv_init+0x48>)
 80043a2:	6018      	str	r0, [r3, #0]
	if (pcb == NULL)
 80043a4:	b190      	cbz	r0, 80043cc <dnserv_init+0x40>
	err = udp_bind(pcb, bind, port);
 80043a6:	462a      	mov	r2, r5
 80043a8:	4621      	mov	r1, r4
 80043aa:	f004 f927 	bl	80085fc <udp_bind>
	if (err != ERR_OK)
 80043ae:	4604      	mov	r4, r0
 80043b0:	b948      	cbnz	r0, 80043c6 <dnserv_init+0x3a>
	udp_recv(pcb, udp_recv_proc, NULL);
 80043b2:	2200      	movs	r2, #0
 80043b4:	4908      	ldr	r1, [pc, #32]	; (80043d8 <dnserv_init+0x4c>)
 80043b6:	4b07      	ldr	r3, [pc, #28]	; (80043d4 <dnserv_init+0x48>)
 80043b8:	6818      	ldr	r0, [r3, #0]
 80043ba:	f004 fa2b 	bl	8008814 <udp_recv>
	query_proc = qp;
 80043be:	4b07      	ldr	r3, [pc, #28]	; (80043dc <dnserv_init+0x50>)
 80043c0:	601e      	str	r6, [r3, #0]
}
 80043c2:	4620      	mov	r0, r4
 80043c4:	bd70      	pop	{r4, r5, r6, pc}
		dnserv_free();
 80043c6:	f7ff ffd5 	bl	8004374 <dnserv_free>
		return err;
 80043ca:	e7fa      	b.n	80043c2 <dnserv_init+0x36>
		return ERR_MEM;
 80043cc:	f04f 34ff 	mov.w	r4, #4294967295
 80043d0:	e7f7      	b.n	80043c2 <dnserv_init+0x36>
 80043d2:	bf00      	nop
 80043d4:	20000df0 	.word	0x20000df0
 80043d8:	08004211 	.word	0x08004211
 80043dc:	20000e78 	.word	0x20000e78

080043e0 <lwip_htons>:
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
 80043e0:	0a03      	lsrs	r3, r0, #8
 80043e2:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
}
 80043e6:	b280      	uxth	r0, r0
 80043e8:	4770      	bx	lr

080043ea <lwip_ntohs>:
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
 80043ea:	0a03      	lsrs	r3, r0, #8
 80043ec:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 */
u16_t
lwip_ntohs(u16_t n)
{
  return lwip_htons(n);
}
 80043f0:	b280      	uxth	r0, r0
 80043f2:	4770      	bx	lr

080043f4 <lwip_htonl>:
lwip_htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
 80043f4:	0e03      	lsrs	r3, r0, #24
    ((n & 0xff0000UL) >> 8) |
 80043f6:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
    ((n & 0xff00) << 8) |
 80043fa:	0202      	lsls	r2, r0, #8
 80043fc:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    ((n & 0xff0000UL) >> 8) |
 8004400:	4313      	orrs	r3, r2
 8004402:	0a00      	lsrs	r0, r0, #8
 8004404:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
}
 8004408:	4318      	orrs	r0, r3
 800440a:	4770      	bx	lr

0800440c <lwip_ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
lwip_ntohl(u32_t n)
{
 800440c:	b508      	push	{r3, lr}
  return lwip_htonl(n);
 800440e:	f7ff fff1 	bl	80043f4 <lwip_htonl>
}
 8004412:	bd08      	pop	{r3, pc}

08004414 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
 8004414:	b508      	push	{r3, lr}
  /* Modules initialization */
  stats_init();
 8004416:	f001 fc61 	bl	8005cdc <stats_init>
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
 800441a:	f000 ff3d 	bl	8005298 <mem_init>
  memp_init();
 800441e:	f001 f8dd 	bl	80055dc <memp_init>
  pbuf_init();
  netif_init();
 8004422:	f001 f97b 	bl	800571c <netif_init>
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 8004426:	f003 ffe1 	bl	80083ec <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 800442a:	f001 fc58 	bl	8005cde <tcp_init>
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
 800442e:	f003 ffad 	bl	800838c <sys_timeouts_init>
 8004432:	bd08      	pop	{r3, pc}

08004434 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 8004434:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004438:	b085      	sub	sp, #20
 800443a:	4680      	mov	r8, r0
 800443c:	4689      	mov	r9, r1
 800443e:	4615      	mov	r5, r2
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 8004440:	2200      	movs	r2, #0
 8004442:	2124      	movs	r1, #36	; 0x24
 8004444:	2001      	movs	r0, #1
 8004446:	f001 fa75 	bl	8005934 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 800444a:	2800      	cmp	r0, #0
 800444c:	d043      	beq.n	80044d6 <icmp_send_response+0xa2>
 800444e:	4606      	mov	r6, r0
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 8004450:	f8d8 7004 	ldr.w	r7, [r8, #4]
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 8004454:	6844      	ldr	r4, [r0, #4]
  icmphdr->type = type;
 8004456:	f884 9000 	strb.w	r9, [r4]
  icmphdr->code = code;
 800445a:	7065      	strb	r5, [r4, #1]
  icmphdr->id = 0;
 800445c:	2500      	movs	r5, #0
 800445e:	7125      	strb	r5, [r4, #4]
 8004460:	7165      	strb	r5, [r4, #5]
  icmphdr->seqno = 0;
 8004462:	71a5      	strb	r5, [r4, #6]
 8004464:	71e5      	strb	r5, [r4, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8004466:	f8d0 c004 	ldr.w	ip, [r0, #4]
 800446a:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800446e:	f8d3 e000 	ldr.w	lr, [r3]
 8004472:	6858      	ldr	r0, [r3, #4]
 8004474:	6899      	ldr	r1, [r3, #8]
 8004476:	f8d3 800c 	ldr.w	r8, [r3, #12]
 800447a:	f8cc e008 	str.w	lr, [ip, #8]
 800447e:	f8cc 000c 	str.w	r0, [ip, #12]
 8004482:	f8cc 1010 	str.w	r1, [ip, #16]
 8004486:	f8cc 8014 	str.w	r8, [ip, #20]
 800448a:	f8d3 e010 	ldr.w	lr, [r3, #16]
 800448e:	6958      	ldr	r0, [r3, #20]
 8004490:	6999      	ldr	r1, [r3, #24]
 8004492:	f8cc e018 	str.w	lr, [ip, #24]
 8004496:	f8cc 001c 	str.w	r0, [ip, #28]
 800449a:	f8cc 1020 	str.w	r1, [ip, #32]
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
 800449e:	70a5      	strb	r5, [r4, #2]
 80044a0:	70e5      	strb	r5, [r4, #3]
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 80044a2:	8971      	ldrh	r1, [r6, #10]
 80044a4:	4620      	mov	r0, r4
 80044a6:	f000 f97c 	bl	80047a2 <inet_chksum>
 80044aa:	8060      	strh	r0, [r4, #2]
  ICMP_STATS_INC(icmp.xmit);
 80044ac:	4a0b      	ldr	r2, [pc, #44]	; (80044dc <icmp_send_response+0xa8>)
 80044ae:	f8b2 3060 	ldrh.w	r3, [r2, #96]	; 0x60
 80044b2:	3301      	adds	r3, #1
 80044b4:	f8a2 3060 	strh.w	r3, [r2, #96]	; 0x60
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 80044b8:	68fb      	ldr	r3, [r7, #12]
 80044ba:	aa04      	add	r2, sp, #16
 80044bc:	f842 3d04 	str.w	r3, [r2, #-4]!
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
 80044c0:	2301      	movs	r3, #1
 80044c2:	9301      	str	r3, [sp, #4]
 80044c4:	9500      	str	r5, [sp, #0]
 80044c6:	23ff      	movs	r3, #255	; 0xff
 80044c8:	4629      	mov	r1, r5
 80044ca:	4630      	mov	r0, r6
 80044cc:	f000 fb60 	bl	8004b90 <ip_output>
  pbuf_free(q);
 80044d0:	4630      	mov	r0, r6
 80044d2:	f001 fa00 	bl	80058d6 <pbuf_free>
}
 80044d6:	b005      	add	sp, #20
 80044d8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80044dc:	2000b110 	.word	0x2000b110

080044e0 <icmp_input>:
{
 80044e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80044e4:	b085      	sub	sp, #20
 80044e6:	4606      	mov	r6, r0
 80044e8:	4688      	mov	r8, r1
  ICMP_STATS_INC(icmp.recv);
 80044ea:	4a62      	ldr	r2, [pc, #392]	; (8004674 <icmp_input+0x194>)
 80044ec:	f8b2 3062 	ldrh.w	r3, [r2, #98]	; 0x62
 80044f0:	3301      	adds	r3, #1
 80044f2:	f8a2 3062 	strh.w	r3, [r2, #98]	; 0x62
  iphdr = (struct ip_hdr *)p->payload;
 80044f6:	6847      	ldr	r7, [r0, #4]
  hlen = IPH_HL(iphdr) * 4;
 80044f8:	783c      	ldrb	r4, [r7, #0]
 80044fa:	f004 040f 	and.w	r4, r4, #15
 80044fe:	00a4      	lsls	r4, r4, #2
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 8004500:	4265      	negs	r5, r4
 8004502:	b22d      	sxth	r5, r5
 8004504:	4629      	mov	r1, r5
 8004506:	f001 f9a8 	bl	800585a <pbuf_header>
 800450a:	b9c0      	cbnz	r0, 800453e <icmp_input+0x5e>
 800450c:	8933      	ldrh	r3, [r6, #8]
 800450e:	2b03      	cmp	r3, #3
 8004510:	d915      	bls.n	800453e <icmp_input+0x5e>
  type = *((u8_t *)p->payload);
 8004512:	6873      	ldr	r3, [r6, #4]
  switch (type) {
 8004514:	781b      	ldrb	r3, [r3, #0]
 8004516:	2b00      	cmp	r3, #0
 8004518:	f000 80a8 	beq.w	800466c <icmp_input+0x18c>
 800451c:	2b08      	cmp	r3, #8
 800451e:	f040 809a 	bne.w	8004656 <icmp_input+0x176>
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
 8004522:	4b55      	ldr	r3, [pc, #340]	; (8004678 <icmp_input+0x198>)
 8004524:	6818      	ldr	r0, [r3, #0]
 8004526:	f000 09f0 	and.w	r9, r0, #240	; 0xf0
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
 800452a:	4641      	mov	r1, r8
 800452c:	f000 fb54 	bl	8004bd8 <ip4_addr_isbroadcast>
 8004530:	b988      	cbnz	r0, 8004556 <icmp_input+0x76>
      if (!accepted) {
 8004532:	f1b9 0fe0 	cmp.w	r9, #224	; 0xe0
 8004536:	d00e      	beq.n	8004556 <icmp_input+0x76>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 8004538:	8933      	ldrh	r3, [r6, #8]
 800453a:	2b07      	cmp	r3, #7
 800453c:	d815      	bhi.n	800456a <icmp_input+0x8a>
  pbuf_free(p);
 800453e:	4630      	mov	r0, r6
 8004540:	f001 f9c9 	bl	80058d6 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
 8004544:	4a4b      	ldr	r2, [pc, #300]	; (8004674 <icmp_input+0x194>)
 8004546:	f8b2 306a 	ldrh.w	r3, [r2, #106]	; 0x6a
 800454a:	3301      	adds	r3, #1
 800454c:	f8a2 306a 	strh.w	r3, [r2, #106]	; 0x6a
}
 8004550:	b005      	add	sp, #20
 8004552:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ICMP_STATS_INC(icmp.err);
 8004556:	4a47      	ldr	r2, [pc, #284]	; (8004674 <icmp_input+0x194>)
 8004558:	f8b2 3074 	ldrh.w	r3, [r2, #116]	; 0x74
 800455c:	3301      	adds	r3, #1
 800455e:	f8a2 3074 	strh.w	r3, [r2, #116]	; 0x74
        pbuf_free(p);
 8004562:	4630      	mov	r0, r6
 8004564:	f001 f9b7 	bl	80058d6 <pbuf_free>
        return;
 8004568:	e7f2      	b.n	8004550 <icmp_input+0x70>
    if (inet_chksum_pbuf(p) != 0) {
 800456a:	4630      	mov	r0, r6
 800456c:	f000 f91f 	bl	80047ae <inet_chksum_pbuf>
 8004570:	b9a0      	cbnz	r0, 800459c <icmp_input+0xbc>
  hlen = IPH_HL(iphdr) * 4;
 8004572:	b224      	sxth	r4, r4
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 8004574:	2122      	movs	r1, #34	; 0x22
 8004576:	4630      	mov	r0, r6
 8004578:	f001 f96f 	bl	800585a <pbuf_header>
 800457c:	b390      	cbz	r0, 80045e4 <icmp_input+0x104>
      if (pbuf_header(p, hlen)) {
 800457e:	4621      	mov	r1, r4
 8004580:	4630      	mov	r0, r6
 8004582:	f001 f96a 	bl	800585a <pbuf_header>
 8004586:	b198      	cbz	r0, 80045b0 <icmp_input+0xd0>
  pbuf_free(p);
 8004588:	4630      	mov	r0, r6
 800458a:	f001 f9a4 	bl	80058d6 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
 800458e:	4a39      	ldr	r2, [pc, #228]	; (8004674 <icmp_input+0x194>)
 8004590:	f8b2 3074 	ldrh.w	r3, [r2, #116]	; 0x74
 8004594:	3301      	adds	r3, #1
 8004596:	f8a2 3074 	strh.w	r3, [r2, #116]	; 0x74
  return;
 800459a:	e7d9      	b.n	8004550 <icmp_input+0x70>
      pbuf_free(p);
 800459c:	4630      	mov	r0, r6
 800459e:	f001 f99a 	bl	80058d6 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
 80045a2:	4a34      	ldr	r2, [pc, #208]	; (8004674 <icmp_input+0x194>)
 80045a4:	f8b2 3068 	ldrh.w	r3, [r2, #104]	; 0x68
 80045a8:	3301      	adds	r3, #1
 80045aa:	f8a2 3068 	strh.w	r3, [r2, #104]	; 0x68
      return;
 80045ae:	e7cf      	b.n	8004550 <icmp_input+0x70>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 80045b0:	2200      	movs	r2, #0
 80045b2:	8931      	ldrh	r1, [r6, #8]
 80045b4:	2002      	movs	r0, #2
 80045b6:	f001 f9bd 	bl	8005934 <pbuf_alloc>
      if (r == NULL) {
 80045ba:	4681      	mov	r9, r0
 80045bc:	2800      	cmp	r0, #0
 80045be:	d0e3      	beq.n	8004588 <icmp_input+0xa8>
      if (pbuf_copy(r, p) != ERR_OK) {
 80045c0:	4631      	mov	r1, r6
 80045c2:	f001 faab 	bl	8005b1c <pbuf_copy>
 80045c6:	2800      	cmp	r0, #0
 80045c8:	d1de      	bne.n	8004588 <icmp_input+0xa8>
      iphdr = (struct ip_hdr *)r->payload;
 80045ca:	f8d9 7004 	ldr.w	r7, [r9, #4]
      if (pbuf_header(r, -hlen)) {
 80045ce:	4629      	mov	r1, r5
 80045d0:	4648      	mov	r0, r9
 80045d2:	f001 f942 	bl	800585a <pbuf_header>
 80045d6:	2800      	cmp	r0, #0
 80045d8:	d1d6      	bne.n	8004588 <icmp_input+0xa8>
      pbuf_free(p);
 80045da:	4630      	mov	r0, r6
 80045dc:	f001 f97b 	bl	80058d6 <pbuf_free>
      p = r;
 80045e0:	464e      	mov	r6, r9
 80045e2:	e006      	b.n	80045f2 <icmp_input+0x112>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 80045e4:	f06f 0121 	mvn.w	r1, #33	; 0x21
 80045e8:	4630      	mov	r0, r6
 80045ea:	f001 f936 	bl	800585a <pbuf_header>
 80045ee:	2800      	cmp	r0, #0
 80045f0:	d1ca      	bne.n	8004588 <icmp_input+0xa8>
    iecho = (struct icmp_echo_hdr *)p->payload;
 80045f2:	6872      	ldr	r2, [r6, #4]
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
 80045f4:	4b20      	ldr	r3, [pc, #128]	; (8004678 <icmp_input+0x198>)
 80045f6:	681b      	ldr	r3, [r3, #0]
 80045f8:	60fb      	str	r3, [r7, #12]
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 80045fa:	4b20      	ldr	r3, [pc, #128]	; (800467c <icmp_input+0x19c>)
 80045fc:	681b      	ldr	r3, [r3, #0]
 80045fe:	613b      	str	r3, [r7, #16]
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 8004600:	2300      	movs	r3, #0
 8004602:	7013      	strb	r3, [r2, #0]
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 8004604:	8853      	ldrh	r3, [r2, #2]
 8004606:	f64f 71f6 	movw	r1, #65526	; 0xfff6
 800460a:	428b      	cmp	r3, r1
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
 800460c:	bf8c      	ite	hi
 800460e:	3309      	addhi	r3, #9
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
 8004610:	3308      	addls	r3, #8
 8004612:	8053      	strh	r3, [r2, #2]
    IPH_TTL_SET(iphdr, ICMP_TTL);
 8004614:	23ff      	movs	r3, #255	; 0xff
 8004616:	723b      	strb	r3, [r7, #8]
    IPH_CHKSUM_SET(iphdr, 0);
 8004618:	2300      	movs	r3, #0
 800461a:	72bb      	strb	r3, [r7, #10]
 800461c:	72fb      	strb	r3, [r7, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800461e:	2114      	movs	r1, #20
 8004620:	4638      	mov	r0, r7
 8004622:	f000 f8be 	bl	80047a2 <inet_chksum>
 8004626:	8178      	strh	r0, [r7, #10]
    ICMP_STATS_INC(icmp.xmit);
 8004628:	4a12      	ldr	r2, [pc, #72]	; (8004674 <icmp_input+0x194>)
 800462a:	f8b2 3060 	ldrh.w	r3, [r2, #96]	; 0x60
 800462e:	3301      	adds	r3, #1
 8004630:	f8a2 3060 	strh.w	r3, [r2, #96]	; 0x60
    if(pbuf_header(p, hlen)) {
 8004634:	4621      	mov	r1, r4
 8004636:	4630      	mov	r0, r6
 8004638:	f001 f90f 	bl	800585a <pbuf_header>
 800463c:	b9b0      	cbnz	r0, 800466c <icmp_input+0x18c>
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
 800463e:	f8cd 8008 	str.w	r8, [sp, #8]
 8004642:	2301      	movs	r3, #1
 8004644:	9301      	str	r3, [sp, #4]
 8004646:	2200      	movs	r2, #0
 8004648:	9200      	str	r2, [sp, #0]
 800464a:	23ff      	movs	r3, #255	; 0xff
 800464c:	490a      	ldr	r1, [pc, #40]	; (8004678 <icmp_input+0x198>)
 800464e:	4630      	mov	r0, r6
 8004650:	f000 fa1c 	bl	8004a8c <ip_output_if>
 8004654:	e00a      	b.n	800466c <icmp_input+0x18c>
    ICMP_STATS_INC(icmp.proterr);
 8004656:	4b07      	ldr	r3, [pc, #28]	; (8004674 <icmp_input+0x194>)
 8004658:	f8b3 2070 	ldrh.w	r2, [r3, #112]	; 0x70
 800465c:	3201      	adds	r2, #1
 800465e:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
    ICMP_STATS_INC(icmp.drop);
 8004662:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
 8004666:	3201      	adds	r2, #1
 8004668:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
  pbuf_free(p);
 800466c:	4630      	mov	r0, r6
 800466e:	f001 f932 	bl	80058d6 <pbuf_free>
  return;
 8004672:	e76d      	b.n	8004550 <icmp_input+0x70>
 8004674:	2000b110 	.word	0x2000b110
 8004678:	200089d8 	.word	0x200089d8
 800467c:	200089d0 	.word	0x200089d0

08004680 <icmp_dest_unreach>:
{
 8004680:	b508      	push	{r3, lr}
  icmp_send_response(p, ICMP_DUR, t);
 8004682:	460a      	mov	r2, r1
 8004684:	2103      	movs	r1, #3
 8004686:	f7ff fed5 	bl	8004434 <icmp_send_response>
 800468a:	bd08      	pop	{r3, pc}

0800468c <icmp_time_exceeded>:
{
 800468c:	b508      	push	{r3, lr}
  icmp_send_response(p, ICMP_TE, t);
 800468e:	460a      	mov	r2, r1
 8004690:	210b      	movs	r1, #11
 8004692:	f7ff fecf 	bl	8004434 <icmp_send_response>
 8004696:	bd08      	pop	{r3, pc}

08004698 <lwip_standard_chksum>:
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
 8004698:	b410      	push	{r4}
 800469a:	b083      	sub	sp, #12
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
 800469c:	2300      	movs	r3, #0
 800469e:	f8ad 3006 	strh.w	r3, [sp, #6]
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 80046a2:	f010 0401 	ands.w	r4, r0, #1
 80046a6:	d007      	beq.n	80046b8 <lwip_standard_chksum+0x20>
 80046a8:	4299      	cmp	r1, r3
 80046aa:	dd2a      	ble.n	8004702 <lwip_standard_chksum+0x6a>
    ((u8_t *)&t)[1] = *pb++;
 80046ac:	1c43      	adds	r3, r0, #1
 80046ae:	7802      	ldrb	r2, [r0, #0]
 80046b0:	f88d 2007 	strb.w	r2, [sp, #7]
    len--;
 80046b4:	3901      	subs	r1, #1
 80046b6:	e000      	b.n	80046ba <lwip_standard_chksum+0x22>
  u8_t *pb = (u8_t *)dataptr;
 80046b8:	4603      	mov	r3, r0
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 80046ba:	2901      	cmp	r1, #1
 80046bc:	dd1f      	ble.n	80046fe <lwip_standard_chksum+0x66>
  u8_t *pb = (u8_t *)dataptr;
 80046be:	2200      	movs	r2, #0
    sum += *ps++;
 80046c0:	f833 0b02 	ldrh.w	r0, [r3], #2
 80046c4:	4402      	add	r2, r0
    len -= 2;
 80046c6:	3902      	subs	r1, #2
  while (len > 1) {
 80046c8:	2901      	cmp	r1, #1
 80046ca:	dcf9      	bgt.n	80046c0 <lwip_standard_chksum+0x28>
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 80046cc:	2900      	cmp	r1, #0
    ((u8_t *)&t)[0] = *(u8_t *)ps;
 80046ce:	bfc4      	itt	gt
 80046d0:	781b      	ldrbgt	r3, [r3, #0]
 80046d2:	f88d 3006 	strbgt.w	r3, [sp, #6]
  }

  /* Add end bytes */
  sum += t;
 80046d6:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 80046da:	4402      	add	r2, r0

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
 80046dc:	b290      	uxth	r0, r2
 80046de:	eb00 4212 	add.w	r2, r0, r2, lsr #16
  sum = FOLD_U32T(sum);
 80046e2:	b290      	uxth	r0, r2
 80046e4:	eb00 4012 	add.w	r0, r0, r2, lsr #16

  /* Swap if alignment was odd */
  if (odd) {
 80046e8:	b124      	cbz	r4, 80046f4 <lwip_standard_chksum+0x5c>
    sum = SWAP_BYTES_IN_WORD(sum);
 80046ea:	0203      	lsls	r3, r0, #8
 80046ec:	b29b      	uxth	r3, r3
 80046ee:	f3c0 2007 	ubfx	r0, r0, #8, #8
 80046f2:	4318      	orrs	r0, r3
  }

  return (u16_t)sum;
 80046f4:	b280      	uxth	r0, r0
}
 80046f6:	b003      	add	sp, #12
 80046f8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80046fc:	4770      	bx	lr
  u32_t sum = 0;
 80046fe:	2200      	movs	r2, #0
 8004700:	e7e4      	b.n	80046cc <lwip_standard_chksum+0x34>
  while (len > 1) {
 8004702:	2901      	cmp	r1, #1
  u8_t *pb = (u8_t *)dataptr;
 8004704:	bfc8      	it	gt
 8004706:	4603      	movgt	r3, r0
  while (len > 1) {
 8004708:	dcd9      	bgt.n	80046be <lwip_standard_chksum+0x26>
  sum = FOLD_U32T(sum);
 800470a:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 800470e:	e7ec      	b.n	80046ea <lwip_standard_chksum+0x52>

08004710 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len)
{
 8004710:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004714:	4689      	mov	r9, r1
 8004716:	4690      	mov	r8, r2
 8004718:	461f      	mov	r7, r3
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 800471a:	2800      	cmp	r0, #0
 800471c:	d03f      	beq.n	800479e <inet_chksum_pseudo+0x8e>
 800471e:	4605      	mov	r5, r0
 8004720:	2600      	movs	r6, #0
 8004722:	4634      	mov	r4, r6
 8004724:	e001      	b.n	800472a <inet_chksum_pseudo+0x1a>
 8004726:	682d      	ldr	r5, [r5, #0]
 8004728:	b1a5      	cbz	r5, 8004754 <inet_chksum_pseudo+0x44>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 800472a:	8969      	ldrh	r1, [r5, #10]
 800472c:	6868      	ldr	r0, [r5, #4]
 800472e:	f7ff ffb3 	bl	8004698 <lwip_standard_chksum>
 8004732:	4404      	add	r4, r0
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 8004734:	b2a0      	uxth	r0, r4
 8004736:	eb00 4414 	add.w	r4, r0, r4, lsr #16
    if (q->len % 2 != 0) {
 800473a:	896b      	ldrh	r3, [r5, #10]
 800473c:	f013 0f01 	tst.w	r3, #1
 8004740:	d0f1      	beq.n	8004726 <inet_chksum_pseudo+0x16>
      swapped = 1 - swapped;
 8004742:	f1c6 0601 	rsb	r6, r6, #1
 8004746:	b2f6      	uxtb	r6, r6
      acc = SWAP_BYTES_IN_WORD(acc);
 8004748:	0223      	lsls	r3, r4, #8
 800474a:	b29b      	uxth	r3, r3
 800474c:	f3c4 2407 	ubfx	r4, r4, #8, #8
 8004750:	431c      	orrs	r4, r3
 8004752:	e7e8      	b.n	8004726 <inet_chksum_pseudo+0x16>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 8004754:	b126      	cbz	r6, 8004760 <inet_chksum_pseudo+0x50>
    acc = SWAP_BYTES_IN_WORD(acc);
 8004756:	0223      	lsls	r3, r4, #8
 8004758:	b29b      	uxth	r3, r3
 800475a:	f3c4 2407 	ubfx	r4, r4, #8, #8
 800475e:	431c      	orrs	r4, r3
  }
  addr = ip4_addr_get_u32(src);
 8004760:	f8d9 2000 	ldr.w	r2, [r9]
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
 8004764:	f8d8 3000 	ldr.w	r3, [r8]
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
 8004768:	0c18      	lsrs	r0, r3, #16
 800476a:	fa10 f083 	uxtah	r0, r0, r3
 800476e:	fa10 f082 	uxtah	r0, r0, r2
 8004772:	eb00 4012 	add.w	r0, r0, r2, lsr #16
 8004776:	4404      	add	r4, r0
  acc += (u32_t)htons((u16_t)proto);
 8004778:	4638      	mov	r0, r7
 800477a:	f7ff fe31 	bl	80043e0 <lwip_htons>
 800477e:	4404      	add	r4, r0
  acc += (u32_t)htons(proto_len);
 8004780:	f8bd 0020 	ldrh.w	r0, [sp, #32]
 8004784:	f7ff fe2c 	bl	80043e0 <lwip_htons>
 8004788:	4420      	add	r0, r4

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 800478a:	b284      	uxth	r4, r0
 800478c:	eb04 4410 	add.w	r4, r4, r0, lsr #16
  acc = FOLD_U32T(acc);
 8004790:	b2a0      	uxth	r0, r4
 8004792:	eb00 4014 	add.w	r0, r0, r4, lsr #16
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 8004796:	43c0      	mvns	r0, r0
}
 8004798:	b280      	uxth	r0, r0
 800479a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  acc = 0;
 800479e:	2400      	movs	r4, #0
 80047a0:	e7de      	b.n	8004760 <inet_chksum_pseudo+0x50>

080047a2 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
 80047a2:	b508      	push	{r3, lr}
  return ~LWIP_CHKSUM(dataptr, len);
 80047a4:	f7ff ff78 	bl	8004698 <lwip_standard_chksum>
 80047a8:	43c0      	mvns	r0, r0
}
 80047aa:	b280      	uxth	r0, r0
 80047ac:	bd08      	pop	{r3, pc}

080047ae <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 80047ae:	b570      	push	{r4, r5, r6, lr}
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 80047b0:	b318      	cbz	r0, 80047fa <inet_chksum_pbuf+0x4c>
 80047b2:	4605      	mov	r5, r0
 80047b4:	2600      	movs	r6, #0
 80047b6:	4634      	mov	r4, r6
 80047b8:	e001      	b.n	80047be <inet_chksum_pbuf+0x10>
 80047ba:	682d      	ldr	r5, [r5, #0]
 80047bc:	b1a5      	cbz	r5, 80047e8 <inet_chksum_pbuf+0x3a>
    acc += LWIP_CHKSUM(q->payload, q->len);
 80047be:	8969      	ldrh	r1, [r5, #10]
 80047c0:	6868      	ldr	r0, [r5, #4]
 80047c2:	f7ff ff69 	bl	8004698 <lwip_standard_chksum>
 80047c6:	4420      	add	r0, r4
    acc = FOLD_U32T(acc);
 80047c8:	b284      	uxth	r4, r0
 80047ca:	eb04 4410 	add.w	r4, r4, r0, lsr #16
    if (q->len % 2 != 0) {
 80047ce:	896b      	ldrh	r3, [r5, #10]
 80047d0:	f013 0f01 	tst.w	r3, #1
 80047d4:	d0f1      	beq.n	80047ba <inet_chksum_pbuf+0xc>
      swapped = 1 - swapped;
 80047d6:	f1c6 0601 	rsb	r6, r6, #1
 80047da:	b2f6      	uxtb	r6, r6
      acc = SWAP_BYTES_IN_WORD(acc);
 80047dc:	0223      	lsls	r3, r4, #8
 80047de:	b29b      	uxth	r3, r3
 80047e0:	f3c4 2407 	ubfx	r4, r4, #8, #8
 80047e4:	431c      	orrs	r4, r3
 80047e6:	e7e8      	b.n	80047ba <inet_chksum_pbuf+0xc>
    }
  }

  if (swapped) {
 80047e8:	b126      	cbz	r6, 80047f4 <inet_chksum_pbuf+0x46>
    acc = SWAP_BYTES_IN_WORD(acc);
 80047ea:	0223      	lsls	r3, r4, #8
 80047ec:	b29b      	uxth	r3, r3
 80047ee:	f3c4 2407 	ubfx	r4, r4, #8, #8
 80047f2:	431c      	orrs	r4, r3
  }
  return (u16_t)~(acc & 0xffffUL);
 80047f4:	43e0      	mvns	r0, r4
}
 80047f6:	b280      	uxth	r0, r0
 80047f8:	bd70      	pop	{r4, r5, r6, pc}
  acc = 0;
 80047fa:	2400      	movs	r4, #0
 80047fc:	e7fa      	b.n	80047f4 <inet_chksum_pbuf+0x46>
	...

08004800 <ip_route>:
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 8004800:	4b11      	ldr	r3, [pc, #68]	; (8004848 <ip_route+0x48>)
 8004802:	681b      	ldr	r3, [r3, #0]
 8004804:	b963      	cbnz	r3, 8004820 <ip_route+0x20>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
 8004806:	4b11      	ldr	r3, [pc, #68]	; (800484c <ip_route+0x4c>)
 8004808:	681b      	ldr	r3, [r3, #0]
 800480a:	b1ab      	cbz	r3, 8004838 <ip_route+0x38>
 800480c:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 8004810:	f012 0f01 	tst.w	r2, #1
 8004814:	d010      	beq.n	8004838 <ip_route+0x38>
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
 8004816:	4618      	mov	r0, r3
 8004818:	4770      	bx	lr
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 800481a:	681b      	ldr	r3, [r3, #0]
 800481c:	2b00      	cmp	r3, #0
 800481e:	d0f2      	beq.n	8004806 <ip_route+0x6>
    if (netif_is_up(netif)) {
 8004820:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 8004824:	f012 0f01 	tst.w	r2, #1
 8004828:	d0f7      	beq.n	800481a <ip_route+0x1a>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
 800482a:	6802      	ldr	r2, [r0, #0]
 800482c:	6859      	ldr	r1, [r3, #4]
 800482e:	404a      	eors	r2, r1
 8004830:	6899      	ldr	r1, [r3, #8]
 8004832:	420a      	tst	r2, r1
 8004834:	d1f1      	bne.n	800481a <ip_route+0x1a>
 8004836:	e7ee      	b.n	8004816 <ip_route+0x16>
    IP_STATS_INC(ip.rterr);
 8004838:	4a05      	ldr	r2, [pc, #20]	; (8004850 <ip_route+0x50>)
 800483a:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
 800483e:	3301      	adds	r3, #1
 8004840:	f8a2 3056 	strh.w	r3, [r2, #86]	; 0x56
    return NULL;
 8004844:	2300      	movs	r3, #0
 8004846:	e7e6      	b.n	8004816 <ip_route+0x16>
 8004848:	2000b104 	.word	0x2000b104
 800484c:	2000b108 	.word	0x2000b108
 8004850:	2000b110 	.word	0x2000b110

08004854 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 8004854:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004858:	4606      	mov	r6, r0
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
 800485a:	4a86      	ldr	r2, [pc, #536]	; (8004a74 <ip_input+0x220>)
 800485c:	f8b2 304a 	ldrh.w	r3, [r2, #74]	; 0x4a
 8004860:	3301      	adds	r3, #1
 8004862:	f8a2 304a 	strh.w	r3, [r2, #74]	; 0x4a
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 8004866:	f8d0 9004 	ldr.w	r9, [r0, #4]
  if (IPH_V(iphdr) != 4) {
 800486a:	f899 5000 	ldrb.w	r5, [r9]
 800486e:	092b      	lsrs	r3, r5, #4
 8004870:	2b04      	cmp	r3, #4
 8004872:	d00f      	beq.n	8004894 <ip_input+0x40>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
 8004874:	f001 f82f 	bl	80058d6 <pbuf_free>
    IP_STATS_INC(ip.err);
 8004878:	4b7e      	ldr	r3, [pc, #504]	; (8004a74 <ip_input+0x220>)
 800487a:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 800487e:	3201      	adds	r2, #1
 8004880:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
    IP_STATS_INC(ip.drop);
 8004884:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 8004888:	3201      	adds	r2, #1
 800488a:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
  current_header = NULL;
  ip_addr_set_any(&current_iphdr_src);
  ip_addr_set_any(&current_iphdr_dest);

  return ERR_OK;
}
 800488e:	2000      	movs	r0, #0
 8004890:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004894:	4688      	mov	r8, r1
  iphdr_hlen = IPH_HL(iphdr);
 8004896:	f005 050f 	and.w	r5, r5, #15
  iphdr_hlen *= 4;
 800489a:	00ad      	lsls	r5, r5, #2
  iphdr_len = ntohs(IPH_LEN(iphdr));
 800489c:	f8b9 0002 	ldrh.w	r0, [r9, #2]
 80048a0:	f7ff fda3 	bl	80043ea <lwip_ntohs>
 80048a4:	4604      	mov	r4, r0
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 80048a6:	8973      	ldrh	r3, [r6, #10]
 80048a8:	42ab      	cmp	r3, r5
 80048aa:	d302      	bcc.n	80048b2 <ip_input+0x5e>
 80048ac:	8933      	ldrh	r3, [r6, #8]
 80048ae:	4283      	cmp	r3, r0
 80048b0:	d20e      	bcs.n	80048d0 <ip_input+0x7c>
    pbuf_free(p);
 80048b2:	4630      	mov	r0, r6
 80048b4:	f001 f80f 	bl	80058d6 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
 80048b8:	4b6e      	ldr	r3, [pc, #440]	; (8004a74 <ip_input+0x220>)
 80048ba:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 80048be:	3201      	adds	r2, #1
 80048c0:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    IP_STATS_INC(ip.drop);
 80048c4:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 80048c8:	3201      	adds	r2, #1
 80048ca:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    return ERR_OK;
 80048ce:	e7de      	b.n	800488e <ip_input+0x3a>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
 80048d0:	4629      	mov	r1, r5
 80048d2:	4648      	mov	r0, r9
 80048d4:	f7ff ff65 	bl	80047a2 <inet_chksum>
 80048d8:	b990      	cbnz	r0, 8004900 <ip_input+0xac>
  pbuf_realloc(p, iphdr_len);
 80048da:	4621      	mov	r1, r4
 80048dc:	4630      	mov	r0, r6
 80048de:	f001 f8c1 	bl	8005a64 <pbuf_realloc>
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
 80048e2:	f8d9 2010 	ldr.w	r2, [r9, #16]
 80048e6:	4b64      	ldr	r3, [pc, #400]	; (8004a78 <ip_input+0x224>)
 80048e8:	601a      	str	r2, [r3, #0]
  ip_addr_copy(current_iphdr_src, iphdr->src);
 80048ea:	f8d9 200c 	ldr.w	r2, [r9, #12]
 80048ee:	4b63      	ldr	r3, [pc, #396]	; (8004a7c <ip_input+0x228>)
 80048f0:	601a      	str	r2, [r3, #0]
    netif = inp;
 80048f2:	4644      	mov	r4, r8
    int first = 1;
 80048f4:	2701      	movs	r7, #1
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 80048f6:	f8df b180 	ldr.w	fp, [pc, #384]	; 8004a78 <ip_input+0x224>
        netif = netif_list;
 80048fa:	f8df a18c 	ldr.w	sl, [pc, #396]	; 8004a88 <ip_input+0x234>
 80048fe:	e016      	b.n	800492e <ip_input+0xda>
    pbuf_free(p);
 8004900:	4630      	mov	r0, r6
 8004902:	f000 ffe8 	bl	80058d6 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
 8004906:	4b5b      	ldr	r3, [pc, #364]	; (8004a74 <ip_input+0x220>)
 8004908:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
 800490c:	3201      	adds	r2, #1
 800490e:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
    IP_STATS_INC(ip.drop);
 8004912:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 8004916:	3201      	adds	r2, #1
 8004918:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    return ERR_OK;
 800491c:	e7b7      	b.n	800488e <ip_input+0x3a>
      if (first) {
 800491e:	b1ff      	cbz	r7, 8004960 <ip_input+0x10c>
        netif = netif_list;
 8004920:	f8da 4000 	ldr.w	r4, [sl]
      if (netif == inp) {
 8004924:	4544      	cmp	r4, r8
        netif = netif->next;
 8004926:	bf08      	it	eq
 8004928:	6824      	ldreq	r4, [r4, #0]
 800492a:	2700      	movs	r7, #0
    } while(netif != NULL);
 800492c:	b1d4      	cbz	r4, 8004964 <ip_input+0x110>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
 800492e:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 8004932:	f013 0f01 	tst.w	r3, #1
 8004936:	d0f2      	beq.n	800491e <ip_input+0xca>
 8004938:	f114 0f04 	cmn.w	r4, #4
 800493c:	d0ef      	beq.n	800491e <ip_input+0xca>
 800493e:	6863      	ldr	r3, [r4, #4]
 8004940:	2b00      	cmp	r3, #0
 8004942:	d0ec      	beq.n	800491e <ip_input+0xca>
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 8004944:	f8db 0000 	ldr.w	r0, [fp]
 8004948:	4283      	cmp	r3, r0
 800494a:	d004      	beq.n	8004956 <ip_input+0x102>
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
 800494c:	4621      	mov	r1, r4
 800494e:	f000 f943 	bl	8004bd8 <ip4_addr_isbroadcast>
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 8004952:	2800      	cmp	r0, #0
 8004954:	d0e3      	beq.n	800491e <ip_input+0xca>
  if (netif == NULL) {
 8004956:	b12c      	cbz	r4, 8004964 <ip_input+0x110>
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
 8004958:	4b48      	ldr	r3, [pc, #288]	; (8004a7c <ip_input+0x228>)
 800495a:	6818      	ldr	r0, [r3, #0]
 800495c:	b1c0      	cbz	r0, 8004990 <ip_input+0x13c>
 800495e:	e00a      	b.n	8004976 <ip_input+0x122>
        netif = netif->next;
 8004960:	6824      	ldr	r4, [r4, #0]
 8004962:	e7df      	b.n	8004924 <ip_input+0xd0>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
 8004964:	f899 3009 	ldrb.w	r3, [r9, #9]
 8004968:	2b11      	cmp	r3, #17
 800496a:	d055      	beq.n	8004a18 <ip_input+0x1c4>
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
 800496c:	4b43      	ldr	r3, [pc, #268]	; (8004a7c <ip_input+0x228>)
 800496e:	6818      	ldr	r0, [r3, #0]
 8004970:	2800      	cmp	r0, #0
 8004972:	d062      	beq.n	8004a3a <ip_input+0x1e6>
 8004974:	2400      	movs	r4, #0
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 8004976:	4641      	mov	r1, r8
 8004978:	f000 f92e 	bl	8004bd8 <ip4_addr_isbroadcast>
 800497c:	2800      	cmp	r0, #0
 800497e:	d152      	bne.n	8004a26 <ip_input+0x1d2>
         (ip_addr_ismulticast(&current_iphdr_src))) {
 8004980:	4b3e      	ldr	r3, [pc, #248]	; (8004a7c <ip_input+0x228>)
 8004982:	681b      	ldr	r3, [r3, #0]
 8004984:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 8004988:	2be0      	cmp	r3, #224	; 0xe0
 800498a:	d04c      	beq.n	8004a26 <ip_input+0x1d2>
  if (netif == NULL) {
 800498c:	2c00      	cmp	r4, #0
 800498e:	d054      	beq.n	8004a3a <ip_input+0x1e6>
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 8004990:	f8b9 3006 	ldrh.w	r3, [r9, #6]
 8004994:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8004998:	b29b      	uxth	r3, r3
 800499a:	b143      	cbz	r3, 80049ae <ip_input+0x15a>
    p = ip_reass(p);
 800499c:	4630      	mov	r0, r6
 800499e:	f000 f9e5 	bl	8004d6c <ip_reass>
    if (p == NULL) {
 80049a2:	4606      	mov	r6, r0
 80049a4:	2800      	cmp	r0, #0
 80049a6:	f43f af72 	beq.w	800488e <ip_input+0x3a>
    iphdr = (struct ip_hdr *)p->payload;
 80049aa:	f8d0 9004 	ldr.w	r9, [r0, #4]
  current_netif = inp;
 80049ae:	4b34      	ldr	r3, [pc, #208]	; (8004a80 <ip_input+0x22c>)
 80049b0:	f8c3 8000 	str.w	r8, [r3]
  current_header = iphdr;
 80049b4:	4b33      	ldr	r3, [pc, #204]	; (8004a84 <ip_input+0x230>)
 80049b6:	f8c3 9000 	str.w	r9, [r3]
  if (raw_input(p, inp) == 0)
 80049ba:	4641      	mov	r1, r8
 80049bc:	4630      	mov	r0, r6
 80049be:	f001 f951 	bl	8005c64 <raw_input>
 80049c2:	2800      	cmp	r0, #0
 80049c4:	d141      	bne.n	8004a4a <ip_input+0x1f6>
    switch (IPH_PROTO(iphdr)) {
 80049c6:	f899 3009 	ldrb.w	r3, [r9, #9]
 80049ca:	2b06      	cmp	r3, #6
 80049cc:	d047      	beq.n	8004a5e <ip_input+0x20a>
 80049ce:	2b11      	cmp	r3, #17
 80049d0:	d037      	beq.n	8004a42 <ip_input+0x1ee>
 80049d2:	2b01      	cmp	r3, #1
 80049d4:	d048      	beq.n	8004a68 <ip_input+0x214>
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 80049d6:	4641      	mov	r1, r8
 80049d8:	4b27      	ldr	r3, [pc, #156]	; (8004a78 <ip_input+0x224>)
 80049da:	6818      	ldr	r0, [r3, #0]
 80049dc:	f000 f8fc 	bl	8004bd8 <ip4_addr_isbroadcast>
 80049e0:	b958      	cbnz	r0, 80049fa <ip_input+0x1a6>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 80049e2:	4b25      	ldr	r3, [pc, #148]	; (8004a78 <ip_input+0x224>)
 80049e4:	681b      	ldr	r3, [r3, #0]
 80049e6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 80049ea:	2be0      	cmp	r3, #224	; 0xe0
 80049ec:	d005      	beq.n	80049fa <ip_input+0x1a6>
        p->payload = iphdr;
 80049ee:	f8c6 9004 	str.w	r9, [r6, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 80049f2:	2102      	movs	r1, #2
 80049f4:	4630      	mov	r0, r6
 80049f6:	f7ff fe43 	bl	8004680 <icmp_dest_unreach>
      pbuf_free(p);
 80049fa:	4630      	mov	r0, r6
 80049fc:	f000 ff6b 	bl	80058d6 <pbuf_free>
      IP_STATS_INC(ip.proterr);
 8004a00:	4b1c      	ldr	r3, [pc, #112]	; (8004a74 <ip_input+0x220>)
 8004a02:	f8b3 2058 	ldrh.w	r2, [r3, #88]	; 0x58
 8004a06:	3201      	adds	r2, #1
 8004a08:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
      IP_STATS_INC(ip.drop);
 8004a0c:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 8004a10:	3201      	adds	r2, #1
 8004a12:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
 8004a16:	e018      	b.n	8004a4a <ip_input+0x1f6>
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
 8004a18:	444d      	add	r5, r9
 8004a1a:	886b      	ldrh	r3, [r5, #2]
 8004a1c:	f5b3 4f86 	cmp.w	r3, #17152	; 0x4300
 8004a20:	d1a4      	bne.n	800496c <ip_input+0x118>
        netif = inp;
 8004a22:	4644      	mov	r4, r8
 8004a24:	e7b2      	b.n	800498c <ip_input+0x138>
      pbuf_free(p);
 8004a26:	4630      	mov	r0, r6
 8004a28:	f000 ff55 	bl	80058d6 <pbuf_free>
      IP_STATS_INC(ip.drop);
 8004a2c:	4a11      	ldr	r2, [pc, #68]	; (8004a74 <ip_input+0x220>)
 8004a2e:	f8b2 304e 	ldrh.w	r3, [r2, #78]	; 0x4e
 8004a32:	3301      	adds	r3, #1
 8004a34:	f8a2 304e 	strh.w	r3, [r2, #78]	; 0x4e
      return ERR_OK;
 8004a38:	e729      	b.n	800488e <ip_input+0x3a>
    pbuf_free(p);
 8004a3a:	4630      	mov	r0, r6
 8004a3c:	f000 ff4b 	bl	80058d6 <pbuf_free>
    return ERR_OK;
 8004a40:	e725      	b.n	800488e <ip_input+0x3a>
      udp_input(p, inp);
 8004a42:	4641      	mov	r1, r8
 8004a44:	4630      	mov	r0, r6
 8004a46:	f003 fcd3 	bl	80083f0 <udp_input>
  current_netif = NULL;
 8004a4a:	2300      	movs	r3, #0
 8004a4c:	4a0c      	ldr	r2, [pc, #48]	; (8004a80 <ip_input+0x22c>)
 8004a4e:	6013      	str	r3, [r2, #0]
  current_header = NULL;
 8004a50:	4a0c      	ldr	r2, [pc, #48]	; (8004a84 <ip_input+0x230>)
 8004a52:	6013      	str	r3, [r2, #0]
  ip_addr_set_any(&current_iphdr_src);
 8004a54:	4a09      	ldr	r2, [pc, #36]	; (8004a7c <ip_input+0x228>)
 8004a56:	6013      	str	r3, [r2, #0]
  ip_addr_set_any(&current_iphdr_dest);
 8004a58:	4a07      	ldr	r2, [pc, #28]	; (8004a78 <ip_input+0x224>)
 8004a5a:	6013      	str	r3, [r2, #0]
  return ERR_OK;
 8004a5c:	e717      	b.n	800488e <ip_input+0x3a>
      tcp_input(p, inp);
 8004a5e:	4641      	mov	r1, r8
 8004a60:	4630      	mov	r0, r6
 8004a62:	f002 fb0f 	bl	8007084 <tcp_input>
      break;
 8004a66:	e7f0      	b.n	8004a4a <ip_input+0x1f6>
      icmp_input(p, inp);
 8004a68:	4641      	mov	r1, r8
 8004a6a:	4630      	mov	r0, r6
 8004a6c:	f7ff fd38 	bl	80044e0 <icmp_input>
      break;
 8004a70:	e7eb      	b.n	8004a4a <ip_input+0x1f6>
 8004a72:	bf00      	nop
 8004a74:	2000b110 	.word	0x2000b110
 8004a78:	200089d8 	.word	0x200089d8
 8004a7c:	200089d0 	.word	0x200089d0
 8004a80:	200089d4 	.word	0x200089d4
 8004a84:	200089dc 	.word	0x200089dc
 8004a88:	2000b104 	.word	0x2000b104

08004a8c <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 8004a8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004a90:	b083      	sub	sp, #12
 8004a92:	4605      	mov	r5, r0
 8004a94:	f89d 9030 	ldrb.w	r9, [sp, #48]	; 0x30
 8004a98:	f89d b034 	ldrb.w	fp, [sp, #52]	; 0x34
 8004a9c:	9e0e      	ldr	r6, [sp, #56]	; 0x38
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
 8004a9e:	2a00      	cmp	r2, #0
 8004aa0:	d065      	beq.n	8004b6e <ip_output_if+0xe2>
 8004aa2:	468a      	mov	sl, r1
 8004aa4:	4698      	mov	r8, r3
 8004aa6:	4617      	mov	r7, r2
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 8004aa8:	2114      	movs	r1, #20
 8004aaa:	f000 fed6 	bl	800585a <pbuf_header>
 8004aae:	2800      	cmp	r0, #0
 8004ab0:	d152      	bne.n	8004b58 <ip_output_if+0xcc>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
 8004ab2:	686c      	ldr	r4, [r5, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 8004ab4:	f884 8008 	strb.w	r8, [r4, #8]
    IPH_PROTO_SET(iphdr, proto);
 8004ab8:	f884 b009 	strb.w	fp, [r4, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
 8004abc:	6838      	ldr	r0, [r7, #0]
 8004abe:	6120      	str	r0, [r4, #16]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 8004ac0:	2345      	movs	r3, #69	; 0x45
 8004ac2:	7023      	strb	r3, [r4, #0]
    IPH_TOS_SET(iphdr, tos);
 8004ac4:	f884 9001 	strb.w	r9, [r4, #1]
    chk_sum += LWIP_MAKE_U16(proto, ttl);
 8004ac8:	ea48 280b 	orr.w	r8, r8, fp, lsl #8
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
 8004acc:	fa18 f880 	uxtah	r8, r8, r0
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
 8004ad0:	ea4f 2309 	mov.w	r3, r9, lsl #8
 8004ad4:	f043 0345 	orr.w	r3, r3, #69	; 0x45
 8004ad8:	4443      	add	r3, r8
 8004ada:	eb03 4810 	add.w	r8, r3, r0, lsr #16
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 8004ade:	8928      	ldrh	r0, [r5, #8]
 8004ae0:	f7ff fc7e 	bl	80043e0 <lwip_htons>
 8004ae4:	4681      	mov	r9, r0
 8004ae6:	8060      	strh	r0, [r4, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 8004ae8:	2300      	movs	r3, #0
 8004aea:	71a3      	strb	r3, [r4, #6]
 8004aec:	71e3      	strb	r3, [r4, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
 8004aee:	f8df b09c 	ldr.w	fp, [pc, #156]	; 8004b8c <ip_output_if+0x100>
 8004af2:	f8bb 0000 	ldrh.w	r0, [fp]
 8004af6:	f7ff fc73 	bl	80043e0 <lwip_htons>
 8004afa:	80a0      	strh	r0, [r4, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 8004afc:	f8bb 3000 	ldrh.w	r3, [fp]
 8004b00:	3301      	adds	r3, #1
 8004b02:	f8ab 3000 	strh.w	r3, [fp]

    if (ip_addr_isany(src)) {
 8004b06:	f1ba 0f00 	cmp.w	sl, #0
 8004b0a:	d002      	beq.n	8004b12 <ip_output_if+0x86>
 8004b0c:	f8da 3000 	ldr.w	r3, [sl]
 8004b10:	bb5b      	cbnz	r3, 8004b6a <ip_output_if+0xde>
      ip_addr_copy(iphdr->src, netif->ip_addr);
 8004b12:	6873      	ldr	r3, [r6, #4]
 8004b14:	60e3      	str	r3, [r4, #12]
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
 8004b16:	68e2      	ldr	r2, [r4, #12]
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
 8004b18:	fa18 f382 	uxtah	r3, r8, r2
 8004b1c:	eb03 4312 	add.w	r3, r3, r2, lsr #16
 8004b20:	444b      	add	r3, r9
 8004b22:	4418      	add	r0, r3
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
 8004b24:	b283      	uxth	r3, r0
 8004b26:	eb03 4010 	add.w	r0, r3, r0, lsr #16
    chk_sum = (chk_sum >> 16) + chk_sum;
 8004b2a:	eb00 4010 	add.w	r0, r0, r0, lsr #16
    chk_sum = ~chk_sum;
    iphdr->_chksum = chk_sum; /* network order */
 8004b2e:	43c0      	mvns	r0, r0
 8004b30:	8160      	strh	r0, [r4, #10]
    iphdr = (struct ip_hdr *)p->payload;
    ip_addr_copy(dest_addr, iphdr->dest);
    dest = &dest_addr;
  }

  IP_STATS_INC(ip.xmit);
 8004b32:	4a15      	ldr	r2, [pc, #84]	; (8004b88 <ip_output_if+0xfc>)
 8004b34:	f8b2 3048 	ldrh.w	r3, [r2, #72]	; 0x48
 8004b38:	3301      	adds	r3, #1
 8004b3a:	f8a2 3048 	strh.w	r3, [r2, #72]	; 0x48
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 8004b3e:	8c33      	ldrh	r3, [r6, #32]
 8004b40:	b113      	cbz	r3, 8004b48 <ip_output_if+0xbc>
 8004b42:	892a      	ldrh	r2, [r5, #8]
 8004b44:	429a      	cmp	r2, r3
 8004b46:	d818      	bhi.n	8004b7a <ip_output_if+0xee>
    return ip_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
 8004b48:	6973      	ldr	r3, [r6, #20]
 8004b4a:	463a      	mov	r2, r7
 8004b4c:	4629      	mov	r1, r5
 8004b4e:	4630      	mov	r0, r6
 8004b50:	4798      	blx	r3
}
 8004b52:	b003      	add	sp, #12
 8004b54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      IP_STATS_INC(ip.err);
 8004b58:	4a0b      	ldr	r2, [pc, #44]	; (8004b88 <ip_output_if+0xfc>)
 8004b5a:	f8b2 305c 	ldrh.w	r3, [r2, #92]	; 0x5c
 8004b5e:	3301      	adds	r3, #1
 8004b60:	f8a2 305c 	strh.w	r3, [r2, #92]	; 0x5c
      return ERR_BUF;
 8004b64:	f06f 0001 	mvn.w	r0, #1
 8004b68:	e7f3      	b.n	8004b52 <ip_output_if+0xc6>
      ip_addr_copy(iphdr->src, *src);
 8004b6a:	60e3      	str	r3, [r4, #12]
 8004b6c:	e7d3      	b.n	8004b16 <ip_output_if+0x8a>
    ip_addr_copy(dest_addr, iphdr->dest);
 8004b6e:	6843      	ldr	r3, [r0, #4]
 8004b70:	691b      	ldr	r3, [r3, #16]
 8004b72:	af02      	add	r7, sp, #8
 8004b74:	f847 3d04 	str.w	r3, [r7, #-4]!
 8004b78:	e7db      	b.n	8004b32 <ip_output_if+0xa6>
    return ip_frag(p, netif, dest);
 8004b7a:	463a      	mov	r2, r7
 8004b7c:	4631      	mov	r1, r6
 8004b7e:	4628      	mov	r0, r5
 8004b80:	f000 faac 	bl	80050dc <ip_frag>
 8004b84:	e7e5      	b.n	8004b52 <ip_output_if+0xc6>
 8004b86:	bf00      	nop
 8004b88:	2000b110 	.word	0x2000b110
 8004b8c:	20000e7c 	.word	0x20000e7c

08004b90 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 8004b90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004b92:	b085      	sub	sp, #20
 8004b94:	4605      	mov	r5, r0
 8004b96:	460e      	mov	r6, r1
 8004b98:	4614      	mov	r4, r2
 8004b9a:	461f      	mov	r7, r3

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(dest)) == NULL) {
 8004b9c:	4610      	mov	r0, r2
 8004b9e:	f7ff fe2f 	bl	8004800 <ip_route>
 8004ba2:	b170      	cbz	r0, 8004bc2 <ip_output+0x32>
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
 8004ba4:	9002      	str	r0, [sp, #8]
 8004ba6:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 8004baa:	9301      	str	r3, [sp, #4]
 8004bac:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 8004bb0:	9300      	str	r3, [sp, #0]
 8004bb2:	463b      	mov	r3, r7
 8004bb4:	4622      	mov	r2, r4
 8004bb6:	4631      	mov	r1, r6
 8004bb8:	4628      	mov	r0, r5
 8004bba:	f7ff ff67 	bl	8004a8c <ip_output_if>
}
 8004bbe:	b005      	add	sp, #20
 8004bc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    IP_STATS_INC(ip.rterr);
 8004bc2:	4a04      	ldr	r2, [pc, #16]	; (8004bd4 <ip_output+0x44>)
 8004bc4:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
 8004bc8:	3301      	adds	r3, #1
 8004bca:	f8a2 3056 	strh.w	r3, [r2, #86]	; 0x56
    return ERR_RTE;
 8004bce:	f06f 0003 	mvn.w	r0, #3
 8004bd2:	e7f4      	b.n	8004bbe <ip_output+0x2e>
 8004bd4:	2000b110 	.word	0x2000b110

08004bd8 <ip4_addr_isbroadcast>:
{
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 8004bd8:	1e43      	subs	r3, r0, #1
 8004bda:	f113 0f03 	cmn.w	r3, #3
 8004bde:	d812      	bhi.n	8004c06 <ip4_addr_isbroadcast+0x2e>
      (addr == IPADDR_ANY)) {
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 8004be0:	f891 3029 	ldrb.w	r3, [r1, #41]	; 0x29
 8004be4:	f013 0f02 	tst.w	r3, #2
 8004be8:	d00f      	beq.n	8004c0a <ip4_addr_isbroadcast+0x32>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
 8004bea:	684b      	ldr	r3, [r1, #4]
 8004bec:	4298      	cmp	r0, r3
 8004bee:	d00e      	beq.n	8004c0e <ip4_addr_isbroadcast+0x36>
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
 8004bf0:	688a      	ldr	r2, [r1, #8]
 8004bf2:	4043      	eors	r3, r0
 8004bf4:	4213      	tst	r3, r2
 8004bf6:	d10c      	bne.n	8004c12 <ip4_addr_isbroadcast+0x3a>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
 8004bf8:	43d2      	mvns	r2, r2
 8004bfa:	ea32 0300 	bics.w	r3, r2, r0
    return 1;
 8004bfe:	bf0c      	ite	eq
 8004c00:	2001      	moveq	r0, #1
 8004c02:	2000      	movne	r0, #0
 8004c04:	4770      	bx	lr
 8004c06:	2001      	movs	r0, #1
 8004c08:	4770      	bx	lr
    return 0;
 8004c0a:	2000      	movs	r0, #0
 8004c0c:	4770      	bx	lr
    return 0;
 8004c0e:	2000      	movs	r0, #0
 8004c10:	4770      	bx	lr
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
 8004c12:	2000      	movs	r0, #0
  }
}
 8004c14:	4770      	bx	lr
	...

08004c18 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 8004c18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004c1c:	4607      	mov	r7, r0
 8004c1e:	4688      	mov	r8, r1
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 8004c20:	6845      	ldr	r5, [r0, #4]
 8004c22:	686b      	ldr	r3, [r5, #4]
  if (iprh->start == 0) {
 8004c24:	889a      	ldrh	r2, [r3, #4]
 8004c26:	b30a      	cbz	r2, 8004c6c <ip_reass_free_complete_datagram+0x54>
  u16_t pbufs_freed = 0;
 8004c28:	2400      	movs	r4, #0
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
 8004c2a:	687d      	ldr	r5, [r7, #4]
  while (p != NULL) {
 8004c2c:	b165      	cbz	r5, 8004c48 <ip_reass_free_complete_datagram+0x30>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
 8004c2e:	686b      	ldr	r3, [r5, #4]
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
 8004c30:	681e      	ldr	r6, [r3, #0]
    clen = pbuf_clen(pcur);
 8004c32:	4628      	mov	r0, r5
 8004c34:	f000 ff41 	bl	8005aba <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 8004c38:	4404      	add	r4, r0
 8004c3a:	b2a4      	uxth	r4, r4
    pbuf_free(pcur);
 8004c3c:	4628      	mov	r0, r5
 8004c3e:	f000 fe4a 	bl	80058d6 <pbuf_free>
    p = iprh->next_pbuf;
 8004c42:	4635      	mov	r5, r6
  while (p != NULL) {
 8004c44:	2e00      	cmp	r6, #0
 8004c46:	d1f2      	bne.n	8004c2e <ip_reass_free_complete_datagram+0x16>
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 8004c48:	4b18      	ldr	r3, [pc, #96]	; (8004cac <ip_reass_free_complete_datagram+0x94>)
 8004c4a:	681b      	ldr	r3, [r3, #0]
 8004c4c:	429f      	cmp	r7, r3
 8004c4e:	d028      	beq.n	8004ca2 <ip_reass_free_complete_datagram+0x8a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
 8004c50:	683b      	ldr	r3, [r7, #0]
 8004c52:	f8c8 3000 	str.w	r3, [r8]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 8004c56:	4639      	mov	r1, r7
 8004c58:	2005      	movs	r0, #5
 8004c5a:	f000 fd45 	bl	80056e8 <memp_free>
  ip_reass_pbufcount -= pbufs_freed;
 8004c5e:	4a14      	ldr	r2, [pc, #80]	; (8004cb0 <ip_reass_free_complete_datagram+0x98>)
 8004c60:	8813      	ldrh	r3, [r2, #0]
 8004c62:	1b1b      	subs	r3, r3, r4
 8004c64:	8013      	strh	r3, [r2, #0]
}
 8004c66:	4620      	mov	r0, r4
 8004c68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ipr->p = iprh->next_pbuf;
 8004c6c:	681b      	ldr	r3, [r3, #0]
 8004c6e:	6043      	str	r3, [r0, #4]
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 8004c70:	686a      	ldr	r2, [r5, #4]
 8004c72:	4603      	mov	r3, r0
 8004c74:	f853 1f08 	ldr.w	r1, [r3, #8]!
 8004c78:	685e      	ldr	r6, [r3, #4]
 8004c7a:	689c      	ldr	r4, [r3, #8]
 8004c7c:	68d8      	ldr	r0, [r3, #12]
 8004c7e:	6011      	str	r1, [r2, #0]
 8004c80:	6056      	str	r6, [r2, #4]
 8004c82:	6094      	str	r4, [r2, #8]
 8004c84:	60d0      	str	r0, [r2, #12]
 8004c86:	6919      	ldr	r1, [r3, #16]
 8004c88:	6111      	str	r1, [r2, #16]
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 8004c8a:	2101      	movs	r1, #1
 8004c8c:	4628      	mov	r0, r5
 8004c8e:	f7ff fcfd 	bl	800468c <icmp_time_exceeded>
    clen = pbuf_clen(p);
 8004c92:	4628      	mov	r0, r5
 8004c94:	f000 ff11 	bl	8005aba <pbuf_clen>
    pbufs_freed += clen;
 8004c98:	b284      	uxth	r4, r0
    pbuf_free(p);
 8004c9a:	4628      	mov	r0, r5
 8004c9c:	f000 fe1b 	bl	80058d6 <pbuf_free>
 8004ca0:	e7c3      	b.n	8004c2a <ip_reass_free_complete_datagram+0x12>
    reassdatagrams = ipr->next;
 8004ca2:	683a      	ldr	r2, [r7, #0]
 8004ca4:	4b01      	ldr	r3, [pc, #4]	; (8004cac <ip_reass_free_complete_datagram+0x94>)
 8004ca6:	601a      	str	r2, [r3, #0]
 8004ca8:	e7d5      	b.n	8004c56 <ip_reass_free_complete_datagram+0x3e>
 8004caa:	bf00      	nop
 8004cac:	20000e80 	.word	0x20000e80
 8004cb0:	20000e7e 	.word	0x20000e7e

08004cb4 <ip_reass_remove_oldest_datagram>:
{
 8004cb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004cb8:	4605      	mov	r5, r0
 8004cba:	4688      	mov	r8, r1
  int pbufs_freed = 0, pbufs_freed_current;
 8004cbc:	2600      	movs	r6, #0
    r = reassdatagrams;
 8004cbe:	4f18      	ldr	r7, [pc, #96]	; (8004d20 <ip_reass_remove_oldest_datagram+0x6c>)
 8004cc0:	e023      	b.n	8004d0a <ip_reass_remove_oldest_datagram+0x56>
        other_datagrams++;
 8004cc2:	3401      	adds	r4, #1
        if (oldest == NULL) {
 8004cc4:	b1b8      	cbz	r0, 8004cf6 <ip_reass_remove_oldest_datagram+0x42>
        } else if (r->timer <= oldest->timer) {
 8004cc6:	f893 e01f 	ldrb.w	lr, [r3, #31]
 8004cca:	7fc2      	ldrb	r2, [r0, #31]
 8004ccc:	4596      	cmp	lr, r2
 8004cce:	bf98      	it	ls
 8004cd0:	4618      	movls	r0, r3
      if (r->next != NULL) {
 8004cd2:	681a      	ldr	r2, [r3, #0]
 8004cd4:	b18a      	cbz	r2, 8004cfa <ip_reass_remove_oldest_datagram+0x46>
 8004cd6:	4619      	mov	r1, r3
 8004cd8:	4613      	mov	r3, r2
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 8004cda:	695a      	ldr	r2, [r3, #20]
 8004cdc:	4562      	cmp	r2, ip
 8004cde:	d1f0      	bne.n	8004cc2 <ip_reass_remove_oldest_datagram+0xe>
 8004ce0:	f8d5 e010 	ldr.w	lr, [r5, #16]
 8004ce4:	699a      	ldr	r2, [r3, #24]
 8004ce6:	4572      	cmp	r2, lr
 8004ce8:	d1eb      	bne.n	8004cc2 <ip_reass_remove_oldest_datagram+0xe>
 8004cea:	f8b3 e00c 	ldrh.w	lr, [r3, #12]
 8004cee:	88aa      	ldrh	r2, [r5, #4]
 8004cf0:	4596      	cmp	lr, r2
 8004cf2:	d1e6      	bne.n	8004cc2 <ip_reass_remove_oldest_datagram+0xe>
 8004cf4:	e7ed      	b.n	8004cd2 <ip_reass_remove_oldest_datagram+0x1e>
 8004cf6:	4618      	mov	r0, r3
 8004cf8:	e7eb      	b.n	8004cd2 <ip_reass_remove_oldest_datagram+0x1e>
    if (oldest != NULL) {
 8004cfa:	b110      	cbz	r0, 8004d02 <ip_reass_remove_oldest_datagram+0x4e>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
 8004cfc:	f7ff ff8c 	bl	8004c18 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
 8004d00:	4406      	add	r6, r0
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 8004d02:	4546      	cmp	r6, r8
 8004d04:	da09      	bge.n	8004d1a <ip_reass_remove_oldest_datagram+0x66>
 8004d06:	2c01      	cmp	r4, #1
 8004d08:	dd07      	ble.n	8004d1a <ip_reass_remove_oldest_datagram+0x66>
    r = reassdatagrams;
 8004d0a:	683b      	ldr	r3, [r7, #0]
    while (r != NULL) {
 8004d0c:	b12b      	cbz	r3, 8004d1a <ip_reass_remove_oldest_datagram+0x66>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 8004d0e:	f8d5 c00c 	ldr.w	ip, [r5, #12]
 8004d12:	2400      	movs	r4, #0
 8004d14:	4621      	mov	r1, r4
 8004d16:	4620      	mov	r0, r4
 8004d18:	e7df      	b.n	8004cda <ip_reass_remove_oldest_datagram+0x26>
}
 8004d1a:	4630      	mov	r0, r6
 8004d1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004d20:	20000e80 	.word	0x20000e80

08004d24 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 8004d24:	b510      	push	{r4, lr}
 8004d26:	4604      	mov	r4, r0
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
 8004d28:	6940      	ldr	r0, [r0, #20]
 8004d2a:	b108      	cbz	r0, 8004d30 <ipfrag_free_pbuf_custom+0xc>
    pbuf_free(pcr->original);
 8004d2c:	f000 fdd3 	bl	80058d6 <pbuf_free>
  memp_free(MEMP_FRAG_PBUF, p);
 8004d30:	4621      	mov	r1, r4
 8004d32:	2006      	movs	r0, #6
 8004d34:	f000 fcd8 	bl	80056e8 <memp_free>
 8004d38:	bd10      	pop	{r4, pc}
	...

08004d3c <ip_reass_tmr>:
{
 8004d3c:	b538      	push	{r3, r4, r5, lr}
  r = reassdatagrams;
 8004d3e:	4b0a      	ldr	r3, [pc, #40]	; (8004d68 <ip_reass_tmr+0x2c>)
 8004d40:	6818      	ldr	r0, [r3, #0]
  while (r != NULL) {
 8004d42:	b178      	cbz	r0, 8004d64 <ip_reass_tmr+0x28>
 8004d44:	2400      	movs	r4, #0
 8004d46:	e005      	b.n	8004d54 <ip_reass_tmr+0x18>
      r = r->next;
 8004d48:	6805      	ldr	r5, [r0, #0]
      ip_reass_free_complete_datagram(tmp, prev);
 8004d4a:	4621      	mov	r1, r4
 8004d4c:	f7ff ff64 	bl	8004c18 <ip_reass_free_complete_datagram>
      r = r->next;
 8004d50:	4628      	mov	r0, r5
  while (r != NULL) {
 8004d52:	b138      	cbz	r0, 8004d64 <ip_reass_tmr+0x28>
    if (r->timer > 0) {
 8004d54:	7fc3      	ldrb	r3, [r0, #31]
 8004d56:	2b00      	cmp	r3, #0
 8004d58:	d0f6      	beq.n	8004d48 <ip_reass_tmr+0xc>
      r->timer--;
 8004d5a:	3b01      	subs	r3, #1
 8004d5c:	77c3      	strb	r3, [r0, #31]
 8004d5e:	4604      	mov	r4, r0
      r = r->next;
 8004d60:	6800      	ldr	r0, [r0, #0]
 8004d62:	e7f6      	b.n	8004d52 <ip_reass_tmr+0x16>
 8004d64:	bd38      	pop	{r3, r4, r5, pc}
 8004d66:	bf00      	nop
 8004d68:	20000e80 	.word	0x20000e80

08004d6c <ip_reass>:
{
 8004d6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004d70:	b083      	sub	sp, #12
 8004d72:	4607      	mov	r7, r0
  IPFRAG_STATS_INC(ip_frag.recv);
 8004d74:	4ab2      	ldr	r2, [pc, #712]	; (8005040 <ip_reass+0x2d4>)
 8004d76:	8e53      	ldrh	r3, [r2, #50]	; 0x32
 8004d78:	3301      	adds	r3, #1
 8004d7a:	8653      	strh	r3, [r2, #50]	; 0x32
  fraghdr = (struct ip_hdr*)p->payload;
 8004d7c:	6846      	ldr	r6, [r0, #4]
  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 8004d7e:	7833      	ldrb	r3, [r6, #0]
 8004d80:	f003 030f 	and.w	r3, r3, #15
 8004d84:	2b05      	cmp	r3, #5
 8004d86:	d11a      	bne.n	8004dbe <ip_reass+0x52>
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 8004d88:	88f0      	ldrh	r0, [r6, #6]
 8004d8a:	f7ff fb2e 	bl	80043ea <lwip_ntohs>
 8004d8e:	9001      	str	r0, [sp, #4]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8004d90:	8870      	ldrh	r0, [r6, #2]
 8004d92:	f7ff fb2a 	bl	80043ea <lwip_ntohs>
 8004d96:	4683      	mov	fp, r0
 8004d98:	f896 8000 	ldrb.w	r8, [r6]
  clen = pbuf_clen(p);
 8004d9c:	4638      	mov	r0, r7
 8004d9e:	f000 fe8c 	bl	8005aba <pbuf_clen>
 8004da2:	4681      	mov	r9, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 8004da4:	4ba7      	ldr	r3, [pc, #668]	; (8005044 <ip_reass+0x2d8>)
 8004da6:	881b      	ldrh	r3, [r3, #0]
 8004da8:	4403      	add	r3, r0
 8004daa:	2b0a      	cmp	r3, #10
 8004dac:	dc16      	bgt.n	8004ddc <ip_reass+0x70>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 8004dae:	4ba6      	ldr	r3, [pc, #664]	; (8005048 <ip_reass+0x2dc>)
 8004db0:	681c      	ldr	r4, [r3, #0]
 8004db2:	2c00      	cmp	r4, #0
 8004db4:	f000 8091 	beq.w	8004eda <ip_reass+0x16e>
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 8004db8:	68f2      	ldr	r2, [r6, #12]
 8004dba:	2500      	movs	r5, #0
 8004dbc:	e022      	b.n	8004e04 <ip_reass+0x98>
    IPFRAG_STATS_INC(ip_frag.err);
 8004dbe:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8004dc2:	3301      	adds	r3, #1
 8004dc4:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
  IPFRAG_STATS_INC(ip_frag.drop);
 8004dc8:	4a9d      	ldr	r2, [pc, #628]	; (8005040 <ip_reass+0x2d4>)
 8004dca:	8ed3      	ldrh	r3, [r2, #54]	; 0x36
 8004dcc:	3301      	adds	r3, #1
 8004dce:	86d3      	strh	r3, [r2, #54]	; 0x36
  pbuf_free(p);
 8004dd0:	4638      	mov	r0, r7
 8004dd2:	f000 fd80 	bl	80058d6 <pbuf_free>
  return NULL;
 8004dd6:	f04f 0800 	mov.w	r8, #0
 8004dda:	e119      	b.n	8005010 <ip_reass+0x2a4>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8004ddc:	4601      	mov	r1, r0
 8004dde:	4630      	mov	r0, r6
 8004de0:	f7ff ff68 	bl	8004cb4 <ip_reass_remove_oldest_datagram>
 8004de4:	b120      	cbz	r0, 8004df0 <ip_reass+0x84>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 8004de6:	4b97      	ldr	r3, [pc, #604]	; (8005044 <ip_reass+0x2d8>)
 8004de8:	881b      	ldrh	r3, [r3, #0]
 8004dea:	444b      	add	r3, r9
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8004dec:	2b0a      	cmp	r3, #10
 8004dee:	ddde      	ble.n	8004dae <ip_reass+0x42>
      IPFRAG_STATS_INC(ip_frag.memerr);
 8004df0:	4a93      	ldr	r2, [pc, #588]	; (8005040 <ip_reass+0x2d4>)
 8004df2:	8f93      	ldrh	r3, [r2, #60]	; 0x3c
 8004df4:	3301      	adds	r3, #1
 8004df6:	8793      	strh	r3, [r2, #60]	; 0x3c
      goto nullreturn;
 8004df8:	e7e6      	b.n	8004dc8 <ip_reass+0x5c>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 8004dfa:	6823      	ldr	r3, [r4, #0]
 8004dfc:	4625      	mov	r5, r4
 8004dfe:	2b00      	cmp	r3, #0
 8004e00:	d06b      	beq.n	8004eda <ip_reass+0x16e>
 8004e02:	461c      	mov	r4, r3
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 8004e04:	6963      	ldr	r3, [r4, #20]
 8004e06:	4293      	cmp	r3, r2
 8004e08:	d1f7      	bne.n	8004dfa <ip_reass+0x8e>
 8004e0a:	6933      	ldr	r3, [r6, #16]
 8004e0c:	69a1      	ldr	r1, [r4, #24]
 8004e0e:	4299      	cmp	r1, r3
 8004e10:	d1f3      	bne.n	8004dfa <ip_reass+0x8e>
 8004e12:	89a1      	ldrh	r1, [r4, #12]
 8004e14:	88b3      	ldrh	r3, [r6, #4]
 8004e16:	4299      	cmp	r1, r3
 8004e18:	d1ef      	bne.n	8004dfa <ip_reass+0x8e>
      IPFRAG_STATS_INC(ip_frag.cachehit);
 8004e1a:	4a89      	ldr	r2, [pc, #548]	; (8005040 <ip_reass+0x2d4>)
 8004e1c:	f8b2 3046 	ldrh.w	r3, [r2, #70]	; 0x46
 8004e20:	3301      	adds	r3, #1
 8004e22:	f8a2 3046 	strh.w	r3, [r2, #70]	; 0x46
  if (ipr == NULL) {
 8004e26:	2c00      	cmp	r4, #0
 8004e28:	d056      	beq.n	8004ed8 <ip_reass+0x16c>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 8004e2a:	88f0      	ldrh	r0, [r6, #6]
 8004e2c:	f7ff fadd 	bl	80043ea <lwip_ntohs>
 8004e30:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8004e34:	2800      	cmp	r0, #0
 8004e36:	f000 8087 	beq.w	8004f48 <ip_reass+0x1dc>
  ip_reass_pbufcount += clen;
 8004e3a:	4a82      	ldr	r2, [pc, #520]	; (8005044 <ip_reass+0x2d8>)
 8004e3c:	8813      	ldrh	r3, [r2, #0]
 8004e3e:	4499      	add	r9, r3
 8004e40:	f8a2 9000 	strh.w	r9, [r2]
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
 8004e44:	88f3      	ldrh	r3, [r6, #6]
 8004e46:	f013 0f20 	tst.w	r3, #32
 8004e4a:	d10c      	bne.n	8004e66 <ip_reass+0xfa>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 8004e4c:	7fa3      	ldrb	r3, [r4, #30]
 8004e4e:	f043 0301 	orr.w	r3, r3, #1
 8004e52:	77a3      	strb	r3, [r4, #30]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8004e54:	f008 080f 	and.w	r8, r8, #15
 8004e58:	ebab 0b88 	sub.w	fp, fp, r8, lsl #2
    ipr->datagram_len = offset + len;
 8004e5c:	9b01      	ldr	r3, [sp, #4]
 8004e5e:	eb0b 0ac3 	add.w	sl, fp, r3, lsl #3
 8004e62:	f8a4 a01c 	strh.w	sl, [r4, #28]
  fraghdr = (struct ip_hdr*)new_p->payload; 
 8004e66:	f8d7 8004 	ldr.w	r8, [r7, #4]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8004e6a:	f8b8 0002 	ldrh.w	r0, [r8, #2]
 8004e6e:	f7ff fabc 	bl	80043ea <lwip_ntohs>
 8004e72:	f898 6000 	ldrb.w	r6, [r8]
 8004e76:	f006 060f 	and.w	r6, r6, #15
 8004e7a:	eba0 0686 	sub.w	r6, r0, r6, lsl #2
 8004e7e:	b2b6      	uxth	r6, r6
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 8004e80:	f8b8 0006 	ldrh.w	r0, [r8, #6]
 8004e84:	f7ff fab1 	bl	80043ea <lwip_ntohs>
 8004e88:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8004e8c:	00c0      	lsls	r0, r0, #3
  iprh = (struct ip_reass_helper*)new_p->payload;
 8004e8e:	f8d7 8004 	ldr.w	r8, [r7, #4]
  iprh->next_pbuf = NULL;
 8004e92:	2300      	movs	r3, #0
 8004e94:	f888 3000 	strb.w	r3, [r8]
 8004e98:	f888 3001 	strb.w	r3, [r8, #1]
 8004e9c:	f888 3002 	strb.w	r3, [r8, #2]
 8004ea0:	f888 3003 	strb.w	r3, [r8, #3]
  iprh->start = offset;
 8004ea4:	f8a8 0004 	strh.w	r0, [r8, #4]
  iprh->end = offset + len;
 8004ea8:	eb06 0c00 	add.w	ip, r6, r0
 8004eac:	fa1f fc8c 	uxth.w	ip, ip
 8004eb0:	f8a8 c006 	strh.w	ip, [r8, #6]
  for (q = ipr->p; q != NULL;) {
 8004eb4:	6862      	ldr	r2, [r4, #4]
 8004eb6:	2a00      	cmp	r2, #0
 8004eb8:	f000 809a 	beq.w	8004ff0 <ip_reass+0x284>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 8004ebc:	6853      	ldr	r3, [r2, #4]
    if (iprh->start < iprh_tmp->start) {
 8004ebe:	8899      	ldrh	r1, [r3, #4]
 8004ec0:	4288      	cmp	r0, r1
 8004ec2:	f0c0 80ad 	bcc.w	8005020 <ip_reass+0x2b4>
    } else if(iprh->start == iprh_tmp->start) {
 8004ec6:	f000 8097 	beq.w	8004ff8 <ip_reass+0x28c>
    } else if(iprh->start < iprh_tmp->end) {
 8004eca:	88da      	ldrh	r2, [r3, #6]
 8004ecc:	4282      	cmp	r2, r0
 8004ece:	f200 8093 	bhi.w	8004ff8 <ip_reass+0x28c>
 8004ed2:	f04f 0e01 	mov.w	lr, #1
 8004ed6:	e078      	b.n	8004fca <ip_reass+0x25e>
 8004ed8:	462c      	mov	r4, r5
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 8004eda:	2005      	movs	r0, #5
 8004edc:	f000 fbce 	bl	800567c <memp_malloc>
  if (ipr == NULL) {
 8004ee0:	4682      	mov	sl, r0
 8004ee2:	b1f8      	cbz	r0, 8004f24 <ip_reass+0x1b8>
  memset(ipr, 0, sizeof(struct ip_reassdata));
 8004ee4:	2220      	movs	r2, #32
 8004ee6:	2100      	movs	r1, #0
 8004ee8:	4650      	mov	r0, sl
 8004eea:	f004 f90b 	bl	8009104 <memset>
  ipr->timer = IP_REASS_MAXAGE;
 8004eee:	2303      	movs	r3, #3
 8004ef0:	f88a 301f 	strb.w	r3, [sl, #31]
  ipr->next = reassdatagrams;
 8004ef4:	4b54      	ldr	r3, [pc, #336]	; (8005048 <ip_reass+0x2dc>)
 8004ef6:	681a      	ldr	r2, [r3, #0]
 8004ef8:	f8ca 2000 	str.w	r2, [sl]
  reassdatagrams = ipr;
 8004efc:	f8c3 a000 	str.w	sl, [r3]
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 8004f00:	6832      	ldr	r2, [r6, #0]
 8004f02:	6875      	ldr	r5, [r6, #4]
 8004f04:	68b0      	ldr	r0, [r6, #8]
 8004f06:	68f1      	ldr	r1, [r6, #12]
 8004f08:	f8ca 2008 	str.w	r2, [sl, #8]
 8004f0c:	f8ca 500c 	str.w	r5, [sl, #12]
 8004f10:	f8ca 0010 	str.w	r0, [sl, #16]
 8004f14:	f8ca 1014 	str.w	r1, [sl, #20]
 8004f18:	6932      	ldr	r2, [r6, #16]
 8004f1a:	f8ca 2018 	str.w	r2, [sl, #24]
 8004f1e:	4625      	mov	r5, r4
 8004f20:	4654      	mov	r4, sl
 8004f22:	e78a      	b.n	8004e3a <ip_reass+0xce>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 8004f24:	4649      	mov	r1, r9
 8004f26:	4630      	mov	r0, r6
 8004f28:	f7ff fec4 	bl	8004cb4 <ip_reass_remove_oldest_datagram>
 8004f2c:	4581      	cmp	r9, r0
 8004f2e:	dd04      	ble.n	8004f3a <ip_reass+0x1ce>
      IPFRAG_STATS_INC(ip_frag.memerr);
 8004f30:	4a43      	ldr	r2, [pc, #268]	; (8005040 <ip_reass+0x2d4>)
 8004f32:	8f93      	ldrh	r3, [r2, #60]	; 0x3c
 8004f34:	3301      	adds	r3, #1
 8004f36:	8793      	strh	r3, [r2, #60]	; 0x3c
 8004f38:	e746      	b.n	8004dc8 <ip_reass+0x5c>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 8004f3a:	2005      	movs	r0, #5
 8004f3c:	f000 fb9e 	bl	800567c <memp_malloc>
    if (ipr == NULL)
 8004f40:	4682      	mov	sl, r0
 8004f42:	2800      	cmp	r0, #0
 8004f44:	d1ce      	bne.n	8004ee4 <ip_reass+0x178>
 8004f46:	e7f3      	b.n	8004f30 <ip_reass+0x1c4>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 8004f48:	89e0      	ldrh	r0, [r4, #14]
 8004f4a:	f7ff fa4e 	bl	80043ea <lwip_ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 8004f4e:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8004f52:	2800      	cmp	r0, #0
 8004f54:	f43f af71 	beq.w	8004e3a <ip_reass+0xce>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 8004f58:	6832      	ldr	r2, [r6, #0]
 8004f5a:	f8d6 e004 	ldr.w	lr, [r6, #4]
 8004f5e:	68b0      	ldr	r0, [r6, #8]
 8004f60:	68f1      	ldr	r1, [r6, #12]
 8004f62:	60a2      	str	r2, [r4, #8]
 8004f64:	f8c4 e00c 	str.w	lr, [r4, #12]
 8004f68:	6120      	str	r0, [r4, #16]
 8004f6a:	6161      	str	r1, [r4, #20]
 8004f6c:	6932      	ldr	r2, [r6, #16]
 8004f6e:	61a2      	str	r2, [r4, #24]
 8004f70:	e763      	b.n	8004e3a <ip_reass+0xce>
      iprh->next_pbuf = q;
 8004f72:	f8c8 6000 	str.w	r6, [r8]
      if (iprh_prev != NULL) {
 8004f76:	2b00      	cmp	r3, #0
 8004f78:	d056      	beq.n	8005028 <ip_reass+0x2bc>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 8004f7a:	88d9      	ldrh	r1, [r3, #6]
 8004f7c:	4281      	cmp	r1, r0
 8004f7e:	d83b      	bhi.n	8004ff8 <ip_reass+0x28c>
 8004f80:	8892      	ldrh	r2, [r2, #4]
 8004f82:	4562      	cmp	r2, ip
 8004f84:	d338      	bcc.n	8004ff8 <ip_reass+0x28c>
        iprh_prev->next_pbuf = new_p;
 8004f86:	601f      	str	r7, [r3, #0]
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 8004f88:	7fa3      	ldrb	r3, [r4, #30]
 8004f8a:	f013 0f01 	tst.w	r3, #1
 8004f8e:	d03d      	beq.n	800500c <ip_reass+0x2a0>
    if (valid) {
 8004f90:	f1be 0f00 	cmp.w	lr, #0
 8004f94:	d03a      	beq.n	800500c <ip_reass+0x2a0>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
 8004f96:	6860      	ldr	r0, [r4, #4]
 8004f98:	6843      	ldr	r3, [r0, #4]
 8004f9a:	889b      	ldrh	r3, [r3, #4]
 8004f9c:	2b00      	cmp	r3, #0
 8004f9e:	d135      	bne.n	800500c <ip_reass+0x2a0>
        q = iprh->next_pbuf;
 8004fa0:	f8d8 3000 	ldr.w	r3, [r8]
        while (q != NULL) {
 8004fa4:	2b00      	cmp	r3, #0
 8004fa6:	d051      	beq.n	800504c <ip_reass+0x2e0>
          iprh = (struct ip_reass_helper*)q->payload;
 8004fa8:	685b      	ldr	r3, [r3, #4]
          if (iprh_prev->end != iprh->start) {
 8004faa:	8899      	ldrh	r1, [r3, #4]
 8004fac:	f8b8 2006 	ldrh.w	r2, [r8, #6]
 8004fb0:	4291      	cmp	r1, r2
 8004fb2:	d12b      	bne.n	800500c <ip_reass+0x2a0>
          q = iprh->next_pbuf;
 8004fb4:	681a      	ldr	r2, [r3, #0]
        while (q != NULL) {
 8004fb6:	2a00      	cmp	r2, #0
 8004fb8:	d048      	beq.n	800504c <ip_reass+0x2e0>
          iprh = (struct ip_reass_helper*)q->payload;
 8004fba:	6852      	ldr	r2, [r2, #4]
          if (iprh_prev->end != iprh->start) {
 8004fbc:	88d9      	ldrh	r1, [r3, #6]
 8004fbe:	8893      	ldrh	r3, [r2, #4]
 8004fc0:	4299      	cmp	r1, r3
 8004fc2:	d123      	bne.n	800500c <ip_reass+0x2a0>
          iprh = (struct ip_reass_helper*)q->payload;
 8004fc4:	4613      	mov	r3, r2
 8004fc6:	e7f5      	b.n	8004fb4 <ip_reass+0x248>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 8004fc8:	4613      	mov	r3, r2
    q = iprh_tmp->next_pbuf;
 8004fca:	681e      	ldr	r6, [r3, #0]
  for (q = ipr->p; q != NULL;) {
 8004fcc:	b376      	cbz	r6, 800502c <ip_reass+0x2c0>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 8004fce:	6872      	ldr	r2, [r6, #4]
    if (iprh->start < iprh_tmp->start) {
 8004fd0:	8891      	ldrh	r1, [r2, #4]
 8004fd2:	4288      	cmp	r0, r1
 8004fd4:	d3cd      	bcc.n	8004f72 <ip_reass+0x206>
    } else if(iprh->start == iprh_tmp->start) {
 8004fd6:	4288      	cmp	r0, r1
 8004fd8:	d00e      	beq.n	8004ff8 <ip_reass+0x28c>
    } else if(iprh->start < iprh_tmp->end) {
 8004fda:	88d6      	ldrh	r6, [r2, #6]
 8004fdc:	4286      	cmp	r6, r0
 8004fde:	d80b      	bhi.n	8004ff8 <ip_reass+0x28c>
      if (iprh_prev != NULL) {
 8004fe0:	2b00      	cmp	r3, #0
 8004fe2:	d0f1      	beq.n	8004fc8 <ip_reass+0x25c>
        if (iprh_prev->end != iprh_tmp->start) {
 8004fe4:	88db      	ldrh	r3, [r3, #6]
          valid = 0;
 8004fe6:	428b      	cmp	r3, r1
 8004fe8:	bf18      	it	ne
 8004fea:	f04f 0e00 	movne.w	lr, #0
 8004fee:	e7eb      	b.n	8004fc8 <ip_reass+0x25c>
  int valid = 1;
 8004ff0:	f04f 0e01 	mov.w	lr, #1
      ipr->p = new_p;
 8004ff4:	6067      	str	r7, [r4, #4]
 8004ff6:	e7c7      	b.n	8004f88 <ip_reass+0x21c>
  ip_reass_pbufcount -= pbuf_clen(new_p);
 8004ff8:	4638      	mov	r0, r7
 8004ffa:	f000 fd5e 	bl	8005aba <pbuf_clen>
 8004ffe:	4a11      	ldr	r2, [pc, #68]	; (8005044 <ip_reass+0x2d8>)
 8005000:	8813      	ldrh	r3, [r2, #0]
 8005002:	1a18      	subs	r0, r3, r0
 8005004:	8010      	strh	r0, [r2, #0]
  pbuf_free(new_p);
 8005006:	4638      	mov	r0, r7
 8005008:	f000 fc65 	bl	80058d6 <pbuf_free>
  return NULL;
 800500c:	f04f 0800 	mov.w	r8, #0
}
 8005010:	4640      	mov	r0, r8
 8005012:	b003      	add	sp, #12
 8005014:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    reassdatagrams = ipr->next;
 8005018:	6822      	ldr	r2, [r4, #0]
 800501a:	4b0b      	ldr	r3, [pc, #44]	; (8005048 <ip_reass+0x2dc>)
 800501c:	601a      	str	r2, [r3, #0]
 800501e:	e04d      	b.n	80050bc <ip_reass+0x350>
      iprh->next_pbuf = q;
 8005020:	f8c8 2000 	str.w	r2, [r8]
  int valid = 1;
 8005024:	f04f 0e01 	mov.w	lr, #1
        ipr->p = new_p;
 8005028:	6067      	str	r7, [r4, #4]
 800502a:	e7ad      	b.n	8004f88 <ip_reass+0x21c>
    if (iprh_prev != NULL) {
 800502c:	2b00      	cmp	r3, #0
 800502e:	d0e1      	beq.n	8004ff4 <ip_reass+0x288>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 8005030:	88da      	ldrh	r2, [r3, #6]
      iprh_prev->next_pbuf = new_p;
 8005032:	601f      	str	r7, [r3, #0]
      if (iprh_prev->end != iprh->start) {
 8005034:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8005038:	4293      	cmp	r3, r2
 800503a:	d1e7      	bne.n	800500c <ip_reass+0x2a0>
 800503c:	e7a4      	b.n	8004f88 <ip_reass+0x21c>
 800503e:	bf00      	nop
 8005040:	2000b110 	.word	0x2000b110
 8005044:	20000e7e 	.word	0x20000e7e
 8005048:	20000e80 	.word	0x20000e80
    ipr->datagram_len += IP_HLEN;
 800504c:	8ba3      	ldrh	r3, [r4, #28]
 800504e:	3314      	adds	r3, #20
 8005050:	83a3      	strh	r3, [r4, #28]
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 8005052:	6847      	ldr	r7, [r0, #4]
 8005054:	683e      	ldr	r6, [r7, #0]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 8005056:	4623      	mov	r3, r4
 8005058:	f853 2f08 	ldr.w	r2, [r3, #8]!
 800505c:	f8d3 e004 	ldr.w	lr, [r3, #4]
 8005060:	6898      	ldr	r0, [r3, #8]
 8005062:	68d9      	ldr	r1, [r3, #12]
 8005064:	603a      	str	r2, [r7, #0]
 8005066:	f8c7 e004 	str.w	lr, [r7, #4]
 800506a:	60b8      	str	r0, [r7, #8]
 800506c:	60f9      	str	r1, [r7, #12]
 800506e:	691a      	ldr	r2, [r3, #16]
 8005070:	613a      	str	r2, [r7, #16]
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 8005072:	8ba0      	ldrh	r0, [r4, #28]
 8005074:	f7ff f9b4 	bl	80043e0 <lwip_htons>
 8005078:	8078      	strh	r0, [r7, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 800507a:	2300      	movs	r3, #0
 800507c:	71bb      	strb	r3, [r7, #6]
 800507e:	71fb      	strb	r3, [r7, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 8005080:	72bb      	strb	r3, [r7, #10]
 8005082:	72fb      	strb	r3, [r7, #11]
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 8005084:	2114      	movs	r1, #20
 8005086:	4638      	mov	r0, r7
 8005088:	f7ff fb8b 	bl	80047a2 <inet_chksum>
 800508c:	8178      	strh	r0, [r7, #10]
    p = ipr->p;
 800508e:	f8d4 8004 	ldr.w	r8, [r4, #4]
      pbuf_header(r, -IP_HLEN);
 8005092:	f06f 0913 	mvn.w	r9, #19
    while(r != NULL) {
 8005096:	b15e      	cbz	r6, 80050b0 <ip_reass+0x344>
      iprh = (struct ip_reass_helper*)r->payload;
 8005098:	6877      	ldr	r7, [r6, #4]
      pbuf_header(r, -IP_HLEN);
 800509a:	4649      	mov	r1, r9
 800509c:	4630      	mov	r0, r6
 800509e:	f000 fbdc 	bl	800585a <pbuf_header>
      pbuf_cat(p, r);
 80050a2:	4631      	mov	r1, r6
 80050a4:	4640      	mov	r0, r8
 80050a6:	f000 fd18 	bl	8005ada <pbuf_cat>
      r = iprh->next_pbuf;
 80050aa:	683e      	ldr	r6, [r7, #0]
    while(r != NULL) {
 80050ac:	2e00      	cmp	r6, #0
 80050ae:	d1f3      	bne.n	8005098 <ip_reass+0x32c>
  if (reassdatagrams == ipr) {
 80050b0:	4b08      	ldr	r3, [pc, #32]	; (80050d4 <ip_reass+0x368>)
 80050b2:	681b      	ldr	r3, [r3, #0]
 80050b4:	429c      	cmp	r4, r3
 80050b6:	d0af      	beq.n	8005018 <ip_reass+0x2ac>
    prev->next = ipr->next;
 80050b8:	6823      	ldr	r3, [r4, #0]
 80050ba:	602b      	str	r3, [r5, #0]
  memp_free(MEMP_REASSDATA, ipr);
 80050bc:	4621      	mov	r1, r4
 80050be:	2005      	movs	r0, #5
 80050c0:	f000 fb12 	bl	80056e8 <memp_free>
    ip_reass_pbufcount -= pbuf_clen(p);
 80050c4:	4640      	mov	r0, r8
 80050c6:	f000 fcf8 	bl	8005aba <pbuf_clen>
 80050ca:	4a03      	ldr	r2, [pc, #12]	; (80050d8 <ip_reass+0x36c>)
 80050cc:	8813      	ldrh	r3, [r2, #0]
 80050ce:	1a18      	subs	r0, r3, r0
 80050d0:	8010      	strh	r0, [r2, #0]
    return p;
 80050d2:	e79d      	b.n	8005010 <ip_reass+0x2a4>
 80050d4:	20000e80 	.word	0x20000e80
 80050d8:	20000e7e 	.word	0x20000e7e

080050dc <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 80050dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80050e0:	b08d      	sub	sp, #52	; 0x34
 80050e2:	4604      	mov	r4, r0
 80050e4:	9109      	str	r1, [sp, #36]	; 0x24
 80050e6:	920a      	str	r2, [sp, #40]	; 0x28
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
 80050e8:	8c0d      	ldrh	r5, [r1, #32]

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
#else /* IP_FRAG_USES_STATIC_BUF */
  original_iphdr = (struct ip_hdr *)p->payload;
 80050ea:	f8d0 8004 	ldr.w	r8, [r0, #4]
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 80050ee:	f8b8 0006 	ldrh.w	r0, [r8, #6]
 80050f2:	f7ff f97a 	bl	80043ea <lwip_ntohs>
  ofo = tmp & IP_OFFMASK;
 80050f6:	f3c0 030c 	ubfx	r3, r0, #0, #13
 80050fa:	9303      	str	r3, [sp, #12]
  omf = tmp & IP_MF;
 80050fc:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
 8005100:	9307      	str	r3, [sp, #28]

  left = p->tot_len - IP_HLEN;
 8005102:	f8b4 9008 	ldrh.w	r9, [r4, #8]
 8005106:	f1a9 0914 	sub.w	r9, r9, #20
 800510a:	fa1f f989 	uxth.w	r9, r9

  nfb = (mtu - IP_HLEN) / 8;
 800510e:	f1a5 0314 	sub.w	r3, r5, #20
 8005112:	9306      	str	r3, [sp, #24]
 8005114:	2b00      	cmp	r3, #0
 8005116:	bfb8      	it	lt
 8005118:	3307      	addlt	r3, #7
 800511a:	f3c3 03cf 	ubfx	r3, r3, #3, #16
 800511e:	9308      	str	r3, [sp, #32]

  while (left) {
 8005120:	f1b9 0f00 	cmp.w	r9, #0
 8005124:	f000 80af 	beq.w	8005286 <ip_frag+0x1aa>
    if (!last) {
      tmp = tmp | IP_MF;
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 8005128:	00db      	lsls	r3, r3, #3
 800512a:	b29b      	uxth	r3, r3
 800512c:	930b      	str	r3, [sp, #44]	; 0x2c
 800512e:	2600      	movs	r6, #0
 8005130:	2514      	movs	r5, #20
 8005132:	e084      	b.n	800523e <ip_frag+0x162>
 8005134:	f8cd 9010 	str.w	r9, [sp, #16]
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 8005138:	2200      	movs	r2, #0
 800513a:	2114      	movs	r1, #20
 800513c:	2002      	movs	r0, #2
 800513e:	f000 fbf9 	bl	8005934 <pbuf_alloc>
    if (rambuf == NULL) {
 8005142:	4682      	mov	sl, r0
 8005144:	2800      	cmp	r0, #0
 8005146:	f000 80a0 	beq.w	800528a <ip_frag+0x1ae>
      return ERR_MEM;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 800514a:	6843      	ldr	r3, [r0, #4]
 800514c:	f8d8 2000 	ldr.w	r2, [r8]
 8005150:	f8d8 7004 	ldr.w	r7, [r8, #4]
 8005154:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8005158:	f8d8 100c 	ldr.w	r1, [r8, #12]
 800515c:	601a      	str	r2, [r3, #0]
 800515e:	605f      	str	r7, [r3, #4]
 8005160:	6098      	str	r0, [r3, #8]
 8005162:	60d9      	str	r1, [r3, #12]
 8005164:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8005168:	611a      	str	r2, [r3, #16]
    iphdr = (struct ip_hdr *)rambuf->payload;
 800516a:	f8da b004 	ldr.w	fp, [sl, #4]

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
 800516e:	6863      	ldr	r3, [r4, #4]
 8005170:	442b      	add	r3, r5
 8005172:	6063      	str	r3, [r4, #4]
    p->len -= poff;
 8005174:	8963      	ldrh	r3, [r4, #10]
 8005176:	1b5d      	subs	r5, r3, r5
 8005178:	8165      	strh	r5, [r4, #10]

    left_to_copy = cop;
    while (left_to_copy) {
 800517a:	9b04      	ldr	r3, [sp, #16]
 800517c:	2b00      	cmp	r3, #0
 800517e:	d02c      	beq.n	80051da <ip_frag+0xfe>
 8005180:	461d      	mov	r5, r3
 8005182:	e01f      	b.n	80051c4 <ip_frag+0xe8>
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 8005184:	2006      	movs	r0, #6
 8005186:	f000 fa79 	bl	800567c <memp_malloc>
      if (!newpbuflen) {
        p = p->next;
        continue;
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
      if (pcr == NULL) {
 800518a:	4607      	mov	r7, r0
 800518c:	2800      	cmp	r0, #0
 800518e:	d066      	beq.n	800525e <ip_frag+0x182>
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
 8005190:	9601      	str	r6, [sp, #4]
 8005192:	6863      	ldr	r3, [r4, #4]
 8005194:	9300      	str	r3, [sp, #0]
 8005196:	4603      	mov	r3, r0
 8005198:	2202      	movs	r2, #2
 800519a:	4631      	mov	r1, r6
 800519c:	2003      	movs	r0, #3
 800519e:	f000 fb2d 	bl	80057fc <pbuf_alloced_custom>
      if (newpbuf == NULL) {
 80051a2:	9002      	str	r0, [sp, #8]
 80051a4:	2800      	cmp	r0, #0
 80051a6:	d062      	beq.n	800526e <ip_frag+0x192>
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      pbuf_ref(p);
 80051a8:	4620      	mov	r0, r4
 80051aa:	f000 fc91 	bl	8005ad0 <pbuf_ref>
      pcr->original = p;
 80051ae:	617c      	str	r4, [r7, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 80051b0:	4b37      	ldr	r3, [pc, #220]	; (8005290 <ip_frag+0x1b4>)
 80051b2:	613b      	str	r3, [r7, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 80051b4:	9902      	ldr	r1, [sp, #8]
 80051b6:	4650      	mov	r0, sl
 80051b8:	f000 fc8f 	bl	8005ada <pbuf_cat>
      left_to_copy -= newpbuflen;
 80051bc:	1bad      	subs	r5, r5, r6
 80051be:	b2ad      	uxth	r5, r5
      if (left_to_copy) {
 80051c0:	b15d      	cbz	r5, 80051da <ip_frag+0xfe>
        p = p->next;
 80051c2:	6824      	ldr	r4, [r4, #0]
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
 80051c4:	8966      	ldrh	r6, [r4, #10]
 80051c6:	42ae      	cmp	r6, r5
 80051c8:	bf28      	it	cs
 80051ca:	462e      	movcs	r6, r5
 80051cc:	b2b6      	uxth	r6, r6
      if (!newpbuflen) {
 80051ce:	2e00      	cmp	r6, #0
 80051d0:	d1d8      	bne.n	8005184 <ip_frag+0xa8>
        p = p->next;
 80051d2:	6824      	ldr	r4, [r4, #0]
    while (left_to_copy) {
 80051d4:	2d00      	cmp	r5, #0
 80051d6:	d1f5      	bne.n	80051c4 <ip_frag+0xe8>
 80051d8:	462e      	mov	r6, r5
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 80051da:	9805      	ldr	r0, [sp, #20]
 80051dc:	f7ff f900 	bl	80043e0 <lwip_htons>
 80051e0:	f8ab 0006 	strh.w	r0, [fp, #6]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 80051e4:	9d04      	ldr	r5, [sp, #16]
 80051e6:	f105 0014 	add.w	r0, r5, #20
 80051ea:	b280      	uxth	r0, r0
 80051ec:	f7ff f8f8 	bl	80043e0 <lwip_htons>
 80051f0:	f8ab 0002 	strh.w	r0, [fp, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 80051f4:	2300      	movs	r3, #0
 80051f6:	f88b 300a 	strb.w	r3, [fp, #10]
 80051fa:	f88b 300b 	strb.w	r3, [fp, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 80051fe:	2114      	movs	r1, #20
 8005200:	4658      	mov	r0, fp
 8005202:	f7ff face 	bl	80047a2 <inet_chksum>
 8005206:	f8ab 000a 	strh.w	r0, [fp, #10]
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
 800520a:	9809      	ldr	r0, [sp, #36]	; 0x24
 800520c:	6943      	ldr	r3, [r0, #20]
 800520e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8005210:	4651      	mov	r1, sl
 8005212:	4798      	blx	r3
    IPFRAG_STATS_INC(ip_frag.xmit);
 8005214:	4b1f      	ldr	r3, [pc, #124]	; (8005294 <ip_frag+0x1b8>)
 8005216:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8005218:	3301      	adds	r3, #1
 800521a:	4a1e      	ldr	r2, [pc, #120]	; (8005294 <ip_frag+0x1b8>)
 800521c:	8613      	strh	r3, [r2, #48]	; 0x30
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
 800521e:	4650      	mov	r0, sl
 8005220:	f000 fb59 	bl	80058d6 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 8005224:	eba9 0305 	sub.w	r3, r9, r5
 8005228:	fa1f f983 	uxth.w	r9, r3
    ofo += nfb;
 800522c:	9b03      	ldr	r3, [sp, #12]
 800522e:	9a08      	ldr	r2, [sp, #32]
 8005230:	4413      	add	r3, r2
 8005232:	b29b      	uxth	r3, r3
 8005234:	9303      	str	r3, [sp, #12]
 8005236:	4635      	mov	r5, r6
  while (left) {
 8005238:	f1b9 0f00 	cmp.w	r9, #0
 800523c:	d021      	beq.n	8005282 <ip_frag+0x1a6>
    tmp = omf | (IP_OFFMASK & (ofo));
 800523e:	9b03      	ldr	r3, [sp, #12]
 8005240:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8005244:	9a07      	ldr	r2, [sp, #28]
 8005246:	4313      	orrs	r3, r2
 8005248:	9305      	str	r3, [sp, #20]
    if (!last) {
 800524a:	9a06      	ldr	r2, [sp, #24]
 800524c:	454a      	cmp	r2, r9
 800524e:	f6bf af71 	bge.w	8005134 <ip_frag+0x58>
      tmp = tmp | IP_MF;
 8005252:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8005256:	9305      	str	r3, [sp, #20]
    cop = last ? left : nfb * 8;
 8005258:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800525a:	9304      	str	r3, [sp, #16]
 800525c:	e76c      	b.n	8005138 <ip_frag+0x5c>
 800525e:	4650      	mov	r0, sl
        pbuf_free(rambuf);
 8005260:	f000 fb39 	bl	80058d6 <pbuf_free>
        return ERR_MEM;
 8005264:	f04f 30ff 	mov.w	r0, #4294967295
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
 8005268:	b00d      	add	sp, #52	; 0x34
 800526a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  memp_free(MEMP_FRAG_PBUF, p);
 800526e:	4639      	mov	r1, r7
 8005270:	2006      	movs	r0, #6
 8005272:	f000 fa39 	bl	80056e8 <memp_free>
        pbuf_free(rambuf);
 8005276:	4650      	mov	r0, sl
 8005278:	f000 fb2d 	bl	80058d6 <pbuf_free>
        return ERR_MEM;
 800527c:	f04f 30ff 	mov.w	r0, #4294967295
 8005280:	e7f2      	b.n	8005268 <ip_frag+0x18c>
  return ERR_OK;
 8005282:	2000      	movs	r0, #0
 8005284:	e7f0      	b.n	8005268 <ip_frag+0x18c>
 8005286:	2000      	movs	r0, #0
 8005288:	e7ee      	b.n	8005268 <ip_frag+0x18c>
      return ERR_MEM;
 800528a:	f04f 30ff 	mov.w	r0, #4294967295
 800528e:	e7eb      	b.n	8005268 <ip_frag+0x18c>
 8005290:	08004d25 	.word	0x08004d25
 8005294:	2000b110 	.word	0x2000b110

08005298 <mem_init>:

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8005298:	4b0b      	ldr	r3, [pc, #44]	; (80052c8 <mem_init+0x30>)
 800529a:	f023 0303 	bic.w	r3, r3, #3
 800529e:	4a0b      	ldr	r2, [pc, #44]	; (80052cc <mem_init+0x34>)
 80052a0:	6013      	str	r3, [r2, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 80052a2:	f242 7210 	movw	r2, #10000	; 0x2710
 80052a6:	801a      	strh	r2, [r3, #0]
  mem->prev = 0;
 80052a8:	2100      	movs	r1, #0
 80052aa:	8059      	strh	r1, [r3, #2]
  mem->used = 0;
 80052ac:	7119      	strb	r1, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 80052ae:	1899      	adds	r1, r3, r2
 80052b0:	4807      	ldr	r0, [pc, #28]	; (80052d0 <mem_init+0x38>)
 80052b2:	6001      	str	r1, [r0, #0]
  ram_end->used = 1;
 80052b4:	2001      	movs	r0, #1
 80052b6:	7108      	strb	r0, [r1, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 80052b8:	529a      	strh	r2, [r3, r2]
  ram_end->prev = MEM_SIZE_ALIGNED;
 80052ba:	804a      	strh	r2, [r1, #2]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 80052bc:	4905      	ldr	r1, [pc, #20]	; (80052d4 <mem_init+0x3c>)
 80052be:	600b      	str	r3, [r1, #0]

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
 80052c0:	4b05      	ldr	r3, [pc, #20]	; (80052d8 <mem_init+0x40>)
 80052c2:	f8a3 20a8 	strh.w	r2, [r3, #168]	; 0xa8
 80052c6:	4770      	bx	lr
 80052c8:	200089e3 	.word	0x200089e3
 80052cc:	20000e88 	.word	0x20000e88
 80052d0:	20000e8c 	.word	0x20000e8c
 80052d4:	20000e84 	.word	0x20000e84
 80052d8:	2000b110 	.word	0x2000b110

080052dc <mem_free>:
mem_free(void *rmem)
{
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 80052dc:	2800      	cmp	r0, #0
 80052de:	d050      	beq.n	8005382 <mem_free+0xa6>
{
 80052e0:	b4f0      	push	{r4, r5, r6, r7}
 80052e2:	4603      	mov	r3, r0
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 80052e4:	4a27      	ldr	r2, [pc, #156]	; (8005384 <mem_free+0xa8>)
 80052e6:	6812      	ldr	r2, [r2, #0]
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 80052e8:	4290      	cmp	r0, r2
 80052ea:	d343      	bcc.n	8005374 <mem_free+0x98>
 80052ec:	4926      	ldr	r1, [pc, #152]	; (8005388 <mem_free+0xac>)
 80052ee:	680f      	ldr	r7, [r1, #0]
 80052f0:	42b8      	cmp	r0, r7
 80052f2:	d23f      	bcs.n	8005374 <mem_free+0x98>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 80052f4:	f1a0 0108 	sub.w	r1, r0, #8
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 80052f8:	2000      	movs	r0, #0
 80052fa:	f803 0c04 	strb.w	r0, [r3, #-4]

  if (mem < lfree) {
 80052fe:	4823      	ldr	r0, [pc, #140]	; (800538c <mem_free+0xb0>)
 8005300:	6800      	ldr	r0, [r0, #0]
 8005302:	4281      	cmp	r1, r0
    /* the newly freed struct is now the lowest */
    lfree = mem;
 8005304:	bf3c      	itt	cc
 8005306:	4821      	ldrcc	r0, [pc, #132]	; (800538c <mem_free+0xb0>)
 8005308:	6001      	strcc	r1, [r0, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
 800530a:	1a8c      	subs	r4, r1, r2
 800530c:	b2a4      	uxth	r4, r4
 800530e:	4d20      	ldr	r5, [pc, #128]	; (8005390 <mem_free+0xb4>)
 8005310:	f8b5 00aa 	ldrh.w	r0, [r5, #170]	; 0xaa
 8005314:	f833 6c08 	ldrh.w	r6, [r3, #-8]
 8005318:	1b80      	subs	r0, r0, r6
 800531a:	4420      	add	r0, r4
 800531c:	f8a5 00aa 	strh.w	r0, [r5, #170]	; 0xaa
  nmem = (struct mem *)(void *)&ram[mem->next];
 8005320:	f833 5c08 	ldrh.w	r5, [r3, #-8]
 8005324:	1950      	adds	r0, r2, r5
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 8005326:	4281      	cmp	r1, r0
 8005328:	d00f      	beq.n	800534a <mem_free+0x6e>
 800532a:	7906      	ldrb	r6, [r0, #4]
 800532c:	b96e      	cbnz	r6, 800534a <mem_free+0x6e>
 800532e:	4287      	cmp	r7, r0
 8005330:	d00b      	beq.n	800534a <mem_free+0x6e>
    if (lfree == nmem) {
 8005332:	4e16      	ldr	r6, [pc, #88]	; (800538c <mem_free+0xb0>)
 8005334:	6836      	ldr	r6, [r6, #0]
 8005336:	42b0      	cmp	r0, r6
      lfree = mem;
 8005338:	bf04      	itt	eq
 800533a:	4814      	ldreq	r0, [pc, #80]	; (800538c <mem_free+0xb0>)
 800533c:	6001      	streq	r1, [r0, #0]
    mem->next = nmem->next;
 800533e:	5b50      	ldrh	r0, [r2, r5]
 8005340:	f823 0c08 	strh.w	r0, [r3, #-8]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 8005344:	5b50      	ldrh	r0, [r2, r5]
 8005346:	4410      	add	r0, r2
 8005348:	8044      	strh	r4, [r0, #2]
  pmem = (struct mem *)(void *)&ram[mem->prev];
 800534a:	f833 0c06 	ldrh.w	r0, [r3, #-6]
 800534e:	1814      	adds	r4, r2, r0
  if (pmem != mem && pmem->used == 0) {
 8005350:	42a1      	cmp	r1, r4
 8005352:	d015      	beq.n	8005380 <mem_free+0xa4>
 8005354:	7925      	ldrb	r5, [r4, #4]
 8005356:	b99d      	cbnz	r5, 8005380 <mem_free+0xa4>
    if (lfree == mem) {
 8005358:	4d0c      	ldr	r5, [pc, #48]	; (800538c <mem_free+0xb0>)
 800535a:	682d      	ldr	r5, [r5, #0]
 800535c:	42a9      	cmp	r1, r5
      lfree = pmem;
 800535e:	bf04      	itt	eq
 8005360:	490a      	ldreq	r1, [pc, #40]	; (800538c <mem_free+0xb0>)
 8005362:	600c      	streq	r4, [r1, #0]
    pmem->next = mem->next;
 8005364:	f833 1c08 	ldrh.w	r1, [r3, #-8]
 8005368:	5211      	strh	r1, [r2, r0]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 800536a:	f833 3c08 	ldrh.w	r3, [r3, #-8]
 800536e:	441a      	add	r2, r3
 8005370:	8050      	strh	r0, [r2, #2]
 8005372:	e005      	b.n	8005380 <mem_free+0xa4>
    MEM_STATS_INC(illegal);
 8005374:	4a06      	ldr	r2, [pc, #24]	; (8005390 <mem_free+0xb4>)
 8005376:	f8b2 30b0 	ldrh.w	r3, [r2, #176]	; 0xb0
 800537a:	3301      	adds	r3, #1
 800537c:	f8a2 30b0 	strh.w	r3, [r2, #176]	; 0xb0
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 8005380:	bcf0      	pop	{r4, r5, r6, r7}
 8005382:	4770      	bx	lr
 8005384:	20000e88 	.word	0x20000e88
 8005388:	20000e8c 	.word	0x20000e8c
 800538c:	20000e84 	.word	0x20000e84
 8005390:	2000b110 	.word	0x2000b110

08005394 <mem_trim>:
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 8005394:	3103      	adds	r1, #3
 8005396:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 800539a:	400b      	ands	r3, r1
 800539c:	2b0c      	cmp	r3, #12
 800539e:	bf38      	it	cc
 80053a0:	230c      	movcc	r3, #12
  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 80053a2:	f242 7210 	movw	r2, #10000	; 0x2710
 80053a6:	4293      	cmp	r3, r2
 80053a8:	d86e      	bhi.n	8005488 <mem_trim+0xf4>
    return NULL;
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 80053aa:	4a39      	ldr	r2, [pc, #228]	; (8005490 <mem_trim+0xfc>)
 80053ac:	6812      	ldr	r2, [r2, #0]
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 80053ae:	4282      	cmp	r2, r0
 80053b0:	d837      	bhi.n	8005422 <mem_trim+0x8e>
 80053b2:	4938      	ldr	r1, [pc, #224]	; (8005494 <mem_trim+0x100>)
 80053b4:	6809      	ldr	r1, [r1, #0]
 80053b6:	4288      	cmp	r0, r1
 80053b8:	d233      	bcs.n	8005422 <mem_trim+0x8e>
{
 80053ba:	b5f0      	push	{r4, r5, r6, r7, lr}
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 80053bc:	f1a0 0408 	sub.w	r4, r0, #8
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
 80053c0:	1aa4      	subs	r4, r4, r2
 80053c2:	b2a4      	uxth	r4, r4

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 80053c4:	f830 5c08 	ldrh.w	r5, [r0, #-8]
 80053c8:	f1a5 0108 	sub.w	r1, r5, #8
 80053cc:	1b09      	subs	r1, r1, r4
 80053ce:	b289      	uxth	r1, r1
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
  if (newsize > size) {
 80053d0:	4299      	cmp	r1, r3
 80053d2:	d35b      	bcc.n	800548c <mem_trim+0xf8>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
 80053d4:	d05b      	beq.n	800548e <mem_trim+0xfa>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = (struct mem *)(void *)&ram[mem->next];
 80053d6:	1956      	adds	r6, r2, r5
  if(mem2->used == 0) {
 80053d8:	7937      	ldrb	r7, [r6, #4]
 80053da:	bb7f      	cbnz	r7, 800543c <mem_trim+0xa8>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
 80053dc:	5b57      	ldrh	r7, [r2, r5]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 80053de:	f104 0508 	add.w	r5, r4, #8
 80053e2:	441d      	add	r5, r3
 80053e4:	b2ad      	uxth	r5, r5
    if (lfree == mem2) {
 80053e6:	f8df e0b4 	ldr.w	lr, [pc, #180]	; 800549c <mem_trim+0x108>
 80053ea:	f8de e000 	ldr.w	lr, [lr]
 80053ee:	4576      	cmp	r6, lr
 80053f0:	d01e      	beq.n	8005430 <mem_trim+0x9c>
      lfree = (struct mem *)(void *)&ram[ptr2];
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
 80053f2:	1956      	adds	r6, r2, r5
    mem2->used = 0;
 80053f4:	f04f 0e00 	mov.w	lr, #0
 80053f8:	f886 e004 	strb.w	lr, [r6, #4]
    /* restore the next pointer */
    mem2->next = next;
 80053fc:	5357      	strh	r7, [r2, r5]
    /* link it back to mem */
    mem2->prev = ptr;
 80053fe:	8074      	strh	r4, [r6, #2]
    /* link mem to it */
    mem->next = ptr2;
 8005400:	f820 5c08 	strh.w	r5, [r0, #-8]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8005404:	5b54      	ldrh	r4, [r2, r5]
 8005406:	f242 7610 	movw	r6, #10000	; 0x2710
 800540a:	42b4      	cmp	r4, r6
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 800540c:	bf1c      	itt	ne
 800540e:	1912      	addne	r2, r2, r4
 8005410:	8055      	strhne	r5, [r2, #2]
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 8005412:	4c21      	ldr	r4, [pc, #132]	; (8005498 <mem_trim+0x104>)
 8005414:	f8b4 20aa 	ldrh.w	r2, [r4, #170]	; 0xaa
 8005418:	4413      	add	r3, r2
 800541a:	1a5b      	subs	r3, r3, r1
 800541c:	f8a4 30aa 	strh.w	r3, [r4, #170]	; 0xaa
 8005420:	bdf0      	pop	{r4, r5, r6, r7, pc}
    MEM_STATS_INC(illegal);
 8005422:	4a1d      	ldr	r2, [pc, #116]	; (8005498 <mem_trim+0x104>)
 8005424:	f8b2 30b0 	ldrh.w	r3, [r2, #176]	; 0xb0
 8005428:	3301      	adds	r3, #1
 800542a:	f8a2 30b0 	strh.w	r3, [r2, #176]	; 0xb0
    return rmem;
 800542e:	4770      	bx	lr
      lfree = (struct mem *)(void *)&ram[ptr2];
 8005430:	1956      	adds	r6, r2, r5
 8005432:	f8df e068 	ldr.w	lr, [pc, #104]	; 800549c <mem_trim+0x108>
 8005436:	f8ce 6000 	str.w	r6, [lr]
 800543a:	e7da      	b.n	80053f2 <mem_trim+0x5e>
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 800543c:	f103 0514 	add.w	r5, r3, #20
 8005440:	428d      	cmp	r5, r1
 8005442:	d824      	bhi.n	800548e <mem_trim+0xfa>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8005444:	f104 0508 	add.w	r5, r4, #8
 8005448:	441d      	add	r5, r3
 800544a:	b2ad      	uxth	r5, r5
    mem2 = (struct mem *)(void *)&ram[ptr2];
 800544c:	1956      	adds	r6, r2, r5
    if (mem2 < lfree) {
 800544e:	4f13      	ldr	r7, [pc, #76]	; (800549c <mem_trim+0x108>)
 8005450:	683f      	ldr	r7, [r7, #0]
 8005452:	42be      	cmp	r6, r7
      lfree = mem2;
 8005454:	bf3c      	itt	cc
 8005456:	4f11      	ldrcc	r7, [pc, #68]	; (800549c <mem_trim+0x108>)
 8005458:	603e      	strcc	r6, [r7, #0]
    }
    mem2->used = 0;
 800545a:	2700      	movs	r7, #0
 800545c:	7137      	strb	r7, [r6, #4]
    mem2->next = mem->next;
 800545e:	f830 7c08 	ldrh.w	r7, [r0, #-8]
 8005462:	5357      	strh	r7, [r2, r5]
    mem2->prev = ptr;
 8005464:	8074      	strh	r4, [r6, #2]
    mem->next = ptr2;
 8005466:	f820 5c08 	strh.w	r5, [r0, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 800546a:	5b54      	ldrh	r4, [r2, r5]
 800546c:	f242 7610 	movw	r6, #10000	; 0x2710
 8005470:	42b4      	cmp	r4, r6
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8005472:	bf1c      	itt	ne
 8005474:	1912      	addne	r2, r2, r4
 8005476:	8055      	strhne	r5, [r2, #2]
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 8005478:	4a07      	ldr	r2, [pc, #28]	; (8005498 <mem_trim+0x104>)
 800547a:	f8b2 40aa 	ldrh.w	r4, [r2, #170]	; 0xaa
 800547e:	4423      	add	r3, r4
 8005480:	1a5b      	subs	r3, r3, r1
 8005482:	f8a2 30aa 	strh.w	r3, [r2, #170]	; 0xaa
 8005486:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NULL;
 8005488:	2000      	movs	r0, #0
 800548a:	4770      	bx	lr
    return NULL;
 800548c:	2000      	movs	r0, #0
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
 800548e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005490:	20000e88 	.word	0x20000e88
 8005494:	20000e8c 	.word	0x20000e8c
 8005498:	2000b110 	.word	0x2000b110
 800549c:	20000e84 	.word	0x20000e84

080054a0 <mem_malloc>:
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 80054a0:	2800      	cmp	r0, #0
 80054a2:	f000 808f 	beq.w	80055c4 <mem_malloc+0x124>
{
 80054a6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80054a8:	4602      	mov	r2, r0
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 80054aa:	3203      	adds	r2, #3
 80054ac:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 80054b0:	4013      	ands	r3, r2
 80054b2:	2b0c      	cmp	r3, #12
 80054b4:	bf38      	it	cc
 80054b6:	230c      	movcc	r3, #12
 80054b8:	469e      	mov	lr, r3
  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
 80054ba:	f242 7310 	movw	r3, #10000	; 0x2710
 80054be:	459e      	cmp	lr, r3
 80054c0:	f200 8082 	bhi.w	80055c8 <mem_malloc+0x128>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 80054c4:	4b41      	ldr	r3, [pc, #260]	; (80055cc <mem_malloc+0x12c>)
 80054c6:	f8d3 c000 	ldr.w	ip, [r3]
 80054ca:	4b41      	ldr	r3, [pc, #260]	; (80055d0 <mem_malloc+0x130>)
 80054cc:	681a      	ldr	r2, [r3, #0]
 80054ce:	eba2 020c 	sub.w	r2, r2, ip
 80054d2:	b293      	uxth	r3, r2
 80054d4:	f5ce 511c 	rsb	r1, lr, #9984	; 0x2700
 80054d8:	3110      	adds	r1, #16
 80054da:	428b      	cmp	r3, r1
 80054dc:	da6a      	bge.n	80055b4 <mem_malloc+0x114>
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 80054de:	f06f 0607 	mvn.w	r6, #7
 80054e2:	4675      	mov	r5, lr
 80054e4:	e030      	b.n	8005548 <mem_malloc+0xa8>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 80054e6:	2201      	movs	r2, #1
 80054e8:	7102      	strb	r2, [r0, #4]
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
 80054ea:	4a3a      	ldr	r2, [pc, #232]	; (80055d4 <mem_malloc+0x134>)
 80054ec:	f8b2 10aa 	ldrh.w	r1, [r2, #170]	; 0xaa
 80054f0:	440c      	add	r4, r1
 80054f2:	1ae3      	subs	r3, r4, r3
 80054f4:	b29b      	uxth	r3, r3
 80054f6:	f8a2 30aa 	strh.w	r3, [r2, #170]	; 0xaa
 80054fa:	f8b2 20ac 	ldrh.w	r2, [r2, #172]	; 0xac
 80054fe:	429a      	cmp	r2, r3
 8005500:	bf3c      	itt	cc
 8005502:	4a34      	ldrcc	r2, [pc, #208]	; (80055d4 <mem_malloc+0x134>)
 8005504:	f8a2 30ac 	strhcc.w	r3, [r2, #172]	; 0xac
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 8005508:	4b31      	ldr	r3, [pc, #196]	; (80055d0 <mem_malloc+0x130>)
 800550a:	681b      	ldr	r3, [r3, #0]
 800550c:	4298      	cmp	r0, r3
 800550e:	d001      	beq.n	8005514 <mem_malloc+0x74>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 8005510:	3008      	adds	r0, #8
 8005512:	bdf0      	pop	{r4, r5, r6, r7, pc}
          while (cur->used && cur != ram_end) {
 8005514:	7903      	ldrb	r3, [r0, #4]
 8005516:	b183      	cbz	r3, 800553a <mem_malloc+0x9a>
 8005518:	4b2f      	ldr	r3, [pc, #188]	; (80055d8 <mem_malloc+0x138>)
 800551a:	6819      	ldr	r1, [r3, #0]
 800551c:	4288      	cmp	r0, r1
 800551e:	d00e      	beq.n	800553e <mem_malloc+0x9e>
            cur = (struct mem *)(void *)&ram[cur->next];
 8005520:	4b2a      	ldr	r3, [pc, #168]	; (80055cc <mem_malloc+0x12c>)
 8005522:	681c      	ldr	r4, [r3, #0]
 8005524:	4603      	mov	r3, r0
 8005526:	881b      	ldrh	r3, [r3, #0]
 8005528:	4423      	add	r3, r4
          while (cur->used && cur != ram_end) {
 800552a:	791a      	ldrb	r2, [r3, #4]
 800552c:	b112      	cbz	r2, 8005534 <mem_malloc+0x94>
 800552e:	428b      	cmp	r3, r1
 8005530:	d1f9      	bne.n	8005526 <mem_malloc+0x86>
            cur = (struct mem *)(void *)&ram[cur->next];
 8005532:	460b      	mov	r3, r1
          lfree = cur;
 8005534:	4a26      	ldr	r2, [pc, #152]	; (80055d0 <mem_malloc+0x130>)
 8005536:	6013      	str	r3, [r2, #0]
 8005538:	e7ea      	b.n	8005510 <mem_malloc+0x70>
      mem = (struct mem *)(void *)&ram[ptr];
 800553a:	4603      	mov	r3, r0
 800553c:	e7fa      	b.n	8005534 <mem_malloc+0x94>
 800553e:	4603      	mov	r3, r0
 8005540:	e7f8      	b.n	8005534 <mem_malloc+0x94>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 8005542:	8803      	ldrh	r3, [r0, #0]
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8005544:	428b      	cmp	r3, r1
 8005546:	da35      	bge.n	80055b4 <mem_malloc+0x114>
      mem = (struct mem *)(void *)&ram[ptr];
 8005548:	eb0c 0003 	add.w	r0, ip, r3
      if ((!mem->used) &&
 800554c:	7902      	ldrb	r2, [r0, #4]
 800554e:	2a00      	cmp	r2, #0
 8005550:	d1f7      	bne.n	8005542 <mem_malloc+0xa2>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 8005552:	f83c 4003 	ldrh.w	r4, [ip, r3]
 8005556:	1af2      	subs	r2, r6, r3
 8005558:	4422      	add	r2, r4
 800555a:	462f      	mov	r7, r5
      if ((!mem->used) &&
 800555c:	4572      	cmp	r2, lr
 800555e:	d3f0      	bcc.n	8005542 <mem_malloc+0xa2>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 8005560:	3714      	adds	r7, #20
 8005562:	42ba      	cmp	r2, r7
 8005564:	d3bf      	bcc.n	80054e6 <mem_malloc+0x46>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 8005566:	f10e 0208 	add.w	r2, lr, #8
 800556a:	441a      	add	r2, r3
 800556c:	b292      	uxth	r2, r2
          mem2 = (struct mem *)(void *)&ram[ptr2];
 800556e:	eb0c 0102 	add.w	r1, ip, r2
          mem2->used = 0;
 8005572:	2400      	movs	r4, #0
 8005574:	710c      	strb	r4, [r1, #4]
          mem2->next = mem->next;
 8005576:	8804      	ldrh	r4, [r0, #0]
 8005578:	f82c 4002 	strh.w	r4, [ip, r2]
          mem2->prev = ptr;
 800557c:	804b      	strh	r3, [r1, #2]
          mem->next = ptr2;
 800557e:	8002      	strh	r2, [r0, #0]
          mem->used = 1;
 8005580:	2301      	movs	r3, #1
 8005582:	7103      	strb	r3, [r0, #4]
          if (mem2->next != MEM_SIZE_ALIGNED) {
 8005584:	f83c 3002 	ldrh.w	r3, [ip, r2]
 8005588:	f242 7110 	movw	r1, #10000	; 0x2710
 800558c:	428b      	cmp	r3, r1
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 800558e:	bf1c      	itt	ne
 8005590:	4463      	addne	r3, ip
 8005592:	805a      	strhne	r2, [r3, #2]
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
 8005594:	4a0f      	ldr	r2, [pc, #60]	; (80055d4 <mem_malloc+0x134>)
 8005596:	f8b2 30aa 	ldrh.w	r3, [r2, #170]	; 0xaa
 800559a:	3308      	adds	r3, #8
 800559c:	4473      	add	r3, lr
 800559e:	b29b      	uxth	r3, r3
 80055a0:	f8a2 30aa 	strh.w	r3, [r2, #170]	; 0xaa
 80055a4:	f8b2 20ac 	ldrh.w	r2, [r2, #172]	; 0xac
 80055a8:	429a      	cmp	r2, r3
 80055aa:	d2ad      	bcs.n	8005508 <mem_malloc+0x68>
 80055ac:	4a09      	ldr	r2, [pc, #36]	; (80055d4 <mem_malloc+0x134>)
 80055ae:	f8a2 30ac 	strh.w	r3, [r2, #172]	; 0xac
 80055b2:	e7a9      	b.n	8005508 <mem_malloc+0x68>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
 80055b4:	4a07      	ldr	r2, [pc, #28]	; (80055d4 <mem_malloc+0x134>)
 80055b6:	f8b2 30ae 	ldrh.w	r3, [r2, #174]	; 0xae
 80055ba:	3301      	adds	r3, #1
 80055bc:	f8a2 30ae 	strh.w	r3, [r2, #174]	; 0xae
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
 80055c0:	2000      	movs	r0, #0
 80055c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NULL;
 80055c4:	2000      	movs	r0, #0
 80055c6:	4770      	bx	lr
    return NULL;
 80055c8:	2000      	movs	r0, #0
}
 80055ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80055cc:	20000e88 	.word	0x20000e88
 80055d0:	20000e84 	.word	0x20000e84
 80055d4:	2000b110 	.word	0x2000b110
 80055d8:	20000e8c 	.word	0x20000e8c

080055dc <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 80055dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80055e0:	4b21      	ldr	r3, [pc, #132]	; (8005668 <memp_init+0x8c>)
 80055e2:	f8df c090 	ldr.w	ip, [pc, #144]	; 8005674 <memp_init+0x98>
 80055e6:	f103 0464 	add.w	r4, r3, #100	; 0x64
 80055ea:	4661      	mov	r1, ip
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    MEMP_STATS_AVAIL(used, i, 0);
 80055ec:	2200      	movs	r2, #0
 80055ee:	f8a3 20b4 	strh.w	r2, [r3, #180]	; 0xb4
    MEMP_STATS_AVAIL(max, i, 0);
 80055f2:	f8a3 20b6 	strh.w	r2, [r3, #182]	; 0xb6
    MEMP_STATS_AVAIL(err, i, 0);
 80055f6:	f8a3 20b8 	strh.w	r2, [r3, #184]	; 0xb8
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
 80055fa:	f831 0b02 	ldrh.w	r0, [r1], #2
 80055fe:	f8a3 00b2 	strh.w	r0, [r3, #178]	; 0xb2
 8005602:	330a      	adds	r3, #10
  for (i = 0; i < MEMP_MAX; ++i) {
 8005604:	42a3      	cmp	r3, r4
 8005606:	d1f2      	bne.n	80055ee <memp_init+0x12>
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
 8005608:	4f18      	ldr	r7, [pc, #96]	; (800566c <memp_init+0x90>)
 800560a:	f027 0703 	bic.w	r7, r7, #3
 800560e:	4e18      	ldr	r6, [pc, #96]	; (8005670 <memp_init+0x94>)
 8005610:	f8df e064 	ldr.w	lr, [pc, #100]	; 8005678 <memp_init+0x9c>
 8005614:	f106 0a28 	add.w	sl, r6, #40	; 0x28
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
 8005618:	f04f 0900 	mov.w	r9, #0
 800561c:	e015      	b.n	800564a <memp_init+0x6e>
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 800561e:	4603      	mov	r3, r0
      memp->next = memp_tab[i];
 8005620:	6019      	str	r1, [r3, #0]
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 8005622:	1958      	adds	r0, r3, r5
 8005624:	3201      	adds	r2, #1
      memp_tab[i] = memp;
 8005626:	4619      	mov	r1, r3
    for (j = 0; j < memp_num[i]; ++j) {
 8005628:	b293      	uxth	r3, r2
 800562a:	42a3      	cmp	r3, r4
 800562c:	d3f7      	bcc.n	800561e <memp_init+0x42>
 800562e:	3c01      	subs	r4, #1
 8005630:	b2a4      	uxth	r4, r4
 8005632:	fb04 5305 	mla	r3, r4, r5, r5
 8005636:	fb04 7405 	mla	r4, r4, r5, r7
 800563a:	f8c8 4000 	str.w	r4, [r8]
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 800563e:	441f      	add	r7, r3
 8005640:	3604      	adds	r6, #4
 8005642:	f10e 0e02 	add.w	lr, lr, #2
  for (i = 0; i < MEMP_MAX; ++i) {
 8005646:	4556      	cmp	r6, sl
 8005648:	d00c      	beq.n	8005664 <memp_init+0x88>
 800564a:	46b0      	mov	r8, r6
    memp_tab[i] = NULL;
 800564c:	f8c6 9000 	str.w	r9, [r6]
    for (j = 0; j < memp_num[i]; ++j) {
 8005650:	f83c 4b02 	ldrh.w	r4, [ip], #2
 8005654:	2c00      	cmp	r4, #0
 8005656:	d0f3      	beq.n	8005640 <memp_init+0x64>
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 8005658:	f8be 5000 	ldrh.w	r5, [lr]
 800565c:	463b      	mov	r3, r7
 800565e:	2200      	movs	r2, #0
 8005660:	4611      	mov	r1, r2
 8005662:	e7dd      	b.n	8005620 <memp_init+0x44>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
 8005664:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005668:	2000b110 	.word	0x2000b110
 800566c:	20000e93 	.word	0x20000e93
 8005670:	20007754 	.word	0x20007754
 8005674:	08009250 	.word	0x08009250
 8005678:	08009264 	.word	0x08009264

0800567c <memp_malloc>:
#endif
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 800567c:	2809      	cmp	r0, #9
 800567e:	d82a      	bhi.n	80056d6 <memp_malloc+0x5a>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
 8005680:	4b17      	ldr	r3, [pc, #92]	; (80056e0 <memp_malloc+0x64>)
 8005682:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
  
  if (memp != NULL) {
 8005686:	b1d2      	cbz	r2, 80056be <memp_malloc+0x42>
    memp_tab[type] = memp->next;
 8005688:	6811      	ldr	r1, [r2, #0]
 800568a:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
 800568e:	eb00 0180 	add.w	r1, r0, r0, lsl #2
 8005692:	4b14      	ldr	r3, [pc, #80]	; (80056e4 <memp_malloc+0x68>)
 8005694:	eb03 0141 	add.w	r1, r3, r1, lsl #1
 8005698:	f8b1 30b4 	ldrh.w	r3, [r1, #180]	; 0xb4
 800569c:	3301      	adds	r3, #1
 800569e:	b29b      	uxth	r3, r3
 80056a0:	f8a1 30b4 	strh.w	r3, [r1, #180]	; 0xb4
 80056a4:	f8b1 10b6 	ldrh.w	r1, [r1, #182]	; 0xb6
 80056a8:	4299      	cmp	r1, r3
 80056aa:	d216      	bcs.n	80056da <memp_malloc+0x5e>
 80056ac:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80056b0:	490c      	ldr	r1, [pc, #48]	; (80056e4 <memp_malloc+0x68>)
 80056b2:	eb01 0040 	add.w	r0, r1, r0, lsl #1
 80056b6:	f8a0 30b6 	strh.w	r3, [r0, #182]	; 0xb6
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
 80056ba:	4610      	mov	r0, r2
 80056bc:	4770      	bx	lr
    MEMP_STATS_INC(err, type);
 80056be:	4b09      	ldr	r3, [pc, #36]	; (80056e4 <memp_malloc+0x68>)
 80056c0:	0082      	lsls	r2, r0, #2
 80056c2:	1811      	adds	r1, r2, r0
 80056c4:	eb03 0141 	add.w	r1, r3, r1, lsl #1
 80056c8:	f8b1 30b8 	ldrh.w	r3, [r1, #184]	; 0xb8
 80056cc:	3301      	adds	r3, #1
 80056ce:	f8a1 30b8 	strh.w	r3, [r1, #184]	; 0xb8
  return memp;
 80056d2:	2000      	movs	r0, #0
 80056d4:	4770      	bx	lr
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 80056d6:	2000      	movs	r0, #0
 80056d8:	4770      	bx	lr
  return memp;
 80056da:	4610      	mov	r0, r2
}
 80056dc:	4770      	bx	lr
 80056de:	bf00      	nop
 80056e0:	20007754 	.word	0x20007754
 80056e4:	2000b110 	.word	0x2000b110

080056e8 <memp_free>:
memp_free(memp_t type, void *mem)
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
 80056e8:	b191      	cbz	r1, 8005710 <memp_free+0x28>
{
 80056ea:	b410      	push	{r4}
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
 80056ec:	eb00 0280 	add.w	r2, r0, r0, lsl #2
 80056f0:	4b08      	ldr	r3, [pc, #32]	; (8005714 <memp_free+0x2c>)
 80056f2:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 80056f6:	f8b3 20b4 	ldrh.w	r2, [r3, #180]	; 0xb4
 80056fa:	3a01      	subs	r2, #1
 80056fc:	f8a3 20b4 	strh.w	r2, [r3, #180]	; 0xb4
  
  memp->next = memp_tab[type]; 
 8005700:	4b05      	ldr	r3, [pc, #20]	; (8005718 <memp_free+0x30>)
 8005702:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 8005706:	600a      	str	r2, [r1, #0]
  memp_tab[type] = memp;
 8005708:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
 800570c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005710:	4770      	bx	lr
 8005712:	bf00      	nop
 8005714:	2000b110 	.word	0x2000b110
 8005718:	20007754 	.word	0x20007754

0800571c <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
 800571c:	4770      	bx	lr
	...

08005720 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
 8005720:	b570      	push	{r4, r5, r6, lr}
 8005722:	4604      	mov	r4, r0
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
 8005724:	2900      	cmp	r1, #0
 8005726:	d027      	beq.n	8005778 <netif_set_ipaddr+0x58>
 8005728:	460d      	mov	r5, r1
 800572a:	680a      	ldr	r2, [r1, #0]
 800572c:	6843      	ldr	r3, [r0, #4]
 800572e:	429a      	cmp	r2, r3
 8005730:	d005      	beq.n	800573e <netif_set_ipaddr+0x1e>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 8005732:	4b12      	ldr	r3, [pc, #72]	; (800577c <netif_set_ipaddr+0x5c>)
 8005734:	6818      	ldr	r0, [r3, #0]
    while (pcb != NULL) {
 8005736:	b958      	cbnz	r0, 8005750 <netif_set_ipaddr+0x30>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8005738:	4b11      	ldr	r3, [pc, #68]	; (8005780 <netif_set_ipaddr+0x60>)
 800573a:	681b      	ldr	r3, [r3, #0]
 800573c:	b98b      	cbnz	r3, 8005762 <netif_set_ipaddr+0x42>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 800573e:	682b      	ldr	r3, [r5, #0]
 8005740:	6063      	str	r3, [r4, #4]
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->ip_addr),
    ip4_addr2_16(&netif->ip_addr),
    ip4_addr3_16(&netif->ip_addr),
    ip4_addr4_16(&netif->ip_addr)));
}
 8005742:	bd70      	pop	{r4, r5, r6, pc}
        struct tcp_pcb *next = pcb->next;
 8005744:	68c6      	ldr	r6, [r0, #12]
        tcp_abort(pcb);
 8005746:	f000 feef 	bl	8006528 <tcp_abort>
        pcb = next;
 800574a:	4630      	mov	r0, r6
    while (pcb != NULL) {
 800574c:	2800      	cmp	r0, #0
 800574e:	d0f3      	beq.n	8005738 <netif_set_ipaddr+0x18>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 8005750:	6802      	ldr	r2, [r0, #0]
 8005752:	6863      	ldr	r3, [r4, #4]
 8005754:	429a      	cmp	r2, r3
 8005756:	d0f5      	beq.n	8005744 <netif_set_ipaddr+0x24>
        pcb = pcb->next;
 8005758:	68c0      	ldr	r0, [r0, #12]
 800575a:	e7f7      	b.n	800574c <netif_set_ipaddr+0x2c>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800575c:	68db      	ldr	r3, [r3, #12]
 800575e:	2b00      	cmp	r3, #0
 8005760:	d0ed      	beq.n	800573e <netif_set_ipaddr+0x1e>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 8005762:	2b00      	cmp	r3, #0
 8005764:	d0fa      	beq.n	800575c <netif_set_ipaddr+0x3c>
 8005766:	681a      	ldr	r2, [r3, #0]
 8005768:	2a00      	cmp	r2, #0
 800576a:	d0f7      	beq.n	800575c <netif_set_ipaddr+0x3c>
 800576c:	6861      	ldr	r1, [r4, #4]
 800576e:	428a      	cmp	r2, r1
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 8005770:	bf04      	itt	eq
 8005772:	682a      	ldreq	r2, [r5, #0]
 8005774:	601a      	streq	r2, [r3, #0]
 8005776:	e7f1      	b.n	800575c <netif_set_ipaddr+0x3c>
  ip_addr_set(&(netif->ip_addr), ipaddr);
 8005778:	2300      	movs	r3, #0
 800577a:	e7e1      	b.n	8005740 <netif_set_ipaddr+0x20>
 800577c:	2000b22c 	.word	0x2000b22c
 8005780:	2000b234 	.word	0x2000b234

08005784 <netif_set_addr>:
{
 8005784:	b570      	push	{r4, r5, r6, lr}
 8005786:	4604      	mov	r4, r0
 8005788:	4616      	mov	r6, r2
 800578a:	461d      	mov	r5, r3
  netif_set_ipaddr(netif, ipaddr);
 800578c:	f7ff ffc8 	bl	8005720 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 8005790:	b12e      	cbz	r6, 800579e <netif_set_addr+0x1a>
 8005792:	6833      	ldr	r3, [r6, #0]
 8005794:	60a3      	str	r3, [r4, #8]
  ip_addr_set(&(netif->gw), gw);
 8005796:	b125      	cbz	r5, 80057a2 <netif_set_addr+0x1e>
 8005798:	682b      	ldr	r3, [r5, #0]
 800579a:	60e3      	str	r3, [r4, #12]
 800579c:	bd70      	pop	{r4, r5, r6, pc}
  ip_addr_set(&(netif->netmask), netmask);
 800579e:	2300      	movs	r3, #0
 80057a0:	e7f8      	b.n	8005794 <netif_set_addr+0x10>
  ip_addr_set(&(netif->gw), gw);
 80057a2:	2300      	movs	r3, #0
 80057a4:	e7f9      	b.n	800579a <netif_set_addr+0x16>
	...

080057a8 <netif_add>:
{
 80057a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80057aa:	4604      	mov	r4, r0
  ip_addr_set_zero(&netif->ip_addr);
 80057ac:	2500      	movs	r5, #0
 80057ae:	6045      	str	r5, [r0, #4]
  ip_addr_set_zero(&netif->netmask);
 80057b0:	6085      	str	r5, [r0, #8]
  ip_addr_set_zero(&netif->gw);
 80057b2:	60c5      	str	r5, [r0, #12]
  netif->flags = 0;
 80057b4:	f880 5029 	strb.w	r5, [r0, #41]	; 0x29
  netif->state = state;
 80057b8:	9d06      	ldr	r5, [sp, #24]
 80057ba:	61c5      	str	r5, [r0, #28]
  netif->num = netif_num++;
 80057bc:	4e0a      	ldr	r6, [pc, #40]	; (80057e8 <netif_add+0x40>)
 80057be:	7835      	ldrb	r5, [r6, #0]
 80057c0:	1c6f      	adds	r7, r5, #1
 80057c2:	7037      	strb	r7, [r6, #0]
 80057c4:	f880 502c 	strb.w	r5, [r0, #44]	; 0x2c
  netif->input = input;
 80057c8:	9d08      	ldr	r5, [sp, #32]
 80057ca:	6105      	str	r5, [r0, #16]
  netif_set_addr(netif, ipaddr, netmask, gw);
 80057cc:	f7ff ffda 	bl	8005784 <netif_set_addr>
  if (init(netif) != ERR_OK) {
 80057d0:	4620      	mov	r0, r4
 80057d2:	9b07      	ldr	r3, [sp, #28]
 80057d4:	4798      	blx	r3
 80057d6:	b928      	cbnz	r0, 80057e4 <netif_add+0x3c>
  netif->next = netif_list;
 80057d8:	4b04      	ldr	r3, [pc, #16]	; (80057ec <netif_add+0x44>)
 80057da:	681a      	ldr	r2, [r3, #0]
 80057dc:	6022      	str	r2, [r4, #0]
  netif_list = netif;
 80057de:	601c      	str	r4, [r3, #0]
  return netif;
 80057e0:	4620      	mov	r0, r4
 80057e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return NULL;
 80057e4:	2000      	movs	r0, #0
}
 80057e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80057e8:	2000777c 	.word	0x2000777c
 80057ec:	2000b104 	.word	0x2000b104

080057f0 <netif_set_default>:
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
 80057f0:	4b01      	ldr	r3, [pc, #4]	; (80057f8 <netif_set_default+0x8>)
 80057f2:	6018      	str	r0, [r3, #0]
 80057f4:	4770      	bx	lr
 80057f6:	bf00      	nop
 80057f8:	2000b108 	.word	0x2000b108

080057fc <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf*
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
 80057fc:	b470      	push	{r4, r5, r6}
 80057fe:	9c03      	ldr	r4, [sp, #12]
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (l) {
 8005800:	2803      	cmp	r0, #3
 8005802:	d826      	bhi.n	8005852 <pbuf_alloced_custom+0x56>
 8005804:	e8df f000 	tbb	[pc, r0]
 8005808:	06040208 	.word	0x06040208
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    break;
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 800580c:	2022      	movs	r0, #34	; 0x22
 800580e:	e004      	b.n	800581a <pbuf_alloced_custom+0x1e>
    break;
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
 8005810:	200e      	movs	r0, #14
    break;
 8005812:	e002      	b.n	800581a <pbuf_alloced_custom+0x1e>
  case PBUF_RAW:
    offset = 0;
 8005814:	2000      	movs	r0, #0
    break;
 8005816:	e000      	b.n	800581a <pbuf_alloced_custom+0x1e>
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 8005818:	2036      	movs	r0, #54	; 0x36
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 800581a:	3003      	adds	r0, #3
 800581c:	f020 0503 	bic.w	r5, r0, #3
 8005820:	440d      	add	r5, r1
 8005822:	f8bd 6010 	ldrh.w	r6, [sp, #16]
 8005826:	42b5      	cmp	r5, r6
 8005828:	dc15      	bgt.n	8005856 <pbuf_alloced_custom+0x5a>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
  }

  p->pbuf.next = NULL;
 800582a:	2500      	movs	r5, #0
 800582c:	601d      	str	r5, [r3, #0]
  if (payload_mem != NULL) {
 800582e:	b16c      	cbz	r4, 800584c <pbuf_alloced_custom+0x50>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 8005830:	f020 0003 	bic.w	r0, r0, #3
 8005834:	4420      	add	r0, r4
 8005836:	6058      	str	r0, [r3, #4]
  } else {
    p->pbuf.payload = NULL;
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 8005838:	2002      	movs	r0, #2
 800583a:	7358      	strb	r0, [r3, #13]
  p->pbuf.len = p->pbuf.tot_len = length;
 800583c:	8119      	strh	r1, [r3, #8]
 800583e:	8159      	strh	r1, [r3, #10]
  p->pbuf.type = type;
 8005840:	731a      	strb	r2, [r3, #12]
  p->pbuf.ref = 1;
 8005842:	2201      	movs	r2, #1
 8005844:	81da      	strh	r2, [r3, #14]
  return &p->pbuf;
 8005846:	4618      	mov	r0, r3
}
 8005848:	bc70      	pop	{r4, r5, r6}
 800584a:	4770      	bx	lr
    p->pbuf.payload = NULL;
 800584c:	2000      	movs	r0, #0
 800584e:	6058      	str	r0, [r3, #4]
 8005850:	e7f2      	b.n	8005838 <pbuf_alloced_custom+0x3c>
    return NULL;
 8005852:	2000      	movs	r0, #0
 8005854:	e7f8      	b.n	8005848 <pbuf_alloced_custom+0x4c>
    return NULL;
 8005856:	2000      	movs	r0, #0
 8005858:	e7f6      	b.n	8005848 <pbuf_alloced_custom+0x4c>

0800585a <pbuf_header>:
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
 800585a:	2900      	cmp	r1, #0
 800585c:	d033      	beq.n	80058c6 <pbuf_header+0x6c>
 800585e:	460b      	mov	r3, r1
 8005860:	2800      	cmp	r0, #0
 8005862:	d032      	beq.n	80058ca <pbuf_header+0x70>
{
 8005864:	b410      	push	{r4}
    return 0;
  }
 
  if (header_size_increment < 0){
 8005866:	2900      	cmp	r1, #0
 8005868:	db0b      	blt.n	8005882 <pbuf_header+0x28>
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
 800586a:	b28c      	uxth	r4, r1
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 800586c:	7b02      	ldrb	r2, [r0, #12]
  /* remember current payload pointer */
  payload = p->payload;
 800586e:	6841      	ldr	r1, [r0, #4]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 8005870:	b172      	cbz	r2, 8005890 <pbuf_header+0x36>
 8005872:	2a03      	cmp	r2, #3
 8005874:	d00c      	beq.n	8005890 <pbuf_header+0x36>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 8005876:	3a01      	subs	r2, #1
 8005878:	b292      	uxth	r2, r2
 800587a:	2a01      	cmp	r2, #1
 800587c:	d919      	bls.n	80058b2 <pbuf_header+0x58>
      return 1;
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
 800587e:	2001      	movs	r0, #1
 8005880:	e014      	b.n	80058ac <pbuf_header+0x52>
    increment_magnitude = -header_size_increment;
 8005882:	424c      	negs	r4, r1
 8005884:	b2a4      	uxth	r4, r4
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8005886:	8942      	ldrh	r2, [r0, #10]
 8005888:	42a2      	cmp	r2, r4
 800588a:	d2ef      	bcs.n	800586c <pbuf_header+0x12>
 800588c:	2001      	movs	r0, #1
 800588e:	e00d      	b.n	80058ac <pbuf_header+0x52>
    p->payload = (u8_t *)p->payload - header_size_increment;
 8005890:	1ac9      	subs	r1, r1, r3
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 8005892:	f100 0210 	add.w	r2, r0, #16
 8005896:	4291      	cmp	r1, r2
 8005898:	d319      	bcc.n	80058ce <pbuf_header+0x74>
    p->payload = (u8_t *)p->payload - header_size_increment;
 800589a:	6041      	str	r1, [r0, #4]
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 800589c:	b29b      	uxth	r3, r3
 800589e:	8942      	ldrh	r2, [r0, #10]
 80058a0:	441a      	add	r2, r3
 80058a2:	8142      	strh	r2, [r0, #10]
  p->tot_len += header_size_increment;
 80058a4:	8902      	ldrh	r2, [r0, #8]
 80058a6:	4413      	add	r3, r2
 80058a8:	8103      	strh	r3, [r0, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 80058aa:	2000      	movs	r0, #0
}
 80058ac:	f85d 4b04 	ldr.w	r4, [sp], #4
 80058b0:	4770      	bx	lr
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 80058b2:	2b00      	cmp	r3, #0
 80058b4:	db01      	blt.n	80058ba <pbuf_header+0x60>
      return 1;
 80058b6:	2001      	movs	r0, #1
 80058b8:	e7f8      	b.n	80058ac <pbuf_header+0x52>
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 80058ba:	8942      	ldrh	r2, [r0, #10]
 80058bc:	42a2      	cmp	r2, r4
 80058be:	d308      	bcc.n	80058d2 <pbuf_header+0x78>
      p->payload = (u8_t *)p->payload - header_size_increment;
 80058c0:	1ac9      	subs	r1, r1, r3
 80058c2:	6041      	str	r1, [r0, #4]
 80058c4:	e7ea      	b.n	800589c <pbuf_header+0x42>
    return 0;
 80058c6:	2000      	movs	r0, #0
 80058c8:	4770      	bx	lr
 80058ca:	2000      	movs	r0, #0
 80058cc:	4770      	bx	lr
      return 1;
 80058ce:	2001      	movs	r0, #1
 80058d0:	e7ec      	b.n	80058ac <pbuf_header+0x52>
      return 1;
 80058d2:	2001      	movs	r0, #1
 80058d4:	e7ea      	b.n	80058ac <pbuf_header+0x52>

080058d6 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 80058d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 80058d8:	b340      	cbz	r0, 800592c <pbuf_free+0x56>
 80058da:	4601      	mov	r1, r0
 80058dc:	2400      	movs	r4, #0
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
 80058de:	2508      	movs	r5, #8
          memp_free(MEMP_PBUF_POOL, p);
 80058e0:	2609      	movs	r6, #9
 80058e2:	e006      	b.n	80058f2 <pbuf_free+0x1c>
        pc->custom_free_function(p);
 80058e4:	690b      	ldr	r3, [r1, #16]
 80058e6:	4608      	mov	r0, r1
 80058e8:	4798      	blx	r3
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
        }
      }
      count++;
 80058ea:	3401      	adds	r4, #1
 80058ec:	b2e4      	uxtb	r4, r4
      /* proceed to next pbuf */
      p = q;
 80058ee:	4639      	mov	r1, r7
  while (p != NULL) {
 80058f0:	b1ef      	cbz	r7, 800592e <pbuf_free+0x58>
    ref = --(p->ref);
 80058f2:	89cb      	ldrh	r3, [r1, #14]
 80058f4:	3b01      	subs	r3, #1
 80058f6:	b29b      	uxth	r3, r3
 80058f8:	81cb      	strh	r3, [r1, #14]
    if (ref == 0) {
 80058fa:	b9c3      	cbnz	r3, 800592e <pbuf_free+0x58>
      q = p->next;
 80058fc:	680f      	ldr	r7, [r1, #0]
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 80058fe:	7b4b      	ldrb	r3, [r1, #13]
 8005900:	f013 0f02 	tst.w	r3, #2
 8005904:	d1ee      	bne.n	80058e4 <pbuf_free+0xe>
      type = p->type;
 8005906:	7b0b      	ldrb	r3, [r1, #12]
        if (type == PBUF_POOL) {
 8005908:	2b03      	cmp	r3, #3
 800590a:	d007      	beq.n	800591c <pbuf_free+0x46>
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 800590c:	3b01      	subs	r3, #1
 800590e:	b29b      	uxth	r3, r3
 8005910:	2b01      	cmp	r3, #1
 8005912:	d907      	bls.n	8005924 <pbuf_free+0x4e>
          mem_free(p);
 8005914:	4608      	mov	r0, r1
 8005916:	f7ff fce1 	bl	80052dc <mem_free>
 800591a:	e7e6      	b.n	80058ea <pbuf_free+0x14>
          memp_free(MEMP_PBUF_POOL, p);
 800591c:	4630      	mov	r0, r6
 800591e:	f7ff fee3 	bl	80056e8 <memp_free>
 8005922:	e7e2      	b.n	80058ea <pbuf_free+0x14>
          memp_free(MEMP_PBUF, p);
 8005924:	4628      	mov	r0, r5
 8005926:	f7ff fedf 	bl	80056e8 <memp_free>
 800592a:	e7de      	b.n	80058ea <pbuf_free+0x14>
    return 0;
 800592c:	2400      	movs	r4, #0
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
 800592e:	4620      	mov	r0, r4
 8005930:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08005934 <pbuf_alloc>:
{
 8005934:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  switch (layer) {
 8005938:	2803      	cmp	r0, #3
 800593a:	f200 808d 	bhi.w	8005a58 <pbuf_alloc+0x124>
 800593e:	e8df f000 	tbb	[pc, r0]
 8005942:	0208      	.short	0x0208
 8005944:	0604      	.short	0x0604
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 8005946:	2422      	movs	r4, #34	; 0x22
 8005948:	e004      	b.n	8005954 <pbuf_alloc+0x20>
    offset = PBUF_LINK_HLEN;
 800594a:	240e      	movs	r4, #14
    break;
 800594c:	e002      	b.n	8005954 <pbuf_alloc+0x20>
    offset = 0;
 800594e:	2400      	movs	r4, #0
    break;
 8005950:	e000      	b.n	8005954 <pbuf_alloc+0x20>
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 8005952:	2436      	movs	r4, #54	; 0x36
 8005954:	4617      	mov	r7, r2
 8005956:	460d      	mov	r5, r1
  switch (type) {
 8005958:	2a03      	cmp	r2, #3
 800595a:	d87f      	bhi.n	8005a5c <pbuf_alloc+0x128>
 800595c:	e8df f002 	tbb	[pc, r2]
 8005960:	026f6f51 	.word	0x026f6f51
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8005964:	2009      	movs	r0, #9
 8005966:	f7ff fe89 	bl	800567c <memp_malloc>
    if (p == NULL) {
 800596a:	4606      	mov	r6, r0
 800596c:	2800      	cmp	r0, #0
 800596e:	d03c      	beq.n	80059ea <pbuf_alloc+0xb6>
    p->type = type;
 8005970:	2303      	movs	r3, #3
 8005972:	7303      	strb	r3, [r0, #12]
    p->next = NULL;
 8005974:	2300      	movs	r3, #0
 8005976:	6003      	str	r3, [r0, #0]
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8005978:	1903      	adds	r3, r0, r4
 800597a:	3313      	adds	r3, #19
 800597c:	f023 0303 	bic.w	r3, r3, #3
 8005980:	6043      	str	r3, [r0, #4]
    p->tot_len = length;
 8005982:	8105      	strh	r5, [r0, #8]
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8005984:	3403      	adds	r4, #3
 8005986:	f024 0403 	bic.w	r4, r4, #3
 800598a:	f5c4 64bd 	rsb	r4, r4, #1512	; 0x5e8
 800598e:	3404      	adds	r4, #4
 8005990:	42ac      	cmp	r4, r5
 8005992:	bfa8      	it	ge
 8005994:	462c      	movge	r4, r5
 8005996:	8144      	strh	r4, [r0, #10]
    p->ref = 1;
 8005998:	2301      	movs	r3, #1
 800599a:	81c3      	strh	r3, [r0, #14]
    rem_len = length - p->len;
 800599c:	b2a4      	uxth	r4, r4
 800599e:	1b2d      	subs	r5, r5, r4
    while (rem_len > 0) {
 80059a0:	2d00      	cmp	r5, #0
 80059a2:	dd45      	ble.n	8005a30 <pbuf_alloc+0xfc>
 80059a4:	4682      	mov	sl, r0
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 80059a6:	f04f 0809 	mov.w	r8, #9
      q->type = type;
 80059aa:	f04f 0903 	mov.w	r9, #3
      q->flags = 0;
 80059ae:	2700      	movs	r7, #0
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 80059b0:	4640      	mov	r0, r8
 80059b2:	f7ff fe63 	bl	800567c <memp_malloc>
      if (q == NULL) {
 80059b6:	4604      	mov	r4, r0
 80059b8:	b1d8      	cbz	r0, 80059f2 <pbuf_alloc+0xbe>
      q->type = type;
 80059ba:	f880 900c 	strb.w	r9, [r0, #12]
      q->flags = 0;
 80059be:	7347      	strb	r7, [r0, #13]
      q->next = NULL;
 80059c0:	6007      	str	r7, [r0, #0]
      r->next = q;
 80059c2:	f8ca 0000 	str.w	r0, [sl]
      q->tot_len = (u16_t)rem_len;
 80059c6:	b2ab      	uxth	r3, r5
 80059c8:	8103      	strh	r3, [r0, #8]
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 80059ca:	f240 52ec 	movw	r2, #1516	; 0x5ec
 80059ce:	4293      	cmp	r3, r2
 80059d0:	bf28      	it	cs
 80059d2:	4613      	movcs	r3, r2
 80059d4:	8143      	strh	r3, [r0, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 80059d6:	f100 0210 	add.w	r2, r0, #16
 80059da:	6042      	str	r2, [r0, #4]
      q->ref = 1;
 80059dc:	2201      	movs	r2, #1
 80059de:	81c2      	strh	r2, [r0, #14]
      rem_len -= q->len;
 80059e0:	1aed      	subs	r5, r5, r3
      r = q;
 80059e2:	4682      	mov	sl, r0
    while (rem_len > 0) {
 80059e4:	2d00      	cmp	r5, #0
 80059e6:	dce3      	bgt.n	80059b0 <pbuf_alloc+0x7c>
 80059e8:	e022      	b.n	8005a30 <pbuf_alloc+0xfc>
  pbuf_free_ooseq_pending = 1;
 80059ea:	2201      	movs	r2, #1
 80059ec:	4b1c      	ldr	r3, [pc, #112]	; (8005a60 <pbuf_alloc+0x12c>)
 80059ee:	701a      	strb	r2, [r3, #0]
 80059f0:	e022      	b.n	8005a38 <pbuf_alloc+0x104>
 80059f2:	2201      	movs	r2, #1
 80059f4:	4b1a      	ldr	r3, [pc, #104]	; (8005a60 <pbuf_alloc+0x12c>)
 80059f6:	701a      	strb	r2, [r3, #0]
        pbuf_free(p);
 80059f8:	4630      	mov	r0, r6
 80059fa:	f7ff ff6c 	bl	80058d6 <pbuf_free>
        return NULL;
 80059fe:	4626      	mov	r6, r4
 8005a00:	e01a      	b.n	8005a38 <pbuf_alloc+0x104>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
 8005a02:	f104 0013 	add.w	r0, r4, #19
 8005a06:	f020 0003 	bic.w	r0, r0, #3
 8005a0a:	1ccb      	adds	r3, r1, #3
 8005a0c:	f023 0303 	bic.w	r3, r3, #3
 8005a10:	4418      	add	r0, r3
 8005a12:	b280      	uxth	r0, r0
 8005a14:	f7ff fd44 	bl	80054a0 <mem_malloc>
    if (p == NULL) {
 8005a18:	4606      	mov	r6, r0
 8005a1a:	b168      	cbz	r0, 8005a38 <pbuf_alloc+0x104>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 8005a1c:	4404      	add	r4, r0
 8005a1e:	3413      	adds	r4, #19
 8005a20:	f024 0403 	bic.w	r4, r4, #3
 8005a24:	6044      	str	r4, [r0, #4]
    p->len = p->tot_len = length;
 8005a26:	8105      	strh	r5, [r0, #8]
 8005a28:	8145      	strh	r5, [r0, #10]
    p->next = NULL;
 8005a2a:	2300      	movs	r3, #0
 8005a2c:	6003      	str	r3, [r0, #0]
    p->type = type;
 8005a2e:	7303      	strb	r3, [r0, #12]
  p->ref = 1;
 8005a30:	2301      	movs	r3, #1
 8005a32:	81f3      	strh	r3, [r6, #14]
  p->flags = 0;
 8005a34:	2300      	movs	r3, #0
 8005a36:	7373      	strb	r3, [r6, #13]
}
 8005a38:	4630      	mov	r0, r6
 8005a3a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 8005a3e:	2008      	movs	r0, #8
 8005a40:	f7ff fe1c 	bl	800567c <memp_malloc>
    if (p == NULL) {
 8005a44:	4606      	mov	r6, r0
 8005a46:	2800      	cmp	r0, #0
 8005a48:	d0f6      	beq.n	8005a38 <pbuf_alloc+0x104>
    p->payload = NULL;
 8005a4a:	2300      	movs	r3, #0
 8005a4c:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
 8005a4e:	8105      	strh	r5, [r0, #8]
 8005a50:	8145      	strh	r5, [r0, #10]
    p->next = NULL;
 8005a52:	6003      	str	r3, [r0, #0]
    p->type = type;
 8005a54:	7307      	strb	r7, [r0, #12]
    break;
 8005a56:	e7eb      	b.n	8005a30 <pbuf_alloc+0xfc>
    return NULL;
 8005a58:	2600      	movs	r6, #0
 8005a5a:	e7ed      	b.n	8005a38 <pbuf_alloc+0x104>
    return NULL;
 8005a5c:	2600      	movs	r6, #0
 8005a5e:	e7eb      	b.n	8005a38 <pbuf_alloc+0x104>
 8005a60:	2000b10c 	.word	0x2000b10c

08005a64 <pbuf_realloc>:
  if (new_len >= p->tot_len) {
 8005a64:	8902      	ldrh	r2, [r0, #8]
 8005a66:	428a      	cmp	r2, r1
 8005a68:	d926      	bls.n	8005ab8 <pbuf_realloc+0x54>
{
 8005a6a:	b538      	push	{r3, r4, r5, lr}
 8005a6c:	4604      	mov	r4, r0
  while (rem_len > q->len) {
 8005a6e:	8943      	ldrh	r3, [r0, #10]
 8005a70:	4299      	cmp	r1, r3
 8005a72:	d91f      	bls.n	8005ab4 <pbuf_realloc+0x50>
 8005a74:	460d      	mov	r5, r1
    q->tot_len += (u16_t)grow;
 8005a76:	1a89      	subs	r1, r1, r2
    rem_len -= q->len;
 8005a78:	1aeb      	subs	r3, r5, r3
 8005a7a:	b29d      	uxth	r5, r3
    q->tot_len += (u16_t)grow;
 8005a7c:	8923      	ldrh	r3, [r4, #8]
 8005a7e:	440b      	add	r3, r1
 8005a80:	8123      	strh	r3, [r4, #8]
    q = q->next;
 8005a82:	6824      	ldr	r4, [r4, #0]
  while (rem_len > q->len) {
 8005a84:	8963      	ldrh	r3, [r4, #10]
 8005a86:	42ab      	cmp	r3, r5
 8005a88:	d3f6      	bcc.n	8005a78 <pbuf_realloc+0x14>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 8005a8a:	7b22      	ldrb	r2, [r4, #12]
 8005a8c:	b94a      	cbnz	r2, 8005aa2 <pbuf_realloc+0x3e>
 8005a8e:	429d      	cmp	r5, r3
 8005a90:	d007      	beq.n	8005aa2 <pbuf_realloc+0x3e>
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 8005a92:	6863      	ldr	r3, [r4, #4]
 8005a94:	1b1b      	subs	r3, r3, r4
 8005a96:	18e9      	adds	r1, r5, r3
 8005a98:	b289      	uxth	r1, r1
 8005a9a:	4620      	mov	r0, r4
 8005a9c:	f7ff fc7a 	bl	8005394 <mem_trim>
 8005aa0:	4604      	mov	r4, r0
  q->len = rem_len;
 8005aa2:	8165      	strh	r5, [r4, #10]
  q->tot_len = q->len;
 8005aa4:	8125      	strh	r5, [r4, #8]
  if (q->next != NULL) {
 8005aa6:	6820      	ldr	r0, [r4, #0]
 8005aa8:	b108      	cbz	r0, 8005aae <pbuf_realloc+0x4a>
    pbuf_free(q->next);
 8005aaa:	f7ff ff14 	bl	80058d6 <pbuf_free>
  q->next = NULL;
 8005aae:	2300      	movs	r3, #0
 8005ab0:	6023      	str	r3, [r4, #0]
 8005ab2:	bd38      	pop	{r3, r4, r5, pc}
  while (rem_len > q->len) {
 8005ab4:	460d      	mov	r5, r1
 8005ab6:	e7e8      	b.n	8005a8a <pbuf_realloc+0x26>
 8005ab8:	4770      	bx	lr

08005aba <pbuf_clen>:
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 8005aba:	4603      	mov	r3, r0
 8005abc:	b130      	cbz	r0, 8005acc <pbuf_clen+0x12>
 8005abe:	2000      	movs	r0, #0
    ++len;
 8005ac0:	3001      	adds	r0, #1
 8005ac2:	b2c0      	uxtb	r0, r0
    p = p->next;
 8005ac4:	681b      	ldr	r3, [r3, #0]
  while (p != NULL) {
 8005ac6:	2b00      	cmp	r3, #0
 8005ac8:	d1fa      	bne.n	8005ac0 <pbuf_clen+0x6>
 8005aca:	4770      	bx	lr
  len = 0;
 8005acc:	2000      	movs	r0, #0
  }
  return len;
}
 8005ace:	4770      	bx	lr

08005ad0 <pbuf_ref>:
void
pbuf_ref(struct pbuf *p)
{
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 8005ad0:	b110      	cbz	r0, 8005ad8 <pbuf_ref+0x8>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
 8005ad2:	89c3      	ldrh	r3, [r0, #14]
 8005ad4:	3301      	adds	r3, #1
 8005ad6:	81c3      	strh	r3, [r0, #14]
 8005ad8:	4770      	bx	lr

08005ada <pbuf_cat>:
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 8005ada:	b1b0      	cbz	r0, 8005b0a <pbuf_cat+0x30>
{
 8005adc:	b410      	push	{r4}
 8005ade:	4604      	mov	r4, r0
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 8005ae0:	b189      	cbz	r1, 8005b06 <pbuf_cat+0x2c>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8005ae2:	6802      	ldr	r2, [r0, #0]
 8005ae4:	b912      	cbnz	r2, 8005aec <pbuf_cat+0x12>
 8005ae6:	4602      	mov	r2, r0
 8005ae8:	e008      	b.n	8005afc <pbuf_cat+0x22>
 8005aea:	461a      	mov	r2, r3
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 8005aec:	8923      	ldrh	r3, [r4, #8]
 8005aee:	8908      	ldrh	r0, [r1, #8]
 8005af0:	4403      	add	r3, r0
 8005af2:	8123      	strh	r3, [r4, #8]
  for (p = h; p->next != NULL; p = p->next) {
 8005af4:	6813      	ldr	r3, [r2, #0]
 8005af6:	4614      	mov	r4, r2
 8005af8:	2b00      	cmp	r3, #0
 8005afa:	d1f6      	bne.n	8005aea <pbuf_cat+0x10>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 8005afc:	8913      	ldrh	r3, [r2, #8]
 8005afe:	8908      	ldrh	r0, [r1, #8]
 8005b00:	4403      	add	r3, r0
 8005b02:	8113      	strh	r3, [r2, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 8005b04:	6011      	str	r1, [r2, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 8005b06:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005b0a:	4770      	bx	lr

08005b0c <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 8005b0c:	b510      	push	{r4, lr}
 8005b0e:	460c      	mov	r4, r1
  pbuf_cat(h, t);
 8005b10:	f7ff ffe3 	bl	8005ada <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 8005b14:	4620      	mov	r0, r4
 8005b16:	f7ff ffdb 	bl	8005ad0 <pbuf_ref>
 8005b1a:	bd10      	pop	{r4, pc}

08005b1c <pbuf_copy>:

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8005b1c:	b310      	cbz	r0, 8005b64 <pbuf_copy+0x48>
{
 8005b1e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005b22:	460e      	mov	r6, r1
 8005b24:	4607      	mov	r7, r0
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8005b26:	b301      	cbz	r1, 8005b6a <pbuf_copy+0x4e>
 8005b28:	8902      	ldrh	r2, [r0, #8]
 8005b2a:	890b      	ldrh	r3, [r1, #8]
 8005b2c:	429a      	cmp	r2, r3
 8005b2e:	d320      	bcc.n	8005b72 <pbuf_copy+0x56>
 8005b30:	f04f 0900 	mov.w	r9, #0
 8005b34:	464d      	mov	r5, r9
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
 8005b36:	46c8      	mov	r8, r9
 8005b38:	e02e      	b.n	8005b98 <pbuf_copy+0x7c>
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
 8005b3a:	683f      	ldr	r7, [r7, #0]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 8005b3c:	b10f      	cbz	r7, 8005b42 <pbuf_copy+0x26>
      offset_to = 0;
 8005b3e:	4645      	mov	r5, r8
 8005b40:	e049      	b.n	8005bd6 <pbuf_copy+0xba>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 8005b42:	2e00      	cmp	r6, #0
 8005b44:	bf14      	ite	ne
 8005b46:	f06f 000d 	mvnne.w	r0, #13
 8005b4a:	2000      	moveq	r0, #0
 8005b4c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 8005b50:	6833      	ldr	r3, [r6, #0]
 8005b52:	2b00      	cmp	r3, #0
 8005b54:	d045      	beq.n	8005be2 <pbuf_copy+0xc6>
 8005b56:	f06f 0005 	mvn.w	r0, #5
 8005b5a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  return ERR_OK;
 8005b5e:	2000      	movs	r0, #0
 8005b60:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8005b64:	f06f 000d 	mvn.w	r0, #13
 8005b68:	4770      	bx	lr
 8005b6a:	f06f 000d 	mvn.w	r0, #13
 8005b6e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005b72:	f06f 000d 	mvn.w	r0, #13
 8005b76:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 8005b7a:	f06f 0005 	mvn.w	r0, #5
 8005b7e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 8005b82:	2f00      	cmp	r7, #0
 8005b84:	d034      	beq.n	8005bf0 <pbuf_copy+0xd4>
 8005b86:	897a      	ldrh	r2, [r7, #10]
 8005b88:	893b      	ldrh	r3, [r7, #8]
 8005b8a:	429a      	cmp	r2, r3
 8005b8c:	d133      	bne.n	8005bf6 <pbuf_copy+0xda>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 8005b8e:	683b      	ldr	r3, [r7, #0]
 8005b90:	2b00      	cmp	r3, #0
 8005b92:	d1f2      	bne.n	8005b7a <pbuf_copy+0x5e>
  } while (p_from);
 8005b94:	2e00      	cmp	r6, #0
 8005b96:	d0e2      	beq.n	8005b5e <pbuf_copy+0x42>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 8005b98:	897b      	ldrh	r3, [r7, #10]
 8005b9a:	8974      	ldrh	r4, [r6, #10]
 8005b9c:	1b59      	subs	r1, r3, r5
 8005b9e:	eba4 0209 	sub.w	r2, r4, r9
 8005ba2:	4291      	cmp	r1, r2
      len = p_from->len - offset_from;
 8005ba4:	bfa7      	ittee	ge
 8005ba6:	4614      	movge	r4, r2
 8005ba8:	b2a4      	uxthge	r4, r4
      len = p_to->len - offset_to;
 8005baa:	1b5b      	sublt	r3, r3, r5
 8005bac:	b29c      	uxthlt	r4, r3
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 8005bae:	6878      	ldr	r0, [r7, #4]
 8005bb0:	6871      	ldr	r1, [r6, #4]
 8005bb2:	4622      	mov	r2, r4
 8005bb4:	4449      	add	r1, r9
 8005bb6:	4428      	add	r0, r5
 8005bb8:	f003 fa99 	bl	80090ee <memcpy>
    offset_to += len;
 8005bbc:	4425      	add	r5, r4
 8005bbe:	b2ad      	uxth	r5, r5
    offset_from += len;
 8005bc0:	444c      	add	r4, r9
 8005bc2:	fa1f f984 	uxth.w	r9, r4
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 8005bc6:	897b      	ldrh	r3, [r7, #10]
    if (offset_from >= p_from->len) {
 8005bc8:	8972      	ldrh	r2, [r6, #10]
 8005bca:	454a      	cmp	r2, r9
      p_from = p_from->next;
 8005bcc:	bf9c      	itt	ls
 8005bce:	6836      	ldrls	r6, [r6, #0]
      offset_from = 0;
 8005bd0:	46c1      	movls	r9, r8
    if (offset_to == p_to->len) {
 8005bd2:	429d      	cmp	r5, r3
 8005bd4:	d0b1      	beq.n	8005b3a <pbuf_copy+0x1e>
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 8005bd6:	2e00      	cmp	r6, #0
 8005bd8:	d0d3      	beq.n	8005b82 <pbuf_copy+0x66>
 8005bda:	8972      	ldrh	r2, [r6, #10]
 8005bdc:	8933      	ldrh	r3, [r6, #8]
 8005bde:	429a      	cmp	r2, r3
 8005be0:	d0b6      	beq.n	8005b50 <pbuf_copy+0x34>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 8005be2:	2f00      	cmp	r7, #0
 8005be4:	d0d8      	beq.n	8005b98 <pbuf_copy+0x7c>
 8005be6:	897a      	ldrh	r2, [r7, #10]
 8005be8:	893b      	ldrh	r3, [r7, #8]
 8005bea:	429a      	cmp	r2, r3
 8005bec:	d1d4      	bne.n	8005b98 <pbuf_copy+0x7c>
 8005bee:	e7ce      	b.n	8005b8e <pbuf_copy+0x72>
  return ERR_OK;
 8005bf0:	2000      	movs	r0, #0
 8005bf2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005bf6:	2000      	movs	r0, #0
}
 8005bf8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08005bfc <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 8005bfc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8005c00:	b338      	cbz	r0, 8005c52 <pbuf_copy_partial+0x56>
 8005c02:	460f      	mov	r7, r1
 8005c04:	4691      	mov	r9, r2
 8005c06:	4605      	mov	r5, r0
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8005c08:	b339      	cbz	r1, 8005c5a <pbuf_copy_partial+0x5e>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8005c0a:	b342      	cbz	r2, 8005c5e <pbuf_copy_partial+0x62>
 8005c0c:	2600      	movs	r6, #0
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
      copied_total += buf_copy_len;
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
 8005c0e:	46b0      	mov	r8, r6
 8005c10:	e017      	b.n	8005c42 <pbuf_copy_partial+0x46>
      buf_copy_len = p->len - offset;
 8005c12:	896c      	ldrh	r4, [r5, #10]
 8005c14:	1ae4      	subs	r4, r4, r3
 8005c16:	b2a4      	uxth	r4, r4
 8005c18:	454c      	cmp	r4, r9
 8005c1a:	bf28      	it	cs
 8005c1c:	464c      	movcs	r4, r9
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8005c1e:	6869      	ldr	r1, [r5, #4]
 8005c20:	4622      	mov	r2, r4
 8005c22:	4419      	add	r1, r3
 8005c24:	19b8      	adds	r0, r7, r6
 8005c26:	f003 fa62 	bl	80090ee <memcpy>
      copied_total += buf_copy_len;
 8005c2a:	4426      	add	r6, r4
 8005c2c:	b2b6      	uxth	r6, r6
      len -= buf_copy_len;
 8005c2e:	eba9 0404 	sub.w	r4, r9, r4
 8005c32:	fa1f f984 	uxth.w	r9, r4
      offset = 0;
 8005c36:	4643      	mov	r3, r8
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8005c38:	682d      	ldr	r5, [r5, #0]
 8005c3a:	f1b9 0f00 	cmp.w	r9, #0
 8005c3e:	d009      	beq.n	8005c54 <pbuf_copy_partial+0x58>
 8005c40:	b145      	cbz	r5, 8005c54 <pbuf_copy_partial+0x58>
    if ((offset != 0) && (offset >= p->len)) {
 8005c42:	2b00      	cmp	r3, #0
 8005c44:	d0e5      	beq.n	8005c12 <pbuf_copy_partial+0x16>
 8005c46:	8969      	ldrh	r1, [r5, #10]
 8005c48:	4299      	cmp	r1, r3
 8005c4a:	d8e2      	bhi.n	8005c12 <pbuf_copy_partial+0x16>
      offset -= p->len;
 8005c4c:	1a5b      	subs	r3, r3, r1
 8005c4e:	b29b      	uxth	r3, r3
 8005c50:	e7f2      	b.n	8005c38 <pbuf_copy_partial+0x3c>
  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8005c52:	2600      	movs	r6, #0
    }
  }
  return copied_total;
}
 8005c54:	4630      	mov	r0, r6
 8005c56:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8005c5a:	2600      	movs	r6, #0
 8005c5c:	e7fa      	b.n	8005c54 <pbuf_copy_partial+0x58>
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8005c5e:	4616      	mov	r6, r2
 8005c60:	e7f8      	b.n	8005c54 <pbuf_copy_partial+0x58>
	...

08005c64 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
 8005c64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);
 8005c68:	6843      	ldr	r3, [r0, #4]
 8005c6a:	7a5e      	ldrb	r6, [r3, #9]

  prev = NULL;
  pcb = raw_pcbs;
 8005c6c:	4b18      	ldr	r3, [pc, #96]	; (8005cd0 <raw_input+0x6c>)
 8005c6e:	681c      	ldr	r4, [r3, #0]
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 8005c70:	b35c      	cbz	r4, 8005cca <raw_input+0x66>
 8005c72:	4682      	mov	sl, r0
 8005c74:	2500      	movs	r5, #0
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 8005c76:	f8df 805c 	ldr.w	r8, [pc, #92]	; 8005cd4 <raw_input+0x70>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
 8005c7a:	f8df 905c 	ldr.w	r9, [pc, #92]	; 8005cd8 <raw_input+0x74>
 8005c7e:	e003      	b.n	8005c88 <raw_input+0x24>
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
 8005c80:	68e3      	ldr	r3, [r4, #12]
 8005c82:	4625      	mov	r5, r4
  while ((eaten == 0) && (pcb != NULL)) {
 8005c84:	b1f3      	cbz	r3, 8005cc4 <raw_input+0x60>
    pcb = pcb->next;
 8005c86:	461c      	mov	r4, r3
    if ((pcb->protocol == proto) &&
 8005c88:	7c23      	ldrb	r3, [r4, #16]
 8005c8a:	42b3      	cmp	r3, r6
 8005c8c:	d1f8      	bne.n	8005c80 <raw_input+0x1c>
 8005c8e:	b12c      	cbz	r4, 8005c9c <raw_input+0x38>
        (ip_addr_isany(&pcb->local_ip) ||
 8005c90:	6823      	ldr	r3, [r4, #0]
 8005c92:	b11b      	cbz	r3, 8005c9c <raw_input+0x38>
 8005c94:	f8d9 2000 	ldr.w	r2, [r9]
 8005c98:	4293      	cmp	r3, r2
 8005c9a:	d1f1      	bne.n	8005c80 <raw_input+0x1c>
        if (pcb->recv != NULL) {
 8005c9c:	6967      	ldr	r7, [r4, #20]
 8005c9e:	2f00      	cmp	r7, #0
 8005ca0:	d0ee      	beq.n	8005c80 <raw_input+0x1c>
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 8005ca2:	4643      	mov	r3, r8
 8005ca4:	4652      	mov	r2, sl
 8005ca6:	4621      	mov	r1, r4
 8005ca8:	69a0      	ldr	r0, [r4, #24]
 8005caa:	47b8      	blx	r7
 8005cac:	2800      	cmp	r0, #0
 8005cae:	d0e7      	beq.n	8005c80 <raw_input+0x1c>
            if (prev != NULL) {
 8005cb0:	b12d      	cbz	r5, 8005cbe <raw_input+0x5a>
              prev->next = pcb->next;
 8005cb2:	68e3      	ldr	r3, [r4, #12]
 8005cb4:	60eb      	str	r3, [r5, #12]
              pcb->next = raw_pcbs;
 8005cb6:	4b06      	ldr	r3, [pc, #24]	; (8005cd0 <raw_input+0x6c>)
 8005cb8:	681a      	ldr	r2, [r3, #0]
 8005cba:	60e2      	str	r2, [r4, #12]
              raw_pcbs = pcb;
 8005cbc:	601c      	str	r4, [r3, #0]
    pcb = pcb->next;
 8005cbe:	2001      	movs	r0, #1
  }
  return eaten;
}
 8005cc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005cc4:	2000      	movs	r0, #0
 8005cc6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  u8_t eaten = 0;
 8005cca:	2000      	movs	r0, #0
 8005ccc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005cd0:	20007780 	.word	0x20007780
 8005cd4:	200089d0 	.word	0x200089d0
 8005cd8:	200089d8 	.word	0x200089d8

08005cdc <stats_init>:
#include <string.h>

struct stats_ lwip_stats;

void stats_init(void)
{
 8005cdc:	4770      	bx	lr

08005cde <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
 8005cde:	4770      	bx	lr

08005ce0 <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 8005ce0:	b470      	push	{r4, r5, r6}
 8005ce2:	4602      	mov	r2, r0
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8005ce4:	6a85      	ldr	r5, [r0, #40]	; 0x28
 8005ce6:	8d84      	ldrh	r4, [r0, #44]	; 0x2c

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8005ce8:	6b01      	ldr	r1, [r0, #48]	; 0x30
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8005cea:	1963      	adds	r3, r4, r5
 8005cec:	1a58      	subs	r0, r3, r1
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8005cee:	8ed3      	ldrh	r3, [r2, #54]	; 0x36
 8005cf0:	f640 3668 	movw	r6, #2920	; 0xb68
 8005cf4:	42b3      	cmp	r3, r6
 8005cf6:	bf94      	ite	ls
 8005cf8:	1ac3      	subls	r3, r0, r3
 8005cfa:	1b83      	subhi	r3, r0, r6
 8005cfc:	2b00      	cmp	r3, #0
 8005cfe:	db02      	blt.n	8005d06 <tcp_update_rcv_ann_wnd+0x26>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 8005d00:	85d4      	strh	r4, [r2, #46]	; 0x2e
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
  }
}
 8005d02:	bc70      	pop	{r4, r5, r6}
 8005d04:	4770      	bx	lr
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 8005d06:	1a6b      	subs	r3, r5, r1
 8005d08:	2b00      	cmp	r3, #0
 8005d0a:	dd03      	ble.n	8005d14 <tcp_update_rcv_ann_wnd+0x34>
      pcb->rcv_ann_wnd = 0;
 8005d0c:	2300      	movs	r3, #0
 8005d0e:	85d3      	strh	r3, [r2, #46]	; 0x2e
    return 0;
 8005d10:	4618      	mov	r0, r3
 8005d12:	e7f6      	b.n	8005d02 <tcp_update_rcv_ann_wnd+0x22>
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 8005d14:	1b49      	subs	r1, r1, r5
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
 8005d16:	85d1      	strh	r1, [r2, #46]	; 0x2e
    return 0;
 8005d18:	2000      	movs	r0, #0
 8005d1a:	e7f2      	b.n	8005d02 <tcp_update_rcv_ann_wnd+0x22>

08005d1c <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 8005d1c:	b510      	push	{r4, lr}
 8005d1e:	4604      	mov	r4, r0
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8005d20:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 8005d22:	4419      	add	r1, r3
 8005d24:	b289      	uxth	r1, r1
  if (pcb->rcv_wnd > TCP_WND) {
 8005d26:	f241 63d0 	movw	r3, #5840	; 0x16d0
 8005d2a:	4299      	cmp	r1, r3
  pcb->rcv_wnd += len;
 8005d2c:	bf92      	itee	ls
 8005d2e:	8581      	strhls	r1, [r0, #44]	; 0x2c
    pcb->rcv_wnd = TCP_WND;
 8005d30:	f241 63d0 	movwhi	r3, #5840	; 0x16d0
 8005d34:	8583      	strhhi	r3, [r0, #44]	; 0x2c
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 8005d36:	f7ff ffd3 	bl	8005ce0 <tcp_update_rcv_ann_wnd>

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8005d3a:	f240 53b3 	movw	r3, #1459	; 0x5b3
 8005d3e:	4298      	cmp	r0, r3
 8005d40:	dc00      	bgt.n	8005d44 <tcp_recved+0x28>
 8005d42:	bd10      	pop	{r4, pc}
    tcp_ack_now(pcb);
 8005d44:	7fa3      	ldrb	r3, [r4, #30]
 8005d46:	f043 0302 	orr.w	r3, r3, #2
 8005d4a:	77a3      	strb	r3, [r4, #30]
    tcp_output(pcb);
 8005d4c:	4620      	mov	r0, r4
 8005d4e:	f002 f801 	bl	8007d54 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
 8005d52:	e7f6      	b.n	8005d42 <tcp_recved+0x26>

08005d54 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
 8005d54:	b150      	cbz	r0, 8005d6c <tcp_seg_free+0x18>
{
 8005d56:	b510      	push	{r4, lr}
 8005d58:	4604      	mov	r4, r0
    if (seg->p != NULL) {
 8005d5a:	6840      	ldr	r0, [r0, #4]
 8005d5c:	b108      	cbz	r0, 8005d62 <tcp_seg_free+0xe>
      pbuf_free(seg->p);
 8005d5e:	f7ff fdba 	bl	80058d6 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8005d62:	4621      	mov	r1, r4
 8005d64:	2004      	movs	r0, #4
 8005d66:	f7ff fcbf 	bl	80056e8 <memp_free>
 8005d6a:	bd10      	pop	{r4, pc}
 8005d6c:	4770      	bx	lr

08005d6e <tcp_segs_free>:
  while (seg != NULL) {
 8005d6e:	4603      	mov	r3, r0
 8005d70:	b140      	cbz	r0, 8005d84 <tcp_segs_free+0x16>
{
 8005d72:	b510      	push	{r4, lr}
    struct tcp_seg *next = seg->next;
 8005d74:	681c      	ldr	r4, [r3, #0]
    tcp_seg_free(seg);
 8005d76:	4618      	mov	r0, r3
 8005d78:	f7ff ffec 	bl	8005d54 <tcp_seg_free>
    seg = next;
 8005d7c:	4623      	mov	r3, r4
  while (seg != NULL) {
 8005d7e:	2c00      	cmp	r4, #0
 8005d80:	d1f8      	bne.n	8005d74 <tcp_segs_free+0x6>
 8005d82:	bd10      	pop	{r4, pc}
 8005d84:	4770      	bx	lr

08005d86 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 8005d86:	b538      	push	{r3, r4, r5, lr}
 8005d88:	4605      	mov	r5, r0
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 8005d8a:	2004      	movs	r0, #4
 8005d8c:	f7ff fc76 	bl	800567c <memp_malloc>
  if (cseg == NULL) {
 8005d90:	4604      	mov	r4, r0
 8005d92:	b150      	cbz	r0, 8005daa <tcp_seg_copy+0x24>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
 8005d94:	6828      	ldr	r0, [r5, #0]
 8005d96:	6869      	ldr	r1, [r5, #4]
 8005d98:	68aa      	ldr	r2, [r5, #8]
 8005d9a:	68eb      	ldr	r3, [r5, #12]
 8005d9c:	6020      	str	r0, [r4, #0]
 8005d9e:	6061      	str	r1, [r4, #4]
 8005da0:	60a2      	str	r2, [r4, #8]
 8005da2:	60e3      	str	r3, [r4, #12]
  pbuf_ref(cseg->p);
 8005da4:	6860      	ldr	r0, [r4, #4]
 8005da6:	f7ff fe93 	bl	8005ad0 <pbuf_ref>
  return cseg;
}
 8005daa:	4620      	mov	r0, r4
 8005dac:	bd38      	pop	{r3, r4, r5, pc}

08005dae <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 8005dae:	b538      	push	{r3, r4, r5, lr}
  if (pcb->state != CLOSED &&
 8005db0:	7e03      	ldrb	r3, [r0, #24]
 8005db2:	2b01      	cmp	r3, #1
 8005db4:	d91a      	bls.n	8005dec <tcp_pcb_purge+0x3e>
 8005db6:	2b0a      	cmp	r3, #10
 8005db8:	d018      	beq.n	8005dec <tcp_pcb_purge+0x3e>
 8005dba:	4604      	mov	r4, r0
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 8005dbc:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8005dbe:	b118      	cbz	r0, 8005dc8 <tcp_pcb_purge+0x1a>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 8005dc0:	f7ff fd89 	bl	80058d6 <pbuf_free>
      pcb->refused_data = NULL;
 8005dc4:	2300      	movs	r3, #0
 8005dc6:	67a3      	str	r3, [r4, #120]	; 0x78
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
 8005dc8:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8005dca:	f7ff ffd0 	bl	8005d6e <tcp_segs_free>
    pcb->ooseq = NULL;
 8005dce:	2500      	movs	r5, #0
 8005dd0:	6765      	str	r5, [r4, #116]	; 0x74
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 8005dd2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005dd6:	86a3      	strh	r3, [r4, #52]	; 0x34

    tcp_segs_free(pcb->unsent);
 8005dd8:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8005dda:	f7ff ffc8 	bl	8005d6e <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 8005dde:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8005de0:	f7ff ffc5 	bl	8005d6e <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 8005de4:	66e5      	str	r5, [r4, #108]	; 0x6c
 8005de6:	6725      	str	r5, [r4, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 8005de8:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
 8005dec:	bd38      	pop	{r3, r4, r5, pc}
	...

08005df0 <tcp_slowtmr>:
{
 8005df0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005df4:	b083      	sub	sp, #12
  ++tcp_ticks;
 8005df6:	4ab6      	ldr	r2, [pc, #728]	; (80060d0 <tcp_slowtmr+0x2e0>)
 8005df8:	6813      	ldr	r3, [r2, #0]
 8005dfa:	3301      	adds	r3, #1
 8005dfc:	6013      	str	r3, [r2, #0]
  ++tcp_timer_ctr;
 8005dfe:	4ab5      	ldr	r2, [pc, #724]	; (80060d4 <tcp_slowtmr+0x2e4>)
 8005e00:	7813      	ldrb	r3, [r2, #0]
 8005e02:	3301      	adds	r3, #1
 8005e04:	7013      	strb	r3, [r2, #0]
    if (pcb->last_timer == tcp_timer_ctr) {
 8005e06:	4615      	mov	r5, r2
        tcp_active_pcbs_changed = 0;
 8005e08:	4fb3      	ldr	r7, [pc, #716]	; (80060d8 <tcp_slowtmr+0x2e8>)
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 8005e0a:	f8df b2e0 	ldr.w	fp, [pc, #736]	; 80060ec <tcp_slowtmr+0x2fc>
  pcb = tcp_active_pcbs;
 8005e0e:	4bb3      	ldr	r3, [pc, #716]	; (80060dc <tcp_slowtmr+0x2ec>)
 8005e10:	681c      	ldr	r4, [r3, #0]
  while (pcb != NULL) {
 8005e12:	2c00      	cmp	r4, #0
 8005e14:	f000 816c 	beq.w	80060f0 <tcp_slowtmr+0x300>
 8005e18:	2600      	movs	r6, #0
 8005e1a:	e003      	b.n	8005e24 <tcp_slowtmr+0x34>
      pcb = pcb->next;
 8005e1c:	68e4      	ldr	r4, [r4, #12]
  while (pcb != NULL) {
 8005e1e:	2c00      	cmp	r4, #0
 8005e20:	f000 8166 	beq.w	80060f0 <tcp_slowtmr+0x300>
    if (pcb->last_timer == tcp_timer_ctr) {
 8005e24:	782b      	ldrb	r3, [r5, #0]
 8005e26:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 8005e2a:	429a      	cmp	r2, r3
 8005e2c:	d0f6      	beq.n	8005e1c <tcp_slowtmr+0x2c>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 8005e2e:	7e22      	ldrb	r2, [r4, #24]
    pcb->last_timer = tcp_timer_ctr;
 8005e30:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 8005e34:	2a02      	cmp	r2, #2
 8005e36:	d024      	beq.n	8005e82 <tcp_slowtmr+0x92>
    else if (pcb->nrtx == TCP_MAXRTX) {
 8005e38:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8005e3c:	2b0c      	cmp	r3, #12
 8005e3e:	d061      	beq.n	8005f04 <tcp_slowtmr+0x114>
      if (pcb->persist_backoff > 0) {
 8005e40:	f894 8095 	ldrb.w	r8, [r4, #149]	; 0x95
 8005e44:	f1b8 0f00 	cmp.w	r8, #0
 8005e48:	d027      	beq.n	8005e9a <tcp_slowtmr+0xaa>
        pcb->persist_cnt++;
 8005e4a:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
 8005e4e:	3301      	adds	r3, #1
 8005e50:	b2db      	uxtb	r3, r3
 8005e52:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 8005e56:	4aa2      	ldr	r2, [pc, #648]	; (80060e0 <tcp_slowtmr+0x2f0>)
 8005e58:	4442      	add	r2, r8
 8005e5a:	f812 2c01 	ldrb.w	r2, [r2, #-1]
 8005e5e:	429a      	cmp	r2, r3
 8005e60:	d873      	bhi.n	8005f4a <tcp_slowtmr+0x15a>
          pcb->persist_cnt = 0;
 8005e62:	2300      	movs	r3, #0
 8005e64:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 8005e68:	f1b8 0f06 	cmp.w	r8, #6
            pcb->persist_backoff++;
 8005e6c:	bf9c      	itt	ls
 8005e6e:	f108 0801 	addls.w	r8, r8, #1
 8005e72:	f884 8095 	strbls.w	r8, [r4, #149]	; 0x95
          tcp_zero_window_probe(pcb);
 8005e76:	4620      	mov	r0, r4
 8005e78:	f002 f9b4 	bl	80081e4 <tcp_zero_window_probe>
    pcb_remove = 0;
 8005e7c:	f04f 0800 	mov.w	r8, #0
 8005e80:	e042      	b.n	8005f08 <tcp_slowtmr+0x118>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 8005e82:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8005e86:	2b06      	cmp	r3, #6
 8005e88:	f000 808f 	beq.w	8005faa <tcp_slowtmr+0x1ba>
    else if (pcb->nrtx == TCP_MAXRTX) {
 8005e8c:	2b0c      	cmp	r3, #12
 8005e8e:	d1d7      	bne.n	8005e40 <tcp_slowtmr+0x50>
    pcb_reset = 0;
 8005e90:	f04f 0900 	mov.w	r9, #0
    else if (pcb->nrtx == TCP_MAXRTX) {
 8005e94:	f04f 0801 	mov.w	r8, #1
 8005e98:	e08e      	b.n	8005fb8 <tcp_slowtmr+0x1c8>
        if(pcb->rtime >= 0) {
 8005e9a:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
 8005e9e:	2900      	cmp	r1, #0
          ++pcb->rtime;
 8005ea0:	bfa4      	itt	ge
 8005ea2:	3101      	addge	r1, #1
 8005ea4:	86a1      	strhge	r1, [r4, #52]	; 0x34
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 8005ea6:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8005ea8:	b371      	cbz	r1, 8005f08 <tcp_slowtmr+0x118>
 8005eaa:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
 8005eae:	f9b4 1044 	ldrsh.w	r1, [r4, #68]	; 0x44
 8005eb2:	4288      	cmp	r0, r1
 8005eb4:	db28      	blt.n	8005f08 <tcp_slowtmr+0x118>
          if (pcb->state != SYN_SENT) {
 8005eb6:	2a02      	cmp	r2, #2
 8005eb8:	d00b      	beq.n	8005ed2 <tcp_slowtmr+0xe2>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 8005eba:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
 8005ebe:	f9b4 2042 	ldrsh.w	r2, [r4, #66]	; 0x42
 8005ec2:	eb02 02e1 	add.w	r2, r2, r1, asr #3
 8005ec6:	4987      	ldr	r1, [pc, #540]	; (80060e4 <tcp_slowtmr+0x2f4>)
 8005ec8:	5ccb      	ldrb	r3, [r1, r3]
 8005eca:	fa02 f303 	lsl.w	r3, r2, r3
 8005ece:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
          pcb->rtime = 0;
 8005ed2:	2300      	movs	r3, #0
 8005ed4:	86a3      	strh	r3, [r4, #52]	; 0x34
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 8005ed6:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 8005eda:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
          pcb->ssthresh = eff_wnd >> 1;
 8005ede:	4293      	cmp	r3, r2
 8005ee0:	bf28      	it	cs
 8005ee2:	4613      	movcs	r3, r2
 8005ee4:	085b      	lsrs	r3, r3, #1
 8005ee6:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
          if (pcb->ssthresh < (pcb->mss << 1)) {
 8005eea:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8005eec:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
            pcb->ssthresh = (pcb->mss << 1);
 8005ef0:	bfbc      	itt	lt
 8005ef2:	0053      	lsllt	r3, r2, #1
 8005ef4:	f8a4 304e 	strhlt.w	r3, [r4, #78]	; 0x4e
          pcb->cwnd = pcb->mss;
 8005ef8:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
          tcp_rexmit_rto(pcb);
 8005efc:	4620      	mov	r0, r4
 8005efe:	f002 f8d3 	bl	80080a8 <tcp_rexmit_rto>
 8005f02:	e001      	b.n	8005f08 <tcp_slowtmr+0x118>
      ++pcb_remove;
 8005f04:	f04f 0801 	mov.w	r8, #1
    if (pcb->state == FIN_WAIT_2) {
 8005f08:	7e23      	ldrb	r3, [r4, #24]
 8005f0a:	2b06      	cmp	r3, #6
 8005f0c:	d020      	beq.n	8005f50 <tcp_slowtmr+0x160>
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
 8005f0e:	7a22      	ldrb	r2, [r4, #8]
 8005f10:	f012 0f08 	tst.w	r2, #8
 8005f14:	d04e      	beq.n	8005fb4 <tcp_slowtmr+0x1c4>
 8005f16:	2b04      	cmp	r3, #4
 8005f18:	d001      	beq.n	8005f1e <tcp_slowtmr+0x12e>
       ((pcb->state == ESTABLISHED) ||
 8005f1a:	2b07      	cmp	r3, #7
 8005f1c:	d17e      	bne.n	800601c <tcp_slowtmr+0x22c>
      if((u32_t)(tcp_ticks - pcb->tmr) >
 8005f1e:	4b6c      	ldr	r3, [pc, #432]	; (80060d0 <tcp_slowtmr+0x2e0>)
 8005f20:	681a      	ldr	r2, [r3, #0]
 8005f22:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005f24:	1ad2      	subs	r2, r2, r3
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 8005f26:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 8005f2a:	f501 2324 	add.w	r3, r1, #671744	; 0xa4000
 8005f2e:	f603 43b8 	addw	r3, r3, #3256	; 0xcb8
 8005f32:	fbab 0303 	umull	r0, r3, fp, r3
      if((u32_t)(tcp_ticks - pcb->tmr) >
 8005f36:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 8005f3a:	d91e      	bls.n	8005f7a <tcp_slowtmr+0x18a>
        ++pcb_remove;
 8005f3c:	f108 0801 	add.w	r8, r8, #1
 8005f40:	fa5f f888 	uxtb.w	r8, r8
        ++pcb_reset;
 8005f44:	f04f 0901 	mov.w	r9, #1
 8005f48:	e036      	b.n	8005fb8 <tcp_slowtmr+0x1c8>
    pcb_remove = 0;
 8005f4a:	f04f 0800 	mov.w	r8, #0
 8005f4e:	e7db      	b.n	8005f08 <tcp_slowtmr+0x118>
      if (pcb->flags & TF_RXCLOSED) {
 8005f50:	7fa3      	ldrb	r3, [r4, #30]
 8005f52:	f013 0f10 	tst.w	r3, #16
 8005f56:	d009      	beq.n	8005f6c <tcp_slowtmr+0x17c>
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 8005f58:	4b5d      	ldr	r3, [pc, #372]	; (80060d0 <tcp_slowtmr+0x2e0>)
 8005f5a:	681b      	ldr	r3, [r3, #0]
 8005f5c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8005f5e:	1a9b      	subs	r3, r3, r2
 8005f60:	2b28      	cmp	r3, #40	; 0x28
 8005f62:	d903      	bls.n	8005f6c <tcp_slowtmr+0x17c>
          ++pcb_remove;
 8005f64:	f108 0801 	add.w	r8, r8, #1
 8005f68:	fa5f f888 	uxtb.w	r8, r8
    if (pcb->ooseq != NULL &&
 8005f6c:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8005f6e:	2800      	cmp	r0, #0
 8005f70:	f000 80e1 	beq.w	8006136 <tcp_slowtmr+0x346>
    pcb_reset = 0;
 8005f74:	f04f 0900 	mov.w	r9, #0
 8005f78:	e020      	b.n	8005fbc <tcp_slowtmr+0x1cc>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 8005f7a:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
 8005f7e:	485a      	ldr	r0, [pc, #360]	; (80060e8 <tcp_slowtmr+0x2f8>)
 8005f80:	fb00 1303 	mla	r3, r0, r3, r1
              / TCP_SLOW_INTERVAL)
 8005f84:	fbab 1303 	umull	r1, r3, fp, r3
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 8005f88:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 8005f8c:	d802      	bhi.n	8005f94 <tcp_slowtmr+0x1a4>
    pcb_reset = 0;
 8005f8e:	f04f 0900 	mov.w	r9, #0
 8005f92:	e011      	b.n	8005fb8 <tcp_slowtmr+0x1c8>
        tcp_keepalive(pcb);
 8005f94:	4620      	mov	r0, r4
 8005f96:	f002 f8f5 	bl	8008184 <tcp_keepalive>
        pcb->keep_cnt_sent++;
 8005f9a:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
 8005f9e:	3301      	adds	r3, #1
 8005fa0:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
    pcb_reset = 0;
 8005fa4:	f04f 0900 	mov.w	r9, #0
 8005fa8:	e006      	b.n	8005fb8 <tcp_slowtmr+0x1c8>
 8005faa:	f04f 0900 	mov.w	r9, #0
 8005fae:	f04f 0801 	mov.w	r8, #1
 8005fb2:	e001      	b.n	8005fb8 <tcp_slowtmr+0x1c8>
 8005fb4:	f04f 0900 	mov.w	r9, #0
    if (pcb->ooseq != NULL &&
 8005fb8:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8005fba:	b150      	cbz	r0, 8005fd2 <tcp_slowtmr+0x1e2>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
 8005fbc:	4b44      	ldr	r3, [pc, #272]	; (80060d0 <tcp_slowtmr+0x2e0>)
 8005fbe:	681a      	ldr	r2, [r3, #0]
 8005fc0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005fc2:	1ad2      	subs	r2, r2, r3
 8005fc4:	f9b4 3044 	ldrsh.w	r3, [r4, #68]	; 0x44
 8005fc8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    if (pcb->ooseq != NULL &&
 8005fcc:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
 8005fd0:	d227      	bcs.n	8006022 <tcp_slowtmr+0x232>
    if (pcb->state == SYN_RCVD) {
 8005fd2:	7e23      	ldrb	r3, [r4, #24]
 8005fd4:	2b03      	cmp	r3, #3
 8005fd6:	d029      	beq.n	800602c <tcp_slowtmr+0x23c>
    if (pcb->state == LAST_ACK) {
 8005fd8:	2b09      	cmp	r3, #9
 8005fda:	d032      	beq.n	8006042 <tcp_slowtmr+0x252>
    if (pcb_remove) {
 8005fdc:	f1b8 0f00 	cmp.w	r8, #0
 8005fe0:	d13a      	bne.n	8006058 <tcp_slowtmr+0x268>
      pcb = pcb->next;
 8005fe2:	f8d4 800c 	ldr.w	r8, [r4, #12]
      ++prev->polltmr;
 8005fe6:	7fe3      	ldrb	r3, [r4, #31]
 8005fe8:	3301      	adds	r3, #1
 8005fea:	b2db      	uxtb	r3, r3
 8005fec:	77e3      	strb	r3, [r4, #31]
      if (prev->polltmr >= prev->pollinterval) {
 8005fee:	f894 2020 	ldrb.w	r2, [r4, #32]
 8005ff2:	429a      	cmp	r2, r3
 8005ff4:	d869      	bhi.n	80060ca <tcp_slowtmr+0x2da>
        prev->polltmr = 0;
 8005ff6:	2300      	movs	r3, #0
 8005ff8:	77e3      	strb	r3, [r4, #31]
        tcp_active_pcbs_changed = 0;
 8005ffa:	703b      	strb	r3, [r7, #0]
        TCP_EVENT_POLL(prev, err);
 8005ffc:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8006000:	2b00      	cmp	r3, #0
 8006002:	d05a      	beq.n	80060ba <tcp_slowtmr+0x2ca>
 8006004:	4621      	mov	r1, r4
 8006006:	6920      	ldr	r0, [r4, #16]
 8006008:	4798      	blx	r3
        if (tcp_active_pcbs_changed) {
 800600a:	783b      	ldrb	r3, [r7, #0]
 800600c:	2b00      	cmp	r3, #0
 800600e:	f47f aefe 	bne.w	8005e0e <tcp_slowtmr+0x1e>
        if (err == ERR_OK) {
 8006012:	2800      	cmp	r0, #0
 8006014:	d051      	beq.n	80060ba <tcp_slowtmr+0x2ca>
 8006016:	4626      	mov	r6, r4
      pcb = pcb->next;
 8006018:	4644      	mov	r4, r8
 800601a:	e700      	b.n	8005e1e <tcp_slowtmr+0x2e>
    pcb_reset = 0;
 800601c:	f04f 0900 	mov.w	r9, #0
 8006020:	e7ca      	b.n	8005fb8 <tcp_slowtmr+0x1c8>
      tcp_segs_free(pcb->ooseq);
 8006022:	f7ff fea4 	bl	8005d6e <tcp_segs_free>
      pcb->ooseq = NULL;
 8006026:	2300      	movs	r3, #0
 8006028:	6763      	str	r3, [r4, #116]	; 0x74
 800602a:	e7d2      	b.n	8005fd2 <tcp_slowtmr+0x1e2>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800602c:	4b28      	ldr	r3, [pc, #160]	; (80060d0 <tcp_slowtmr+0x2e0>)
 800602e:	681b      	ldr	r3, [r3, #0]
 8006030:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8006032:	1a9b      	subs	r3, r3, r2
 8006034:	2b28      	cmp	r3, #40	; 0x28
 8006036:	d9d1      	bls.n	8005fdc <tcp_slowtmr+0x1ec>
        ++pcb_remove;
 8006038:	f108 0801 	add.w	r8, r8, #1
 800603c:	fa5f f888 	uxtb.w	r8, r8
 8006040:	e7cc      	b.n	8005fdc <tcp_slowtmr+0x1ec>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8006042:	4b23      	ldr	r3, [pc, #140]	; (80060d0 <tcp_slowtmr+0x2e0>)
 8006044:	681b      	ldr	r3, [r3, #0]
 8006046:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8006048:	1a9b      	subs	r3, r3, r2
 800604a:	2bf0      	cmp	r3, #240	; 0xf0
        ++pcb_remove;
 800604c:	bf84      	itt	hi
 800604e:	f108 0801 	addhi.w	r8, r8, #1
 8006052:	fa5f f888 	uxtbhi.w	r8, r8
 8006056:	e7c1      	b.n	8005fdc <tcp_slowtmr+0x1ec>
      tcp_pcb_purge(pcb);
 8006058:	4620      	mov	r0, r4
 800605a:	f7ff fea8 	bl	8005dae <tcp_pcb_purge>
      if (prev != NULL) {
 800605e:	b1ee      	cbz	r6, 800609c <tcp_slowtmr+0x2ac>
        prev->next = pcb->next;
 8006060:	68e3      	ldr	r3, [r4, #12]
 8006062:	60f3      	str	r3, [r6, #12]
      if (pcb_reset) {
 8006064:	f1b9 0f00 	cmp.w	r9, #0
 8006068:	d11c      	bne.n	80060a4 <tcp_slowtmr+0x2b4>
      err_fn = pcb->errf;
 800606a:	f8d4 808c 	ldr.w	r8, [r4, #140]	; 0x8c
      err_arg = pcb->callback_arg;
 800606e:	f8d4 a010 	ldr.w	sl, [r4, #16]
      pcb = pcb->next;
 8006072:	f8d4 900c 	ldr.w	r9, [r4, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 8006076:	4621      	mov	r1, r4
 8006078:	2002      	movs	r0, #2
 800607a:	f7ff fb35 	bl	80056e8 <memp_free>
      tcp_active_pcbs_changed = 0;
 800607e:	2300      	movs	r3, #0
 8006080:	703b      	strb	r3, [r7, #0]
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
 8006082:	f1b8 0f00 	cmp.w	r8, #0
 8006086:	d01e      	beq.n	80060c6 <tcp_slowtmr+0x2d6>
 8006088:	f06f 0109 	mvn.w	r1, #9
 800608c:	4650      	mov	r0, sl
 800608e:	47c0      	blx	r8
      if (tcp_active_pcbs_changed) {
 8006090:	783b      	ldrb	r3, [r7, #0]
 8006092:	2b00      	cmp	r3, #0
 8006094:	f47f aebb 	bne.w	8005e0e <tcp_slowtmr+0x1e>
      pcb = pcb->next;
 8006098:	464c      	mov	r4, r9
 800609a:	e6c0      	b.n	8005e1e <tcp_slowtmr+0x2e>
        tcp_active_pcbs = pcb->next;
 800609c:	68e3      	ldr	r3, [r4, #12]
 800609e:	4a0f      	ldr	r2, [pc, #60]	; (80060dc <tcp_slowtmr+0x2ec>)
 80060a0:	6013      	str	r3, [r2, #0]
 80060a2:	e7df      	b.n	8006064 <tcp_slowtmr+0x274>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 80060a4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80060a6:	6d20      	ldr	r0, [r4, #80]	; 0x50
 80060a8:	8ba3      	ldrh	r3, [r4, #28]
 80060aa:	9301      	str	r3, [sp, #4]
 80060ac:	8b63      	ldrh	r3, [r4, #26]
 80060ae:	9300      	str	r3, [sp, #0]
 80060b0:	1d23      	adds	r3, r4, #4
 80060b2:	4622      	mov	r2, r4
 80060b4:	f001 ffa6 	bl	8008004 <tcp_rst>
 80060b8:	e7d7      	b.n	800606a <tcp_slowtmr+0x27a>
          tcp_output(prev);
 80060ba:	4620      	mov	r0, r4
 80060bc:	f001 fe4a 	bl	8007d54 <tcp_output>
 80060c0:	4626      	mov	r6, r4
      pcb = pcb->next;
 80060c2:	4644      	mov	r4, r8
 80060c4:	e6ab      	b.n	8005e1e <tcp_slowtmr+0x2e>
      pcb = pcb->next;
 80060c6:	464c      	mov	r4, r9
 80060c8:	e6a9      	b.n	8005e1e <tcp_slowtmr+0x2e>
 80060ca:	4626      	mov	r6, r4
      pcb = pcb->next;
 80060cc:	4644      	mov	r4, r8
 80060ce:	e6a6      	b.n	8005e1e <tcp_slowtmr+0x2e>
 80060d0:	2000b230 	.word	0x2000b230
 80060d4:	20007785 	.word	0x20007785
 80060d8:	2000b228 	.word	0x2000b228
 80060dc:	2000b22c 	.word	0x2000b22c
 80060e0:	08009288 	.word	0x08009288
 80060e4:	08009278 	.word	0x08009278
 80060e8:	000124f8 	.word	0x000124f8
 80060ec:	10624dd3 	.word	0x10624dd3
  pcb = tcp_tw_pcbs;
 80060f0:	4b14      	ldr	r3, [pc, #80]	; (8006144 <tcp_slowtmr+0x354>)
 80060f2:	681c      	ldr	r4, [r3, #0]
  while (pcb != NULL) {
 80060f4:	b314      	cbz	r4, 800613c <tcp_slowtmr+0x34c>
 80060f6:	2500      	movs	r5, #0
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 80060f8:	4e13      	ldr	r6, [pc, #76]	; (8006148 <tcp_slowtmr+0x358>)
      memp_free(MEMP_TCP_PCB, pcb2);
 80060fa:	2702      	movs	r7, #2
        tcp_tw_pcbs = pcb->next;
 80060fc:	4698      	mov	r8, r3
 80060fe:	e006      	b.n	800610e <tcp_slowtmr+0x31e>
 8006100:	68e3      	ldr	r3, [r4, #12]
 8006102:	f8c8 3000 	str.w	r3, [r8]
 8006106:	e00e      	b.n	8006126 <tcp_slowtmr+0x336>
      pcb = pcb->next;
 8006108:	4625      	mov	r5, r4
 800610a:	68e4      	ldr	r4, [r4, #12]
  while (pcb != NULL) {
 800610c:	b1b4      	cbz	r4, 800613c <tcp_slowtmr+0x34c>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800610e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8006110:	6833      	ldr	r3, [r6, #0]
 8006112:	1a9b      	subs	r3, r3, r2
    if (pcb_remove) {
 8006114:	2bf0      	cmp	r3, #240	; 0xf0
 8006116:	d9f7      	bls.n	8006108 <tcp_slowtmr+0x318>
      tcp_pcb_purge(pcb);
 8006118:	4620      	mov	r0, r4
 800611a:	f7ff fe48 	bl	8005dae <tcp_pcb_purge>
      if (prev != NULL) {
 800611e:	2d00      	cmp	r5, #0
 8006120:	d0ee      	beq.n	8006100 <tcp_slowtmr+0x310>
        prev->next = pcb->next;
 8006122:	68e3      	ldr	r3, [r4, #12]
 8006124:	60eb      	str	r3, [r5, #12]
      pcb = pcb->next;
 8006126:	f8d4 900c 	ldr.w	r9, [r4, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 800612a:	4621      	mov	r1, r4
 800612c:	4638      	mov	r0, r7
 800612e:	f7ff fadb 	bl	80056e8 <memp_free>
      pcb = pcb->next;
 8006132:	464c      	mov	r4, r9
 8006134:	e7ea      	b.n	800610c <tcp_slowtmr+0x31c>
    pcb_reset = 0;
 8006136:	f04f 0900 	mov.w	r9, #0
 800613a:	e74f      	b.n	8005fdc <tcp_slowtmr+0x1ec>
}
 800613c:	b003      	add	sp, #12
 800613e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006142:	bf00      	nop
 8006144:	2000b240 	.word	0x2000b240
 8006148:	2000b230 	.word	0x2000b230

0800614c <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 800614c:	b510      	push	{r4, lr}
 800614e:	460c      	mov	r4, r1
  TCP_RMV(pcblist, pcb);
 8006150:	6802      	ldr	r2, [r0, #0]
 8006152:	428a      	cmp	r2, r1
 8006154:	d00b      	beq.n	800616e <tcp_pcb_remove+0x22>
 8006156:	4b18      	ldr	r3, [pc, #96]	; (80061b8 <tcp_pcb_remove+0x6c>)
 8006158:	601a      	str	r2, [r3, #0]
 800615a:	b17a      	cbz	r2, 800617c <tcp_pcb_remove+0x30>
 800615c:	68d3      	ldr	r3, [r2, #12]
 800615e:	4299      	cmp	r1, r3
 8006160:	d01d      	beq.n	800619e <tcp_pcb_remove+0x52>
 8006162:	b1f3      	cbz	r3, 80061a2 <tcp_pcb_remove+0x56>
 8006164:	68da      	ldr	r2, [r3, #12]
 8006166:	4294      	cmp	r4, r2
 8006168:	d004      	beq.n	8006174 <tcp_pcb_remove+0x28>
 800616a:	4613      	mov	r3, r2
 800616c:	e7f9      	b.n	8006162 <tcp_pcb_remove+0x16>
 800616e:	68d3      	ldr	r3, [r2, #12]
 8006170:	6003      	str	r3, [r0, #0]
 8006172:	e003      	b.n	800617c <tcp_pcb_remove+0x30>
 8006174:	4a10      	ldr	r2, [pc, #64]	; (80061b8 <tcp_pcb_remove+0x6c>)
 8006176:	6013      	str	r3, [r2, #0]
 8006178:	68e2      	ldr	r2, [r4, #12]
 800617a:	60da      	str	r2, [r3, #12]
 800617c:	2300      	movs	r3, #0
 800617e:	60e3      	str	r3, [r4, #12]

  tcp_pcb_purge(pcb);
 8006180:	4620      	mov	r0, r4
 8006182:	f7ff fe14 	bl	8005dae <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 8006186:	7e23      	ldrb	r3, [r4, #24]
 8006188:	2b0a      	cmp	r3, #10
 800618a:	d005      	beq.n	8006198 <tcp_pcb_remove+0x4c>
 800618c:	2b01      	cmp	r3, #1
 800618e:	d003      	beq.n	8006198 <tcp_pcb_remove+0x4c>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 8006190:	7fa3      	ldrb	r3, [r4, #30]
     pcb->state != LISTEN &&
 8006192:	f013 0f01 	tst.w	r3, #1
 8006196:	d108      	bne.n	80061aa <tcp_pcb_remove+0x5e>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 8006198:	2300      	movs	r3, #0
 800619a:	7623      	strb	r3, [r4, #24]
 800619c:	bd10      	pop	{r4, pc}
  TCP_RMV(pcblist, pcb);
 800619e:	4613      	mov	r3, r2
 80061a0:	e7ea      	b.n	8006178 <tcp_pcb_remove+0x2c>
 80061a2:	2200      	movs	r2, #0
 80061a4:	4b04      	ldr	r3, [pc, #16]	; (80061b8 <tcp_pcb_remove+0x6c>)
 80061a6:	601a      	str	r2, [r3, #0]
 80061a8:	e7e8      	b.n	800617c <tcp_pcb_remove+0x30>
    pcb->flags |= TF_ACK_NOW;
 80061aa:	f043 0302 	orr.w	r3, r3, #2
 80061ae:	77a3      	strb	r3, [r4, #30]
    tcp_output(pcb);
 80061b0:	4620      	mov	r0, r4
 80061b2:	f001 fdcf 	bl	8007d54 <tcp_output>
 80061b6:	e7ef      	b.n	8006198 <tcp_pcb_remove+0x4c>
 80061b8:	2000b238 	.word	0x2000b238

080061bc <tcp_close_shutdown>:
{
 80061bc:	b510      	push	{r4, lr}
 80061be:	b082      	sub	sp, #8
 80061c0:	4604      	mov	r4, r0
  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 80061c2:	b121      	cbz	r1, 80061ce <tcp_close_shutdown+0x12>
 80061c4:	7e03      	ldrb	r3, [r0, #24]
 80061c6:	2b04      	cmp	r3, #4
 80061c8:	d00b      	beq.n	80061e2 <tcp_close_shutdown+0x26>
 80061ca:	2b07      	cmp	r3, #7
 80061cc:	d009      	beq.n	80061e2 <tcp_close_shutdown+0x26>
  switch (pcb->state) {
 80061ce:	7e23      	ldrb	r3, [r4, #24]
 80061d0:	2b07      	cmp	r3, #7
 80061d2:	f200 80ae 	bhi.w	8006332 <tcp_close_shutdown+0x176>
 80061d6:	e8df f003 	tbb	[pc, r3]
 80061da:	774e      	.short	0x774e
 80061dc:	ac9a8c80 	.word	0xac9a8c80
 80061e0:	a3ac      	.short	0xa3ac
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 80061e2:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80061e4:	b1e3      	cbz	r3, 8006220 <tcp_close_shutdown+0x64>
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 80061e6:	8ba3      	ldrh	r3, [r4, #28]
 80061e8:	9301      	str	r3, [sp, #4]
 80061ea:	8b63      	ldrh	r3, [r4, #26]
 80061ec:	9300      	str	r3, [sp, #0]
 80061ee:	1d23      	adds	r3, r4, #4
 80061f0:	4622      	mov	r2, r4
 80061f2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80061f4:	6d20      	ldr	r0, [r4, #80]	; 0x50
 80061f6:	f001 ff05 	bl	8008004 <tcp_rst>
      tcp_pcb_purge(pcb);
 80061fa:	4620      	mov	r0, r4
 80061fc:	f7ff fdd7 	bl	8005dae <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8006200:	4b4e      	ldr	r3, [pc, #312]	; (800633c <tcp_close_shutdown+0x180>)
 8006202:	681a      	ldr	r2, [r3, #0]
 8006204:	4294      	cmp	r4, r2
 8006206:	d011      	beq.n	800622c <tcp_close_shutdown+0x70>
 8006208:	4b4d      	ldr	r3, [pc, #308]	; (8006340 <tcp_close_shutdown+0x184>)
 800620a:	601a      	str	r2, [r3, #0]
 800620c:	b1aa      	cbz	r2, 800623a <tcp_close_shutdown+0x7e>
 800620e:	68d3      	ldr	r3, [r2, #12]
 8006210:	429c      	cmp	r4, r3
 8006212:	d020      	beq.n	8006256 <tcp_close_shutdown+0x9a>
 8006214:	b30b      	cbz	r3, 800625a <tcp_close_shutdown+0x9e>
 8006216:	68da      	ldr	r2, [r3, #12]
 8006218:	4294      	cmp	r4, r2
 800621a:	d00a      	beq.n	8006232 <tcp_close_shutdown+0x76>
 800621c:	4613      	mov	r3, r2
 800621e:	e7f9      	b.n	8006214 <tcp_close_shutdown+0x58>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 8006220:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 8006222:	f241 63d0 	movw	r3, #5840	; 0x16d0
 8006226:	429a      	cmp	r2, r3
 8006228:	d1dd      	bne.n	80061e6 <tcp_close_shutdown+0x2a>
 800622a:	e7d0      	b.n	80061ce <tcp_close_shutdown+0x12>
      TCP_RMV_ACTIVE(pcb);
 800622c:	68d2      	ldr	r2, [r2, #12]
 800622e:	601a      	str	r2, [r3, #0]
 8006230:	e003      	b.n	800623a <tcp_close_shutdown+0x7e>
 8006232:	4a43      	ldr	r2, [pc, #268]	; (8006340 <tcp_close_shutdown+0x184>)
 8006234:	6013      	str	r3, [r2, #0]
 8006236:	68e2      	ldr	r2, [r4, #12]
 8006238:	60da      	str	r2, [r3, #12]
 800623a:	2300      	movs	r3, #0
 800623c:	60e3      	str	r3, [r4, #12]
 800623e:	2201      	movs	r2, #1
 8006240:	4b40      	ldr	r3, [pc, #256]	; (8006344 <tcp_close_shutdown+0x188>)
 8006242:	701a      	strb	r2, [r3, #0]
      if (pcb->state == ESTABLISHED) {
 8006244:	7e23      	ldrb	r3, [r4, #24]
 8006246:	2b04      	cmp	r3, #4
 8006248:	d00b      	beq.n	8006262 <tcp_close_shutdown+0xa6>
        memp_free(MEMP_TCP_PCB, pcb);
 800624a:	4621      	mov	r1, r4
 800624c:	2002      	movs	r0, #2
 800624e:	f7ff fa4b 	bl	80056e8 <memp_free>
      return ERR_OK;
 8006252:	2300      	movs	r3, #0
 8006254:	e02f      	b.n	80062b6 <tcp_close_shutdown+0xfa>
      TCP_RMV_ACTIVE(pcb);
 8006256:	4613      	mov	r3, r2
 8006258:	e7ed      	b.n	8006236 <tcp_close_shutdown+0x7a>
 800625a:	2200      	movs	r2, #0
 800625c:	4b38      	ldr	r3, [pc, #224]	; (8006340 <tcp_close_shutdown+0x184>)
 800625e:	601a      	str	r2, [r3, #0]
 8006260:	e7eb      	b.n	800623a <tcp_close_shutdown+0x7e>
        pcb->state = TIME_WAIT;
 8006262:	230a      	movs	r3, #10
 8006264:	7623      	strb	r3, [r4, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 8006266:	4b38      	ldr	r3, [pc, #224]	; (8006348 <tcp_close_shutdown+0x18c>)
 8006268:	681a      	ldr	r2, [r3, #0]
 800626a:	60e2      	str	r2, [r4, #12]
 800626c:	601c      	str	r4, [r3, #0]
 800626e:	f002 f853 	bl	8008318 <tcp_timer_needed>
      return ERR_OK;
 8006272:	2300      	movs	r3, #0
 8006274:	e01f      	b.n	80062b6 <tcp_close_shutdown+0xfa>
    if (pcb->local_port != 0) {
 8006276:	8b63      	ldrh	r3, [r4, #26]
 8006278:	b1c3      	cbz	r3, 80062ac <tcp_close_shutdown+0xf0>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800627a:	4b34      	ldr	r3, [pc, #208]	; (800634c <tcp_close_shutdown+0x190>)
 800627c:	681a      	ldr	r2, [r3, #0]
 800627e:	4294      	cmp	r4, r2
 8006280:	d00b      	beq.n	800629a <tcp_close_shutdown+0xde>
 8006282:	4b2f      	ldr	r3, [pc, #188]	; (8006340 <tcp_close_shutdown+0x184>)
 8006284:	601a      	str	r2, [r3, #0]
 8006286:	b17a      	cbz	r2, 80062a8 <tcp_close_shutdown+0xec>
 8006288:	68d3      	ldr	r3, [r2, #12]
 800628a:	429c      	cmp	r4, r3
 800628c:	d016      	beq.n	80062bc <tcp_close_shutdown+0x100>
 800628e:	b1bb      	cbz	r3, 80062c0 <tcp_close_shutdown+0x104>
 8006290:	68da      	ldr	r2, [r3, #12]
 8006292:	4294      	cmp	r4, r2
 8006294:	d004      	beq.n	80062a0 <tcp_close_shutdown+0xe4>
 8006296:	4613      	mov	r3, r2
 8006298:	e7f9      	b.n	800628e <tcp_close_shutdown+0xd2>
 800629a:	68d2      	ldr	r2, [r2, #12]
 800629c:	601a      	str	r2, [r3, #0]
 800629e:	e003      	b.n	80062a8 <tcp_close_shutdown+0xec>
 80062a0:	4a27      	ldr	r2, [pc, #156]	; (8006340 <tcp_close_shutdown+0x184>)
 80062a2:	6013      	str	r3, [r2, #0]
 80062a4:	68e2      	ldr	r2, [r4, #12]
 80062a6:	60da      	str	r2, [r3, #12]
 80062a8:	2300      	movs	r3, #0
 80062aa:	60e3      	str	r3, [r4, #12]
    memp_free(MEMP_TCP_PCB, pcb);
 80062ac:	4621      	mov	r1, r4
 80062ae:	2002      	movs	r0, #2
 80062b0:	f7ff fa1a 	bl	80056e8 <memp_free>
    err = ERR_OK;
 80062b4:	2300      	movs	r3, #0
}
 80062b6:	4618      	mov	r0, r3
 80062b8:	b002      	add	sp, #8
 80062ba:	bd10      	pop	{r4, pc}
      TCP_RMV(&tcp_bound_pcbs, pcb);
 80062bc:	4613      	mov	r3, r2
 80062be:	e7f1      	b.n	80062a4 <tcp_close_shutdown+0xe8>
 80062c0:	2200      	movs	r2, #0
 80062c2:	4b1f      	ldr	r3, [pc, #124]	; (8006340 <tcp_close_shutdown+0x184>)
 80062c4:	601a      	str	r2, [r3, #0]
 80062c6:	e7ef      	b.n	80062a8 <tcp_close_shutdown+0xec>
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 80062c8:	4621      	mov	r1, r4
 80062ca:	4821      	ldr	r0, [pc, #132]	; (8006350 <tcp_close_shutdown+0x194>)
 80062cc:	f7ff ff3e 	bl	800614c <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 80062d0:	4621      	mov	r1, r4
 80062d2:	2003      	movs	r0, #3
 80062d4:	f7ff fa08 	bl	80056e8 <memp_free>
    break;
 80062d8:	e7ec      	b.n	80062b4 <tcp_close_shutdown+0xf8>
    TCP_PCB_REMOVE_ACTIVE(pcb);
 80062da:	4621      	mov	r1, r4
 80062dc:	4817      	ldr	r0, [pc, #92]	; (800633c <tcp_close_shutdown+0x180>)
 80062de:	f7ff ff35 	bl	800614c <tcp_pcb_remove>
 80062e2:	2201      	movs	r2, #1
 80062e4:	4b17      	ldr	r3, [pc, #92]	; (8006344 <tcp_close_shutdown+0x188>)
 80062e6:	701a      	strb	r2, [r3, #0]
    memp_free(MEMP_TCP_PCB, pcb);
 80062e8:	4621      	mov	r1, r4
 80062ea:	2002      	movs	r0, #2
 80062ec:	f7ff f9fc 	bl	80056e8 <memp_free>
    break;
 80062f0:	e7e0      	b.n	80062b4 <tcp_close_shutdown+0xf8>
    err = tcp_send_fin(pcb);
 80062f2:	4620      	mov	r0, r4
 80062f4:	f001 fcdc 	bl	8007cb0 <tcp_send_fin>
    if (err == ERR_OK) {
 80062f8:	4603      	mov	r3, r0
 80062fa:	2800      	cmp	r0, #0
 80062fc:	d1db      	bne.n	80062b6 <tcp_close_shutdown+0xfa>
      pcb->state = FIN_WAIT_1;
 80062fe:	2305      	movs	r3, #5
 8006300:	7623      	strb	r3, [r4, #24]
  if (pcb != NULL && err == ERR_OK) {
 8006302:	b1c4      	cbz	r4, 8006336 <tcp_close_shutdown+0x17a>
    tcp_output(pcb);
 8006304:	4620      	mov	r0, r4
 8006306:	f001 fd25 	bl	8007d54 <tcp_output>
  return err;
 800630a:	2300      	movs	r3, #0
 800630c:	e7d3      	b.n	80062b6 <tcp_close_shutdown+0xfa>
    err = tcp_send_fin(pcb);
 800630e:	4620      	mov	r0, r4
 8006310:	f001 fcce 	bl	8007cb0 <tcp_send_fin>
    if (err == ERR_OK) {
 8006314:	4603      	mov	r3, r0
 8006316:	2800      	cmp	r0, #0
 8006318:	d1cd      	bne.n	80062b6 <tcp_close_shutdown+0xfa>
      pcb->state = FIN_WAIT_1;
 800631a:	2305      	movs	r3, #5
 800631c:	7623      	strb	r3, [r4, #24]
 800631e:	e7f0      	b.n	8006302 <tcp_close_shutdown+0x146>
    err = tcp_send_fin(pcb);
 8006320:	4620      	mov	r0, r4
 8006322:	f001 fcc5 	bl	8007cb0 <tcp_send_fin>
    if (err == ERR_OK) {
 8006326:	4603      	mov	r3, r0
 8006328:	2800      	cmp	r0, #0
 800632a:	d1c4      	bne.n	80062b6 <tcp_close_shutdown+0xfa>
      pcb->state = LAST_ACK;
 800632c:	2309      	movs	r3, #9
 800632e:	7623      	strb	r3, [r4, #24]
 8006330:	e7e7      	b.n	8006302 <tcp_close_shutdown+0x146>
    err = ERR_OK;
 8006332:	2300      	movs	r3, #0
 8006334:	e7bf      	b.n	80062b6 <tcp_close_shutdown+0xfa>
  if (pcb != NULL && err == ERR_OK) {
 8006336:	2300      	movs	r3, #0
 8006338:	e7bd      	b.n	80062b6 <tcp_close_shutdown+0xfa>
 800633a:	bf00      	nop
 800633c:	2000b22c 	.word	0x2000b22c
 8006340:	2000b238 	.word	0x2000b238
 8006344:	2000b228 	.word	0x2000b228
 8006348:	2000b240 	.word	0x2000b240
 800634c:	2000b23c 	.word	0x2000b23c
 8006350:	2000b234 	.word	0x2000b234

08006354 <tcp_close>:
{
 8006354:	b508      	push	{r3, lr}
  if (pcb->state != LISTEN) {
 8006356:	7e03      	ldrb	r3, [r0, #24]
 8006358:	2b01      	cmp	r3, #1
 800635a:	d003      	beq.n	8006364 <tcp_close+0x10>
    pcb->flags |= TF_RXCLOSED;
 800635c:	7f83      	ldrb	r3, [r0, #30]
 800635e:	f043 0310 	orr.w	r3, r3, #16
 8006362:	7783      	strb	r3, [r0, #30]
  return tcp_close_shutdown(pcb, 1);
 8006364:	2101      	movs	r1, #1
 8006366:	f7ff ff29 	bl	80061bc <tcp_close_shutdown>
}
 800636a:	bd08      	pop	{r3, pc}

0800636c <tcp_recv_null>:
{
 800636c:	b510      	push	{r4, lr}
 800636e:	4608      	mov	r0, r1
  if (p != NULL) {
 8006370:	b142      	cbz	r2, 8006384 <tcp_recv_null+0x18>
 8006372:	4614      	mov	r4, r2
    tcp_recved(pcb, p->tot_len);
 8006374:	8911      	ldrh	r1, [r2, #8]
 8006376:	f7ff fcd1 	bl	8005d1c <tcp_recved>
    pbuf_free(p);
 800637a:	4620      	mov	r0, r4
 800637c:	f7ff faab 	bl	80058d6 <pbuf_free>
  return ERR_OK;
 8006380:	2000      	movs	r0, #0
 8006382:	bd10      	pop	{r4, pc}
  } else if (err == ERR_OK) {
 8006384:	b10b      	cbz	r3, 800638a <tcp_recv_null+0x1e>
  return ERR_OK;
 8006386:	2000      	movs	r0, #0
}
 8006388:	bd10      	pop	{r4, pc}
    return tcp_close(pcb);
 800638a:	f7ff ffe3 	bl	8006354 <tcp_close>
 800638e:	bd10      	pop	{r4, pc}

08006390 <tcp_process_refused_data>:
{
 8006390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006392:	4604      	mov	r4, r0
  u8_t refused_flags = pcb->refused_data->flags;
 8006394:	6f86      	ldr	r6, [r0, #120]	; 0x78
 8006396:	7b77      	ldrb	r7, [r6, #13]
  pcb->refused_data = NULL;
 8006398:	2300      	movs	r3, #0
 800639a:	6783      	str	r3, [r0, #120]	; 0x78
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800639c:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
 80063a0:	b1e5      	cbz	r5, 80063dc <tcp_process_refused_data+0x4c>
 80063a2:	4632      	mov	r2, r6
 80063a4:	4601      	mov	r1, r0
 80063a6:	6900      	ldr	r0, [r0, #16]
 80063a8:	47a8      	blx	r5
 80063aa:	4605      	mov	r5, r0
  if (err == ERR_OK) {
 80063ac:	b9f5      	cbnz	r5, 80063ec <tcp_process_refused_data+0x5c>
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
 80063ae:	f017 0f20 	tst.w	r7, #32
 80063b2:	d020      	beq.n	80063f6 <tcp_process_refused_data+0x66>
      if (pcb->rcv_wnd != TCP_WND) {
 80063b4:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 80063b6:	f241 62d0 	movw	r2, #5840	; 0x16d0
 80063ba:	4293      	cmp	r3, r2
        pcb->rcv_wnd++;
 80063bc:	bf1c      	itt	ne
 80063be:	3301      	addne	r3, #1
 80063c0:	85a3      	strhne	r3, [r4, #44]	; 0x2c
      TCP_EVENT_CLOSED(pcb, err);
 80063c2:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
 80063c6:	b1b6      	cbz	r6, 80063f6 <tcp_process_refused_data+0x66>
 80063c8:	2300      	movs	r3, #0
 80063ca:	461a      	mov	r2, r3
 80063cc:	4621      	mov	r1, r4
 80063ce:	6920      	ldr	r0, [r4, #16]
 80063d0:	47b0      	blx	r6
        return ERR_ABRT;
 80063d2:	f110 0f0a 	cmn.w	r0, #10
 80063d6:	bf08      	it	eq
 80063d8:	4605      	moveq	r5, r0
 80063da:	e00c      	b.n	80063f6 <tcp_process_refused_data+0x66>
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 80063dc:	2300      	movs	r3, #0
 80063de:	4632      	mov	r2, r6
 80063e0:	4601      	mov	r1, r0
 80063e2:	4618      	mov	r0, r3
 80063e4:	f7ff ffc2 	bl	800636c <tcp_recv_null>
 80063e8:	4605      	mov	r5, r0
 80063ea:	e7df      	b.n	80063ac <tcp_process_refused_data+0x1c>
  } else if (err == ERR_ABRT) {
 80063ec:	f115 0f0a 	cmn.w	r5, #10
    pcb->refused_data = refused_data;
 80063f0:	bf1c      	itt	ne
 80063f2:	67a6      	strne	r6, [r4, #120]	; 0x78
  return ERR_OK;
 80063f4:	2500      	movne	r5, #0
}
 80063f6:	4628      	mov	r0, r5
 80063f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080063fc <tcp_fasttmr>:
{
 80063fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  ++tcp_timer_ctr;
 8006400:	4a18      	ldr	r2, [pc, #96]	; (8006464 <tcp_fasttmr+0x68>)
 8006402:	7813      	ldrb	r3, [r2, #0]
 8006404:	3301      	adds	r3, #1
 8006406:	7013      	strb	r3, [r2, #0]
  pcb = tcp_active_pcbs;
 8006408:	4f17      	ldr	r7, [pc, #92]	; (8006468 <tcp_fasttmr+0x6c>)
    if (pcb->last_timer != tcp_timer_ctr) {
 800640a:	4615      	mov	r5, r2
        tcp_active_pcbs_changed = 0;
 800640c:	4e17      	ldr	r6, [pc, #92]	; (800646c <tcp_fasttmr+0x70>)
 800640e:	f04f 0800 	mov.w	r8, #0
  pcb = tcp_active_pcbs;
 8006412:	683c      	ldr	r4, [r7, #0]
  while(pcb != NULL) {
 8006414:	b324      	cbz	r4, 8006460 <tcp_fasttmr+0x64>
    if (pcb->last_timer != tcp_timer_ctr) {
 8006416:	782b      	ldrb	r3, [r5, #0]
 8006418:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 800641c:	429a      	cmp	r2, r3
 800641e:	d100      	bne.n	8006422 <tcp_fasttmr+0x26>
 8006420:	e7fe      	b.n	8006420 <tcp_fasttmr+0x24>
      pcb->last_timer = tcp_timer_ctr;
 8006422:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
      if (pcb->flags & TF_ACK_DELAY) {
 8006426:	7fa3      	ldrb	r3, [r4, #30]
 8006428:	f013 0f01 	tst.w	r3, #1
 800642c:	d10d      	bne.n	800644a <tcp_fasttmr+0x4e>
      next = pcb->next;
 800642e:	f8d4 900c 	ldr.w	r9, [r4, #12]
      if (pcb->refused_data != NULL) {
 8006432:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8006434:	b13b      	cbz	r3, 8006446 <tcp_fasttmr+0x4a>
        tcp_active_pcbs_changed = 0;
 8006436:	f886 8000 	strb.w	r8, [r6]
        tcp_process_refused_data(pcb);
 800643a:	4620      	mov	r0, r4
 800643c:	f7ff ffa8 	bl	8006390 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 8006440:	7833      	ldrb	r3, [r6, #0]
 8006442:	2b00      	cmp	r3, #0
 8006444:	d1e5      	bne.n	8006412 <tcp_fasttmr+0x16>
{
 8006446:	464c      	mov	r4, r9
 8006448:	e7e4      	b.n	8006414 <tcp_fasttmr+0x18>
        tcp_ack_now(pcb);
 800644a:	f043 0302 	orr.w	r3, r3, #2
 800644e:	77a3      	strb	r3, [r4, #30]
        tcp_output(pcb);
 8006450:	4620      	mov	r0, r4
 8006452:	f001 fc7f 	bl	8007d54 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8006456:	7fa3      	ldrb	r3, [r4, #30]
 8006458:	f023 0303 	bic.w	r3, r3, #3
 800645c:	77a3      	strb	r3, [r4, #30]
 800645e:	e7e6      	b.n	800642e <tcp_fasttmr+0x32>
 8006460:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006464:	20007785 	.word	0x20007785
 8006468:	2000b22c 	.word	0x2000b22c
 800646c:	2000b228 	.word	0x2000b228

08006470 <tcp_tmr>:
{
 8006470:	b508      	push	{r3, lr}
  tcp_fasttmr();
 8006472:	f7ff ffc3 	bl	80063fc <tcp_fasttmr>
  if (++tcp_timer & 1) {
 8006476:	4a06      	ldr	r2, [pc, #24]	; (8006490 <tcp_tmr+0x20>)
 8006478:	7813      	ldrb	r3, [r2, #0]
 800647a:	3301      	adds	r3, #1
 800647c:	b2db      	uxtb	r3, r3
 800647e:	7013      	strb	r3, [r2, #0]
 8006480:	f013 0f01 	tst.w	r3, #1
 8006484:	d100      	bne.n	8006488 <tcp_tmr+0x18>
 8006486:	bd08      	pop	{r3, pc}
    tcp_slowtmr();
 8006488:	f7ff fcb2 	bl	8005df0 <tcp_slowtmr>
}
 800648c:	e7fb      	b.n	8006486 <tcp_tmr+0x16>
 800648e:	bf00      	nop
 8006490:	20007784 	.word	0x20007784

08006494 <tcp_abandon>:
{
 8006494:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006498:	b083      	sub	sp, #12
 800649a:	4604      	mov	r4, r0
  if (pcb->state == TIME_WAIT) {
 800649c:	7e03      	ldrb	r3, [r0, #24]
 800649e:	2b0a      	cmp	r3, #10
 80064a0:	d027      	beq.n	80064f2 <tcp_abandon+0x5e>
 80064a2:	460e      	mov	r6, r1
    seqno = pcb->snd_nxt;
 80064a4:	f8d0 8050 	ldr.w	r8, [r0, #80]	; 0x50
    ackno = pcb->rcv_nxt;
 80064a8:	f8d0 9028 	ldr.w	r9, [r0, #40]	; 0x28
    errf = pcb->errf;
 80064ac:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
    errf_arg = pcb->callback_arg;
 80064b0:	6907      	ldr	r7, [r0, #16]
    TCP_PCB_REMOVE_ACTIVE(pcb);
 80064b2:	4601      	mov	r1, r0
 80064b4:	4819      	ldr	r0, [pc, #100]	; (800651c <tcp_abandon+0x88>)
 80064b6:	f7ff fe49 	bl	800614c <tcp_pcb_remove>
 80064ba:	2201      	movs	r2, #1
 80064bc:	4b18      	ldr	r3, [pc, #96]	; (8006520 <tcp_abandon+0x8c>)
 80064be:	701a      	strb	r2, [r3, #0]
    if (pcb->unacked != NULL) {
 80064c0:	6f20      	ldr	r0, [r4, #112]	; 0x70
 80064c2:	b108      	cbz	r0, 80064c8 <tcp_abandon+0x34>
      tcp_segs_free(pcb->unacked);
 80064c4:	f7ff fc53 	bl	8005d6e <tcp_segs_free>
    if (pcb->unsent != NULL) {
 80064c8:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80064ca:	b108      	cbz	r0, 80064d0 <tcp_abandon+0x3c>
      tcp_segs_free(pcb->unsent);
 80064cc:	f7ff fc4f 	bl	8005d6e <tcp_segs_free>
    if (pcb->ooseq != NULL) {
 80064d0:	6f60      	ldr	r0, [r4, #116]	; 0x74
 80064d2:	b108      	cbz	r0, 80064d8 <tcp_abandon+0x44>
      tcp_segs_free(pcb->ooseq);
 80064d4:	f7ff fc4b 	bl	8005d6e <tcp_segs_free>
    if (reset) {
 80064d8:	b9a6      	cbnz	r6, 8006504 <tcp_abandon+0x70>
    memp_free(MEMP_TCP_PCB, pcb);
 80064da:	4621      	mov	r1, r4
 80064dc:	2002      	movs	r0, #2
 80064de:	f7ff f903 	bl	80056e8 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 80064e2:	b11d      	cbz	r5, 80064ec <tcp_abandon+0x58>
 80064e4:	f06f 0109 	mvn.w	r1, #9
 80064e8:	4638      	mov	r0, r7
 80064ea:	47a8      	blx	r5
}
 80064ec:	b003      	add	sp, #12
 80064ee:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 80064f2:	4601      	mov	r1, r0
 80064f4:	480b      	ldr	r0, [pc, #44]	; (8006524 <tcp_abandon+0x90>)
 80064f6:	f7ff fe29 	bl	800614c <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 80064fa:	4621      	mov	r1, r4
 80064fc:	2002      	movs	r0, #2
 80064fe:	f7ff f8f3 	bl	80056e8 <memp_free>
 8006502:	e7f3      	b.n	80064ec <tcp_abandon+0x58>
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
 8006504:	8ba3      	ldrh	r3, [r4, #28]
 8006506:	9301      	str	r3, [sp, #4]
 8006508:	8b63      	ldrh	r3, [r4, #26]
 800650a:	9300      	str	r3, [sp, #0]
 800650c:	1d23      	adds	r3, r4, #4
 800650e:	4622      	mov	r2, r4
 8006510:	4649      	mov	r1, r9
 8006512:	4640      	mov	r0, r8
 8006514:	f001 fd76 	bl	8008004 <tcp_rst>
 8006518:	e7df      	b.n	80064da <tcp_abandon+0x46>
 800651a:	bf00      	nop
 800651c:	2000b22c 	.word	0x2000b22c
 8006520:	2000b228 	.word	0x2000b228
 8006524:	2000b240 	.word	0x2000b240

08006528 <tcp_abort>:
{
 8006528:	b508      	push	{r3, lr}
  tcp_abandon(pcb, 1);
 800652a:	2101      	movs	r1, #1
 800652c:	f7ff ffb2 	bl	8006494 <tcp_abandon>
 8006530:	bd08      	pop	{r3, pc}
	...

08006534 <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 8006534:	4b03      	ldr	r3, [pc, #12]	; (8006544 <tcp_next_iss+0x10>)
 8006536:	6818      	ldr	r0, [r3, #0]
 8006538:	4a03      	ldr	r2, [pc, #12]	; (8006548 <tcp_next_iss+0x14>)
 800653a:	6812      	ldr	r2, [r2, #0]
 800653c:	4410      	add	r0, r2
 800653e:	6018      	str	r0, [r3, #0]
  return iss;
}
 8006540:	4770      	bx	lr
 8006542:	bf00      	nop
 8006544:	2000014c 	.word	0x2000014c
 8006548:	2000b230 	.word	0x2000b230

0800654c <tcp_alloc>:
{
 800654c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800654e:	4605      	mov	r5, r0
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8006550:	2002      	movs	r0, #2
 8006552:	f7ff f893 	bl	800567c <memp_malloc>
  if (pcb == NULL) {
 8006556:	4604      	mov	r4, r0
 8006558:	2800      	cmp	r0, #0
 800655a:	d03b      	beq.n	80065d4 <tcp_alloc+0x88>
    memset(pcb, 0, sizeof(struct tcp_pcb));
 800655c:	2298      	movs	r2, #152	; 0x98
 800655e:	2100      	movs	r1, #0
 8006560:	4620      	mov	r0, r4
 8006562:	f002 fdcf 	bl	8009104 <memset>
    pcb->prio = prio;
 8006566:	7665      	strb	r5, [r4, #25]
    pcb->snd_buf = TCP_SND_BUF;
 8006568:	f640 3368 	movw	r3, #2920	; 0xb68
 800656c:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
    pcb->snd_queuelen = 0;
 8006570:	2500      	movs	r5, #0
 8006572:	f8a4 5068 	strh.w	r5, [r4, #104]	; 0x68
    pcb->rcv_wnd = TCP_WND;
 8006576:	f241 63d0 	movw	r3, #5840	; 0x16d0
 800657a:	85a3      	strh	r3, [r4, #44]	; 0x2c
    pcb->rcv_ann_wnd = TCP_WND;
 800657c:	85e3      	strh	r3, [r4, #46]	; 0x2e
    pcb->tos = 0;
 800657e:	7265      	strb	r5, [r4, #9]
    pcb->ttl = TCP_TTL;
 8006580:	23ff      	movs	r3, #255	; 0xff
 8006582:	72a3      	strb	r3, [r4, #10]
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 8006584:	f44f 7306 	mov.w	r3, #536	; 0x218
 8006588:	86e3      	strh	r3, [r4, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 800658a:	2306      	movs	r3, #6
 800658c:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
    pcb->sa = 0;
 8006590:	f8a4 5040 	strh.w	r5, [r4, #64]	; 0x40
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 8006594:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
    pcb->rtime = -1;
 8006598:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800659c:	86a3      	strh	r3, [r4, #52]	; 0x34
    pcb->cwnd = 1;
 800659e:	2301      	movs	r3, #1
 80065a0:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    iss = tcp_next_iss();
 80065a4:	f7ff ffc6 	bl	8006534 <tcp_next_iss>
    pcb->snd_wl2 = iss;
 80065a8:	65a0      	str	r0, [r4, #88]	; 0x58
    pcb->snd_nxt = iss;
 80065aa:	6520      	str	r0, [r4, #80]	; 0x50
    pcb->lastack = iss;
 80065ac:	64a0      	str	r0, [r4, #72]	; 0x48
    pcb->snd_lbb = iss;   
 80065ae:	65e0      	str	r0, [r4, #92]	; 0x5c
    pcb->tmr = tcp_ticks;
 80065b0:	4b2c      	ldr	r3, [pc, #176]	; (8006664 <tcp_alloc+0x118>)
 80065b2:	681b      	ldr	r3, [r3, #0]
 80065b4:	6263      	str	r3, [r4, #36]	; 0x24
    pcb->last_timer = tcp_timer_ctr;
 80065b6:	4b2c      	ldr	r3, [pc, #176]	; (8006668 <tcp_alloc+0x11c>)
 80065b8:	781b      	ldrb	r3, [r3, #0]
 80065ba:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    pcb->polltmr = 0;
 80065be:	77e5      	strb	r5, [r4, #31]
    pcb->recv = tcp_recv_null;
 80065c0:	4b2a      	ldr	r3, [pc, #168]	; (800666c <tcp_alloc+0x120>)
 80065c2:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 80065c6:	4b2a      	ldr	r3, [pc, #168]	; (8006670 <tcp_alloc+0x124>)
 80065c8:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    pcb->keep_cnt_sent = 0;
 80065cc:	f884 5096 	strb.w	r5, [r4, #150]	; 0x96
}
 80065d0:	4620      	mov	r0, r4
 80065d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80065d4:	4b27      	ldr	r3, [pc, #156]	; (8006674 <tcp_alloc+0x128>)
 80065d6:	681b      	ldr	r3, [r3, #0]
 80065d8:	b17b      	cbz	r3, 80065fa <tcp_alloc+0xae>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80065da:	4a22      	ldr	r2, [pc, #136]	; (8006664 <tcp_alloc+0x118>)
 80065dc:	6810      	ldr	r0, [r2, #0]
 80065de:	2100      	movs	r1, #0
 80065e0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80065e2:	1a82      	subs	r2, r0, r2
 80065e4:	428a      	cmp	r2, r1
      inactivity = tcp_ticks - pcb->tmr;
 80065e6:	bf24      	itt	cs
 80065e8:	4611      	movcs	r1, r2
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80065ea:	461c      	movcs	r4, r3
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80065ec:	68db      	ldr	r3, [r3, #12]
 80065ee:	2b00      	cmp	r3, #0
 80065f0:	d1f6      	bne.n	80065e0 <tcp_alloc+0x94>
  if (inactive != NULL) {
 80065f2:	b114      	cbz	r4, 80065fa <tcp_alloc+0xae>
    tcp_abort(inactive);
 80065f4:	4620      	mov	r0, r4
 80065f6:	f7ff ff97 	bl	8006528 <tcp_abort>
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 80065fa:	2002      	movs	r0, #2
 80065fc:	f7ff f83e 	bl	800567c <memp_malloc>
    if (pcb == NULL) {
 8006600:	4604      	mov	r4, r0
 8006602:	b130      	cbz	r0, 8006612 <tcp_alloc+0xc6>
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 8006604:	4a1c      	ldr	r2, [pc, #112]	; (8006678 <tcp_alloc+0x12c>)
 8006606:	f8b2 30cc 	ldrh.w	r3, [r2, #204]	; 0xcc
 800660a:	3b01      	subs	r3, #1
 800660c:	f8a2 30cc 	strh.w	r3, [r2, #204]	; 0xcc
 8006610:	e7a4      	b.n	800655c <tcp_alloc+0x10>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8006612:	4b1a      	ldr	r3, [pc, #104]	; (800667c <tcp_alloc+0x130>)
 8006614:	681b      	ldr	r3, [r3, #0]
 8006616:	b1bb      	cbz	r3, 8006648 <tcp_alloc+0xfc>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8006618:	4a12      	ldr	r2, [pc, #72]	; (8006664 <tcp_alloc+0x118>)
 800661a:	6817      	ldr	r7, [r2, #0]
 800661c:	2600      	movs	r6, #0
 800661e:	207f      	movs	r0, #127	; 0x7f
 8006620:	e001      	b.n	8006626 <tcp_alloc+0xda>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8006622:	68db      	ldr	r3, [r3, #12]
 8006624:	b163      	cbz	r3, 8006640 <tcp_alloc+0xf4>
    if (pcb->prio <= prio &&
 8006626:	7e5a      	ldrb	r2, [r3, #25]
 8006628:	4295      	cmp	r5, r2
 800662a:	d3fa      	bcc.n	8006622 <tcp_alloc+0xd6>
 800662c:	4282      	cmp	r2, r0
 800662e:	d8f8      	bhi.n	8006622 <tcp_alloc+0xd6>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8006630:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8006632:	1a79      	subs	r1, r7, r1
       pcb->prio <= mprio &&
 8006634:	42b1      	cmp	r1, r6
 8006636:	d3f4      	bcc.n	8006622 <tcp_alloc+0xd6>
      mprio = pcb->prio;
 8006638:	4610      	mov	r0, r2
      inactivity = tcp_ticks - pcb->tmr;
 800663a:	460e      	mov	r6, r1
       pcb->prio <= mprio &&
 800663c:	461c      	mov	r4, r3
 800663e:	e7f0      	b.n	8006622 <tcp_alloc+0xd6>
  if (inactive != NULL) {
 8006640:	b114      	cbz	r4, 8006648 <tcp_alloc+0xfc>
    tcp_abort(inactive);
 8006642:	4620      	mov	r0, r4
 8006644:	f7ff ff70 	bl	8006528 <tcp_abort>
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8006648:	2002      	movs	r0, #2
 800664a:	f7ff f817 	bl	800567c <memp_malloc>
      if (pcb != NULL) {
 800664e:	4604      	mov	r4, r0
 8006650:	2800      	cmp	r0, #0
 8006652:	d0bd      	beq.n	80065d0 <tcp_alloc+0x84>
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 8006654:	4a08      	ldr	r2, [pc, #32]	; (8006678 <tcp_alloc+0x12c>)
 8006656:	f8b2 30cc 	ldrh.w	r3, [r2, #204]	; 0xcc
 800665a:	3b01      	subs	r3, #1
 800665c:	f8a2 30cc 	strh.w	r3, [r2, #204]	; 0xcc
 8006660:	e7d0      	b.n	8006604 <tcp_alloc+0xb8>
 8006662:	bf00      	nop
 8006664:	2000b230 	.word	0x2000b230
 8006668:	20007785 	.word	0x20007785
 800666c:	0800636d 	.word	0x0800636d
 8006670:	006ddd00 	.word	0x006ddd00
 8006674:	2000b240 	.word	0x2000b240
 8006678:	2000b110 	.word	0x2000b110
 800667c:	2000b22c 	.word	0x2000b22c

08006680 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
 8006680:	b510      	push	{r4, lr}
 8006682:	4604      	mov	r4, r0
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
 8006684:	4608      	mov	r0, r1
 8006686:	f7fe f8bb 	bl	8004800 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
 800668a:	b138      	cbz	r0, 800669c <tcp_eff_send_mss+0x1c>
 800668c:	8c00      	ldrh	r0, [r0, #32]
 800668e:	b138      	cbz	r0, 80066a0 <tcp_eff_send_mss+0x20>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
 8006690:	3828      	subs	r0, #40	; 0x28
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 8006692:	b280      	uxth	r0, r0
 8006694:	42a0      	cmp	r0, r4
 8006696:	bf28      	it	cs
 8006698:	4620      	movcs	r0, r4
 800669a:	bd10      	pop	{r4, pc}
 800669c:	4620      	mov	r0, r4
 800669e:	bd10      	pop	{r4, pc}
 80066a0:	4620      	mov	r0, r4
  }
  return sendmss;
}
 80066a2:	bd10      	pop	{r4, pc}

080066a4 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 80066a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80066a6:	4605      	mov	r5, r0
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 80066a8:	4b22      	ldr	r3, [pc, #136]	; (8006734 <tcp_parseopt+0x90>)
 80066aa:	681c      	ldr	r4, [r3, #0]

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
 80066ac:	89a0      	ldrh	r0, [r4, #12]
 80066ae:	f7fd fe9c 	bl	80043ea <lwip_ntohs>
 80066b2:	f3c0 300f 	ubfx	r0, r0, #12, #16
 80066b6:	2805      	cmp	r0, #5
 80066b8:	d800      	bhi.n	80066bc <tcp_parseopt+0x18>
 80066ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 80066bc:	4b1d      	ldr	r3, [pc, #116]	; (8006734 <tcp_parseopt+0x90>)
 80066be:	681b      	ldr	r3, [r3, #0]
 80066c0:	8998      	ldrh	r0, [r3, #12]
 80066c2:	f7fd fe92 	bl	80043ea <lwip_ntohs>
 80066c6:	0b06      	lsrs	r6, r0, #12
 80066c8:	3e05      	subs	r6, #5
 80066ca:	00b6      	lsls	r6, r6, #2
 80066cc:	b2b6      	uxth	r6, r6
    for (c = 0; c < max_c; ) {
 80066ce:	2e00      	cmp	r6, #0
 80066d0:	d0f3      	beq.n	80066ba <tcp_parseopt+0x16>
  opts = (u8_t *)tcphdr + TCP_HLEN;
 80066d2:	f104 0214 	add.w	r2, r4, #20
 80066d6:	2300      	movs	r3, #0
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 80066d8:	f240 57b3 	movw	r7, #1459	; 0x5b3
 80066dc:	f240 54b4 	movw	r4, #1460	; 0x5b4
 80066e0:	e003      	b.n	80066ea <tcp_parseopt+0x46>
        ++c;
 80066e2:	3301      	adds	r3, #1
 80066e4:	b29b      	uxth	r3, r3
    for (c = 0; c < max_c; ) {
 80066e6:	429e      	cmp	r6, r3
 80066e8:	d9e7      	bls.n	80066ba <tcp_parseopt+0x16>
      opt = opts[c];
 80066ea:	4618      	mov	r0, r3
      switch (opt) {
 80066ec:	5cd1      	ldrb	r1, [r2, r3]
 80066ee:	2901      	cmp	r1, #1
 80066f0:	d0f7      	beq.n	80066e2 <tcp_parseopt+0x3e>
 80066f2:	2900      	cmp	r1, #0
 80066f4:	d0e1      	beq.n	80066ba <tcp_parseopt+0x16>
 80066f6:	2902      	cmp	r1, #2
 80066f8:	d006      	beq.n	8006708 <tcp_parseopt+0x64>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
 80066fa:	4410      	add	r0, r2
 80066fc:	7841      	ldrb	r1, [r0, #1]
 80066fe:	2900      	cmp	r1, #0
 8006700:	d0db      	beq.n	80066ba <tcp_parseopt+0x16>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
 8006702:	440b      	add	r3, r1
 8006704:	b29b      	uxth	r3, r3
 8006706:	e7ee      	b.n	80066e6 <tcp_parseopt+0x42>
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
 8006708:	18d1      	adds	r1, r2, r3
 800670a:	7849      	ldrb	r1, [r1, #1]
 800670c:	2904      	cmp	r1, #4
 800670e:	d1d4      	bne.n	80066ba <tcp_parseopt+0x16>
 8006710:	1d19      	adds	r1, r3, #4
 8006712:	42b1      	cmp	r1, r6
 8006714:	dcd1      	bgt.n	80066ba <tcp_parseopt+0x16>
        mss = (opts[c + 2] << 8) | opts[c + 3];
 8006716:	4410      	add	r0, r2
 8006718:	f890 e002 	ldrb.w	lr, [r0, #2]
 800671c:	78c1      	ldrb	r1, [r0, #3]
 800671e:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 8006722:	1e48      	subs	r0, r1, #1
 8006724:	b280      	uxth	r0, r0
 8006726:	42b8      	cmp	r0, r7
 8006728:	bf88      	it	hi
 800672a:	4621      	movhi	r1, r4
 800672c:	86e9      	strh	r1, [r5, #54]	; 0x36
        c += 0x04;
 800672e:	3304      	adds	r3, #4
 8006730:	b29b      	uxth	r3, r3
        break;
 8006732:	e7d8      	b.n	80066e6 <tcp_parseopt+0x42>
 8006734:	200077ac 	.word	0x200077ac

08006738 <tcp_oos_insert_segment>:
{
 8006738:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800673c:	4605      	mov	r5, r0
 800673e:	4688      	mov	r8, r1
  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 8006740:	68c3      	ldr	r3, [r0, #12]
 8006742:	8998      	ldrh	r0, [r3, #12]
 8006744:	f7fd fe51 	bl	80043ea <lwip_ntohs>
 8006748:	f010 0f01 	tst.w	r0, #1
 800674c:	d114      	bne.n	8006778 <tcp_oos_insert_segment+0x40>
    while (next &&
 800674e:	f1b8 0f00 	cmp.w	r8, #0
 8006752:	d04a      	beq.n	80067ea <tcp_oos_insert_segment+0xb2>
           TCP_SEQ_GEQ((seqno + cseg->len),
 8006754:	f8d8 200c 	ldr.w	r2, [r8, #12]
 8006758:	892b      	ldrh	r3, [r5, #8]
 800675a:	6851      	ldr	r1, [r2, #4]
 800675c:	1a5b      	subs	r3, r3, r1
 800675e:	4924      	ldr	r1, [pc, #144]	; (80067f0 <tcp_oos_insert_segment+0xb8>)
 8006760:	6809      	ldr	r1, [r1, #0]
 8006762:	440b      	add	r3, r1
 8006764:	f8b8 1008 	ldrh.w	r1, [r8, #8]
 8006768:	1a5b      	subs	r3, r3, r1
    while (next &&
 800676a:	2b00      	cmp	r3, #0
 800676c:	bfb8      	it	lt
 800676e:	4644      	movlt	r4, r8
 8006770:	db29      	blt.n	80067c6 <tcp_oos_insert_segment+0x8e>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 8006772:	2701      	movs	r7, #1
           TCP_SEQ_GEQ((seqno + cseg->len),
 8006774:	4e1e      	ldr	r6, [pc, #120]	; (80067f0 <tcp_oos_insert_segment+0xb8>)
 8006776:	e015      	b.n	80067a4 <tcp_oos_insert_segment+0x6c>
    tcp_segs_free(next);
 8006778:	4640      	mov	r0, r8
 800677a:	f7ff faf8 	bl	8005d6e <tcp_segs_free>
    next = NULL;
 800677e:	2400      	movs	r4, #0
 8006780:	e030      	b.n	80067e4 <tcp_oos_insert_segment+0xac>
      next = next->next;
 8006782:	f8d8 4000 	ldr.w	r4, [r8]
      tcp_seg_free(old_seg);
 8006786:	4640      	mov	r0, r8
 8006788:	f7ff fae4 	bl	8005d54 <tcp_seg_free>
    while (next &&
 800678c:	b36c      	cbz	r4, 80067ea <tcp_oos_insert_segment+0xb2>
           TCP_SEQ_GEQ((seqno + cseg->len),
 800678e:	68e2      	ldr	r2, [r4, #12]
 8006790:	892b      	ldrh	r3, [r5, #8]
 8006792:	6831      	ldr	r1, [r6, #0]
 8006794:	440b      	add	r3, r1
 8006796:	6851      	ldr	r1, [r2, #4]
 8006798:	1a5b      	subs	r3, r3, r1
 800679a:	8921      	ldrh	r1, [r4, #8]
 800679c:	1a5b      	subs	r3, r3, r1
    while (next &&
 800679e:	2b00      	cmp	r3, #0
 80067a0:	db11      	blt.n	80067c6 <tcp_oos_insert_segment+0x8e>
      next = next->next;
 80067a2:	46a0      	mov	r8, r4
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 80067a4:	8990      	ldrh	r0, [r2, #12]
 80067a6:	f7fd fe20 	bl	80043ea <lwip_ntohs>
 80067aa:	f010 0f01 	tst.w	r0, #1
 80067ae:	d0e8      	beq.n	8006782 <tcp_oos_insert_segment+0x4a>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 80067b0:	f8d5 900c 	ldr.w	r9, [r5, #12]
 80067b4:	f8b9 400c 	ldrh.w	r4, [r9, #12]
 80067b8:	4638      	mov	r0, r7
 80067ba:	f7fd fe11 	bl	80043e0 <lwip_htons>
 80067be:	4320      	orrs	r0, r4
 80067c0:	f8a9 000c 	strh.w	r0, [r9, #12]
 80067c4:	e7dd      	b.n	8006782 <tcp_oos_insert_segment+0x4a>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 80067c6:	4b0a      	ldr	r3, [pc, #40]	; (80067f0 <tcp_oos_insert_segment+0xb8>)
 80067c8:	6819      	ldr	r1, [r3, #0]
 80067ca:	68e3      	ldr	r3, [r4, #12]
 80067cc:	685a      	ldr	r2, [r3, #4]
 80067ce:	892b      	ldrh	r3, [r5, #8]
 80067d0:	440b      	add	r3, r1
 80067d2:	1a9b      	subs	r3, r3, r2
    if (next &&
 80067d4:	2b00      	cmp	r3, #0
 80067d6:	dd05      	ble.n	80067e4 <tcp_oos_insert_segment+0xac>
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 80067d8:	1a52      	subs	r2, r2, r1
 80067da:	b291      	uxth	r1, r2
 80067dc:	8129      	strh	r1, [r5, #8]
      pbuf_realloc(cseg->p, cseg->len);
 80067de:	6868      	ldr	r0, [r5, #4]
 80067e0:	f7ff f940 	bl	8005a64 <pbuf_realloc>
  cseg->next = next;
 80067e4:	602c      	str	r4, [r5, #0]
}
 80067e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    next = NULL;
 80067ea:	2400      	movs	r4, #0
 80067ec:	e7fa      	b.n	80067e4 <tcp_oos_insert_segment+0xac>
 80067ee:	bf00      	nop
 80067f0:	200077a8 	.word	0x200077a8

080067f4 <tcp_receive>:
{
 80067f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80067f8:	4604      	mov	r4, r0
  if (flags & TCP_ACK) {
 80067fa:	4bae      	ldr	r3, [pc, #696]	; (8006ab4 <tcp_receive+0x2c0>)
 80067fc:	781b      	ldrb	r3, [r3, #0]
 80067fe:	f013 0f10 	tst.w	r3, #16
 8006802:	f000 8169 	beq.w	8006ad8 <tcp_receive+0x2e4>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 8006806:	7e00      	ldrb	r0, [r0, #24]
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 8006808:	f8b4 6060 	ldrh.w	r6, [r4, #96]	; 0x60
 800680c:	6da5      	ldr	r5, [r4, #88]	; 0x58
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800680e:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8006810:	4ba9      	ldr	r3, [pc, #676]	; (8006ab8 <tcp_receive+0x2c4>)
 8006812:	681b      	ldr	r3, [r3, #0]
 8006814:	1ad1      	subs	r1, r2, r3
 8006816:	2900      	cmp	r1, #0
 8006818:	db26      	blt.n	8006868 <tcp_receive+0x74>
 800681a:	429a      	cmp	r2, r3
 800681c:	d019      	beq.n	8006852 <tcp_receive+0x5e>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 800681e:	4aa7      	ldr	r2, [pc, #668]	; (8006abc <tcp_receive+0x2c8>)
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 8006820:	6812      	ldr	r2, [r2, #0]
 8006822:	4295      	cmp	r5, r2
 8006824:	d01b      	beq.n	800685e <tcp_receive+0x6a>
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 8006826:	4ba5      	ldr	r3, [pc, #660]	; (8006abc <tcp_receive+0x2c8>)
 8006828:	681a      	ldr	r2, [r3, #0]
 800682a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800682c:	1ad1      	subs	r1, r2, r3
 800682e:	2900      	cmp	r1, #0
 8006830:	dd3f      	ble.n	80068b2 <tcp_receive+0xbe>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
 8006832:	2901      	cmp	r1, #1
 8006834:	d403      	bmi.n	800683e <tcp_receive+0x4a>
 8006836:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8006838:	1a51      	subs	r1, r2, r1
 800683a:	2900      	cmp	r1, #0
 800683c:	dd6c      	ble.n	8006918 <tcp_receive+0x124>
      pcb->acked = 0;
 800683e:	2300      	movs	r3, #0
 8006840:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    while (pcb->unsent != NULL &&
 8006844:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006846:	2b00      	cmp	r3, #0
 8006848:	f000 813e 	beq.w	8006ac8 <tcp_receive+0x2d4>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 800684c:	4e9b      	ldr	r6, [pc, #620]	; (8006abc <tcp_receive+0x2c8>)
        pcb->unsent_oversize = 0;
 800684e:	2700      	movs	r7, #0
 8006850:	e0fa      	b.n	8006a48 <tcp_receive+0x254>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 8006852:	4a9a      	ldr	r2, [pc, #616]	; (8006abc <tcp_receive+0x2c8>)
 8006854:	6812      	ldr	r2, [r2, #0]
 8006856:	1aaa      	subs	r2, r5, r2
 8006858:	2a00      	cmp	r2, #0
 800685a:	dae0      	bge.n	800681e <tcp_receive+0x2a>
 800685c:	e004      	b.n	8006868 <tcp_receive+0x74>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 800685e:	4a98      	ldr	r2, [pc, #608]	; (8006ac0 <tcp_receive+0x2cc>)
 8006860:	6812      	ldr	r2, [r2, #0]
 8006862:	89d2      	ldrh	r2, [r2, #14]
 8006864:	42b2      	cmp	r2, r6
 8006866:	d9de      	bls.n	8006826 <tcp_receive+0x32>
      pcb->snd_wnd = tcphdr->wnd;
 8006868:	4a95      	ldr	r2, [pc, #596]	; (8006ac0 <tcp_receive+0x2cc>)
 800686a:	6812      	ldr	r2, [r2, #0]
 800686c:	89d1      	ldrh	r1, [r2, #14]
 800686e:	b28f      	uxth	r7, r1
 8006870:	f8a4 1060 	strh.w	r1, [r4, #96]	; 0x60
      if (pcb->snd_wnd_max < tcphdr->wnd) {
 8006874:	89d2      	ldrh	r2, [r2, #14]
 8006876:	b291      	uxth	r1, r2
 8006878:	f8b4 e062 	ldrh.w	lr, [r4, #98]	; 0x62
 800687c:	458e      	cmp	lr, r1
        pcb->snd_wnd_max = tcphdr->wnd;
 800687e:	bf38      	it	cc
 8006880:	f8a4 2062 	strhcc.w	r2, [r4, #98]	; 0x62
      pcb->snd_wl1 = seqno;
 8006884:	6563      	str	r3, [r4, #84]	; 0x54
      pcb->snd_wl2 = ackno;
 8006886:	4b8d      	ldr	r3, [pc, #564]	; (8006abc <tcp_receive+0x2c8>)
 8006888:	681b      	ldr	r3, [r3, #0]
 800688a:	65a3      	str	r3, [r4, #88]	; 0x58
      if (pcb->snd_wnd == 0) {
 800688c:	b94f      	cbnz	r7, 80068a2 <tcp_receive+0xae>
        if (pcb->persist_backoff == 0) {
 800688e:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
 8006892:	2b00      	cmp	r3, #0
 8006894:	d1c7      	bne.n	8006826 <tcp_receive+0x32>
          pcb->persist_cnt = 0;
 8006896:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
          pcb->persist_backoff = 1;
 800689a:	2301      	movs	r3, #1
 800689c:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
 80068a0:	e7c1      	b.n	8006826 <tcp_receive+0x32>
      } else if (pcb->persist_backoff > 0) {
 80068a2:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
 80068a6:	2b00      	cmp	r3, #0
 80068a8:	d0bd      	beq.n	8006826 <tcp_receive+0x32>
          pcb->persist_backoff = 0;
 80068aa:	2300      	movs	r3, #0
 80068ac:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
 80068b0:	e7b9      	b.n	8006826 <tcp_receive+0x32>
      pcb->acked = 0;
 80068b2:	2100      	movs	r1, #0
 80068b4:	f8a4 1064 	strh.w	r1, [r4, #100]	; 0x64
      if (tcplen == 0) {
 80068b8:	4982      	ldr	r1, [pc, #520]	; (8006ac4 <tcp_receive+0x2d0>)
 80068ba:	8809      	ldrh	r1, [r1, #0]
 80068bc:	b931      	cbnz	r1, 80068cc <tcp_receive+0xd8>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 80068be:	4435      	add	r5, r6
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
 80068c0:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
 80068c4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80068c6:	4401      	add	r1, r0
 80068c8:	428d      	cmp	r5, r1
 80068ca:	d003      	beq.n	80068d4 <tcp_receive+0xe0>
        pcb->dupacks = 0;
 80068cc:	2300      	movs	r3, #0
 80068ce:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
 80068d2:	e7b7      	b.n	8006844 <tcp_receive+0x50>
          if (pcb->rtime >= 0) {
 80068d4:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
 80068d8:	2900      	cmp	r1, #0
 80068da:	dbf7      	blt.n	80068cc <tcp_receive+0xd8>
            if (pcb->lastack == ackno) {
 80068dc:	429a      	cmp	r2, r3
 80068de:	d1f5      	bne.n	80068cc <tcp_receive+0xd8>
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 80068e0:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
 80068e4:	1c53      	adds	r3, r2, #1
 80068e6:	b2db      	uxtb	r3, r3
 80068e8:	429a      	cmp	r2, r3
                ++pcb->dupacks;
 80068ea:	bf38      	it	cc
 80068ec:	f884 3047 	strbcc.w	r3, [r4, #71]	; 0x47
              if (pcb->dupacks > 3) {
 80068f0:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
 80068f4:	2b03      	cmp	r3, #3
 80068f6:	d909      	bls.n	800690c <tcp_receive+0x118>
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 80068f8:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 80068fc:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80068fe:	4413      	add	r3, r2
 8006900:	b29b      	uxth	r3, r3
 8006902:	429a      	cmp	r2, r3
 8006904:	d29e      	bcs.n	8006844 <tcp_receive+0x50>
                  pcb->cwnd += pcb->mss;
 8006906:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 800690a:	e79b      	b.n	8006844 <tcp_receive+0x50>
              } else if (pcb->dupacks == 3) {
 800690c:	2b03      	cmp	r3, #3
 800690e:	d199      	bne.n	8006844 <tcp_receive+0x50>
                tcp_rexmit_fast(pcb);
 8006910:	4620      	mov	r0, r4
 8006912:	f001 fc0b 	bl	800812c <tcp_rexmit_fast>
 8006916:	e795      	b.n	8006844 <tcp_receive+0x50>
      if (pcb->flags & TF_INFR) {
 8006918:	7fa1      	ldrb	r1, [r4, #30]
 800691a:	f011 0f04 	tst.w	r1, #4
 800691e:	d006      	beq.n	800692e <tcp_receive+0x13a>
        pcb->flags &= ~TF_INFR;
 8006920:	f021 0104 	bic.w	r1, r1, #4
 8006924:	77a1      	strb	r1, [r4, #30]
        pcb->cwnd = pcb->ssthresh;
 8006926:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
 800692a:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
      pcb->nrtx = 0;
 800692e:	2500      	movs	r5, #0
 8006930:	f884 5046 	strb.w	r5, [r4, #70]	; 0x46
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 8006934:	f9b4 6040 	ldrsh.w	r6, [r4, #64]	; 0x40
 8006938:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
 800693c:	eb01 01e6 	add.w	r1, r1, r6, asr #3
 8006940:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 8006944:	1ad3      	subs	r3, r2, r3
 8006946:	b29b      	uxth	r3, r3
 8006948:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
      pcb->snd_buf += pcb->acked;
 800694c:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
 8006950:	440b      	add	r3, r1
 8006952:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
      pcb->dupacks = 0;
 8006956:	f884 5047 	strb.w	r5, [r4, #71]	; 0x47
      pcb->lastack = ackno;
 800695a:	64a2      	str	r2, [r4, #72]	; 0x48
      if (pcb->state >= ESTABLISHED) {
 800695c:	2803      	cmp	r0, #3
 800695e:	d918      	bls.n	8006992 <tcp_receive+0x19e>
        if (pcb->cwnd < pcb->ssthresh) {
 8006960:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 8006964:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 8006968:	4293      	cmp	r3, r2
 800696a:	d907      	bls.n	800697c <tcp_receive+0x188>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 800696c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800696e:	4413      	add	r3, r2
 8006970:	b29b      	uxth	r3, r3
 8006972:	429a      	cmp	r2, r3
 8006974:	d20d      	bcs.n	8006992 <tcp_receive+0x19e>
            pcb->cwnd += pcb->mss;
 8006976:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 800697a:	e00a      	b.n	8006992 <tcp_receive+0x19e>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 800697c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800697e:	fb03 f303 	mul.w	r3, r3, r3
 8006982:	fb93 f3f2 	sdiv	r3, r3, r2
 8006986:	4413      	add	r3, r2
 8006988:	b29b      	uxth	r3, r3
          if (new_cwnd > pcb->cwnd) {
 800698a:	429a      	cmp	r2, r3
            pcb->cwnd = new_cwnd;
 800698c:	bf38      	it	cc
 800698e:	f8a4 304c 	strhcc.w	r3, [r4, #76]	; 0x4c
      while (pcb->unacked != NULL &&
 8006992:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8006994:	2b00      	cmp	r3, #0
 8006996:	d042      	beq.n	8006a1e <tcp_receive+0x22a>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 8006998:	4e48      	ldr	r6, [pc, #288]	; (8006abc <tcp_receive+0x2c8>)
 800699a:	e00d      	b.n	80069b8 <tcp_receive+0x1c4>
        pcb->snd_queuelen -= pbuf_clen(next->p);
 800699c:	6868      	ldr	r0, [r5, #4]
 800699e:	f7ff f88c 	bl	8005aba <pbuf_clen>
 80069a2:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 80069a6:	1a18      	subs	r0, r3, r0
 80069a8:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
        tcp_seg_free(next);
 80069ac:	4628      	mov	r0, r5
 80069ae:	f7ff f9d1 	bl	8005d54 <tcp_seg_free>
      while (pcb->unacked != NULL &&
 80069b2:	6f23      	ldr	r3, [r4, #112]	; 0x70
 80069b4:	2b00      	cmp	r3, #0
 80069b6:	d032      	beq.n	8006a1e <tcp_receive+0x22a>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 80069b8:	68db      	ldr	r3, [r3, #12]
 80069ba:	6858      	ldr	r0, [r3, #4]
 80069bc:	f7fd fd26 	bl	800440c <lwip_ntohl>
 80069c0:	4605      	mov	r5, r0
 80069c2:	6f23      	ldr	r3, [r4, #112]	; 0x70
 80069c4:	891f      	ldrh	r7, [r3, #8]
 80069c6:	68db      	ldr	r3, [r3, #12]
 80069c8:	8998      	ldrh	r0, [r3, #12]
 80069ca:	f7fd fd0e 	bl	80043ea <lwip_ntohs>
 80069ce:	f010 0003 	ands.w	r0, r0, #3
 80069d2:	bf18      	it	ne
 80069d4:	2001      	movne	r0, #1
 80069d6:	4438      	add	r0, r7
 80069d8:	6833      	ldr	r3, [r6, #0]
 80069da:	1aed      	subs	r5, r5, r3
 80069dc:	4428      	add	r0, r5
      while (pcb->unacked != NULL &&
 80069de:	2800      	cmp	r0, #0
 80069e0:	dc16      	bgt.n	8006a10 <tcp_receive+0x21c>
        next = pcb->unacked;
 80069e2:	6f25      	ldr	r5, [r4, #112]	; 0x70
        pcb->unacked = pcb->unacked->next;
 80069e4:	682b      	ldr	r3, [r5, #0]
 80069e6:	6723      	str	r3, [r4, #112]	; 0x70
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 80069e8:	6868      	ldr	r0, [r5, #4]
 80069ea:	f7ff f866 	bl	8005aba <pbuf_clen>
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 80069ee:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 80069f2:	2b00      	cmp	r3, #0
 80069f4:	d0d2      	beq.n	800699c <tcp_receive+0x1a8>
 80069f6:	68eb      	ldr	r3, [r5, #12]
 80069f8:	8998      	ldrh	r0, [r3, #12]
 80069fa:	f7fd fcf6 	bl	80043ea <lwip_ntohs>
 80069fe:	f010 0f01 	tst.w	r0, #1
 8006a02:	d0cb      	beq.n	800699c <tcp_receive+0x1a8>
          pcb->acked--;
 8006a04:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8006a08:	3b01      	subs	r3, #1
 8006a0a:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 8006a0e:	e7c5      	b.n	800699c <tcp_receive+0x1a8>
      if(pcb->unacked == NULL)
 8006a10:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8006a12:	b123      	cbz	r3, 8006a1e <tcp_receive+0x22a>
        pcb->rtime = 0;
 8006a14:	2300      	movs	r3, #0
 8006a16:	86a3      	strh	r3, [r4, #52]	; 0x34
      pcb->polltmr = 0;
 8006a18:	2300      	movs	r3, #0
 8006a1a:	77e3      	strb	r3, [r4, #31]
 8006a1c:	e712      	b.n	8006844 <tcp_receive+0x50>
        pcb->rtime = -1;
 8006a1e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006a22:	86a3      	strh	r3, [r4, #52]	; 0x34
 8006a24:	e7f8      	b.n	8006a18 <tcp_receive+0x224>
        pcb->unsent_oversize = 0;
 8006a26:	f8a4 706a 	strh.w	r7, [r4, #106]	; 0x6a
 8006a2a:	e02e      	b.n	8006a8a <tcp_receive+0x296>
      pcb->snd_queuelen -= pbuf_clen(next->p);
 8006a2c:	6868      	ldr	r0, [r5, #4]
 8006a2e:	f7ff f844 	bl	8005aba <pbuf_clen>
 8006a32:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8006a36:	1a18      	subs	r0, r3, r0
 8006a38:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
      tcp_seg_free(next);
 8006a3c:	4628      	mov	r0, r5
 8006a3e:	f7ff f989 	bl	8005d54 <tcp_seg_free>
    while (pcb->unsent != NULL &&
 8006a42:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006a44:	2b00      	cmp	r3, #0
 8006a46:	d03f      	beq.n	8006ac8 <tcp_receive+0x2d4>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 8006a48:	6835      	ldr	r5, [r6, #0]
 8006a4a:	68db      	ldr	r3, [r3, #12]
 8006a4c:	6858      	ldr	r0, [r3, #4]
 8006a4e:	f7fd fcdd 	bl	800440c <lwip_ntohl>
 8006a52:	4681      	mov	r9, r0
 8006a54:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006a56:	f8b3 8008 	ldrh.w	r8, [r3, #8]
 8006a5a:	68db      	ldr	r3, [r3, #12]
 8006a5c:	8998      	ldrh	r0, [r3, #12]
 8006a5e:	f7fd fcc4 	bl	80043ea <lwip_ntohs>
 8006a62:	eba5 0509 	sub.w	r5, r5, r9
 8006a66:	f010 0003 	ands.w	r0, r0, #3
 8006a6a:	bf18      	it	ne
 8006a6c:	2001      	movne	r0, #1
 8006a6e:	4440      	add	r0, r8
 8006a70:	1a2d      	subs	r5, r5, r0
    while (pcb->unsent != NULL &&
 8006a72:	2d00      	cmp	r5, #0
 8006a74:	db28      	blt.n	8006ac8 <tcp_receive+0x2d4>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 8006a76:	6833      	ldr	r3, [r6, #0]
 8006a78:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8006a7a:	1a9b      	subs	r3, r3, r2
 8006a7c:	2b00      	cmp	r3, #0
 8006a7e:	dc23      	bgt.n	8006ac8 <tcp_receive+0x2d4>
      next = pcb->unsent;
 8006a80:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
      pcb->unsent = pcb->unsent->next;
 8006a82:	682b      	ldr	r3, [r5, #0]
 8006a84:	66e3      	str	r3, [r4, #108]	; 0x6c
      if (pcb->unsent == NULL) {
 8006a86:	2b00      	cmp	r3, #0
 8006a88:	d0cd      	beq.n	8006a26 <tcp_receive+0x232>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 8006a8a:	6868      	ldr	r0, [r5, #4]
 8006a8c:	f7ff f815 	bl	8005aba <pbuf_clen>
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 8006a90:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8006a94:	2b00      	cmp	r3, #0
 8006a96:	d0c9      	beq.n	8006a2c <tcp_receive+0x238>
 8006a98:	68eb      	ldr	r3, [r5, #12]
 8006a9a:	8998      	ldrh	r0, [r3, #12]
 8006a9c:	f7fd fca5 	bl	80043ea <lwip_ntohs>
 8006aa0:	f010 0f01 	tst.w	r0, #1
 8006aa4:	d0c2      	beq.n	8006a2c <tcp_receive+0x238>
        pcb->acked--;
 8006aa6:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8006aaa:	3b01      	subs	r3, #1
 8006aac:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 8006ab0:	e7bc      	b.n	8006a2c <tcp_receive+0x238>
 8006ab2:	bf00      	nop
 8006ab4:	2000778c 	.word	0x2000778c
 8006ab8:	200077a8 	.word	0x200077a8
 8006abc:	20007788 	.word	0x20007788
 8006ac0:	200077ac 	.word	0x200077ac
 8006ac4:	200077b0 	.word	0x200077b0
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 8006ac8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006aca:	b12b      	cbz	r3, 8006ad8 <tcp_receive+0x2e4>
 8006acc:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8006ace:	49a1      	ldr	r1, [pc, #644]	; (8006d54 <tcp_receive+0x560>)
 8006ad0:	6809      	ldr	r1, [r1, #0]
 8006ad2:	1a52      	subs	r2, r2, r1
 8006ad4:	2a00      	cmp	r2, #0
 8006ad6:	db23      	blt.n	8006b20 <tcp_receive+0x32c>
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 8006ad8:	4b9f      	ldr	r3, [pc, #636]	; (8006d58 <tcp_receive+0x564>)
 8006ada:	881b      	ldrh	r3, [r3, #0]
 8006adc:	2b00      	cmp	r3, #0
 8006ade:	f000 8256 	beq.w	8006f8e <tcp_receive+0x79a>
 8006ae2:	7e22      	ldrb	r2, [r4, #24]
 8006ae4:	2a06      	cmp	r2, #6
 8006ae6:	f200 8252 	bhi.w	8006f8e <tcp_receive+0x79a>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
 8006aea:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006aec:	4a9b      	ldr	r2, [pc, #620]	; (8006d5c <tcp_receive+0x568>)
 8006aee:	6812      	ldr	r2, [r2, #0]
 8006af0:	1a8d      	subs	r5, r1, r2
 8006af2:	2d01      	cmp	r5, #1
 8006af4:	d405      	bmi.n	8006b02 <tcp_receive+0x30e>
 8006af6:	f1c2 0001 	rsb	r0, r2, #1
 8006afa:	1ac3      	subs	r3, r0, r3
 8006afc:	440b      	add	r3, r1
 8006afe:	2b00      	cmp	r3, #0
 8006b00:	dd2e      	ble.n	8006b60 <tcp_receive+0x36c>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
 8006b02:	1a53      	subs	r3, r2, r1
 8006b04:	2b00      	cmp	r3, #0
 8006b06:	db55      	blt.n	8006bb4 <tcp_receive+0x3c0>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 8006b08:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006b0a:	f1c3 0301 	rsb	r3, r3, #1
 8006b0e:	4413      	add	r3, r2
 8006b10:	1a5b      	subs	r3, r3, r1
 8006b12:	2b00      	cmp	r3, #0
 8006b14:	dd53      	ble.n	8006bbe <tcp_receive+0x3ca>
      tcp_send_empty_ack(pcb);
 8006b16:	4620      	mov	r0, r4
 8006b18:	f001 f8ec 	bl	8007cf4 <tcp_send_empty_ack>
 8006b1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      m = m - (pcb->sa >> 3);
 8006b20:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
      m = (s16_t)(tcp_ticks - pcb->rttest);
 8006b24:	4a8e      	ldr	r2, [pc, #568]	; (8006d60 <tcp_receive+0x56c>)
 8006b26:	6812      	ldr	r2, [r2, #0]
 8006b28:	1ad3      	subs	r3, r2, r3
      m = m - (pcb->sa >> 3);
 8006b2a:	eba3 03e1 	sub.w	r3, r3, r1, asr #3
 8006b2e:	b29b      	uxth	r3, r3
 8006b30:	b218      	sxth	r0, r3
      pcb->sa += m;
 8006b32:	185a      	adds	r2, r3, r1
 8006b34:	b212      	sxth	r2, r2
 8006b36:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
      if (m < 0) {
 8006b3a:	2800      	cmp	r0, #0
        m = -m;
 8006b3c:	bfbc      	itt	lt
 8006b3e:	425b      	neglt	r3, r3
 8006b40:	b218      	sxthlt	r0, r3
      m = m - (pcb->sv >> 2);
 8006b42:	f9b4 3042 	ldrsh.w	r3, [r4, #66]	; 0x42
      pcb->sv += m;
 8006b46:	eba3 03a3 	sub.w	r3, r3, r3, asr #2
 8006b4a:	4403      	add	r3, r0
 8006b4c:	b29b      	uxth	r3, r3
 8006b4e:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 8006b52:	eb03 03e2 	add.w	r3, r3, r2, asr #3
 8006b56:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
      pcb->rttest = 0;
 8006b5a:	2300      	movs	r3, #0
 8006b5c:	63a3      	str	r3, [r4, #56]	; 0x38
 8006b5e:	e7bb      	b.n	8006ad8 <tcp_receive+0x2e4>
      off = pcb->rcv_nxt - seqno;
 8006b60:	462b      	mov	r3, r5
      p = inseg.p;
 8006b62:	4a80      	ldr	r2, [pc, #512]	; (8006d64 <tcp_receive+0x570>)
 8006b64:	6850      	ldr	r0, [r2, #4]
      if (inseg.p->len < off) {
 8006b66:	8942      	ldrh	r2, [r0, #10]
 8006b68:	4295      	cmp	r5, r2
 8006b6a:	dd1e      	ble.n	8006baa <tcp_receive+0x3b6>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 8006b6c:	8901      	ldrh	r1, [r0, #8]
 8006b6e:	1b49      	subs	r1, r1, r5
 8006b70:	b289      	uxth	r1, r1
          p->len = 0;
 8006b72:	2500      	movs	r5, #0
          off -= p->len;
 8006b74:	1a9b      	subs	r3, r3, r2
          p->tot_len = new_tot_len;
 8006b76:	8101      	strh	r1, [r0, #8]
          p->len = 0;
 8006b78:	8145      	strh	r5, [r0, #10]
          p = p->next;
 8006b7a:	6800      	ldr	r0, [r0, #0]
        while (p->len < off) {
 8006b7c:	8942      	ldrh	r2, [r0, #10]
 8006b7e:	429a      	cmp	r2, r3
 8006b80:	dbf8      	blt.n	8006b74 <tcp_receive+0x380>
        if(pbuf_header(p, (s16_t)-off)) {
 8006b82:	425b      	negs	r3, r3
 8006b84:	b219      	sxth	r1, r3
 8006b86:	f7fe fe68 	bl	800585a <pbuf_header>
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 8006b8a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006b8c:	4975      	ldr	r1, [pc, #468]	; (8006d64 <tcp_receive+0x570>)
 8006b8e:	4873      	ldr	r0, [pc, #460]	; (8006d5c <tcp_receive+0x568>)
 8006b90:	6803      	ldr	r3, [r0, #0]
 8006b92:	890d      	ldrh	r5, [r1, #8]
 8006b94:	442b      	add	r3, r5
 8006b96:	1a9b      	subs	r3, r3, r2
 8006b98:	810b      	strh	r3, [r1, #8]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 8006b9a:	68cb      	ldr	r3, [r1, #12]
 8006b9c:	6002      	str	r2, [r0, #0]
 8006b9e:	605a      	str	r2, [r3, #4]
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 8006ba0:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006ba2:	1a53      	subs	r3, r2, r1
 8006ba4:	2b00      	cmp	r3, #0
 8006ba6:	daaf      	bge.n	8006b08 <tcp_receive+0x314>
 8006ba8:	e7b5      	b.n	8006b16 <tcp_receive+0x322>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
 8006baa:	4269      	negs	r1, r5
 8006bac:	b209      	sxth	r1, r1
 8006bae:	f7fe fe54 	bl	800585a <pbuf_header>
 8006bb2:	e7ea      	b.n	8006b8a <tcp_receive+0x396>
        tcp_ack_now(pcb);
 8006bb4:	7fa3      	ldrb	r3, [r4, #30]
 8006bb6:	f043 0302 	orr.w	r3, r3, #2
 8006bba:	77a3      	strb	r3, [r4, #30]
 8006bbc:	e7ab      	b.n	8006b16 <tcp_receive+0x322>
      if (pcb->rcv_nxt == seqno) {
 8006bbe:	428a      	cmp	r2, r1
 8006bc0:	d013      	beq.n	8006bea <tcp_receive+0x3f6>
        tcp_send_empty_ack(pcb);
 8006bc2:	4620      	mov	r0, r4
 8006bc4:	f001 f896 	bl	8007cf4 <tcp_send_empty_ack>
        if (pcb->ooseq == NULL) {
 8006bc8:	6f66      	ldr	r6, [r4, #116]	; 0x74
 8006bca:	2e00      	cmp	r6, #0
 8006bcc:	f000 8128 	beq.w	8006e20 <tcp_receive+0x62c>
            if (seqno == next->tcphdr->seqno) {
 8006bd0:	68f1      	ldr	r1, [r6, #12]
 8006bd2:	684a      	ldr	r2, [r1, #4]
 8006bd4:	4b61      	ldr	r3, [pc, #388]	; (8006d5c <tcp_receive+0x568>)
 8006bd6:	6818      	ldr	r0, [r3, #0]
 8006bd8:	4282      	cmp	r2, r0
 8006bda:	f000 8127 	beq.w	8006e2c <tcp_receive+0x638>
 8006bde:	2700      	movs	r7, #0
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 8006be0:	f100 3eff 	add.w	lr, r0, #4294967295
 8006be4:	f100 0c01 	add.w	ip, r0, #1
 8006be8:	e143      	b.n	8006e72 <tcp_receive+0x67e>
        tcplen = TCP_TCPLEN(&inseg);
 8006bea:	4b5e      	ldr	r3, [pc, #376]	; (8006d64 <tcp_receive+0x570>)
 8006bec:	891d      	ldrh	r5, [r3, #8]
 8006bee:	68db      	ldr	r3, [r3, #12]
 8006bf0:	8998      	ldrh	r0, [r3, #12]
 8006bf2:	f7fd fbfa 	bl	80043ea <lwip_ntohs>
 8006bf6:	f010 0303 	ands.w	r3, r0, #3
 8006bfa:	bf18      	it	ne
 8006bfc:	2301      	movne	r3, #1
 8006bfe:	442b      	add	r3, r5
 8006c00:	b29b      	uxth	r3, r3
 8006c02:	4a55      	ldr	r2, [pc, #340]	; (8006d58 <tcp_receive+0x564>)
 8006c04:	8013      	strh	r3, [r2, #0]
        if (tcplen > pcb->rcv_wnd) {
 8006c06:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 8006c08:	429a      	cmp	r2, r3
 8006c0a:	d317      	bcc.n	8006c3c <tcp_receive+0x448>
        if (pcb->ooseq != NULL) {
 8006c0c:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8006c0e:	2b00      	cmp	r3, #0
 8006c10:	f000 81d1 	beq.w	8006fb6 <tcp_receive+0x7c2>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8006c14:	4b53      	ldr	r3, [pc, #332]	; (8006d64 <tcp_receive+0x570>)
 8006c16:	68db      	ldr	r3, [r3, #12]
 8006c18:	8998      	ldrh	r0, [r3, #12]
 8006c1a:	f7fd fbe6 	bl	80043ea <lwip_ntohs>
 8006c1e:	f010 0f01 	tst.w	r0, #1
 8006c22:	d042      	beq.n	8006caa <tcp_receive+0x4b6>
            while (pcb->ooseq != NULL) {
 8006c24:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8006c26:	2800      	cmp	r0, #0
 8006c28:	f000 81c5 	beq.w	8006fb6 <tcp_receive+0x7c2>
              pcb->ooseq = pcb->ooseq->next;
 8006c2c:	6803      	ldr	r3, [r0, #0]
 8006c2e:	6763      	str	r3, [r4, #116]	; 0x74
              tcp_seg_free(old_ooseq);
 8006c30:	f7ff f890 	bl	8005d54 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
 8006c34:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8006c36:	2800      	cmp	r0, #0
 8006c38:	d1f8      	bne.n	8006c2c <tcp_receive+0x438>
 8006c3a:	e1bc      	b.n	8006fb6 <tcp_receive+0x7c2>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8006c3c:	4b49      	ldr	r3, [pc, #292]	; (8006d64 <tcp_receive+0x570>)
 8006c3e:	68db      	ldr	r3, [r3, #12]
 8006c40:	8998      	ldrh	r0, [r3, #12]
 8006c42:	f7fd fbd2 	bl	80043ea <lwip_ntohs>
 8006c46:	f010 0f01 	tst.w	r0, #1
 8006c4a:	d11f      	bne.n	8006c8c <tcp_receive+0x498>
          inseg.len = pcb->rcv_wnd;
 8006c4c:	4b45      	ldr	r3, [pc, #276]	; (8006d64 <tcp_receive+0x570>)
 8006c4e:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 8006c50:	811a      	strh	r2, [r3, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8006c52:	68db      	ldr	r3, [r3, #12]
 8006c54:	8998      	ldrh	r0, [r3, #12]
 8006c56:	f7fd fbc8 	bl	80043ea <lwip_ntohs>
 8006c5a:	f010 0f02 	tst.w	r0, #2
 8006c5e:	d003      	beq.n	8006c68 <tcp_receive+0x474>
            inseg.len -= 1;
 8006c60:	4a40      	ldr	r2, [pc, #256]	; (8006d64 <tcp_receive+0x570>)
 8006c62:	8913      	ldrh	r3, [r2, #8]
 8006c64:	3b01      	subs	r3, #1
 8006c66:	8113      	strh	r3, [r2, #8]
          pbuf_realloc(inseg.p, inseg.len);
 8006c68:	4d3e      	ldr	r5, [pc, #248]	; (8006d64 <tcp_receive+0x570>)
 8006c6a:	8929      	ldrh	r1, [r5, #8]
 8006c6c:	6868      	ldr	r0, [r5, #4]
 8006c6e:	f7fe fef9 	bl	8005a64 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 8006c72:	892e      	ldrh	r6, [r5, #8]
 8006c74:	68eb      	ldr	r3, [r5, #12]
 8006c76:	8998      	ldrh	r0, [r3, #12]
 8006c78:	f7fd fbb7 	bl	80043ea <lwip_ntohs>
 8006c7c:	f010 0003 	ands.w	r0, r0, #3
 8006c80:	bf18      	it	ne
 8006c82:	2001      	movne	r0, #1
 8006c84:	4406      	add	r6, r0
 8006c86:	4b34      	ldr	r3, [pc, #208]	; (8006d58 <tcp_receive+0x564>)
 8006c88:	801e      	strh	r6, [r3, #0]
 8006c8a:	e7bf      	b.n	8006c0c <tcp_receive+0x418>
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
 8006c8c:	4b35      	ldr	r3, [pc, #212]	; (8006d64 <tcp_receive+0x570>)
 8006c8e:	68de      	ldr	r6, [r3, #12]
 8006c90:	89b5      	ldrh	r5, [r6, #12]
 8006c92:	4628      	mov	r0, r5
 8006c94:	f7fd fba9 	bl	80043ea <lwip_ntohs>
 8006c98:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 8006c9c:	f7fd fba0 	bl	80043e0 <lwip_htons>
 8006ca0:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 8006ca4:	4305      	orrs	r5, r0
 8006ca6:	81b5      	strh	r5, [r6, #12]
 8006ca8:	e7d0      	b.n	8006c4c <tcp_receive+0x458>
            next = pcb->ooseq;
 8006caa:	f8d4 9074 	ldr.w	r9, [r4, #116]	; 0x74
            while (next &&
 8006cae:	f1b9 0f00 	cmp.w	r9, #0
 8006cb2:	f000 817e 	beq.w	8006fb2 <tcp_receive+0x7be>
                   TCP_SEQ_GEQ(seqno + tcplen,
 8006cb6:	f8d9 200c 	ldr.w	r2, [r9, #12]
 8006cba:	4b27      	ldr	r3, [pc, #156]	; (8006d58 <tcp_receive+0x564>)
 8006cbc:	881b      	ldrh	r3, [r3, #0]
 8006cbe:	4927      	ldr	r1, [pc, #156]	; (8006d5c <tcp_receive+0x568>)
 8006cc0:	6809      	ldr	r1, [r1, #0]
 8006cc2:	440b      	add	r3, r1
 8006cc4:	6851      	ldr	r1, [r2, #4]
 8006cc6:	1a5b      	subs	r3, r3, r1
 8006cc8:	f8b9 1008 	ldrh.w	r1, [r9, #8]
 8006ccc:	1a5b      	subs	r3, r3, r1
            while (next &&
 8006cce:	2b00      	cmp	r3, #0
 8006cd0:	f2c0 81a2 	blt.w	8007018 <tcp_receive+0x824>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 8006cd4:	f8df 808c 	ldr.w	r8, [pc, #140]	; 8006d64 <tcp_receive+0x570>
                tcplen = TCP_TCPLEN(&inseg);
 8006cd8:	4e1f      	ldr	r6, [pc, #124]	; (8006d58 <tcp_receive+0x564>)
                   TCP_SEQ_GEQ(seqno + tcplen,
 8006cda:	4f20      	ldr	r7, [pc, #128]	; (8006d5c <tcp_receive+0x568>)
 8006cdc:	e013      	b.n	8006d06 <tcp_receive+0x512>
              next = next->next;
 8006cde:	f8d9 5000 	ldr.w	r5, [r9]
              tcp_seg_free(prev);
 8006ce2:	4648      	mov	r0, r9
 8006ce4:	f7ff f836 	bl	8005d54 <tcp_seg_free>
            while (next &&
 8006ce8:	2d00      	cmp	r5, #0
 8006cea:	f000 8162 	beq.w	8006fb2 <tcp_receive+0x7be>
                   TCP_SEQ_GEQ(seqno + tcplen,
 8006cee:	68ea      	ldr	r2, [r5, #12]
 8006cf0:	8833      	ldrh	r3, [r6, #0]
 8006cf2:	6839      	ldr	r1, [r7, #0]
 8006cf4:	440b      	add	r3, r1
 8006cf6:	6851      	ldr	r1, [r2, #4]
 8006cf8:	1a5b      	subs	r3, r3, r1
 8006cfa:	8929      	ldrh	r1, [r5, #8]
 8006cfc:	1a5b      	subs	r3, r3, r1
            while (next &&
 8006cfe:	2b00      	cmp	r3, #0
 8006d00:	f2c0 818b 	blt.w	800701a <tcp_receive+0x826>
              next = next->next;
 8006d04:	46a9      	mov	r9, r5
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 8006d06:	8990      	ldrh	r0, [r2, #12]
 8006d08:	f7fd fb6f 	bl	80043ea <lwip_ntohs>
 8006d0c:	f010 0f01 	tst.w	r0, #1
 8006d10:	d0e5      	beq.n	8006cde <tcp_receive+0x4ea>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 8006d12:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8006d16:	8998      	ldrh	r0, [r3, #12]
 8006d18:	f7fd fb67 	bl	80043ea <lwip_ntohs>
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 8006d1c:	f010 0f02 	tst.w	r0, #2
 8006d20:	d1dd      	bne.n	8006cde <tcp_receive+0x4ea>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 8006d22:	f8d8 a00c 	ldr.w	sl, [r8, #12]
 8006d26:	f8ba 500c 	ldrh.w	r5, [sl, #12]
 8006d2a:	2001      	movs	r0, #1
 8006d2c:	f7fd fb58 	bl	80043e0 <lwip_htons>
 8006d30:	4328      	orrs	r0, r5
 8006d32:	f8aa 000c 	strh.w	r0, [sl, #12]
                tcplen = TCP_TCPLEN(&inseg);
 8006d36:	f8b8 5008 	ldrh.w	r5, [r8, #8]
 8006d3a:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8006d3e:	8998      	ldrh	r0, [r3, #12]
 8006d40:	f7fd fb53 	bl	80043ea <lwip_ntohs>
 8006d44:	f010 0003 	ands.w	r0, r0, #3
 8006d48:	bf18      	it	ne
 8006d4a:	2001      	movne	r0, #1
 8006d4c:	4405      	add	r5, r0
 8006d4e:	8035      	strh	r5, [r6, #0]
 8006d50:	e7c5      	b.n	8006cde <tcp_receive+0x4ea>
 8006d52:	bf00      	nop
 8006d54:	20007788 	.word	0x20007788
 8006d58:	200077b0 	.word	0x200077b0
 8006d5c:	200077a8 	.word	0x200077a8
 8006d60:	2000b230 	.word	0x2000b230
 8006d64:	20007790 	.word	0x20007790
              recv_data = cseg->p;
 8006d68:	f8c8 1000 	str.w	r1, [r8]
            cseg->p = NULL;
 8006d6c:	2300      	movs	r3, #0
 8006d6e:	606b      	str	r3, [r5, #4]
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 8006d70:	68eb      	ldr	r3, [r5, #12]
 8006d72:	8998      	ldrh	r0, [r3, #12]
 8006d74:	f7fd fb39 	bl	80043ea <lwip_ntohs>
 8006d78:	f010 0f01 	tst.w	r0, #1
 8006d7c:	d008      	beq.n	8006d90 <tcp_receive+0x59c>
            recv_flags |= TF_GOT_FIN;
 8006d7e:	7833      	ldrb	r3, [r6, #0]
 8006d80:	f043 0320 	orr.w	r3, r3, #32
 8006d84:	7033      	strb	r3, [r6, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 8006d86:	7e23      	ldrb	r3, [r4, #24]
 8006d88:	2b04      	cmp	r3, #4
              pcb->state = CLOSE_WAIT;
 8006d8a:	bf04      	itt	eq
 8006d8c:	2307      	moveq	r3, #7
 8006d8e:	7623      	strbeq	r3, [r4, #24]
          pcb->ooseq = cseg->next;
 8006d90:	682b      	ldr	r3, [r5, #0]
 8006d92:	6763      	str	r3, [r4, #116]	; 0x74
          tcp_seg_free(cseg);
 8006d94:	4628      	mov	r0, r5
 8006d96:	f7fe ffdd 	bl	8005d54 <tcp_seg_free>
        while (pcb->ooseq != NULL &&
 8006d9a:	6f65      	ldr	r5, [r4, #116]	; 0x74
 8006d9c:	2d00      	cmp	r5, #0
 8006d9e:	d032      	beq.n	8006e06 <tcp_receive+0x612>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 8006da0:	68eb      	ldr	r3, [r5, #12]
 8006da2:	685a      	ldr	r2, [r3, #4]
        while (pcb->ooseq != NULL &&
 8006da4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006da6:	428a      	cmp	r2, r1
 8006da8:	d12d      	bne.n	8006e06 <tcp_receive+0x612>
          seqno = pcb->ooseq->tcphdr->seqno;
 8006daa:	603a      	str	r2, [r7, #0]
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 8006dac:	f8b5 9008 	ldrh.w	r9, [r5, #8]
 8006db0:	8998      	ldrh	r0, [r3, #12]
 8006db2:	f7fd fb1a 	bl	80043ea <lwip_ntohs>
 8006db6:	f010 0003 	ands.w	r0, r0, #3
 8006dba:	bf18      	it	ne
 8006dbc:	2001      	movne	r0, #1
 8006dbe:	4448      	add	r0, r9
 8006dc0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8006dc2:	4418      	add	r0, r3
 8006dc4:	62a0      	str	r0, [r4, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 8006dc6:	68eb      	ldr	r3, [r5, #12]
 8006dc8:	8998      	ldrh	r0, [r3, #12]
 8006dca:	f7fd fb0e 	bl	80043ea <lwip_ntohs>
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 8006dce:	f8b5 9008 	ldrh.w	r9, [r5, #8]
 8006dd2:	68eb      	ldr	r3, [r5, #12]
 8006dd4:	8998      	ldrh	r0, [r3, #12]
 8006dd6:	f7fd fb08 	bl	80043ea <lwip_ntohs>
 8006dda:	f010 0003 	ands.w	r0, r0, #3
 8006dde:	bf18      	it	ne
 8006de0:	2001      	movne	r0, #1
 8006de2:	4448      	add	r0, r9
 8006de4:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006de6:	1a18      	subs	r0, r3, r0
 8006de8:	85a0      	strh	r0, [r4, #44]	; 0x2c
          tcp_update_rcv_ann_wnd(pcb);
 8006dea:	4620      	mov	r0, r4
 8006dec:	f7fe ff78 	bl	8005ce0 <tcp_update_rcv_ann_wnd>
          if (cseg->p->tot_len > 0) {
 8006df0:	6869      	ldr	r1, [r5, #4]
 8006df2:	890b      	ldrh	r3, [r1, #8]
 8006df4:	2b00      	cmp	r3, #0
 8006df6:	d0bb      	beq.n	8006d70 <tcp_receive+0x57c>
            if (recv_data) {
 8006df8:	f8d8 0000 	ldr.w	r0, [r8]
 8006dfc:	2800      	cmp	r0, #0
 8006dfe:	d0b3      	beq.n	8006d68 <tcp_receive+0x574>
              pbuf_cat(recv_data, cseg->p);
 8006e00:	f7fe fe6b 	bl	8005ada <pbuf_cat>
 8006e04:	e7b2      	b.n	8006d6c <tcp_receive+0x578>
        tcp_ack(pcb);
 8006e06:	7fa3      	ldrb	r3, [r4, #30]
 8006e08:	f013 0f01 	tst.w	r3, #1
 8006e0c:	bf1a      	itte	ne
 8006e0e:	f023 0301 	bicne.w	r3, r3, #1
 8006e12:	f043 0302 	orrne.w	r3, r3, #2
 8006e16:	f043 0301 	orreq.w	r3, r3, #1
 8006e1a:	77a3      	strb	r3, [r4, #30]
 8006e1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          pcb->ooseq = tcp_seg_copy(&inseg);
 8006e20:	4893      	ldr	r0, [pc, #588]	; (8007070 <tcp_receive+0x87c>)
 8006e22:	f7fe ffb0 	bl	8005d86 <tcp_seg_copy>
 8006e26:	6760      	str	r0, [r4, #116]	; 0x74
 8006e28:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if (seqno == next->tcphdr->seqno) {
 8006e2c:	4635      	mov	r5, r6
 8006e2e:	2600      	movs	r6, #0
              if (inseg.len > next->len) {
 8006e30:	4b8f      	ldr	r3, [pc, #572]	; (8007070 <tcp_receive+0x87c>)
 8006e32:	891a      	ldrh	r2, [r3, #8]
 8006e34:	892b      	ldrh	r3, [r5, #8]
 8006e36:	429a      	cmp	r2, r3
 8006e38:	d94f      	bls.n	8006eda <tcp_receive+0x6e6>
                cseg = tcp_seg_copy(&inseg);
 8006e3a:	488d      	ldr	r0, [pc, #564]	; (8007070 <tcp_receive+0x87c>)
 8006e3c:	f7fe ffa3 	bl	8005d86 <tcp_seg_copy>
                if (cseg != NULL) {
 8006e40:	4603      	mov	r3, r0
 8006e42:	2800      	cmp	r0, #0
 8006e44:	d049      	beq.n	8006eda <tcp_receive+0x6e6>
                  if (prev != NULL) {
 8006e46:	b136      	cbz	r6, 8006e56 <tcp_receive+0x662>
                    prev->next = cseg;
 8006e48:	6030      	str	r0, [r6, #0]
                  tcp_oos_insert_segment(cseg, next);
 8006e4a:	4629      	mov	r1, r5
 8006e4c:	4618      	mov	r0, r3
 8006e4e:	f7ff fc73 	bl	8006738 <tcp_oos_insert_segment>
 8006e52:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                    pcb->ooseq = cseg;
 8006e56:	6760      	str	r0, [r4, #116]	; 0x74
 8006e58:	e7f7      	b.n	8006e4a <tcp_receive+0x656>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 8006e5a:	1a83      	subs	r3, r0, r2
 8006e5c:	2b00      	cmp	r3, #0
 8006e5e:	db2f      	blt.n	8006ec0 <tcp_receive+0x6cc>
              if (next->next == NULL &&
 8006e60:	6835      	ldr	r5, [r6, #0]
 8006e62:	2d00      	cmp	r5, #0
 8006e64:	d036      	beq.n	8006ed4 <tcp_receive+0x6e0>
            if (seqno == next->tcphdr->seqno) {
 8006e66:	68e9      	ldr	r1, [r5, #12]
 8006e68:	684a      	ldr	r2, [r1, #4]
 8006e6a:	4637      	mov	r7, r6
 8006e6c:	4282      	cmp	r2, r0
 8006e6e:	d0df      	beq.n	8006e30 <tcp_receive+0x63c>
              if (next->next == NULL &&
 8006e70:	462e      	mov	r6, r5
              if (prev == NULL) {
 8006e72:	2f00      	cmp	r7, #0
 8006e74:	d0f1      	beq.n	8006e5a <tcp_receive+0x666>
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 8006e76:	68fb      	ldr	r3, [r7, #12]
 8006e78:	685b      	ldr	r3, [r3, #4]
 8006e7a:	ebae 0303 	sub.w	r3, lr, r3
 8006e7e:	2b00      	cmp	r3, #0
 8006e80:	dbee      	blt.n	8006e60 <tcp_receive+0x66c>
 8006e82:	ebac 0302 	sub.w	r3, ip, r2
 8006e86:	2b00      	cmp	r3, #0
 8006e88:	dcea      	bgt.n	8006e60 <tcp_receive+0x66c>
                  cseg = tcp_seg_copy(&inseg);
 8006e8a:	4879      	ldr	r0, [pc, #484]	; (8007070 <tcp_receive+0x87c>)
 8006e8c:	f7fe ff7b 	bl	8005d86 <tcp_seg_copy>
                  if (cseg != NULL) {
 8006e90:	4604      	mov	r4, r0
 8006e92:	b310      	cbz	r0, 8006eda <tcp_receive+0x6e6>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 8006e94:	68fb      	ldr	r3, [r7, #12]
 8006e96:	6859      	ldr	r1, [r3, #4]
 8006e98:	4b76      	ldr	r3, [pc, #472]	; (8007074 <tcp_receive+0x880>)
 8006e9a:	681b      	ldr	r3, [r3, #0]
 8006e9c:	893a      	ldrh	r2, [r7, #8]
 8006e9e:	440a      	add	r2, r1
 8006ea0:	1ad2      	subs	r2, r2, r3
 8006ea2:	2a00      	cmp	r2, #0
 8006ea4:	dd05      	ble.n	8006eb2 <tcp_receive+0x6be>
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 8006ea6:	1a5b      	subs	r3, r3, r1
 8006ea8:	b299      	uxth	r1, r3
 8006eaa:	8139      	strh	r1, [r7, #8]
                      pbuf_realloc(prev->p, prev->len);
 8006eac:	6878      	ldr	r0, [r7, #4]
 8006eae:	f7fe fdd9 	bl	8005a64 <pbuf_realloc>
                    prev->next = cseg;
 8006eb2:	603c      	str	r4, [r7, #0]
                    tcp_oos_insert_segment(cseg, next);
 8006eb4:	4631      	mov	r1, r6
 8006eb6:	4620      	mov	r0, r4
 8006eb8:	f7ff fc3e 	bl	8006738 <tcp_oos_insert_segment>
 8006ebc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                  cseg = tcp_seg_copy(&inseg);
 8006ec0:	486b      	ldr	r0, [pc, #428]	; (8007070 <tcp_receive+0x87c>)
 8006ec2:	f7fe ff60 	bl	8005d86 <tcp_seg_copy>
                  if (cseg != NULL) {
 8006ec6:	b140      	cbz	r0, 8006eda <tcp_receive+0x6e6>
                    pcb->ooseq = cseg;
 8006ec8:	6760      	str	r0, [r4, #116]	; 0x74
                    tcp_oos_insert_segment(cseg, next);
 8006eca:	4631      	mov	r1, r6
 8006ecc:	f7ff fc34 	bl	8006738 <tcp_oos_insert_segment>
 8006ed0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 8006ed4:	1a82      	subs	r2, r0, r2
              if (next->next == NULL &&
 8006ed6:	2a00      	cmp	r2, #0
 8006ed8:	dc01      	bgt.n	8006ede <tcp_receive+0x6ea>
 8006eda:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 8006ede:	8988      	ldrh	r0, [r1, #12]
 8006ee0:	f7fd fa83 	bl	80043ea <lwip_ntohs>
 8006ee4:	f010 0f01 	tst.w	r0, #1
 8006ee8:	d1f7      	bne.n	8006eda <tcp_receive+0x6e6>
                next->next = tcp_seg_copy(&inseg);
 8006eea:	4861      	ldr	r0, [pc, #388]	; (8007070 <tcp_receive+0x87c>)
 8006eec:	f7fe ff4b 	bl	8005d86 <tcp_seg_copy>
 8006ef0:	6030      	str	r0, [r6, #0]
                if (next->next != NULL) {
 8006ef2:	2800      	cmp	r0, #0
 8006ef4:	d0f1      	beq.n	8006eda <tcp_receive+0x6e6>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 8006ef6:	68f3      	ldr	r3, [r6, #12]
 8006ef8:	6859      	ldr	r1, [r3, #4]
 8006efa:	4b5e      	ldr	r3, [pc, #376]	; (8007074 <tcp_receive+0x880>)
 8006efc:	681b      	ldr	r3, [r3, #0]
 8006efe:	8932      	ldrh	r2, [r6, #8]
 8006f00:	440a      	add	r2, r1
 8006f02:	1ad2      	subs	r2, r2, r3
 8006f04:	2a00      	cmp	r2, #0
 8006f06:	dd05      	ble.n	8006f14 <tcp_receive+0x720>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 8006f08:	1a5b      	subs	r3, r3, r1
 8006f0a:	b299      	uxth	r1, r3
 8006f0c:	8131      	strh	r1, [r6, #8]
                    pbuf_realloc(next->p, next->len);
 8006f0e:	6870      	ldr	r0, [r6, #4]
 8006f10:	f7fe fda8 	bl	8005a64 <pbuf_realloc>
                  if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
 8006f14:	4b58      	ldr	r3, [pc, #352]	; (8007078 <tcp_receive+0x884>)
 8006f16:	881a      	ldrh	r2, [r3, #0]
 8006f18:	4b56      	ldr	r3, [pc, #344]	; (8007074 <tcp_receive+0x880>)
 8006f1a:	681b      	ldr	r3, [r3, #0]
 8006f1c:	441a      	add	r2, r3
 8006f1e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006f20:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006f22:	440b      	add	r3, r1
 8006f24:	429a      	cmp	r2, r3
 8006f26:	d9d8      	bls.n	8006eda <tcp_receive+0x6e6>
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 8006f28:	6833      	ldr	r3, [r6, #0]
 8006f2a:	68db      	ldr	r3, [r3, #12]
 8006f2c:	8998      	ldrh	r0, [r3, #12]
 8006f2e:	f7fd fa5c 	bl	80043ea <lwip_ntohs>
 8006f32:	f010 0f01 	tst.w	r0, #1
 8006f36:	d11b      	bne.n	8006f70 <tcp_receive+0x77c>
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
 8006f38:	6832      	ldr	r2, [r6, #0]
 8006f3a:	4b4e      	ldr	r3, [pc, #312]	; (8007074 <tcp_receive+0x880>)
 8006f3c:	6819      	ldr	r1, [r3, #0]
 8006f3e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006f40:	1a5b      	subs	r3, r3, r1
 8006f42:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006f44:	440b      	add	r3, r1
 8006f46:	8113      	strh	r3, [r2, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 8006f48:	6833      	ldr	r3, [r6, #0]
 8006f4a:	8919      	ldrh	r1, [r3, #8]
 8006f4c:	6858      	ldr	r0, [r3, #4]
 8006f4e:	f7fe fd89 	bl	8005a64 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 8006f52:	6833      	ldr	r3, [r6, #0]
 8006f54:	891c      	ldrh	r4, [r3, #8]
 8006f56:	68db      	ldr	r3, [r3, #12]
 8006f58:	8998      	ldrh	r0, [r3, #12]
 8006f5a:	f7fd fa46 	bl	80043ea <lwip_ntohs>
 8006f5e:	f010 0003 	ands.w	r0, r0, #3
 8006f62:	bf18      	it	ne
 8006f64:	2001      	movne	r0, #1
 8006f66:	4404      	add	r4, r0
 8006f68:	4b43      	ldr	r3, [pc, #268]	; (8007078 <tcp_receive+0x884>)
 8006f6a:	801c      	strh	r4, [r3, #0]
 8006f6c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
 8006f70:	6833      	ldr	r3, [r6, #0]
 8006f72:	68df      	ldr	r7, [r3, #12]
 8006f74:	89bd      	ldrh	r5, [r7, #12]
 8006f76:	4628      	mov	r0, r5
 8006f78:	f7fd fa37 	bl	80043ea <lwip_ntohs>
 8006f7c:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 8006f80:	f7fd fa2e 	bl	80043e0 <lwip_htons>
 8006f84:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 8006f88:	4305      	orrs	r5, r0
 8006f8a:	81bd      	strh	r5, [r7, #12]
 8006f8c:	e7d4      	b.n	8006f38 <tcp_receive+0x744>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
 8006f8e:	4b39      	ldr	r3, [pc, #228]	; (8007074 <tcp_receive+0x880>)
 8006f90:	681b      	ldr	r3, [r3, #0]
 8006f92:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006f94:	1a99      	subs	r1, r3, r2
 8006f96:	2900      	cmp	r1, #0
 8006f98:	db05      	blt.n	8006fa6 <tcp_receive+0x7b2>
 8006f9a:	3301      	adds	r3, #1
 8006f9c:	1a9b      	subs	r3, r3, r2
 8006f9e:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 8006fa0:	1a9b      	subs	r3, r3, r2
 8006fa2:	2b00      	cmp	r3, #0
 8006fa4:	dd99      	ble.n	8006eda <tcp_receive+0x6e6>
      tcp_ack_now(pcb);
 8006fa6:	7fa3      	ldrb	r3, [r4, #30]
 8006fa8:	f043 0302 	orr.w	r3, r3, #2
 8006fac:	77a3      	strb	r3, [r4, #30]
}
 8006fae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
              next = next->next;
 8006fb2:	2500      	movs	r5, #0
            pcb->ooseq = next;
 8006fb4:	6765      	str	r5, [r4, #116]	; 0x74
        pcb->rcv_nxt = seqno + tcplen;
 8006fb6:	4b30      	ldr	r3, [pc, #192]	; (8007078 <tcp_receive+0x884>)
 8006fb8:	881a      	ldrh	r2, [r3, #0]
 8006fba:	4b2e      	ldr	r3, [pc, #184]	; (8007074 <tcp_receive+0x880>)
 8006fbc:	681b      	ldr	r3, [r3, #0]
 8006fbe:	4413      	add	r3, r2
 8006fc0:	62a3      	str	r3, [r4, #40]	; 0x28
        pcb->rcv_wnd -= tcplen;
 8006fc2:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006fc4:	1a9b      	subs	r3, r3, r2
 8006fc6:	85a3      	strh	r3, [r4, #44]	; 0x2c
        tcp_update_rcv_ann_wnd(pcb);
 8006fc8:	4620      	mov	r0, r4
 8006fca:	f7fe fe89 	bl	8005ce0 <tcp_update_rcv_ann_wnd>
        if (inseg.p->tot_len > 0) {
 8006fce:	4b28      	ldr	r3, [pc, #160]	; (8007070 <tcp_receive+0x87c>)
 8006fd0:	685b      	ldr	r3, [r3, #4]
 8006fd2:	891a      	ldrh	r2, [r3, #8]
 8006fd4:	b122      	cbz	r2, 8006fe0 <tcp_receive+0x7ec>
          recv_data = inseg.p;
 8006fd6:	4a29      	ldr	r2, [pc, #164]	; (800707c <tcp_receive+0x888>)
 8006fd8:	6013      	str	r3, [r2, #0]
          inseg.p = NULL;
 8006fda:	2200      	movs	r2, #0
 8006fdc:	4b24      	ldr	r3, [pc, #144]	; (8007070 <tcp_receive+0x87c>)
 8006fde:	605a      	str	r2, [r3, #4]
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8006fe0:	4b23      	ldr	r3, [pc, #140]	; (8007070 <tcp_receive+0x87c>)
 8006fe2:	68db      	ldr	r3, [r3, #12]
 8006fe4:	8998      	ldrh	r0, [r3, #12]
 8006fe6:	f7fd fa00 	bl	80043ea <lwip_ntohs>
 8006fea:	f010 0f01 	tst.w	r0, #1
 8006fee:	d004      	beq.n	8006ffa <tcp_receive+0x806>
          recv_flags |= TF_GOT_FIN;
 8006ff0:	4a23      	ldr	r2, [pc, #140]	; (8007080 <tcp_receive+0x88c>)
 8006ff2:	7813      	ldrb	r3, [r2, #0]
 8006ff4:	f043 0320 	orr.w	r3, r3, #32
 8006ff8:	7013      	strb	r3, [r2, #0]
        while (pcb->ooseq != NULL &&
 8006ffa:	6f65      	ldr	r5, [r4, #116]	; 0x74
 8006ffc:	2d00      	cmp	r5, #0
 8006ffe:	f43f af02 	beq.w	8006e06 <tcp_receive+0x612>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 8007002:	68eb      	ldr	r3, [r5, #12]
 8007004:	685a      	ldr	r2, [r3, #4]
        while (pcb->ooseq != NULL &&
 8007006:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8007008:	428a      	cmp	r2, r1
 800700a:	f47f aefc 	bne.w	8006e06 <tcp_receive+0x612>
          seqno = pcb->ooseq->tcphdr->seqno;
 800700e:	4f19      	ldr	r7, [pc, #100]	; (8007074 <tcp_receive+0x880>)
            if (recv_data) {
 8007010:	f8df 8068 	ldr.w	r8, [pc, #104]	; 800707c <tcp_receive+0x888>
            recv_flags |= TF_GOT_FIN;
 8007014:	4e1a      	ldr	r6, [pc, #104]	; (8007080 <tcp_receive+0x88c>)
 8007016:	e6c8      	b.n	8006daa <tcp_receive+0x5b6>
            next = pcb->ooseq;
 8007018:	464d      	mov	r5, r9
                TCP_SEQ_GT(seqno + tcplen,
 800701a:	4b16      	ldr	r3, [pc, #88]	; (8007074 <tcp_receive+0x880>)
 800701c:	6819      	ldr	r1, [r3, #0]
 800701e:	68eb      	ldr	r3, [r5, #12]
 8007020:	685a      	ldr	r2, [r3, #4]
 8007022:	4b15      	ldr	r3, [pc, #84]	; (8007078 <tcp_receive+0x884>)
 8007024:	881b      	ldrh	r3, [r3, #0]
 8007026:	440b      	add	r3, r1
 8007028:	1a9b      	subs	r3, r3, r2
            if (next &&
 800702a:	2b00      	cmp	r3, #0
 800702c:	ddc2      	ble.n	8006fb4 <tcp_receive+0x7c0>
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 800702e:	4b10      	ldr	r3, [pc, #64]	; (8007070 <tcp_receive+0x87c>)
 8007030:	1a52      	subs	r2, r2, r1
 8007032:	811a      	strh	r2, [r3, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8007034:	68db      	ldr	r3, [r3, #12]
 8007036:	8998      	ldrh	r0, [r3, #12]
 8007038:	f7fd f9d7 	bl	80043ea <lwip_ntohs>
 800703c:	f010 0f02 	tst.w	r0, #2
 8007040:	d003      	beq.n	800704a <tcp_receive+0x856>
                inseg.len -= 1;
 8007042:	4a0b      	ldr	r2, [pc, #44]	; (8007070 <tcp_receive+0x87c>)
 8007044:	8913      	ldrh	r3, [r2, #8]
 8007046:	3b01      	subs	r3, #1
 8007048:	8113      	strh	r3, [r2, #8]
              pbuf_realloc(inseg.p, inseg.len);
 800704a:	4e09      	ldr	r6, [pc, #36]	; (8007070 <tcp_receive+0x87c>)
 800704c:	8931      	ldrh	r1, [r6, #8]
 800704e:	6870      	ldr	r0, [r6, #4]
 8007050:	f7fe fd08 	bl	8005a64 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 8007054:	8937      	ldrh	r7, [r6, #8]
 8007056:	68f3      	ldr	r3, [r6, #12]
 8007058:	8998      	ldrh	r0, [r3, #12]
 800705a:	f7fd f9c6 	bl	80043ea <lwip_ntohs>
 800705e:	f010 0003 	ands.w	r0, r0, #3
 8007062:	bf18      	it	ne
 8007064:	2001      	movne	r0, #1
 8007066:	4407      	add	r7, r0
 8007068:	4b03      	ldr	r3, [pc, #12]	; (8007078 <tcp_receive+0x884>)
 800706a:	801f      	strh	r7, [r3, #0]
 800706c:	e7a2      	b.n	8006fb4 <tcp_receive+0x7c0>
 800706e:	bf00      	nop
 8007070:	20007790 	.word	0x20007790
 8007074:	200077a8 	.word	0x200077a8
 8007078:	200077b0 	.word	0x200077b0
 800707c:	200077a0 	.word	0x200077a0
 8007080:	200077a4 	.word	0x200077a4

08007084 <tcp_input>:
{
 8007084:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8007088:	b083      	sub	sp, #12
 800708a:	4604      	mov	r4, r0
 800708c:	460d      	mov	r5, r1
  TCP_STATS_INC(tcp.recv);
 800708e:	4aa5      	ldr	r2, [pc, #660]	; (8007324 <tcp_input+0x2a0>)
 8007090:	f8b2 3092 	ldrh.w	r3, [r2, #146]	; 0x92
 8007094:	3301      	adds	r3, #1
 8007096:	f8a2 3092 	strh.w	r3, [r2, #146]	; 0x92
  iphdr = (struct ip_hdr *)p->payload;
 800709a:	6843      	ldr	r3, [r0, #4]
 800709c:	7819      	ldrb	r1, [r3, #0]
 800709e:	f001 010f 	and.w	r1, r1, #15
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 80070a2:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80070a6:	4aa0      	ldr	r2, [pc, #640]	; (8007328 <tcp_input+0x2a4>)
 80070a8:	6013      	str	r3, [r2, #0]
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 80070aa:	0089      	lsls	r1, r1, #2
 80070ac:	4249      	negs	r1, r1
 80070ae:	f7fe fbd4 	bl	800585a <pbuf_header>
 80070b2:	b910      	cbnz	r0, 80070ba <tcp_input+0x36>
 80070b4:	8923      	ldrh	r3, [r4, #8]
 80070b6:	2b13      	cmp	r3, #19
 80070b8:	d811      	bhi.n	80070de <tcp_input+0x5a>
    TCP_STATS_INC(tcp.lenerr);
 80070ba:	4a9a      	ldr	r2, [pc, #616]	; (8007324 <tcp_input+0x2a0>)
 80070bc:	f8b2 309a 	ldrh.w	r3, [r2, #154]	; 0x9a
 80070c0:	3301      	adds	r3, #1
 80070c2:	f8a2 309a 	strh.w	r3, [r2, #154]	; 0x9a
  TCP_STATS_INC(tcp.drop);
 80070c6:	4a97      	ldr	r2, [pc, #604]	; (8007324 <tcp_input+0x2a0>)
 80070c8:	f8b2 3096 	ldrh.w	r3, [r2, #150]	; 0x96
 80070cc:	3301      	adds	r3, #1
 80070ce:	f8a2 3096 	strh.w	r3, [r2, #150]	; 0x96
  pbuf_free(p);
 80070d2:	4620      	mov	r0, r4
 80070d4:	f7fe fbff 	bl	80058d6 <pbuf_free>
}
 80070d8:	b003      	add	sp, #12
 80070da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 80070de:	4629      	mov	r1, r5
 80070e0:	4b92      	ldr	r3, [pc, #584]	; (800732c <tcp_input+0x2a8>)
 80070e2:	6818      	ldr	r0, [r3, #0]
 80070e4:	f7fd fd78 	bl	8004bd8 <ip4_addr_isbroadcast>
 80070e8:	b9a8      	cbnz	r0, 8007116 <tcp_input+0x92>
      ip_addr_ismulticast(&current_iphdr_dest)) {
 80070ea:	4b90      	ldr	r3, [pc, #576]	; (800732c <tcp_input+0x2a8>)
 80070ec:	681b      	ldr	r3, [r3, #0]
 80070ee:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 80070f2:	2be0      	cmp	r3, #224	; 0xe0
 80070f4:	d00f      	beq.n	8007116 <tcp_input+0x92>
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 80070f6:	8923      	ldrh	r3, [r4, #8]
 80070f8:	9300      	str	r3, [sp, #0]
 80070fa:	2306      	movs	r3, #6
 80070fc:	4a8b      	ldr	r2, [pc, #556]	; (800732c <tcp_input+0x2a8>)
 80070fe:	498c      	ldr	r1, [pc, #560]	; (8007330 <tcp_input+0x2ac>)
 8007100:	4620      	mov	r0, r4
 8007102:	f7fd fb05 	bl	8004710 <inet_chksum_pseudo>
 8007106:	b168      	cbz	r0, 8007124 <tcp_input+0xa0>
    TCP_STATS_INC(tcp.chkerr);
 8007108:	4a86      	ldr	r2, [pc, #536]	; (8007324 <tcp_input+0x2a0>)
 800710a:	f8b2 3098 	ldrh.w	r3, [r2, #152]	; 0x98
 800710e:	3301      	adds	r3, #1
 8007110:	f8a2 3098 	strh.w	r3, [r2, #152]	; 0x98
    goto dropped;
 8007114:	e7d7      	b.n	80070c6 <tcp_input+0x42>
    TCP_STATS_INC(tcp.proterr);
 8007116:	4a83      	ldr	r2, [pc, #524]	; (8007324 <tcp_input+0x2a0>)
 8007118:	f8b2 30a0 	ldrh.w	r3, [r2, #160]	; 0xa0
 800711c:	3301      	adds	r3, #1
 800711e:	f8a2 30a0 	strh.w	r3, [r2, #160]	; 0xa0
    goto dropped;
 8007122:	e7d0      	b.n	80070c6 <tcp_input+0x42>
  hdrlen = TCPH_HDRLEN(tcphdr);
 8007124:	4b80      	ldr	r3, [pc, #512]	; (8007328 <tcp_input+0x2a4>)
 8007126:	681b      	ldr	r3, [r3, #0]
 8007128:	8998      	ldrh	r0, [r3, #12]
 800712a:	f7fd f95e 	bl	80043ea <lwip_ntohs>
 800712e:	0b00      	lsrs	r0, r0, #12
  if(pbuf_header(p, -(hdrlen * 4))){
 8007130:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
 8007134:	0081      	lsls	r1, r0, #2
 8007136:	b209      	sxth	r1, r1
 8007138:	4620      	mov	r0, r4
 800713a:	f7fe fb8e 	bl	800585a <pbuf_header>
 800713e:	b130      	cbz	r0, 800714e <tcp_input+0xca>
    TCP_STATS_INC(tcp.lenerr);
 8007140:	4a78      	ldr	r2, [pc, #480]	; (8007324 <tcp_input+0x2a0>)
 8007142:	f8b2 309a 	ldrh.w	r3, [r2, #154]	; 0x9a
 8007146:	3301      	adds	r3, #1
 8007148:	f8a2 309a 	strh.w	r3, [r2, #154]	; 0x9a
    goto dropped;
 800714c:	e7bb      	b.n	80070c6 <tcp_input+0x42>
  tcphdr->src = ntohs(tcphdr->src);
 800714e:	4d76      	ldr	r5, [pc, #472]	; (8007328 <tcp_input+0x2a4>)
 8007150:	682e      	ldr	r6, [r5, #0]
 8007152:	8830      	ldrh	r0, [r6, #0]
 8007154:	f7fd f949 	bl	80043ea <lwip_ntohs>
 8007158:	8030      	strh	r0, [r6, #0]
  tcphdr->dest = ntohs(tcphdr->dest);
 800715a:	682e      	ldr	r6, [r5, #0]
 800715c:	8870      	ldrh	r0, [r6, #2]
 800715e:	f7fd f944 	bl	80043ea <lwip_ntohs>
 8007162:	8070      	strh	r0, [r6, #2]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 8007164:	682e      	ldr	r6, [r5, #0]
 8007166:	6870      	ldr	r0, [r6, #4]
 8007168:	f7fd f950 	bl	800440c <lwip_ntohl>
 800716c:	6070      	str	r0, [r6, #4]
 800716e:	4b71      	ldr	r3, [pc, #452]	; (8007334 <tcp_input+0x2b0>)
 8007170:	6018      	str	r0, [r3, #0]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8007172:	682e      	ldr	r6, [r5, #0]
 8007174:	68b0      	ldr	r0, [r6, #8]
 8007176:	f7fd f949 	bl	800440c <lwip_ntohl>
 800717a:	60b0      	str	r0, [r6, #8]
 800717c:	4b6e      	ldr	r3, [pc, #440]	; (8007338 <tcp_input+0x2b4>)
 800717e:	6018      	str	r0, [r3, #0]
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8007180:	682e      	ldr	r6, [r5, #0]
 8007182:	89f0      	ldrh	r0, [r6, #14]
 8007184:	f7fd f931 	bl	80043ea <lwip_ntohs>
 8007188:	81f0      	strh	r0, [r6, #14]
  flags = TCPH_FLAGS(tcphdr);
 800718a:	682b      	ldr	r3, [r5, #0]
 800718c:	8998      	ldrh	r0, [r3, #12]
 800718e:	f7fd f92c 	bl	80043ea <lwip_ntohs>
 8007192:	fa5f fe80 	uxtb.w	lr, r0
 8007196:	f00e 023f 	and.w	r2, lr, #63	; 0x3f
 800719a:	4b68      	ldr	r3, [pc, #416]	; (800733c <tcp_input+0x2b8>)
 800719c:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 800719e:	f01e 0303 	ands.w	r3, lr, #3
 80071a2:	bf18      	it	ne
 80071a4:	2301      	movne	r3, #1
 80071a6:	8921      	ldrh	r1, [r4, #8]
 80071a8:	440b      	add	r3, r1
 80071aa:	b299      	uxth	r1, r3
 80071ac:	4b64      	ldr	r3, [pc, #400]	; (8007340 <tcp_input+0x2bc>)
 80071ae:	8019      	strh	r1, [r3, #0]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80071b0:	4b64      	ldr	r3, [pc, #400]	; (8007344 <tcp_input+0x2c0>)
 80071b2:	6818      	ldr	r0, [r3, #0]
 80071b4:	2800      	cmp	r0, #0
 80071b6:	d060      	beq.n	800727a <tcp_input+0x1f6>
    if (pcb->remote_port == tcphdr->src &&
 80071b8:	682f      	ldr	r7, [r5, #0]
 80071ba:	883e      	ldrh	r6, [r7, #0]
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 80071bc:	4b5c      	ldr	r3, [pc, #368]	; (8007330 <tcp_input+0x2ac>)
 80071be:	f8d3 c000 	ldr.w	ip, [r3]
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
 80071c2:	4b5a      	ldr	r3, [pc, #360]	; (800732c <tcp_input+0x2a8>)
 80071c4:	f8d3 8000 	ldr.w	r8, [r3]
 80071c8:	4605      	mov	r5, r0
 80071ca:	2200      	movs	r2, #0
 80071cc:	e004      	b.n	80071d8 <tcp_input+0x154>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80071ce:	68eb      	ldr	r3, [r5, #12]
 80071d0:	462a      	mov	r2, r5
 80071d2:	2b00      	cmp	r3, #0
 80071d4:	d051      	beq.n	800727a <tcp_input+0x1f6>
 80071d6:	461d      	mov	r5, r3
    if (pcb->remote_port == tcphdr->src &&
 80071d8:	8bab      	ldrh	r3, [r5, #28]
 80071da:	42b3      	cmp	r3, r6
 80071dc:	d1f7      	bne.n	80071ce <tcp_input+0x14a>
 80071de:	f8b5 901a 	ldrh.w	r9, [r5, #26]
 80071e2:	887b      	ldrh	r3, [r7, #2]
 80071e4:	4599      	cmp	r9, r3
 80071e6:	d1f2      	bne.n	80071ce <tcp_input+0x14a>
       pcb->local_port == tcphdr->dest &&
 80071e8:	686b      	ldr	r3, [r5, #4]
 80071ea:	4563      	cmp	r3, ip
 80071ec:	d1ef      	bne.n	80071ce <tcp_input+0x14a>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 80071ee:	682b      	ldr	r3, [r5, #0]
 80071f0:	4543      	cmp	r3, r8
 80071f2:	d1ec      	bne.n	80071ce <tcp_input+0x14a>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 80071f4:	68eb      	ldr	r3, [r5, #12]
      if (prev != NULL) {
 80071f6:	b11a      	cbz	r2, 8007200 <tcp_input+0x17c>
        prev->next = pcb->next;
 80071f8:	60d3      	str	r3, [r2, #12]
        pcb->next = tcp_active_pcbs;
 80071fa:	60e8      	str	r0, [r5, #12]
        tcp_active_pcbs = pcb;
 80071fc:	4b51      	ldr	r3, [pc, #324]	; (8007344 <tcp_input+0x2c0>)
 80071fe:	601d      	str	r5, [r3, #0]
  if (pcb == NULL) {
 8007200:	2d00      	cmp	r5, #0
 8007202:	d03a      	beq.n	800727a <tcp_input+0x1f6>
    inseg.next = NULL;
 8007204:	4b50      	ldr	r3, [pc, #320]	; (8007348 <tcp_input+0x2c4>)
 8007206:	2200      	movs	r2, #0
 8007208:	601a      	str	r2, [r3, #0]
    inseg.len = p->tot_len;
 800720a:	8921      	ldrh	r1, [r4, #8]
 800720c:	8119      	strh	r1, [r3, #8]
    inseg.p = p;
 800720e:	605c      	str	r4, [r3, #4]
    inseg.tcphdr = tcphdr;
 8007210:	60df      	str	r7, [r3, #12]
    recv_data = NULL;
 8007212:	4b4e      	ldr	r3, [pc, #312]	; (800734c <tcp_input+0x2c8>)
 8007214:	601a      	str	r2, [r3, #0]
    recv_flags = 0;
 8007216:	4b4e      	ldr	r3, [pc, #312]	; (8007350 <tcp_input+0x2cc>)
 8007218:	701a      	strb	r2, [r3, #0]
    if (flags & TCP_PSH) {
 800721a:	f01e 0f08 	tst.w	lr, #8
 800721e:	d003      	beq.n	8007228 <tcp_input+0x1a4>
      p->flags |= PBUF_FLAG_PUSH;
 8007220:	7b63      	ldrb	r3, [r4, #13]
 8007222:	f043 0301 	orr.w	r3, r3, #1
 8007226:	7363      	strb	r3, [r4, #13]
    if (pcb->refused_data != NULL) {
 8007228:	6fab      	ldr	r3, [r5, #120]	; 0x78
 800722a:	2b00      	cmp	r3, #0
 800722c:	f000 811d 	beq.w	800746a <tcp_input+0x3e6>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 8007230:	4628      	mov	r0, r5
 8007232:	f7ff f8ad 	bl	8006390 <tcp_process_refused_data>
 8007236:	f110 0f0a 	cmn.w	r0, #10
 800723a:	d008      	beq.n	800724e <tcp_input+0x1ca>
 800723c:	6fab      	ldr	r3, [r5, #120]	; 0x78
 800723e:	2b00      	cmp	r3, #0
 8007240:	f000 8113 	beq.w	800746a <tcp_input+0x3e6>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 8007244:	4b3e      	ldr	r3, [pc, #248]	; (8007340 <tcp_input+0x2bc>)
 8007246:	881b      	ldrh	r3, [r3, #0]
 8007248:	2b00      	cmp	r3, #0
 800724a:	f000 810e 	beq.w	800746a <tcp_input+0x3e6>
        TCP_STATS_INC(tcp.drop);
 800724e:	4a35      	ldr	r2, [pc, #212]	; (8007324 <tcp_input+0x2a0>)
 8007250:	f8b2 3096 	ldrh.w	r3, [r2, #150]	; 0x96
 8007254:	3301      	adds	r3, #1
 8007256:	f8a2 3096 	strh.w	r3, [r2, #150]	; 0x96
    tcp_input_pcb = NULL;
 800725a:	2300      	movs	r3, #0
 800725c:	4a3d      	ldr	r2, [pc, #244]	; (8007354 <tcp_input+0x2d0>)
 800725e:	6013      	str	r3, [r2, #0]
    recv_data = NULL;
 8007260:	4a3a      	ldr	r2, [pc, #232]	; (800734c <tcp_input+0x2c8>)
 8007262:	6013      	str	r3, [r2, #0]
    if (inseg.p != NULL)
 8007264:	4b38      	ldr	r3, [pc, #224]	; (8007348 <tcp_input+0x2c4>)
 8007266:	6858      	ldr	r0, [r3, #4]
 8007268:	2800      	cmp	r0, #0
 800726a:	f43f af35 	beq.w	80070d8 <tcp_input+0x54>
      pbuf_free(inseg.p);
 800726e:	f7fe fb32 	bl	80058d6 <pbuf_free>
      inseg.p = NULL;
 8007272:	2200      	movs	r2, #0
 8007274:	4b34      	ldr	r3, [pc, #208]	; (8007348 <tcp_input+0x2c4>)
 8007276:	605a      	str	r2, [r3, #4]
 8007278:	e72e      	b.n	80070d8 <tcp_input+0x54>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800727a:	4b37      	ldr	r3, [pc, #220]	; (8007358 <tcp_input+0x2d4>)
 800727c:	6818      	ldr	r0, [r3, #0]
 800727e:	2800      	cmp	r0, #0
 8007280:	d042      	beq.n	8007308 <tcp_input+0x284>
      if (pcb->remote_port == tcphdr->src &&
 8007282:	4b29      	ldr	r3, [pc, #164]	; (8007328 <tcp_input+0x2a4>)
 8007284:	681f      	ldr	r7, [r3, #0]
 8007286:	883a      	ldrh	r2, [r7, #0]
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8007288:	4b29      	ldr	r3, [pc, #164]	; (8007330 <tcp_input+0x2ac>)
 800728a:	f8d3 8000 	ldr.w	r8, [r3]
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
 800728e:	4b27      	ldr	r3, [pc, #156]	; (800732c <tcp_input+0x2a8>)
 8007290:	f8d3 c000 	ldr.w	ip, [r3]
 8007294:	e00f      	b.n	80072b6 <tcp_input+0x232>
  } else if (flags & TCP_FIN) {
 8007296:	f01e 0f01 	tst.w	lr, #1
 800729a:	d002      	beq.n	80072a2 <tcp_input+0x21e>
    pcb->tmr = tcp_ticks;
 800729c:	4b2f      	ldr	r3, [pc, #188]	; (800735c <tcp_input+0x2d8>)
 800729e:	681b      	ldr	r3, [r3, #0]
 80072a0:	6243      	str	r3, [r0, #36]	; 0x24
  if ((tcplen > 0))  {
 80072a2:	b369      	cbz	r1, 8007300 <tcp_input+0x27c>
    pcb->flags |= TF_ACK_NOW;
 80072a4:	7f83      	ldrb	r3, [r0, #30]
 80072a6:	f043 0302 	orr.w	r3, r3, #2
 80072aa:	7783      	strb	r3, [r0, #30]
    return tcp_output(pcb);
 80072ac:	f000 fd52 	bl	8007d54 <tcp_output>
 80072b0:	e026      	b.n	8007300 <tcp_input+0x27c>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80072b2:	68c0      	ldr	r0, [r0, #12]
 80072b4:	b340      	cbz	r0, 8007308 <tcp_input+0x284>
      if (pcb->remote_port == tcphdr->src &&
 80072b6:	8b83      	ldrh	r3, [r0, #28]
 80072b8:	4293      	cmp	r3, r2
 80072ba:	d1fa      	bne.n	80072b2 <tcp_input+0x22e>
         pcb->local_port == tcphdr->dest &&
 80072bc:	8b45      	ldrh	r5, [r0, #26]
      if (pcb->remote_port == tcphdr->src &&
 80072be:	887e      	ldrh	r6, [r7, #2]
 80072c0:	42ae      	cmp	r6, r5
 80072c2:	d1f6      	bne.n	80072b2 <tcp_input+0x22e>
         pcb->local_port == tcphdr->dest &&
 80072c4:	6846      	ldr	r6, [r0, #4]
 80072c6:	4546      	cmp	r6, r8
 80072c8:	d1f3      	bne.n	80072b2 <tcp_input+0x22e>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 80072ca:	6806      	ldr	r6, [r0, #0]
 80072cc:	4566      	cmp	r6, ip
 80072ce:	d1f0      	bne.n	80072b2 <tcp_input+0x22e>
  if (flags & TCP_RST)  {
 80072d0:	f01e 0f04 	tst.w	lr, #4
 80072d4:	d114      	bne.n	8007300 <tcp_input+0x27c>
  if (flags & TCP_SYN) {
 80072d6:	f01e 0f02 	tst.w	lr, #2
 80072da:	d0dc      	beq.n	8007296 <tcp_input+0x212>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
 80072dc:	4a15      	ldr	r2, [pc, #84]	; (8007334 <tcp_input+0x2b0>)
 80072de:	6816      	ldr	r6, [r2, #0]
 80072e0:	6a82      	ldr	r2, [r0, #40]	; 0x28
 80072e2:	1ab2      	subs	r2, r6, r2
 80072e4:	d4dd      	bmi.n	80072a2 <tcp_input+0x21e>
 80072e6:	8d87      	ldrh	r7, [r0, #44]	; 0x2c
 80072e8:	1bd2      	subs	r2, r2, r7
 80072ea:	2a00      	cmp	r2, #0
 80072ec:	dcd9      	bgt.n	80072a2 <tcp_input+0x21e>
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 80072ee:	9301      	str	r3, [sp, #4]
 80072f0:	9500      	str	r5, [sp, #0]
 80072f2:	4b0f      	ldr	r3, [pc, #60]	; (8007330 <tcp_input+0x2ac>)
 80072f4:	4a0d      	ldr	r2, [pc, #52]	; (800732c <tcp_input+0x2a8>)
 80072f6:	4431      	add	r1, r6
 80072f8:	480f      	ldr	r0, [pc, #60]	; (8007338 <tcp_input+0x2b4>)
 80072fa:	6800      	ldr	r0, [r0, #0]
 80072fc:	f000 fe82 	bl	8008004 <tcp_rst>
        pbuf_free(p);
 8007300:	4620      	mov	r0, r4
 8007302:	f7fe fae8 	bl	80058d6 <pbuf_free>
        return;
 8007306:	e6e7      	b.n	80070d8 <tcp_input+0x54>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8007308:	4b15      	ldr	r3, [pc, #84]	; (8007360 <tcp_input+0x2dc>)
 800730a:	681f      	ldr	r7, [r3, #0]
 800730c:	2f00      	cmp	r7, #0
 800730e:	f000 837c 	beq.w	8007a0a <tcp_input+0x986>
      if (lpcb->local_port == tcphdr->dest) {
 8007312:	4b05      	ldr	r3, [pc, #20]	; (8007328 <tcp_input+0x2a4>)
 8007314:	681e      	ldr	r6, [r3, #0]
 8007316:	8870      	ldrh	r0, [r6, #2]
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
 8007318:	4b04      	ldr	r3, [pc, #16]	; (800732c <tcp_input+0x2a8>)
 800731a:	f8d3 c000 	ldr.w	ip, [r3]
 800731e:	463d      	mov	r5, r7
 8007320:	2200      	movs	r2, #0
 8007322:	e025      	b.n	8007370 <tcp_input+0x2ec>
 8007324:	2000b110 	.word	0x2000b110
 8007328:	200077ac 	.word	0x200077ac
 800732c:	200089d8 	.word	0x200089d8
 8007330:	200089d0 	.word	0x200089d0
 8007334:	200077a8 	.word	0x200077a8
 8007338:	20007788 	.word	0x20007788
 800733c:	2000778c 	.word	0x2000778c
 8007340:	200077b0 	.word	0x200077b0
 8007344:	2000b22c 	.word	0x2000b22c
 8007348:	20007790 	.word	0x20007790
 800734c:	200077a0 	.word	0x200077a0
 8007350:	200077a4 	.word	0x200077a4
 8007354:	2000b244 	.word	0x2000b244
 8007358:	2000b240 	.word	0x2000b240
 800735c:	2000b230 	.word	0x2000b230
 8007360:	2000b234 	.word	0x2000b234
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8007364:	68eb      	ldr	r3, [r5, #12]
 8007366:	462a      	mov	r2, r5
 8007368:	2b00      	cmp	r3, #0
 800736a:	f000 834e 	beq.w	8007a0a <tcp_input+0x986>
 800736e:	461d      	mov	r5, r3
      if (lpcb->local_port == tcphdr->dest) {
 8007370:	8b6b      	ldrh	r3, [r5, #26]
 8007372:	4283      	cmp	r3, r0
 8007374:	d1f6      	bne.n	8007364 <tcp_input+0x2e0>
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
 8007376:	682b      	ldr	r3, [r5, #0]
 8007378:	4563      	cmp	r3, ip
 800737a:	d002      	beq.n	8007382 <tcp_input+0x2fe>
 800737c:	b10d      	cbz	r5, 8007382 <tcp_input+0x2fe>
            ip_addr_isany(&(lpcb->local_ip))) {
 800737e:	2b00      	cmp	r3, #0
 8007380:	d1f0      	bne.n	8007364 <tcp_input+0x2e0>
    if (lpcb != NULL) {
 8007382:	2d00      	cmp	r5, #0
 8007384:	f000 8341 	beq.w	8007a0a <tcp_input+0x986>
      if (prev != NULL) {
 8007388:	b122      	cbz	r2, 8007394 <tcp_input+0x310>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 800738a:	68eb      	ldr	r3, [r5, #12]
 800738c:	60d3      	str	r3, [r2, #12]
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 800738e:	60ef      	str	r7, [r5, #12]
        tcp_listen_pcbs.listen_pcbs = lpcb;
 8007390:	4ba3      	ldr	r3, [pc, #652]	; (8007620 <tcp_input+0x59c>)
 8007392:	601d      	str	r5, [r3, #0]
  if (flags & TCP_RST) {
 8007394:	f01e 0f04 	tst.w	lr, #4
 8007398:	d157      	bne.n	800744a <tcp_input+0x3c6>
  if (flags & TCP_ACK) {
 800739a:	f01e 0f10 	tst.w	lr, #16
 800739e:	d147      	bne.n	8007430 <tcp_input+0x3ac>
  } else if (flags & TCP_SYN) {
 80073a0:	f01e 0f02 	tst.w	lr, #2
 80073a4:	d051      	beq.n	800744a <tcp_input+0x3c6>
    npcb = tcp_alloc(pcb->prio);
 80073a6:	7e68      	ldrb	r0, [r5, #25]
 80073a8:	f7ff f8d0 	bl	800654c <tcp_alloc>
    if (npcb == NULL) {
 80073ac:	4606      	mov	r6, r0
 80073ae:	2800      	cmp	r0, #0
 80073b0:	d04f      	beq.n	8007452 <tcp_input+0x3ce>
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
 80073b2:	4b9c      	ldr	r3, [pc, #624]	; (8007624 <tcp_input+0x5a0>)
 80073b4:	681b      	ldr	r3, [r3, #0]
 80073b6:	6003      	str	r3, [r0, #0]
    npcb->local_port = pcb->local_port;
 80073b8:	8b6b      	ldrh	r3, [r5, #26]
 80073ba:	8343      	strh	r3, [r0, #26]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 80073bc:	4b9a      	ldr	r3, [pc, #616]	; (8007628 <tcp_input+0x5a4>)
 80073be:	681b      	ldr	r3, [r3, #0]
 80073c0:	6043      	str	r3, [r0, #4]
    npcb->remote_port = tcphdr->src;
 80073c2:	4b9a      	ldr	r3, [pc, #616]	; (800762c <tcp_input+0x5a8>)
 80073c4:	681a      	ldr	r2, [r3, #0]
 80073c6:	8813      	ldrh	r3, [r2, #0]
 80073c8:	8383      	strh	r3, [r0, #28]
    npcb->state = SYN_RCVD;
 80073ca:	2303      	movs	r3, #3
 80073cc:	7603      	strb	r3, [r0, #24]
    npcb->rcv_nxt = seqno + 1;
 80073ce:	4b98      	ldr	r3, [pc, #608]	; (8007630 <tcp_input+0x5ac>)
 80073d0:	681b      	ldr	r3, [r3, #0]
 80073d2:	1c59      	adds	r1, r3, #1
 80073d4:	6281      	str	r1, [r0, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 80073d6:	6301      	str	r1, [r0, #48]	; 0x30
    npcb->snd_wnd = tcphdr->wnd;
 80073d8:	89d1      	ldrh	r1, [r2, #14]
 80073da:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60
    npcb->snd_wnd_max = tcphdr->wnd;
 80073de:	89d2      	ldrh	r2, [r2, #14]
 80073e0:	f8a0 2062 	strh.w	r2, [r0, #98]	; 0x62
    npcb->ssthresh = npcb->snd_wnd;
 80073e4:	f8a0 104e 	strh.w	r1, [r0, #78]	; 0x4e
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 80073e8:	3b01      	subs	r3, #1
 80073ea:	6543      	str	r3, [r0, #84]	; 0x54
    npcb->callback_arg = pcb->callback_arg;
 80073ec:	692b      	ldr	r3, [r5, #16]
 80073ee:	6103      	str	r3, [r0, #16]
    npcb->accept = pcb->accept;
 80073f0:	696b      	ldr	r3, [r5, #20]
 80073f2:	6143      	str	r3, [r0, #20]
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 80073f4:	7a2b      	ldrb	r3, [r5, #8]
 80073f6:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 80073fa:	7203      	strb	r3, [r0, #8]
    TCP_REG_ACTIVE(npcb);
 80073fc:	4b8d      	ldr	r3, [pc, #564]	; (8007634 <tcp_input+0x5b0>)
 80073fe:	681a      	ldr	r2, [r3, #0]
 8007400:	60c2      	str	r2, [r0, #12]
 8007402:	6018      	str	r0, [r3, #0]
 8007404:	f000 ff88 	bl	8008318 <tcp_timer_needed>
 8007408:	2201      	movs	r2, #1
 800740a:	4b8b      	ldr	r3, [pc, #556]	; (8007638 <tcp_input+0x5b4>)
 800740c:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
 800740e:	4630      	mov	r0, r6
 8007410:	f7ff f948 	bl	80066a4 <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 8007414:	1d31      	adds	r1, r6, #4
 8007416:	8ef0      	ldrh	r0, [r6, #54]	; 0x36
 8007418:	f7ff f932 	bl	8006680 <tcp_eff_send_mss>
 800741c:	86f0      	strh	r0, [r6, #54]	; 0x36
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 800741e:	2112      	movs	r1, #18
 8007420:	4630      	mov	r0, r6
 8007422:	f000 fbc5 	bl	8007bb0 <tcp_enqueue_flags>
    if (rc != ERR_OK) {
 8007426:	b9d8      	cbnz	r0, 8007460 <tcp_input+0x3dc>
    return tcp_output(npcb);
 8007428:	4630      	mov	r0, r6
 800742a:	f000 fc93 	bl	8007d54 <tcp_output>
 800742e:	e00c      	b.n	800744a <tcp_input+0x3c6>
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 8007430:	4b7f      	ldr	r3, [pc, #508]	; (8007630 <tcp_input+0x5ac>)
 8007432:	6818      	ldr	r0, [r3, #0]
 8007434:	8833      	ldrh	r3, [r6, #0]
 8007436:	9301      	str	r3, [sp, #4]
 8007438:	8873      	ldrh	r3, [r6, #2]
 800743a:	9300      	str	r3, [sp, #0]
 800743c:	4b7a      	ldr	r3, [pc, #488]	; (8007628 <tcp_input+0x5a4>)
 800743e:	4a79      	ldr	r2, [pc, #484]	; (8007624 <tcp_input+0x5a0>)
 8007440:	4401      	add	r1, r0
 8007442:	487e      	ldr	r0, [pc, #504]	; (800763c <tcp_input+0x5b8>)
 8007444:	6800      	ldr	r0, [r0, #0]
 8007446:	f000 fddd 	bl	8008004 <tcp_rst>
      pbuf_free(p);
 800744a:	4620      	mov	r0, r4
 800744c:	f7fe fa43 	bl	80058d6 <pbuf_free>
      return;
 8007450:	e642      	b.n	80070d8 <tcp_input+0x54>
      TCP_STATS_INC(tcp.memerr);
 8007452:	4a7b      	ldr	r2, [pc, #492]	; (8007640 <tcp_input+0x5bc>)
 8007454:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 8007458:	3301      	adds	r3, #1
 800745a:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
 800745e:	e7f4      	b.n	800744a <tcp_input+0x3c6>
      tcp_abandon(npcb, 0);
 8007460:	2100      	movs	r1, #0
 8007462:	4630      	mov	r0, r6
 8007464:	f7ff f816 	bl	8006494 <tcp_abandon>
 8007468:	e7ef      	b.n	800744a <tcp_input+0x3c6>
    tcp_input_pcb = pcb;
 800746a:	4b76      	ldr	r3, [pc, #472]	; (8007644 <tcp_input+0x5c0>)
 800746c:	601d      	str	r5, [r3, #0]
  if (flags & TCP_RST) {
 800746e:	4b76      	ldr	r3, [pc, #472]	; (8007648 <tcp_input+0x5c4>)
 8007470:	781b      	ldrb	r3, [r3, #0]
 8007472:	f013 0f04 	tst.w	r3, #4
 8007476:	d036      	beq.n	80074e6 <tcp_input+0x462>
    if (pcb->state == SYN_SENT) {
 8007478:	7e2b      	ldrb	r3, [r5, #24]
 800747a:	2b02      	cmp	r3, #2
 800747c:	d021      	beq.n	80074c2 <tcp_input+0x43e>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 800747e:	4b6c      	ldr	r3, [pc, #432]	; (8007630 <tcp_input+0x5ac>)
 8007480:	681b      	ldr	r3, [r3, #0]
 8007482:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8007484:	1a9b      	subs	r3, r3, r2
 8007486:	d406      	bmi.n	8007496 <tcp_input+0x412>
 8007488:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
 800748a:	1a9b      	subs	r3, r3, r2
  u8_t acceptable = 0;
 800748c:	2b00      	cmp	r3, #0
 800748e:	bfcc      	ite	gt
 8007490:	2300      	movgt	r3, #0
 8007492:	2301      	movle	r3, #1
    if (acceptable) {
 8007494:	b9eb      	cbnz	r3, 80074d2 <tcp_input+0x44e>
      if (recv_flags & TF_RESET) {
 8007496:	4b6d      	ldr	r3, [pc, #436]	; (800764c <tcp_input+0x5c8>)
 8007498:	781b      	ldrb	r3, [r3, #0]
 800749a:	f013 0f08 	tst.w	r3, #8
 800749e:	f000 8248 	beq.w	8007932 <tcp_input+0x8ae>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
 80074a2:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 80074a6:	b11b      	cbz	r3, 80074b0 <tcp_input+0x42c>
 80074a8:	f06f 010a 	mvn.w	r1, #10
 80074ac:	6928      	ldr	r0, [r5, #16]
 80074ae:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 80074b0:	4629      	mov	r1, r5
 80074b2:	4860      	ldr	r0, [pc, #384]	; (8007634 <tcp_input+0x5b0>)
 80074b4:	f7fe fe4a 	bl	800614c <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 80074b8:	4629      	mov	r1, r5
 80074ba:	2002      	movs	r0, #2
 80074bc:	f7fe f914 	bl	80056e8 <memp_free>
 80074c0:	e6cb      	b.n	800725a <tcp_input+0x1d6>
      if (ackno == pcb->snd_nxt) {
 80074c2:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 80074c4:	4a5d      	ldr	r2, [pc, #372]	; (800763c <tcp_input+0x5b8>)
 80074c6:	6812      	ldr	r2, [r2, #0]
  u8_t acceptable = 0;
 80074c8:	4293      	cmp	r3, r2
 80074ca:	bf14      	ite	ne
 80074cc:	2300      	movne	r3, #0
 80074ce:	2301      	moveq	r3, #1
 80074d0:	e7e0      	b.n	8007494 <tcp_input+0x410>
      recv_flags |= TF_RESET;
 80074d2:	4a5e      	ldr	r2, [pc, #376]	; (800764c <tcp_input+0x5c8>)
 80074d4:	7813      	ldrb	r3, [r2, #0]
 80074d6:	f043 0308 	orr.w	r3, r3, #8
 80074da:	7013      	strb	r3, [r2, #0]
      pcb->flags &= ~TF_ACK_DELAY;
 80074dc:	7fab      	ldrb	r3, [r5, #30]
 80074de:	f023 0301 	bic.w	r3, r3, #1
 80074e2:	77ab      	strb	r3, [r5, #30]
 80074e4:	e7d7      	b.n	8007496 <tcp_input+0x412>
  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
 80074e6:	f013 0f02 	tst.w	r3, #2
 80074ea:	d009      	beq.n	8007500 <tcp_input+0x47c>
 80074ec:	7e2b      	ldrb	r3, [r5, #24]
 80074ee:	3b02      	subs	r3, #2
 80074f0:	b2db      	uxtb	r3, r3
 80074f2:	2b01      	cmp	r3, #1
 80074f4:	d904      	bls.n	8007500 <tcp_input+0x47c>
    tcp_ack_now(pcb);
 80074f6:	7fab      	ldrb	r3, [r5, #30]
 80074f8:	f043 0302 	orr.w	r3, r3, #2
 80074fc:	77ab      	strb	r3, [r5, #30]
 80074fe:	e7ca      	b.n	8007496 <tcp_input+0x412>
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 8007500:	7fab      	ldrb	r3, [r5, #30]
 8007502:	f013 0f10 	tst.w	r3, #16
 8007506:	d102      	bne.n	800750e <tcp_input+0x48a>
    pcb->tmr = tcp_ticks;
 8007508:	4b51      	ldr	r3, [pc, #324]	; (8007650 <tcp_input+0x5cc>)
 800750a:	681b      	ldr	r3, [r3, #0]
 800750c:	626b      	str	r3, [r5, #36]	; 0x24
  pcb->keep_cnt_sent = 0;
 800750e:	2300      	movs	r3, #0
 8007510:	f885 3096 	strb.w	r3, [r5, #150]	; 0x96
  tcp_parseopt(pcb);
 8007514:	4628      	mov	r0, r5
 8007516:	f7ff f8c5 	bl	80066a4 <tcp_parseopt>
  switch (pcb->state) {
 800751a:	7e2b      	ldrb	r3, [r5, #24]
 800751c:	3b02      	subs	r3, #2
 800751e:	2b07      	cmp	r3, #7
 8007520:	d8b9      	bhi.n	8007496 <tcp_input+0x412>
 8007522:	e8df f013 	tbh	[pc, r3, lsl #1]
 8007526:	0008      	.short	0x0008
 8007528:	00f70099 	.word	0x00f70099
 800752c:	01600107 	.word	0x01600107
 8007530:	019b00f7 	.word	0x019b00f7
 8007534:	01f1      	.short	0x01f1
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 8007536:	4b44      	ldr	r3, [pc, #272]	; (8007648 <tcp_input+0x5c4>)
 8007538:	781b      	ldrb	r3, [r3, #0]
 800753a:	f003 0312 	and.w	r3, r3, #18
 800753e:	2b12      	cmp	r3, #18
 8007540:	d016      	beq.n	8007570 <tcp_input+0x4ec>
    else if (flags & TCP_ACK) {
 8007542:	4b41      	ldr	r3, [pc, #260]	; (8007648 <tcp_input+0x5c4>)
 8007544:	781b      	ldrb	r3, [r3, #0]
 8007546:	f013 0f10 	tst.w	r3, #16
 800754a:	d0a4      	beq.n	8007496 <tcp_input+0x412>
        tcphdr->dest, tcphdr->src);
 800754c:	4b37      	ldr	r3, [pc, #220]	; (800762c <tcp_input+0x5a8>)
 800754e:	681b      	ldr	r3, [r3, #0]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 8007550:	4a40      	ldr	r2, [pc, #256]	; (8007654 <tcp_input+0x5d0>)
 8007552:	8810      	ldrh	r0, [r2, #0]
 8007554:	4a36      	ldr	r2, [pc, #216]	; (8007630 <tcp_input+0x5ac>)
 8007556:	6811      	ldr	r1, [r2, #0]
 8007558:	881a      	ldrh	r2, [r3, #0]
 800755a:	9201      	str	r2, [sp, #4]
 800755c:	885b      	ldrh	r3, [r3, #2]
 800755e:	9300      	str	r3, [sp, #0]
 8007560:	4b31      	ldr	r3, [pc, #196]	; (8007628 <tcp_input+0x5a4>)
 8007562:	4a30      	ldr	r2, [pc, #192]	; (8007624 <tcp_input+0x5a0>)
 8007564:	4401      	add	r1, r0
 8007566:	4835      	ldr	r0, [pc, #212]	; (800763c <tcp_input+0x5b8>)
 8007568:	6800      	ldr	r0, [r0, #0]
 800756a:	f000 fd4b 	bl	8008004 <tcp_rst>
 800756e:	e792      	b.n	8007496 <tcp_input+0x412>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
 8007570:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007572:	68db      	ldr	r3, [r3, #12]
 8007574:	6858      	ldr	r0, [r3, #4]
 8007576:	f7fc ff49 	bl	800440c <lwip_ntohl>
 800757a:	3001      	adds	r0, #1
 800757c:	4b2f      	ldr	r3, [pc, #188]	; (800763c <tcp_input+0x5b8>)
 800757e:	681b      	ldr	r3, [r3, #0]
 8007580:	4298      	cmp	r0, r3
 8007582:	d1de      	bne.n	8007542 <tcp_input+0x4be>
      pcb->snd_buf++;
 8007584:	f8b5 3066 	ldrh.w	r3, [r5, #102]	; 0x66
 8007588:	3301      	adds	r3, #1
 800758a:	f8a5 3066 	strh.w	r3, [r5, #102]	; 0x66
      pcb->rcv_nxt = seqno + 1;
 800758e:	4b28      	ldr	r3, [pc, #160]	; (8007630 <tcp_input+0x5ac>)
 8007590:	681b      	ldr	r3, [r3, #0]
 8007592:	1c5a      	adds	r2, r3, #1
 8007594:	62aa      	str	r2, [r5, #40]	; 0x28
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 8007596:	632a      	str	r2, [r5, #48]	; 0x30
      pcb->lastack = ackno;
 8007598:	64a8      	str	r0, [r5, #72]	; 0x48
      pcb->snd_wnd = tcphdr->wnd;
 800759a:	4a24      	ldr	r2, [pc, #144]	; (800762c <tcp_input+0x5a8>)
 800759c:	6812      	ldr	r2, [r2, #0]
 800759e:	89d1      	ldrh	r1, [r2, #14]
 80075a0:	f8a5 1060 	strh.w	r1, [r5, #96]	; 0x60
      pcb->snd_wnd_max = tcphdr->wnd;
 80075a4:	89d2      	ldrh	r2, [r2, #14]
 80075a6:	f8a5 2062 	strh.w	r2, [r5, #98]	; 0x62
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 80075aa:	3b01      	subs	r3, #1
 80075ac:	656b      	str	r3, [r5, #84]	; 0x54
      pcb->state = ESTABLISHED;
 80075ae:	2304      	movs	r3, #4
 80075b0:	762b      	strb	r3, [r5, #24]
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 80075b2:	18e9      	adds	r1, r5, r3
 80075b4:	8ee8      	ldrh	r0, [r5, #54]	; 0x36
 80075b6:	f7ff f863 	bl	8006680 <tcp_eff_send_mss>
 80075ba:	86e8      	strh	r0, [r5, #54]	; 0x36
      pcb->ssthresh = pcb->mss * 10;
 80075bc:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 80075c0:	005b      	lsls	r3, r3, #1
 80075c2:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 80075c6:	f8b5 304c 	ldrh.w	r3, [r5, #76]	; 0x4c
 80075ca:	2b01      	cmp	r3, #1
 80075cc:	bf04      	itt	eq
 80075ce:	0040      	lsleq	r0, r0, #1
 80075d0:	b280      	uxtheq	r0, r0
 80075d2:	f8a5 004c 	strh.w	r0, [r5, #76]	; 0x4c
      --pcb->snd_queuelen;
 80075d6:	f8b5 3068 	ldrh.w	r3, [r5, #104]	; 0x68
 80075da:	3b01      	subs	r3, #1
 80075dc:	f8a5 3068 	strh.w	r3, [r5, #104]	; 0x68
      rseg = pcb->unacked;
 80075e0:	6f28      	ldr	r0, [r5, #112]	; 0x70
      pcb->unacked = rseg->next;
 80075e2:	6803      	ldr	r3, [r0, #0]
 80075e4:	672b      	str	r3, [r5, #112]	; 0x70
      tcp_seg_free(rseg);
 80075e6:	f7fe fbb5 	bl	8005d54 <tcp_seg_free>
      if(pcb->unacked == NULL)
 80075ea:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80075ec:	b993      	cbnz	r3, 8007614 <tcp_input+0x590>
        pcb->rtime = -1;
 80075ee:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80075f2:	86ab      	strh	r3, [r5, #52]	; 0x34
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 80075f4:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 80075f8:	b13b      	cbz	r3, 800760a <tcp_input+0x586>
 80075fa:	2200      	movs	r2, #0
 80075fc:	4629      	mov	r1, r5
 80075fe:	6928      	ldr	r0, [r5, #16]
 8007600:	4798      	blx	r3
      if (err == ERR_ABRT) {
 8007602:	f110 0f0a 	cmn.w	r0, #10
 8007606:	f43f ae28 	beq.w	800725a <tcp_input+0x1d6>
      tcp_ack_now(pcb);
 800760a:	7fab      	ldrb	r3, [r5, #30]
 800760c:	f043 0302 	orr.w	r3, r3, #2
 8007610:	77ab      	strb	r3, [r5, #30]
 8007612:	e740      	b.n	8007496 <tcp_input+0x412>
        pcb->rtime = 0;
 8007614:	2300      	movs	r3, #0
 8007616:	86ab      	strh	r3, [r5, #52]	; 0x34
        pcb->nrtx = 0;
 8007618:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
 800761c:	e7ea      	b.n	80075f4 <tcp_input+0x570>
 800761e:	bf00      	nop
 8007620:	2000b234 	.word	0x2000b234
 8007624:	200089d8 	.word	0x200089d8
 8007628:	200089d0 	.word	0x200089d0
 800762c:	200077ac 	.word	0x200077ac
 8007630:	200077a8 	.word	0x200077a8
 8007634:	2000b22c 	.word	0x2000b22c
 8007638:	2000b228 	.word	0x2000b228
 800763c:	20007788 	.word	0x20007788
 8007640:	2000b110 	.word	0x2000b110
 8007644:	2000b244 	.word	0x2000b244
 8007648:	2000778c 	.word	0x2000778c
 800764c:	200077a4 	.word	0x200077a4
 8007650:	2000b230 	.word	0x2000b230
 8007654:	200077b0 	.word	0x200077b0
    if (flags & TCP_ACK) {
 8007658:	4b9f      	ldr	r3, [pc, #636]	; (80078d8 <tcp_input+0x854>)
 800765a:	781b      	ldrb	r3, [r3, #0]
 800765c:	f013 0f10 	tst.w	r3, #16
 8007660:	d049      	beq.n	80076f6 <tcp_input+0x672>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 8007662:	4b9e      	ldr	r3, [pc, #632]	; (80078dc <tcp_input+0x858>)
 8007664:	6818      	ldr	r0, [r3, #0]
 8007666:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8007668:	43db      	mvns	r3, r3
 800766a:	42c3      	cmn	r3, r0
 800766c:	d433      	bmi.n	80076d6 <tcp_input+0x652>
 800766e:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8007670:	1ac3      	subs	r3, r0, r3
 8007672:	2b00      	cmp	r3, #0
 8007674:	dc2f      	bgt.n	80076d6 <tcp_input+0x652>
        pcb->state = ESTABLISHED;
 8007676:	2304      	movs	r3, #4
 8007678:	762b      	strb	r3, [r5, #24]
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
 800767a:	696b      	ldr	r3, [r5, #20]
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 800767c:	b143      	cbz	r3, 8007690 <tcp_input+0x60c>
 800767e:	2200      	movs	r2, #0
 8007680:	4629      	mov	r1, r5
 8007682:	6928      	ldr	r0, [r5, #16]
 8007684:	4798      	blx	r3
        if (err != ERR_OK) {
 8007686:	b138      	cbz	r0, 8007698 <tcp_input+0x614>
          if (err != ERR_ABRT) {
 8007688:	f110 0f0a 	cmn.w	r0, #10
 800768c:	f43f ade5 	beq.w	800725a <tcp_input+0x1d6>
            tcp_abort(pcb);
 8007690:	4628      	mov	r0, r5
 8007692:	f7fe ff49 	bl	8006528 <tcp_abort>
 8007696:	e5e0      	b.n	800725a <tcp_input+0x1d6>
        old_cwnd = pcb->cwnd;
 8007698:	f8b5 404c 	ldrh.w	r4, [r5, #76]	; 0x4c
        tcp_receive(pcb);
 800769c:	4628      	mov	r0, r5
 800769e:	f7ff f8a9 	bl	80067f4 <tcp_receive>
        if (pcb->acked != 0) {
 80076a2:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
 80076a6:	b113      	cbz	r3, 80076ae <tcp_input+0x62a>
          pcb->acked--;
 80076a8:	3b01      	subs	r3, #1
 80076aa:	f8a5 3064 	strh.w	r3, [r5, #100]	; 0x64
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 80076ae:	2c01      	cmp	r4, #1
 80076b0:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
 80076b2:	bf04      	itt	eq
 80076b4:	005b      	lsleq	r3, r3, #1
 80076b6:	b29b      	uxtheq	r3, r3
 80076b8:	f8a5 304c 	strh.w	r3, [r5, #76]	; 0x4c
        if (recv_flags & TF_GOT_FIN) {
 80076bc:	4b88      	ldr	r3, [pc, #544]	; (80078e0 <tcp_input+0x85c>)
 80076be:	781b      	ldrb	r3, [r3, #0]
 80076c0:	f013 0f20 	tst.w	r3, #32
 80076c4:	f43f aee7 	beq.w	8007496 <tcp_input+0x412>
          tcp_ack_now(pcb);
 80076c8:	7fab      	ldrb	r3, [r5, #30]
 80076ca:	f043 0302 	orr.w	r3, r3, #2
 80076ce:	77ab      	strb	r3, [r5, #30]
          pcb->state = CLOSE_WAIT;
 80076d0:	2307      	movs	r3, #7
 80076d2:	762b      	strb	r3, [r5, #24]
 80076d4:	e6df      	b.n	8007496 <tcp_input+0x412>
                tcphdr->dest, tcphdr->src);
 80076d6:	4b83      	ldr	r3, [pc, #524]	; (80078e4 <tcp_input+0x860>)
 80076d8:	681b      	ldr	r3, [r3, #0]
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 80076da:	4a83      	ldr	r2, [pc, #524]	; (80078e8 <tcp_input+0x864>)
 80076dc:	8814      	ldrh	r4, [r2, #0]
 80076de:	4a83      	ldr	r2, [pc, #524]	; (80078ec <tcp_input+0x868>)
 80076e0:	6811      	ldr	r1, [r2, #0]
 80076e2:	881a      	ldrh	r2, [r3, #0]
 80076e4:	9201      	str	r2, [sp, #4]
 80076e6:	885b      	ldrh	r3, [r3, #2]
 80076e8:	9300      	str	r3, [sp, #0]
 80076ea:	4b81      	ldr	r3, [pc, #516]	; (80078f0 <tcp_input+0x86c>)
 80076ec:	4a81      	ldr	r2, [pc, #516]	; (80078f4 <tcp_input+0x870>)
 80076ee:	4421      	add	r1, r4
 80076f0:	f000 fc88 	bl	8008004 <tcp_rst>
 80076f4:	e6cf      	b.n	8007496 <tcp_input+0x412>
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 80076f6:	f013 0f02 	tst.w	r3, #2
 80076fa:	f43f aecc 	beq.w	8007496 <tcp_input+0x412>
 80076fe:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8007700:	3b01      	subs	r3, #1
 8007702:	4a7a      	ldr	r2, [pc, #488]	; (80078ec <tcp_input+0x868>)
 8007704:	6812      	ldr	r2, [r2, #0]
 8007706:	4293      	cmp	r3, r2
 8007708:	f47f aec5 	bne.w	8007496 <tcp_input+0x412>
      tcp_rexmit(pcb);
 800770c:	4628      	mov	r0, r5
 800770e:	f000 fce3 	bl	80080d8 <tcp_rexmit>
 8007712:	e6c0      	b.n	8007496 <tcp_input+0x412>
    tcp_receive(pcb);
 8007714:	4628      	mov	r0, r5
 8007716:	f7ff f86d 	bl	80067f4 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 800771a:	4b71      	ldr	r3, [pc, #452]	; (80078e0 <tcp_input+0x85c>)
 800771c:	781b      	ldrb	r3, [r3, #0]
 800771e:	f013 0f20 	tst.w	r3, #32
 8007722:	f43f aeb8 	beq.w	8007496 <tcp_input+0x412>
      tcp_ack_now(pcb);
 8007726:	7fab      	ldrb	r3, [r5, #30]
 8007728:	f043 0302 	orr.w	r3, r3, #2
 800772c:	77ab      	strb	r3, [r5, #30]
      pcb->state = CLOSE_WAIT;
 800772e:	2307      	movs	r3, #7
 8007730:	762b      	strb	r3, [r5, #24]
 8007732:	e6b0      	b.n	8007496 <tcp_input+0x412>
    tcp_receive(pcb);
 8007734:	4628      	mov	r0, r5
 8007736:	f7ff f85d 	bl	80067f4 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 800773a:	4b69      	ldr	r3, [pc, #420]	; (80078e0 <tcp_input+0x85c>)
 800773c:	781b      	ldrb	r3, [r3, #0]
 800773e:	f013 0f20 	tst.w	r3, #32
 8007742:	d041      	beq.n	80077c8 <tcp_input+0x744>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 8007744:	4b64      	ldr	r3, [pc, #400]	; (80078d8 <tcp_input+0x854>)
 8007746:	781b      	ldrb	r3, [r3, #0]
 8007748:	f013 0f10 	tst.w	r3, #16
 800774c:	d035      	beq.n	80077ba <tcp_input+0x736>
 800774e:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8007750:	4b62      	ldr	r3, [pc, #392]	; (80078dc <tcp_input+0x858>)
 8007752:	681b      	ldr	r3, [r3, #0]
 8007754:	429a      	cmp	r2, r3
 8007756:	d130      	bne.n	80077ba <tcp_input+0x736>
        tcp_ack_now(pcb);
 8007758:	7fab      	ldrb	r3, [r5, #30]
 800775a:	f043 0302 	orr.w	r3, r3, #2
 800775e:	77ab      	strb	r3, [r5, #30]
        tcp_pcb_purge(pcb);
 8007760:	4628      	mov	r0, r5
 8007762:	f7fe fb24 	bl	8005dae <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 8007766:	4b64      	ldr	r3, [pc, #400]	; (80078f8 <tcp_input+0x874>)
 8007768:	681b      	ldr	r3, [r3, #0]
 800776a:	429d      	cmp	r5, r3
 800776c:	d10e      	bne.n	800778c <tcp_input+0x708>
 800776e:	68ea      	ldr	r2, [r5, #12]
 8007770:	4b61      	ldr	r3, [pc, #388]	; (80078f8 <tcp_input+0x874>)
 8007772:	601a      	str	r2, [r3, #0]
 8007774:	2201      	movs	r2, #1
 8007776:	4b61      	ldr	r3, [pc, #388]	; (80078fc <tcp_input+0x878>)
 8007778:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 800777a:	230a      	movs	r3, #10
 800777c:	762b      	strb	r3, [r5, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800777e:	4b60      	ldr	r3, [pc, #384]	; (8007900 <tcp_input+0x87c>)
 8007780:	681a      	ldr	r2, [r3, #0]
 8007782:	60ea      	str	r2, [r5, #12]
 8007784:	601d      	str	r5, [r3, #0]
 8007786:	f000 fdc7 	bl	8008318 <tcp_timer_needed>
 800778a:	e684      	b.n	8007496 <tcp_input+0x412>
        TCP_RMV_ACTIVE(pcb);
 800778c:	4a5d      	ldr	r2, [pc, #372]	; (8007904 <tcp_input+0x880>)
 800778e:	6013      	str	r3, [r2, #0]
 8007790:	2200      	movs	r2, #0
 8007792:	2001      	movs	r0, #1
 8007794:	b92b      	cbnz	r3, 80077a2 <tcp_input+0x71e>
 8007796:	2a00      	cmp	r2, #0
 8007798:	d0ec      	beq.n	8007774 <tcp_input+0x6f0>
 800779a:	2200      	movs	r2, #0
 800779c:	4b59      	ldr	r3, [pc, #356]	; (8007904 <tcp_input+0x880>)
 800779e:	601a      	str	r2, [r3, #0]
 80077a0:	e7e8      	b.n	8007774 <tcp_input+0x6f0>
 80077a2:	68d9      	ldr	r1, [r3, #12]
 80077a4:	428d      	cmp	r5, r1
 80077a6:	d105      	bne.n	80077b4 <tcp_input+0x730>
 80077a8:	b10a      	cbz	r2, 80077ae <tcp_input+0x72a>
 80077aa:	4a56      	ldr	r2, [pc, #344]	; (8007904 <tcp_input+0x880>)
 80077ac:	6013      	str	r3, [r2, #0]
 80077ae:	68ea      	ldr	r2, [r5, #12]
 80077b0:	60da      	str	r2, [r3, #12]
 80077b2:	e7df      	b.n	8007774 <tcp_input+0x6f0>
 80077b4:	4602      	mov	r2, r0
 80077b6:	460b      	mov	r3, r1
 80077b8:	e7ec      	b.n	8007794 <tcp_input+0x710>
        tcp_ack_now(pcb);
 80077ba:	7fab      	ldrb	r3, [r5, #30]
 80077bc:	f043 0302 	orr.w	r3, r3, #2
 80077c0:	77ab      	strb	r3, [r5, #30]
        pcb->state = CLOSING;
 80077c2:	2308      	movs	r3, #8
 80077c4:	762b      	strb	r3, [r5, #24]
 80077c6:	e666      	b.n	8007496 <tcp_input+0x412>
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 80077c8:	4b43      	ldr	r3, [pc, #268]	; (80078d8 <tcp_input+0x854>)
 80077ca:	781b      	ldrb	r3, [r3, #0]
 80077cc:	f013 0f10 	tst.w	r3, #16
 80077d0:	f43f ae61 	beq.w	8007496 <tcp_input+0x412>
 80077d4:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 80077d6:	4b41      	ldr	r3, [pc, #260]	; (80078dc <tcp_input+0x858>)
 80077d8:	681b      	ldr	r3, [r3, #0]
 80077da:	429a      	cmp	r2, r3
 80077dc:	f47f ae5b 	bne.w	8007496 <tcp_input+0x412>
      pcb->state = FIN_WAIT_2;
 80077e0:	2306      	movs	r3, #6
 80077e2:	762b      	strb	r3, [r5, #24]
 80077e4:	e657      	b.n	8007496 <tcp_input+0x412>
    tcp_receive(pcb);
 80077e6:	4628      	mov	r0, r5
 80077e8:	f7ff f804 	bl	80067f4 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 80077ec:	4b3c      	ldr	r3, [pc, #240]	; (80078e0 <tcp_input+0x85c>)
 80077ee:	781b      	ldrb	r3, [r3, #0]
 80077f0:	f013 0f20 	tst.w	r3, #32
 80077f4:	f43f ae4f 	beq.w	8007496 <tcp_input+0x412>
      tcp_ack_now(pcb);
 80077f8:	7fab      	ldrb	r3, [r5, #30]
 80077fa:	f043 0302 	orr.w	r3, r3, #2
 80077fe:	77ab      	strb	r3, [r5, #30]
      tcp_pcb_purge(pcb);
 8007800:	4628      	mov	r0, r5
 8007802:	f7fe fad4 	bl	8005dae <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8007806:	4b3c      	ldr	r3, [pc, #240]	; (80078f8 <tcp_input+0x874>)
 8007808:	681b      	ldr	r3, [r3, #0]
 800780a:	429d      	cmp	r5, r3
 800780c:	d10e      	bne.n	800782c <tcp_input+0x7a8>
 800780e:	68ea      	ldr	r2, [r5, #12]
 8007810:	4b39      	ldr	r3, [pc, #228]	; (80078f8 <tcp_input+0x874>)
 8007812:	601a      	str	r2, [r3, #0]
 8007814:	2201      	movs	r2, #1
 8007816:	4b39      	ldr	r3, [pc, #228]	; (80078fc <tcp_input+0x878>)
 8007818:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
 800781a:	230a      	movs	r3, #10
 800781c:	762b      	strb	r3, [r5, #24]
      TCP_REG(&tcp_tw_pcbs, pcb);
 800781e:	4b38      	ldr	r3, [pc, #224]	; (8007900 <tcp_input+0x87c>)
 8007820:	681a      	ldr	r2, [r3, #0]
 8007822:	60ea      	str	r2, [r5, #12]
 8007824:	601d      	str	r5, [r3, #0]
 8007826:	f000 fd77 	bl	8008318 <tcp_timer_needed>
 800782a:	e634      	b.n	8007496 <tcp_input+0x412>
      TCP_RMV_ACTIVE(pcb);
 800782c:	4a35      	ldr	r2, [pc, #212]	; (8007904 <tcp_input+0x880>)
 800782e:	6013      	str	r3, [r2, #0]
 8007830:	2200      	movs	r2, #0
 8007832:	2001      	movs	r0, #1
 8007834:	e004      	b.n	8007840 <tcp_input+0x7bc>
 8007836:	68d9      	ldr	r1, [r3, #12]
 8007838:	428d      	cmp	r5, r1
 800783a:	d009      	beq.n	8007850 <tcp_input+0x7cc>
 800783c:	4602      	mov	r2, r0
 800783e:	460b      	mov	r3, r1
 8007840:	2b00      	cmp	r3, #0
 8007842:	d1f8      	bne.n	8007836 <tcp_input+0x7b2>
 8007844:	2a00      	cmp	r2, #0
 8007846:	d0e5      	beq.n	8007814 <tcp_input+0x790>
 8007848:	2200      	movs	r2, #0
 800784a:	4b2e      	ldr	r3, [pc, #184]	; (8007904 <tcp_input+0x880>)
 800784c:	601a      	str	r2, [r3, #0]
 800784e:	e7e1      	b.n	8007814 <tcp_input+0x790>
 8007850:	b10a      	cbz	r2, 8007856 <tcp_input+0x7d2>
 8007852:	4a2c      	ldr	r2, [pc, #176]	; (8007904 <tcp_input+0x880>)
 8007854:	6013      	str	r3, [r2, #0]
 8007856:	68ea      	ldr	r2, [r5, #12]
 8007858:	60da      	str	r2, [r3, #12]
 800785a:	e7db      	b.n	8007814 <tcp_input+0x790>
    tcp_receive(pcb);
 800785c:	4628      	mov	r0, r5
 800785e:	f7fe ffc9 	bl	80067f4 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 8007862:	4b1d      	ldr	r3, [pc, #116]	; (80078d8 <tcp_input+0x854>)
 8007864:	781b      	ldrb	r3, [r3, #0]
 8007866:	f013 0f10 	tst.w	r3, #16
 800786a:	f43f ae14 	beq.w	8007496 <tcp_input+0x412>
 800786e:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8007870:	4b1a      	ldr	r3, [pc, #104]	; (80078dc <tcp_input+0x858>)
 8007872:	681b      	ldr	r3, [r3, #0]
 8007874:	429a      	cmp	r2, r3
 8007876:	f47f ae0e 	bne.w	8007496 <tcp_input+0x412>
      tcp_pcb_purge(pcb);
 800787a:	4628      	mov	r0, r5
 800787c:	f7fe fa97 	bl	8005dae <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8007880:	4b1d      	ldr	r3, [pc, #116]	; (80078f8 <tcp_input+0x874>)
 8007882:	681b      	ldr	r3, [r3, #0]
 8007884:	429d      	cmp	r5, r3
 8007886:	d10e      	bne.n	80078a6 <tcp_input+0x822>
 8007888:	68ea      	ldr	r2, [r5, #12]
 800788a:	4b1b      	ldr	r3, [pc, #108]	; (80078f8 <tcp_input+0x874>)
 800788c:	601a      	str	r2, [r3, #0]
 800788e:	2201      	movs	r2, #1
 8007890:	4b1a      	ldr	r3, [pc, #104]	; (80078fc <tcp_input+0x878>)
 8007892:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
 8007894:	230a      	movs	r3, #10
 8007896:	762b      	strb	r3, [r5, #24]
      TCP_REG(&tcp_tw_pcbs, pcb);
 8007898:	4b19      	ldr	r3, [pc, #100]	; (8007900 <tcp_input+0x87c>)
 800789a:	681a      	ldr	r2, [r3, #0]
 800789c:	60ea      	str	r2, [r5, #12]
 800789e:	601d      	str	r5, [r3, #0]
 80078a0:	f000 fd3a 	bl	8008318 <tcp_timer_needed>
 80078a4:	e5f7      	b.n	8007496 <tcp_input+0x412>
      TCP_RMV_ACTIVE(pcb);
 80078a6:	4a17      	ldr	r2, [pc, #92]	; (8007904 <tcp_input+0x880>)
 80078a8:	6013      	str	r3, [r2, #0]
 80078aa:	2200      	movs	r2, #0
 80078ac:	2001      	movs	r0, #1
 80078ae:	e004      	b.n	80078ba <tcp_input+0x836>
 80078b0:	68d9      	ldr	r1, [r3, #12]
 80078b2:	428d      	cmp	r5, r1
 80078b4:	d009      	beq.n	80078ca <tcp_input+0x846>
 80078b6:	4602      	mov	r2, r0
 80078b8:	460b      	mov	r3, r1
 80078ba:	2b00      	cmp	r3, #0
 80078bc:	d1f8      	bne.n	80078b0 <tcp_input+0x82c>
 80078be:	2a00      	cmp	r2, #0
 80078c0:	d0e5      	beq.n	800788e <tcp_input+0x80a>
 80078c2:	2200      	movs	r2, #0
 80078c4:	4b0f      	ldr	r3, [pc, #60]	; (8007904 <tcp_input+0x880>)
 80078c6:	601a      	str	r2, [r3, #0]
 80078c8:	e7e1      	b.n	800788e <tcp_input+0x80a>
 80078ca:	b10a      	cbz	r2, 80078d0 <tcp_input+0x84c>
 80078cc:	4a0d      	ldr	r2, [pc, #52]	; (8007904 <tcp_input+0x880>)
 80078ce:	6013      	str	r3, [r2, #0]
 80078d0:	68ea      	ldr	r2, [r5, #12]
 80078d2:	60da      	str	r2, [r3, #12]
 80078d4:	e7db      	b.n	800788e <tcp_input+0x80a>
 80078d6:	bf00      	nop
 80078d8:	2000778c 	.word	0x2000778c
 80078dc:	20007788 	.word	0x20007788
 80078e0:	200077a4 	.word	0x200077a4
 80078e4:	200077ac 	.word	0x200077ac
 80078e8:	200077b0 	.word	0x200077b0
 80078ec:	200077a8 	.word	0x200077a8
 80078f0:	200089d0 	.word	0x200089d0
 80078f4:	200089d8 	.word	0x200089d8
 80078f8:	2000b22c 	.word	0x2000b22c
 80078fc:	2000b228 	.word	0x2000b228
 8007900:	2000b240 	.word	0x2000b240
 8007904:	2000b238 	.word	0x2000b238
    tcp_receive(pcb);
 8007908:	4628      	mov	r0, r5
 800790a:	f7fe ff73 	bl	80067f4 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 800790e:	4b53      	ldr	r3, [pc, #332]	; (8007a5c <tcp_input+0x9d8>)
 8007910:	781b      	ldrb	r3, [r3, #0]
 8007912:	f013 0f10 	tst.w	r3, #16
 8007916:	f43f adbe 	beq.w	8007496 <tcp_input+0x412>
 800791a:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 800791c:	4b50      	ldr	r3, [pc, #320]	; (8007a60 <tcp_input+0x9dc>)
 800791e:	681b      	ldr	r3, [r3, #0]
 8007920:	429a      	cmp	r2, r3
 8007922:	f47f adb8 	bne.w	8007496 <tcp_input+0x412>
      recv_flags |= TF_CLOSED;
 8007926:	4a4f      	ldr	r2, [pc, #316]	; (8007a64 <tcp_input+0x9e0>)
 8007928:	7813      	ldrb	r3, [r2, #0]
 800792a:	f043 0310 	orr.w	r3, r3, #16
 800792e:	7013      	strb	r3, [r2, #0]
 8007930:	e5b1      	b.n	8007496 <tcp_input+0x412>
      } else if (recv_flags & TF_CLOSED) {
 8007932:	f013 0f10 	tst.w	r3, #16
 8007936:	d013      	beq.n	8007960 <tcp_input+0x8dc>
        if (!(pcb->flags & TF_RXCLOSED)) {
 8007938:	7fab      	ldrb	r3, [r5, #30]
 800793a:	f013 0f10 	tst.w	r3, #16
 800793e:	d106      	bne.n	800794e <tcp_input+0x8ca>
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
 8007940:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 8007944:	b11b      	cbz	r3, 800794e <tcp_input+0x8ca>
 8007946:	f06f 010b 	mvn.w	r1, #11
 800794a:	6928      	ldr	r0, [r5, #16]
 800794c:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800794e:	4629      	mov	r1, r5
 8007950:	4845      	ldr	r0, [pc, #276]	; (8007a68 <tcp_input+0x9e4>)
 8007952:	f7fe fbfb 	bl	800614c <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 8007956:	4629      	mov	r1, r5
 8007958:	2002      	movs	r0, #2
 800795a:	f7fd fec5 	bl	80056e8 <memp_free>
 800795e:	e47c      	b.n	800725a <tcp_input+0x1d6>
        if (pcb->acked > 0) {
 8007960:	f8b5 2064 	ldrh.w	r2, [r5, #100]	; 0x64
 8007964:	b142      	cbz	r2, 8007978 <tcp_input+0x8f4>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
 8007966:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 8007968:	b133      	cbz	r3, 8007978 <tcp_input+0x8f4>
 800796a:	4629      	mov	r1, r5
 800796c:	6928      	ldr	r0, [r5, #16]
 800796e:	4798      	blx	r3
          if (err == ERR_ABRT) {
 8007970:	f110 0f0a 	cmn.w	r0, #10
 8007974:	f43f ac71 	beq.w	800725a <tcp_input+0x1d6>
        if (recv_data != NULL) {
 8007978:	4b3c      	ldr	r3, [pc, #240]	; (8007a6c <tcp_input+0x9e8>)
 800797a:	681a      	ldr	r2, [r3, #0]
 800797c:	b1ca      	cbz	r2, 80079b2 <tcp_input+0x92e>
          if (pcb->flags & TF_RXCLOSED) {
 800797e:	7fab      	ldrb	r3, [r5, #30]
 8007980:	f013 0f10 	tst.w	r3, #16
 8007984:	d006      	beq.n	8007994 <tcp_input+0x910>
            pbuf_free(recv_data);
 8007986:	4610      	mov	r0, r2
 8007988:	f7fd ffa5 	bl	80058d6 <pbuf_free>
            tcp_abort(pcb);
 800798c:	4628      	mov	r0, r5
 800798e:	f7fe fdcb 	bl	8006528 <tcp_abort>
            goto aborted;
 8007992:	e462      	b.n	800725a <tcp_input+0x1d6>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 8007994:	f8d5 4080 	ldr.w	r4, [r5, #128]	; 0x80
 8007998:	b1ec      	cbz	r4, 80079d6 <tcp_input+0x952>
 800799a:	2300      	movs	r3, #0
 800799c:	4629      	mov	r1, r5
 800799e:	6928      	ldr	r0, [r5, #16]
 80079a0:	47a0      	blx	r4
          if (err == ERR_ABRT) {
 80079a2:	f110 0f0a 	cmn.w	r0, #10
 80079a6:	f43f ac58 	beq.w	800725a <tcp_input+0x1d6>
          if (err != ERR_OK) {
 80079aa:	b110      	cbz	r0, 80079b2 <tcp_input+0x92e>
            pcb->refused_data = recv_data;
 80079ac:	4b2f      	ldr	r3, [pc, #188]	; (8007a6c <tcp_input+0x9e8>)
 80079ae:	681b      	ldr	r3, [r3, #0]
 80079b0:	67ab      	str	r3, [r5, #120]	; 0x78
        if (recv_flags & TF_GOT_FIN) {
 80079b2:	4b2c      	ldr	r3, [pc, #176]	; (8007a64 <tcp_input+0x9e0>)
 80079b4:	781b      	ldrb	r3, [r3, #0]
 80079b6:	f013 0f20 	tst.w	r3, #32
 80079ba:	d005      	beq.n	80079c8 <tcp_input+0x944>
          if (pcb->refused_data != NULL) {
 80079bc:	6fab      	ldr	r3, [r5, #120]	; 0x78
 80079be:	b183      	cbz	r3, 80079e2 <tcp_input+0x95e>
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 80079c0:	7b5a      	ldrb	r2, [r3, #13]
 80079c2:	f042 0220 	orr.w	r2, r2, #32
 80079c6:	735a      	strb	r2, [r3, #13]
        tcp_input_pcb = NULL;
 80079c8:	2200      	movs	r2, #0
 80079ca:	4b29      	ldr	r3, [pc, #164]	; (8007a70 <tcp_input+0x9ec>)
 80079cc:	601a      	str	r2, [r3, #0]
        tcp_output(pcb);
 80079ce:	4628      	mov	r0, r5
 80079d0:	f000 f9c0 	bl	8007d54 <tcp_output>
 80079d4:	e441      	b.n	800725a <tcp_input+0x1d6>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 80079d6:	2300      	movs	r3, #0
 80079d8:	4629      	mov	r1, r5
 80079da:	4618      	mov	r0, r3
 80079dc:	f7fe fcc6 	bl	800636c <tcp_recv_null>
 80079e0:	e7df      	b.n	80079a2 <tcp_input+0x91e>
            if (pcb->rcv_wnd != TCP_WND) {
 80079e2:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
 80079e4:	f241 62d0 	movw	r2, #5840	; 0x16d0
 80079e8:	4293      	cmp	r3, r2
              pcb->rcv_wnd++;
 80079ea:	bf1c      	itt	ne
 80079ec:	3301      	addne	r3, #1
 80079ee:	85ab      	strhne	r3, [r5, #44]	; 0x2c
            TCP_EVENT_CLOSED(pcb, err);
 80079f0:	f8d5 4080 	ldr.w	r4, [r5, #128]	; 0x80
 80079f4:	2c00      	cmp	r4, #0
 80079f6:	d0e7      	beq.n	80079c8 <tcp_input+0x944>
 80079f8:	2300      	movs	r3, #0
 80079fa:	461a      	mov	r2, r3
 80079fc:	4629      	mov	r1, r5
 80079fe:	6928      	ldr	r0, [r5, #16]
 8007a00:	47a0      	blx	r4
            if (err == ERR_ABRT) {
 8007a02:	f110 0f0a 	cmn.w	r0, #10
 8007a06:	d1df      	bne.n	80079c8 <tcp_input+0x944>
 8007a08:	e427      	b.n	800725a <tcp_input+0x1d6>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 8007a0a:	4b1a      	ldr	r3, [pc, #104]	; (8007a74 <tcp_input+0x9f0>)
 8007a0c:	681b      	ldr	r3, [r3, #0]
 8007a0e:	8998      	ldrh	r0, [r3, #12]
 8007a10:	f7fc fceb 	bl	80043ea <lwip_ntohs>
 8007a14:	f010 0f04 	tst.w	r0, #4
 8007a18:	d11b      	bne.n	8007a52 <tcp_input+0x9ce>
      TCP_STATS_INC(tcp.proterr);
 8007a1a:	4b17      	ldr	r3, [pc, #92]	; (8007a78 <tcp_input+0x9f4>)
 8007a1c:	f8b3 20a0 	ldrh.w	r2, [r3, #160]	; 0xa0
 8007a20:	3201      	adds	r2, #1
 8007a22:	f8a3 20a0 	strh.w	r2, [r3, #160]	; 0xa0
      TCP_STATS_INC(tcp.drop);
 8007a26:	f8b3 2096 	ldrh.w	r2, [r3, #150]	; 0x96
 8007a2a:	3201      	adds	r2, #1
 8007a2c:	f8a3 2096 	strh.w	r2, [r3, #150]	; 0x96
        tcphdr->dest, tcphdr->src);
 8007a30:	4b10      	ldr	r3, [pc, #64]	; (8007a74 <tcp_input+0x9f0>)
 8007a32:	681b      	ldr	r3, [r3, #0]
      tcp_rst(ackno, seqno + tcplen,
 8007a34:	4a11      	ldr	r2, [pc, #68]	; (8007a7c <tcp_input+0x9f8>)
 8007a36:	8810      	ldrh	r0, [r2, #0]
 8007a38:	4a11      	ldr	r2, [pc, #68]	; (8007a80 <tcp_input+0x9fc>)
 8007a3a:	6811      	ldr	r1, [r2, #0]
 8007a3c:	881a      	ldrh	r2, [r3, #0]
 8007a3e:	9201      	str	r2, [sp, #4]
 8007a40:	885b      	ldrh	r3, [r3, #2]
 8007a42:	9300      	str	r3, [sp, #0]
 8007a44:	4b0f      	ldr	r3, [pc, #60]	; (8007a84 <tcp_input+0xa00>)
 8007a46:	4a10      	ldr	r2, [pc, #64]	; (8007a88 <tcp_input+0xa04>)
 8007a48:	4401      	add	r1, r0
 8007a4a:	4805      	ldr	r0, [pc, #20]	; (8007a60 <tcp_input+0x9dc>)
 8007a4c:	6800      	ldr	r0, [r0, #0]
 8007a4e:	f000 fad9 	bl	8008004 <tcp_rst>
    pbuf_free(p);
 8007a52:	4620      	mov	r0, r4
 8007a54:	f7fd ff3f 	bl	80058d6 <pbuf_free>
 8007a58:	f7ff bb3e 	b.w	80070d8 <tcp_input+0x54>
 8007a5c:	2000778c 	.word	0x2000778c
 8007a60:	20007788 	.word	0x20007788
 8007a64:	200077a4 	.word	0x200077a4
 8007a68:	2000b22c 	.word	0x2000b22c
 8007a6c:	200077a0 	.word	0x200077a0
 8007a70:	2000b244 	.word	0x2000b244
 8007a74:	200077ac 	.word	0x200077ac
 8007a78:	2000b110 	.word	0x2000b110
 8007a7c:	200077b0 	.word	0x200077b0
 8007a80:	200077a8 	.word	0x200077a8
 8007a84:	200089d0 	.word	0x200089d0
 8007a88:	200089d8 	.word	0x200089d8

08007a8c <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
 8007a8c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007a90:	4681      	mov	r9, r0
 8007a92:	4688      	mov	r8, r1
 8007a94:	4616      	mov	r6, r2
 8007a96:	469a      	mov	sl, r3
 8007a98:	f89d 7020 	ldrb.w	r7, [sp, #32]
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 8007a9c:	f007 0301 	and.w	r3, r7, #1
 8007aa0:	f007 0202 	and.w	r2, r7, #2
 8007aa4:	2a00      	cmp	r2, #0
 8007aa6:	bf14      	ite	ne
 8007aa8:	250c      	movne	r5, #12
 8007aaa:	2500      	moveq	r5, #0
 8007aac:	eb05 0583 	add.w	r5, r5, r3, lsl #2

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 8007ab0:	2004      	movs	r0, #4
 8007ab2:	f7fd fde3 	bl	800567c <memp_malloc>
 8007ab6:	4604      	mov	r4, r0
 8007ab8:	b388      	cbz	r0, 8007b1e <tcp_create_segment+0x92>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
 8007aba:	7287      	strb	r7, [r0, #10]
  seg->next = NULL;
 8007abc:	2300      	movs	r3, #0
 8007abe:	6003      	str	r3, [r0, #0]
  seg->p = p;
 8007ac0:	f8c0 8004 	str.w	r8, [r0, #4]
  seg->len = p->tot_len - optlen;
 8007ac4:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 8007ac8:	1b5b      	subs	r3, r3, r5
 8007aca:	8103      	strh	r3, [r0, #8]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 8007acc:	2114      	movs	r1, #20
 8007ace:	4640      	mov	r0, r8
 8007ad0:	f7fd fec3 	bl	800585a <pbuf_header>
 8007ad4:	bb38      	cbnz	r0, 8007b26 <tcp_create_segment+0x9a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 8007ad6:	6863      	ldr	r3, [r4, #4]
 8007ad8:	685f      	ldr	r7, [r3, #4]
 8007ada:	60e7      	str	r7, [r4, #12]
  seg->tcphdr->src = htons(pcb->local_port);
 8007adc:	f8b9 001a 	ldrh.w	r0, [r9, #26]
 8007ae0:	f7fc fc7e 	bl	80043e0 <lwip_htons>
 8007ae4:	8038      	strh	r0, [r7, #0]
  seg->tcphdr->dest = htons(pcb->remote_port);
 8007ae6:	68e7      	ldr	r7, [r4, #12]
 8007ae8:	f8b9 001c 	ldrh.w	r0, [r9, #28]
 8007aec:	f7fc fc78 	bl	80043e0 <lwip_htons>
 8007af0:	8078      	strh	r0, [r7, #2]
  seg->tcphdr->seqno = htonl(seqno);
 8007af2:	68e7      	ldr	r7, [r4, #12]
 8007af4:	4650      	mov	r0, sl
 8007af6:	f7fc fc7d 	bl	80043f4 <lwip_htonl>
 8007afa:	6078      	str	r0, [r7, #4]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 8007afc:	68e7      	ldr	r7, [r4, #12]
 8007afe:	f3c5 0587 	ubfx	r5, r5, #2, #8
 8007b02:	3505      	adds	r5, #5
 8007b04:	ea46 3505 	orr.w	r5, r6, r5, lsl #12
 8007b08:	b2a8      	uxth	r0, r5
 8007b0a:	f7fc fc69 	bl	80043e0 <lwip_htons>
 8007b0e:	81b8      	strh	r0, [r7, #12]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 8007b10:	68e3      	ldr	r3, [r4, #12]
 8007b12:	2200      	movs	r2, #0
 8007b14:	749a      	strb	r2, [r3, #18]
 8007b16:	74da      	strb	r2, [r3, #19]
  return seg;
} 
 8007b18:	4620      	mov	r0, r4
 8007b1a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    pbuf_free(p);
 8007b1e:	4640      	mov	r0, r8
 8007b20:	f7fd fed9 	bl	80058d6 <pbuf_free>
    return NULL;
 8007b24:	e7f8      	b.n	8007b18 <tcp_create_segment+0x8c>
    TCP_STATS_INC(tcp.err);
 8007b26:	4a05      	ldr	r2, [pc, #20]	; (8007b3c <tcp_create_segment+0xb0>)
 8007b28:	f8b2 30a4 	ldrh.w	r3, [r2, #164]	; 0xa4
 8007b2c:	3301      	adds	r3, #1
 8007b2e:	f8a2 30a4 	strh.w	r3, [r2, #164]	; 0xa4
    tcp_seg_free(seg);
 8007b32:	4620      	mov	r0, r4
 8007b34:	f7fe f90e 	bl	8005d54 <tcp_seg_free>
    return NULL;
 8007b38:	2400      	movs	r4, #0
 8007b3a:	e7ed      	b.n	8007b18 <tcp_create_segment+0x8c>
 8007b3c:	2000b110 	.word	0x2000b110

08007b40 <tcp_output_alloc_header>:
{
 8007b40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007b44:	4606      	mov	r6, r0
 8007b46:	460c      	mov	r4, r1
 8007b48:	4698      	mov	r8, r3
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8007b4a:	3214      	adds	r2, #20
 8007b4c:	4411      	add	r1, r2
 8007b4e:	2200      	movs	r2, #0
 8007b50:	b289      	uxth	r1, r1
 8007b52:	2001      	movs	r0, #1
 8007b54:	f7fd feee 	bl	8005934 <pbuf_alloc>
  if (p != NULL) {
 8007b58:	4607      	mov	r7, r0
 8007b5a:	b328      	cbz	r0, 8007ba8 <tcp_output_alloc_header+0x68>
    tcphdr = (struct tcp_hdr *)p->payload;
 8007b5c:	6845      	ldr	r5, [r0, #4]
    tcphdr->src = htons(pcb->local_port);
 8007b5e:	8b70      	ldrh	r0, [r6, #26]
 8007b60:	f7fc fc3e 	bl	80043e0 <lwip_htons>
 8007b64:	8028      	strh	r0, [r5, #0]
    tcphdr->dest = htons(pcb->remote_port);
 8007b66:	8bb0      	ldrh	r0, [r6, #28]
 8007b68:	f7fc fc3a 	bl	80043e0 <lwip_htons>
 8007b6c:	8068      	strh	r0, [r5, #2]
    tcphdr->seqno = seqno_be;
 8007b6e:	f8c5 8004 	str.w	r8, [r5, #4]
    tcphdr->ackno = htonl(pcb->rcv_nxt);
 8007b72:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 8007b74:	f7fc fc3e 	bl	80043f4 <lwip_htonl>
 8007b78:	60a8      	str	r0, [r5, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 8007b7a:	08a0      	lsrs	r0, r4, #2
 8007b7c:	3005      	adds	r0, #5
 8007b7e:	0300      	lsls	r0, r0, #12
 8007b80:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
 8007b84:	f040 0010 	orr.w	r0, r0, #16
 8007b88:	f7fc fc2a 	bl	80043e0 <lwip_htons>
 8007b8c:	81a8      	strh	r0, [r5, #12]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8007b8e:	8df0      	ldrh	r0, [r6, #46]	; 0x2e
 8007b90:	f7fc fc26 	bl	80043e0 <lwip_htons>
 8007b94:	81e8      	strh	r0, [r5, #14]
    tcphdr->chksum = 0;
 8007b96:	2300      	movs	r3, #0
 8007b98:	742b      	strb	r3, [r5, #16]
 8007b9a:	746b      	strb	r3, [r5, #17]
    tcphdr->urgp = 0;
 8007b9c:	74ab      	strb	r3, [r5, #18]
 8007b9e:	74eb      	strb	r3, [r5, #19]
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8007ba0:	8df2      	ldrh	r2, [r6, #46]	; 0x2e
 8007ba2:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8007ba4:	4413      	add	r3, r2
 8007ba6:	6333      	str	r3, [r6, #48]	; 0x30
}
 8007ba8:	4638      	mov	r0, r7
 8007baa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08007bb0 <tcp_enqueue_flags>:

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8007bb0:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
 8007bb4:	2b07      	cmp	r3, #7
 8007bb6:	d825      	bhi.n	8007c04 <tcp_enqueue_flags+0x54>
{
 8007bb8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007bba:	b083      	sub	sp, #12
 8007bbc:	f001 0603 	and.w	r6, r1, #3
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

  if (flags & TCP_SYN) {
 8007bc0:	f001 0302 	and.w	r3, r1, #2
  u8_t optflags = 0;
 8007bc4:	f3c1 0740 	ubfx	r7, r1, #1, #1
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 8007bc8:	2b00      	cmp	r3, #0
 8007bca:	bf14      	ite	ne
 8007bcc:	f04f 0e04 	movne.w	lr, #4
 8007bd0:	f04f 0e00 	moveq.w	lr, #0

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
 8007bd4:	f8b0 3066 	ldrh.w	r3, [r0, #102]	; 0x66
 8007bd8:	b30b      	cbz	r3, 8007c1e <tcp_enqueue_flags+0x6e>
 8007bda:	460d      	mov	r5, r1
 8007bdc:	4604      	mov	r4, r0
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 8007bde:	2200      	movs	r2, #0
 8007be0:	4671      	mov	r1, lr
 8007be2:	4610      	mov	r0, r2
 8007be4:	f7fd fea6 	bl	8005934 <pbuf_alloc>
 8007be8:	4601      	mov	r1, r0
 8007bea:	b308      	cbz	r0, 8007c30 <tcp_enqueue_flags+0x80>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 8007bec:	9700      	str	r7, [sp, #0]
 8007bee:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8007bf0:	462a      	mov	r2, r5
 8007bf2:	4620      	mov	r0, r4
 8007bf4:	f7ff ff4a 	bl	8007a8c <tcp_create_segment>
 8007bf8:	4601      	mov	r1, r0
 8007bfa:	b330      	cbz	r0, 8007c4a <tcp_enqueue_flags+0x9a>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 8007bfc:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8007bfe:	bb92      	cbnz	r2, 8007c66 <tcp_enqueue_flags+0xb6>
    pcb->unsent = seg;
 8007c00:	66e0      	str	r0, [r4, #108]	; 0x6c
 8007c02:	e034      	b.n	8007c6e <tcp_enqueue_flags+0xbe>
    TCP_STATS_INC(tcp.memerr);
 8007c04:	4a29      	ldr	r2, [pc, #164]	; (8007cac <tcp_enqueue_flags+0xfc>)
 8007c06:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 8007c0a:	3301      	adds	r3, #1
 8007c0c:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    pcb->flags |= TF_NAGLEMEMERR;
 8007c10:	7f83      	ldrb	r3, [r0, #30]
 8007c12:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8007c16:	7783      	strb	r3, [r0, #30]
    return ERR_MEM;
 8007c18:	f04f 30ff 	mov.w	r0, #4294967295
 8007c1c:	4770      	bx	lr
    TCP_STATS_INC(tcp.memerr);
 8007c1e:	4a23      	ldr	r2, [pc, #140]	; (8007cac <tcp_enqueue_flags+0xfc>)
 8007c20:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 8007c24:	3301      	adds	r3, #1
 8007c26:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    return ERR_MEM;
 8007c2a:	f04f 30ff 	mov.w	r0, #4294967295
 8007c2e:	e03a      	b.n	8007ca6 <tcp_enqueue_flags+0xf6>
    pcb->flags |= TF_NAGLEMEMERR;
 8007c30:	7fa3      	ldrb	r3, [r4, #30]
 8007c32:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8007c36:	77a3      	strb	r3, [r4, #30]
    TCP_STATS_INC(tcp.memerr);
 8007c38:	4a1c      	ldr	r2, [pc, #112]	; (8007cac <tcp_enqueue_flags+0xfc>)
 8007c3a:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 8007c3e:	3301      	adds	r3, #1
 8007c40:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    return ERR_MEM;
 8007c44:	f04f 30ff 	mov.w	r0, #4294967295
 8007c48:	e02d      	b.n	8007ca6 <tcp_enqueue_flags+0xf6>
    pcb->flags |= TF_NAGLEMEMERR;
 8007c4a:	7fa3      	ldrb	r3, [r4, #30]
 8007c4c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8007c50:	77a3      	strb	r3, [r4, #30]
    TCP_STATS_INC(tcp.memerr);
 8007c52:	4a16      	ldr	r2, [pc, #88]	; (8007cac <tcp_enqueue_flags+0xfc>)
 8007c54:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 8007c58:	3301      	adds	r3, #1
 8007c5a:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    return ERR_MEM;
 8007c5e:	f04f 30ff 	mov.w	r0, #4294967295
 8007c62:	e020      	b.n	8007ca6 <tcp_enqueue_flags+0xf6>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 8007c64:	461a      	mov	r2, r3
 8007c66:	6813      	ldr	r3, [r2, #0]
 8007c68:	2b00      	cmp	r3, #0
 8007c6a:	d1fb      	bne.n	8007c64 <tcp_enqueue_flags+0xb4>
    useg->next = seg;
 8007c6c:	6011      	str	r1, [r2, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 8007c6e:	2300      	movs	r3, #0
 8007c70:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 8007c74:	b13e      	cbz	r6, 8007c86 <tcp_enqueue_flags+0xd6>
    pcb->snd_lbb++;
 8007c76:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8007c78:	3301      	adds	r3, #1
 8007c7a:	65e3      	str	r3, [r4, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 8007c7c:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
 8007c80:	3b01      	subs	r3, #1
 8007c82:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
  }
  if (flags & TCP_FIN) {
 8007c86:	f015 0f01 	tst.w	r5, #1
 8007c8a:	d003      	beq.n	8007c94 <tcp_enqueue_flags+0xe4>
    pcb->flags |= TF_FIN;
 8007c8c:	7fa3      	ldrb	r3, [r4, #30]
 8007c8e:	f043 0320 	orr.w	r3, r3, #32
 8007c92:	77a3      	strb	r3, [r4, #30]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 8007c94:	6848      	ldr	r0, [r1, #4]
 8007c96:	f7fd ff10 	bl	8005aba <pbuf_clen>
 8007c9a:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8007c9e:	4418      	add	r0, r3
 8007ca0:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 8007ca4:	2000      	movs	r0, #0
}
 8007ca6:	b003      	add	sp, #12
 8007ca8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007caa:	bf00      	nop
 8007cac:	2000b110 	.word	0x2000b110

08007cb0 <tcp_send_fin>:
{
 8007cb0:	b570      	push	{r4, r5, r6, lr}
 8007cb2:	4605      	mov	r5, r0
  if (pcb->unsent != NULL) {
 8007cb4:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
 8007cb6:	b90c      	cbnz	r4, 8007cbc <tcp_send_fin+0xc>
 8007cb8:	e00a      	b.n	8007cd0 <tcp_send_fin+0x20>
         last_unsent = last_unsent->next);
 8007cba:	461c      	mov	r4, r3
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8007cbc:	6823      	ldr	r3, [r4, #0]
 8007cbe:	2b00      	cmp	r3, #0
 8007cc0:	d1fb      	bne.n	8007cba <tcp_send_fin+0xa>
    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 8007cc2:	68e3      	ldr	r3, [r4, #12]
 8007cc4:	8998      	ldrh	r0, [r3, #12]
 8007cc6:	f7fc fb90 	bl	80043ea <lwip_ntohs>
 8007cca:	f010 0f07 	tst.w	r0, #7
 8007cce:	d004      	beq.n	8007cda <tcp_send_fin+0x2a>
  return tcp_enqueue_flags(pcb, TCP_FIN);
 8007cd0:	2101      	movs	r1, #1
 8007cd2:	4628      	mov	r0, r5
 8007cd4:	f7ff ff6c 	bl	8007bb0 <tcp_enqueue_flags>
}
 8007cd8:	bd70      	pop	{r4, r5, r6, pc}
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 8007cda:	68e6      	ldr	r6, [r4, #12]
 8007cdc:	89b4      	ldrh	r4, [r6, #12]
 8007cde:	2001      	movs	r0, #1
 8007ce0:	f7fc fb7e 	bl	80043e0 <lwip_htons>
 8007ce4:	4320      	orrs	r0, r4
 8007ce6:	81b0      	strh	r0, [r6, #12]
      pcb->flags |= TF_FIN;
 8007ce8:	7fab      	ldrb	r3, [r5, #30]
 8007cea:	f043 0320 	orr.w	r3, r3, #32
 8007cee:	77ab      	strb	r3, [r5, #30]
      return ERR_OK;
 8007cf0:	2000      	movs	r0, #0
 8007cf2:	bd70      	pop	{r4, r5, r6, pc}

08007cf4 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 8007cf4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007cf6:	b083      	sub	sp, #12
 8007cf8:	4604      	mov	r4, r0
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
 8007cfa:	6d00      	ldr	r0, [r0, #80]	; 0x50
 8007cfc:	f7fc fb7a 	bl	80043f4 <lwip_htonl>
 8007d00:	4603      	mov	r3, r0
 8007d02:	2200      	movs	r2, #0
 8007d04:	4611      	mov	r1, r2
 8007d06:	4620      	mov	r0, r4
 8007d08:	f7ff ff1a 	bl	8007b40 <tcp_output_alloc_header>
  if (p == NULL) {
 8007d0c:	b1f0      	cbz	r0, 8007d4c <tcp_send_empty_ack+0x58>
 8007d0e:	4605      	mov	r5, r0
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8007d10:	6847      	ldr	r7, [r0, #4]
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8007d12:	7fa3      	ldrb	r3, [r4, #30]
 8007d14:	f023 0303 	bic.w	r3, r3, #3
 8007d18:	77a3      	strb	r3, [r4, #30]
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
 8007d1a:	1d26      	adds	r6, r4, #4
 8007d1c:	8903      	ldrh	r3, [r0, #8]
 8007d1e:	9300      	str	r3, [sp, #0]
 8007d20:	2306      	movs	r3, #6
 8007d22:	4632      	mov	r2, r6
 8007d24:	4621      	mov	r1, r4
 8007d26:	f7fc fcf3 	bl	8004710 <inet_chksum_pseudo>
 8007d2a:	8238      	strh	r0, [r7, #16]
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 8007d2c:	7aa3      	ldrb	r3, [r4, #10]
 8007d2e:	2206      	movs	r2, #6
 8007d30:	9201      	str	r2, [sp, #4]
 8007d32:	7a62      	ldrb	r2, [r4, #9]
 8007d34:	9200      	str	r2, [sp, #0]
 8007d36:	4632      	mov	r2, r6
 8007d38:	4621      	mov	r1, r4
 8007d3a:	4628      	mov	r0, r5
 8007d3c:	f7fc ff28 	bl	8004b90 <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
 8007d40:	4628      	mov	r0, r5
 8007d42:	f7fd fdc8 	bl	80058d6 <pbuf_free>

  return ERR_OK;
 8007d46:	2000      	movs	r0, #0
}
 8007d48:	b003      	add	sp, #12
 8007d4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return ERR_BUF;
 8007d4c:	f06f 0001 	mvn.w	r0, #1
 8007d50:	e7fa      	b.n	8007d48 <tcp_send_empty_ack+0x54>
	...

08007d54 <tcp_output>:

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 8007d54:	4ba8      	ldr	r3, [pc, #672]	; (8007ff8 <tcp_output+0x2a4>)
 8007d56:	681b      	ldr	r3, [r3, #0]
 8007d58:	4298      	cmp	r0, r3
 8007d5a:	f000 814a 	beq.w	8007ff2 <tcp_output+0x29e>
{
 8007d5e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007d62:	b083      	sub	sp, #12
 8007d64:	4605      	mov	r5, r0
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 8007d66:	f8b0 a060 	ldrh.w	sl, [r0, #96]	; 0x60
 8007d6a:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
 8007d6e:	459a      	cmp	sl, r3
 8007d70:	bf28      	it	cs
 8007d72:	469a      	movcs	sl, r3

  seg = pcb->unsent;
 8007d74:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 8007d76:	7f83      	ldrb	r3, [r0, #30]
 8007d78:	f013 0f02 	tst.w	r3, #2
 8007d7c:	d014      	beq.n	8007da8 <tcp_output+0x54>
 8007d7e:	b17c      	cbz	r4, 8007da0 <tcp_output+0x4c>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 8007d80:	68e3      	ldr	r3, [r4, #12]
 8007d82:	6858      	ldr	r0, [r3, #4]
 8007d84:	f7fc fb42 	bl	800440c <lwip_ntohl>
 8007d88:	8923      	ldrh	r3, [r4, #8]
 8007d8a:	6caa      	ldr	r2, [r5, #72]	; 0x48
 8007d8c:	1a9b      	subs	r3, r3, r2
 8007d8e:	4418      	add	r0, r3
     (seg == NULL ||
 8007d90:	4582      	cmp	sl, r0
 8007d92:	d305      	bcc.n	8007da0 <tcp_output+0x4c>
     return tcp_send_empty_ack(pcb);
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 8007d94:	f8d5 8070 	ldr.w	r8, [r5, #112]	; 0x70
  if (useg != NULL) {
 8007d98:	f1b8 0f00 	cmp.w	r8, #0
 8007d9c:	d10f      	bne.n	8007dbe <tcp_output+0x6a>
 8007d9e:	e015      	b.n	8007dcc <tcp_output+0x78>
     return tcp_send_empty_ack(pcb);
 8007da0:	4628      	mov	r0, r5
 8007da2:	f7ff ffa7 	bl	8007cf4 <tcp_send_empty_ack>
 8007da6:	e121      	b.n	8007fec <tcp_output+0x298>
  useg = pcb->unacked;
 8007da8:	f8d0 8070 	ldr.w	r8, [r0, #112]	; 0x70
  if (useg != NULL) {
 8007dac:	f1b8 0f00 	cmp.w	r8, #0
 8007db0:	d105      	bne.n	8007dbe <tcp_output+0x6a>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 8007db2:	b95c      	cbnz	r4, 8007dcc <tcp_output+0x78>
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8007db4:	2300      	movs	r3, #0
 8007db6:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
 8007dba:	e112      	b.n	8007fe2 <tcp_output+0x28e>
    for (; useg->next != NULL; useg = useg->next);
 8007dbc:	4698      	mov	r8, r3
 8007dbe:	f8d8 3000 	ldr.w	r3, [r8]
 8007dc2:	2b00      	cmp	r3, #0
 8007dc4:	d1fa      	bne.n	8007dbc <tcp_output+0x68>
  while (seg != NULL &&
 8007dc6:	2c00      	cmp	r4, #0
 8007dc8:	f000 8107 	beq.w	8007fda <tcp_output+0x286>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
 8007dcc:	f8df 922c 	ldr.w	r9, [pc, #556]	; 8007ffc <tcp_output+0x2a8>
    pcb->rttest = tcp_ticks;
 8007dd0:	f8df b22c 	ldr.w	fp, [pc, #556]	; 8008000 <tcp_output+0x2ac>
 8007dd4:	e0a8      	b.n	8007f28 <tcp_output+0x1d4>
    if((tcp_do_output_nagle(pcb) == 0) &&
 8007dd6:	f8b5 2066 	ldrh.w	r2, [r5, #102]	; 0x66
 8007dda:	b13a      	cbz	r2, 8007dec <tcp_output+0x98>
 8007ddc:	f8b5 2068 	ldrh.w	r2, [r5, #104]	; 0x68
 8007de0:	2a07      	cmp	r2, #7
 8007de2:	d803      	bhi.n	8007dec <tcp_output+0x98>
 8007de4:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 8007de8:	f000 80f7 	beq.w	8007fda <tcp_output+0x286>
    pcb->unsent = seg->next;
 8007dec:	6823      	ldr	r3, [r4, #0]
 8007dee:	66eb      	str	r3, [r5, #108]	; 0x6c
    if (pcb->state != SYN_SENT) {
 8007df0:	7e2b      	ldrb	r3, [r5, #24]
 8007df2:	2b02      	cmp	r3, #2
 8007df4:	d00a      	beq.n	8007e0c <tcp_output+0xb8>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 8007df6:	68e7      	ldr	r7, [r4, #12]
 8007df8:	89be      	ldrh	r6, [r7, #12]
 8007dfa:	2010      	movs	r0, #16
 8007dfc:	f7fc faf0 	bl	80043e0 <lwip_htons>
 8007e00:	4330      	orrs	r0, r6
 8007e02:	81b8      	strh	r0, [r7, #12]
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8007e04:	7fab      	ldrb	r3, [r5, #30]
 8007e06:	f023 0303 	bic.w	r3, r3, #3
 8007e0a:	77ab      	strb	r3, [r5, #30]
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
 8007e0c:	68e6      	ldr	r6, [r4, #12]
 8007e0e:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 8007e10:	f7fc faf0 	bl	80043f4 <lwip_htonl>
 8007e14:	60b0      	str	r0, [r6, #8]
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8007e16:	68e6      	ldr	r6, [r4, #12]
 8007e18:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
 8007e1a:	f7fc fae1 	bl	80043e0 <lwip_htons>
 8007e1e:	81f0      	strh	r0, [r6, #14]
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8007e20:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
 8007e22:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8007e24:	4413      	add	r3, r2
 8007e26:	632b      	str	r3, [r5, #48]	; 0x30
  if (seg->flags & TF_SEG_OPTS_MSS) {
 8007e28:	7aa3      	ldrb	r3, [r4, #10]
 8007e2a:	f013 0f01 	tst.w	r3, #1
 8007e2e:	f040 80a0 	bne.w	8007f72 <tcp_output+0x21e>
  if (pcb->rtime == -1) {
 8007e32:	f9b5 3034 	ldrsh.w	r3, [r5, #52]	; 0x34
 8007e36:	f1b3 3fff 	cmp.w	r3, #4294967295
    pcb->rtime = 0;
 8007e3a:	bf04      	itt	eq
 8007e3c:	2300      	moveq	r3, #0
 8007e3e:	86ab      	strheq	r3, [r5, #52]	; 0x34
  if (ip_addr_isany(&(pcb->local_ip))) {
 8007e40:	b10d      	cbz	r5, 8007e46 <tcp_output+0xf2>
 8007e42:	682b      	ldr	r3, [r5, #0]
 8007e44:	b933      	cbnz	r3, 8007e54 <tcp_output+0x100>
    netif = ip_route(&(pcb->remote_ip));
 8007e46:	1d28      	adds	r0, r5, #4
 8007e48:	f7fc fcda 	bl	8004800 <ip_route>
    if (netif == NULL) {
 8007e4c:	2800      	cmp	r0, #0
 8007e4e:	d032      	beq.n	8007eb6 <tcp_output+0x162>
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
 8007e50:	6843      	ldr	r3, [r0, #4]
 8007e52:	602b      	str	r3, [r5, #0]
  if (pcb->rttest == 0) {
 8007e54:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8007e56:	2b00      	cmp	r3, #0
 8007e58:	f000 8097 	beq.w	8007f8a <tcp_output+0x236>
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8007e5c:	6862      	ldr	r2, [r4, #4]
 8007e5e:	68e3      	ldr	r3, [r4, #12]
 8007e60:	6851      	ldr	r1, [r2, #4]
 8007e62:	1a5b      	subs	r3, r3, r1
 8007e64:	b29b      	uxth	r3, r3
  seg->p->len -= len;
 8007e66:	8951      	ldrh	r1, [r2, #10]
 8007e68:	1ac9      	subs	r1, r1, r3
 8007e6a:	8151      	strh	r1, [r2, #10]
  seg->p->tot_len -= len;
 8007e6c:	6861      	ldr	r1, [r4, #4]
 8007e6e:	890a      	ldrh	r2, [r1, #8]
 8007e70:	1ad3      	subs	r3, r2, r3
 8007e72:	810b      	strh	r3, [r1, #8]
  seg->p->payload = seg->tcphdr;
 8007e74:	6863      	ldr	r3, [r4, #4]
 8007e76:	68e2      	ldr	r2, [r4, #12]
 8007e78:	605a      	str	r2, [r3, #4]
  seg->tcphdr->chksum = 0;
 8007e7a:	68e3      	ldr	r3, [r4, #12]
 8007e7c:	2200      	movs	r2, #0
 8007e7e:	741a      	strb	r2, [r3, #16]
 8007e80:	745a      	strb	r2, [r3, #17]
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
 8007e82:	68e7      	ldr	r7, [r4, #12]
 8007e84:	6860      	ldr	r0, [r4, #4]
 8007e86:	1d2e      	adds	r6, r5, #4
 8007e88:	8903      	ldrh	r3, [r0, #8]
 8007e8a:	9300      	str	r3, [sp, #0]
 8007e8c:	2306      	movs	r3, #6
 8007e8e:	4632      	mov	r2, r6
 8007e90:	4629      	mov	r1, r5
 8007e92:	f7fc fc3d 	bl	8004710 <inet_chksum_pseudo>
 8007e96:	8238      	strh	r0, [r7, #16]
  TCP_STATS_INC(tcp.xmit);
 8007e98:	f8b9 3090 	ldrh.w	r3, [r9, #144]	; 0x90
 8007e9c:	3301      	adds	r3, #1
 8007e9e:	f8a9 3090 	strh.w	r3, [r9, #144]	; 0x90

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 8007ea2:	7aab      	ldrb	r3, [r5, #10]
 8007ea4:	6860      	ldr	r0, [r4, #4]
 8007ea6:	2206      	movs	r2, #6
 8007ea8:	9201      	str	r2, [sp, #4]
 8007eaa:	7a6a      	ldrb	r2, [r5, #9]
 8007eac:	9200      	str	r2, [sp, #0]
 8007eae:	4632      	mov	r2, r6
 8007eb0:	4629      	mov	r1, r5
 8007eb2:	f7fc fe6d 	bl	8004b90 <ip_output>
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 8007eb6:	68e3      	ldr	r3, [r4, #12]
 8007eb8:	6858      	ldr	r0, [r3, #4]
 8007eba:	f7fc faa7 	bl	800440c <lwip_ntohl>
 8007ebe:	4606      	mov	r6, r0
 8007ec0:	8927      	ldrh	r7, [r4, #8]
 8007ec2:	68e3      	ldr	r3, [r4, #12]
 8007ec4:	8998      	ldrh	r0, [r3, #12]
 8007ec6:	f7fc fa90 	bl	80043ea <lwip_ntohs>
 8007eca:	f010 0003 	ands.w	r0, r0, #3
 8007ece:	bf18      	it	ne
 8007ed0:	2001      	movne	r0, #1
 8007ed2:	4438      	add	r0, r7
 8007ed4:	4406      	add	r6, r0
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 8007ed6:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8007ed8:	1b9b      	subs	r3, r3, r6
 8007eda:	2b00      	cmp	r3, #0
      pcb->snd_nxt = snd_nxt;
 8007edc:	bfb8      	it	lt
 8007ede:	652e      	strlt	r6, [r5, #80]	; 0x50
    if (TCP_TCPLEN(seg) > 0) {
 8007ee0:	8926      	ldrh	r6, [r4, #8]
 8007ee2:	68e3      	ldr	r3, [r4, #12]
 8007ee4:	8998      	ldrh	r0, [r3, #12]
 8007ee6:	f7fc fa80 	bl	80043ea <lwip_ntohs>
 8007eea:	f010 0003 	ands.w	r0, r0, #3
 8007eee:	bf18      	it	ne
 8007ef0:	2001      	movne	r0, #1
 8007ef2:	42f0      	cmn	r0, r6
 8007ef4:	d06d      	beq.n	8007fd2 <tcp_output+0x27e>
      seg->next = NULL;
 8007ef6:	2300      	movs	r3, #0
 8007ef8:	6023      	str	r3, [r4, #0]
      if (pcb->unacked == NULL) {
 8007efa:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007efc:	2b00      	cmp	r3, #0
 8007efe:	d04d      	beq.n	8007f9c <tcp_output+0x248>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
 8007f00:	68e3      	ldr	r3, [r4, #12]
 8007f02:	6858      	ldr	r0, [r3, #4]
 8007f04:	f7fc fa82 	bl	800440c <lwip_ntohl>
 8007f08:	4606      	mov	r6, r0
 8007f0a:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8007f0e:	6858      	ldr	r0, [r3, #4]
 8007f10:	f7fc fa7c 	bl	800440c <lwip_ntohl>
 8007f14:	1a30      	subs	r0, r6, r0
 8007f16:	2800      	cmp	r0, #0
 8007f18:	db43      	blt.n	8007fa2 <tcp_output+0x24e>
          useg->next = seg;
 8007f1a:	f8c8 4000 	str.w	r4, [r8]
 8007f1e:	46a0      	mov	r8, r4
    seg = pcb->unsent;
 8007f20:	6eec      	ldr	r4, [r5, #108]	; 0x6c
  while (seg != NULL &&
 8007f22:	2c00      	cmp	r4, #0
 8007f24:	f43f af46 	beq.w	8007db4 <tcp_output+0x60>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 8007f28:	68e3      	ldr	r3, [r4, #12]
 8007f2a:	6858      	ldr	r0, [r3, #4]
 8007f2c:	f7fc fa6e 	bl	800440c <lwip_ntohl>
 8007f30:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8007f32:	1ac0      	subs	r0, r0, r3
 8007f34:	8923      	ldrh	r3, [r4, #8]
 8007f36:	4418      	add	r0, r3
  while (seg != NULL &&
 8007f38:	4582      	cmp	sl, r0
 8007f3a:	d34e      	bcc.n	8007fda <tcp_output+0x286>
    LWIP_ASSERT("RST not expected here!", 
 8007f3c:	68e3      	ldr	r3, [r4, #12]
 8007f3e:	8998      	ldrh	r0, [r3, #12]
 8007f40:	f7fc fa53 	bl	80043ea <lwip_ntohs>
    if((tcp_do_output_nagle(pcb) == 0) &&
 8007f44:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007f46:	2b00      	cmp	r3, #0
 8007f48:	f43f af50 	beq.w	8007dec <tcp_output+0x98>
 8007f4c:	7fab      	ldrb	r3, [r5, #30]
 8007f4e:	f013 0f44 	tst.w	r3, #68	; 0x44
 8007f52:	f47f af4b 	bne.w	8007dec <tcp_output+0x98>
 8007f56:	6eea      	ldr	r2, [r5, #108]	; 0x6c
 8007f58:	2a00      	cmp	r2, #0
 8007f5a:	f43f af3c 	beq.w	8007dd6 <tcp_output+0x82>
 8007f5e:	6811      	ldr	r1, [r2, #0]
 8007f60:	2900      	cmp	r1, #0
 8007f62:	f47f af43 	bne.w	8007dec <tcp_output+0x98>
 8007f66:	8911      	ldrh	r1, [r2, #8]
 8007f68:	8eea      	ldrh	r2, [r5, #54]	; 0x36
 8007f6a:	4291      	cmp	r1, r2
 8007f6c:	f4bf af3e 	bcs.w	8007dec <tcp_output+0x98>
 8007f70:	e731      	b.n	8007dd6 <tcp_output+0x82>
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 8007f72:	68e6      	ldr	r6, [r4, #12]
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
 8007f74:	1d29      	adds	r1, r5, #4
 8007f76:	f240 50b4 	movw	r0, #1460	; 0x5b4
 8007f7a:	f7fe fb81 	bl	8006680 <tcp_eff_send_mss>
    *opts = TCP_BUILD_MSS_OPTION(mss);
 8007f7e:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
 8007f82:	f7fc fa37 	bl	80043f4 <lwip_htonl>
 8007f86:	6170      	str	r0, [r6, #20]
 8007f88:	e753      	b.n	8007e32 <tcp_output+0xde>
    pcb->rttest = tcp_ticks;
 8007f8a:	f8db 3000 	ldr.w	r3, [fp]
 8007f8e:	63ab      	str	r3, [r5, #56]	; 0x38
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 8007f90:	68e3      	ldr	r3, [r4, #12]
 8007f92:	6858      	ldr	r0, [r3, #4]
 8007f94:	f7fc fa3a 	bl	800440c <lwip_ntohl>
 8007f98:	63e8      	str	r0, [r5, #60]	; 0x3c
 8007f9a:	e75f      	b.n	8007e5c <tcp_output+0x108>
        pcb->unacked = seg;
 8007f9c:	672c      	str	r4, [r5, #112]	; 0x70
 8007f9e:	46a0      	mov	r8, r4
 8007fa0:	e7be      	b.n	8007f20 <tcp_output+0x1cc>
          struct tcp_seg **cur_seg = &(pcb->unacked);
 8007fa2:	f105 0770 	add.w	r7, r5, #112	; 0x70
          while (*cur_seg &&
 8007fa6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007fa8:	b17b      	cbz	r3, 8007fca <tcp_output+0x276>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 8007faa:	68db      	ldr	r3, [r3, #12]
 8007fac:	6858      	ldr	r0, [r3, #4]
 8007fae:	f7fc fa2d 	bl	800440c <lwip_ntohl>
 8007fb2:	4606      	mov	r6, r0
 8007fb4:	68e3      	ldr	r3, [r4, #12]
 8007fb6:	6858      	ldr	r0, [r3, #4]
 8007fb8:	f7fc fa28 	bl	800440c <lwip_ntohl>
 8007fbc:	1a30      	subs	r0, r6, r0
          while (*cur_seg &&
 8007fbe:	2800      	cmp	r0, #0
 8007fc0:	da03      	bge.n	8007fca <tcp_output+0x276>
              cur_seg = &((*cur_seg)->next );
 8007fc2:	683f      	ldr	r7, [r7, #0]
          while (*cur_seg &&
 8007fc4:	683b      	ldr	r3, [r7, #0]
 8007fc6:	2b00      	cmp	r3, #0
 8007fc8:	d1ef      	bne.n	8007faa <tcp_output+0x256>
          seg->next = (*cur_seg);
 8007fca:	683b      	ldr	r3, [r7, #0]
 8007fcc:	6023      	str	r3, [r4, #0]
          (*cur_seg) = seg;
 8007fce:	603c      	str	r4, [r7, #0]
 8007fd0:	e7a6      	b.n	8007f20 <tcp_output+0x1cc>
      tcp_seg_free(seg);
 8007fd2:	4620      	mov	r0, r4
 8007fd4:	f7fd febe 	bl	8005d54 <tcp_seg_free>
 8007fd8:	e7a2      	b.n	8007f20 <tcp_output+0x1cc>
  if (pcb->unsent == NULL) {
 8007fda:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 8007fdc:	2b00      	cmp	r3, #0
 8007fde:	f43f aee9 	beq.w	8007db4 <tcp_output+0x60>
  pcb->flags &= ~TF_NAGLEMEMERR;
 8007fe2:	7fab      	ldrb	r3, [r5, #30]
 8007fe4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8007fe8:	77ab      	strb	r3, [r5, #30]
  return ERR_OK;
 8007fea:	2000      	movs	r0, #0
}
 8007fec:	b003      	add	sp, #12
 8007fee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return ERR_OK;
 8007ff2:	2000      	movs	r0, #0
 8007ff4:	4770      	bx	lr
 8007ff6:	bf00      	nop
 8007ff8:	2000b244 	.word	0x2000b244
 8007ffc:	2000b110 	.word	0x2000b110
 8008000:	2000b230 	.word	0x2000b230

08008004 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 8008004:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008008:	b083      	sub	sp, #12
 800800a:	4681      	mov	r9, r0
 800800c:	460e      	mov	r6, r1
 800800e:	4617      	mov	r7, r2
 8008010:	4698      	mov	r8, r3
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 8008012:	2200      	movs	r2, #0
 8008014:	2114      	movs	r1, #20
 8008016:	2001      	movs	r0, #1
 8008018:	f7fd fc8c 	bl	8005934 <pbuf_alloc>
  if (p == NULL) {
 800801c:	2800      	cmp	r0, #0
 800801e:	d03d      	beq.n	800809c <tcp_rst+0x98>
 8008020:	4605      	mov	r5, r0
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
 8008022:	6844      	ldr	r4, [r0, #4]
  tcphdr->src = htons(local_port);
 8008024:	f8bd 0028 	ldrh.w	r0, [sp, #40]	; 0x28
 8008028:	f7fc f9da 	bl	80043e0 <lwip_htons>
 800802c:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = htons(remote_port);
 800802e:	f8bd 002c 	ldrh.w	r0, [sp, #44]	; 0x2c
 8008032:	f7fc f9d5 	bl	80043e0 <lwip_htons>
 8008036:	8060      	strh	r0, [r4, #2]
  tcphdr->seqno = htonl(seqno);
 8008038:	4648      	mov	r0, r9
 800803a:	f7fc f9db 	bl	80043f4 <lwip_htonl>
 800803e:	6060      	str	r0, [r4, #4]
  tcphdr->ackno = htonl(ackno);
 8008040:	4630      	mov	r0, r6
 8008042:	f7fc f9d7 	bl	80043f4 <lwip_htonl>
 8008046:	60a0      	str	r0, [r4, #8]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 8008048:	f245 0014 	movw	r0, #20500	; 0x5014
 800804c:	f7fc f9c8 	bl	80043e0 <lwip_htons>
 8008050:	81a0      	strh	r0, [r4, #12]
  tcphdr->wnd = PP_HTONS(TCP_WND);
 8008052:	2600      	movs	r6, #0
 8008054:	2316      	movs	r3, #22
 8008056:	73a3      	strb	r3, [r4, #14]
 8008058:	f06f 032f 	mvn.w	r3, #47	; 0x2f
 800805c:	73e3      	strb	r3, [r4, #15]
  tcphdr->chksum = 0;
 800805e:	7426      	strb	r6, [r4, #16]
 8008060:	7466      	strb	r6, [r4, #17]
  tcphdr->urgp = 0;
 8008062:	74a6      	strb	r6, [r4, #18]
 8008064:	74e6      	strb	r6, [r4, #19]

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
 8008066:	892b      	ldrh	r3, [r5, #8]
 8008068:	9300      	str	r3, [sp, #0]
 800806a:	2306      	movs	r3, #6
 800806c:	4642      	mov	r2, r8
 800806e:	4639      	mov	r1, r7
 8008070:	4628      	mov	r0, r5
 8008072:	f7fc fb4d 	bl	8004710 <inet_chksum_pseudo>
 8008076:	8220      	strh	r0, [r4, #16]
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 8008078:	4a0a      	ldr	r2, [pc, #40]	; (80080a4 <tcp_rst+0xa0>)
 800807a:	f8b2 3090 	ldrh.w	r3, [r2, #144]	; 0x90
 800807e:	3301      	adds	r3, #1
 8008080:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 8008084:	2306      	movs	r3, #6
 8008086:	9301      	str	r3, [sp, #4]
 8008088:	9600      	str	r6, [sp, #0]
 800808a:	23ff      	movs	r3, #255	; 0xff
 800808c:	4642      	mov	r2, r8
 800808e:	4639      	mov	r1, r7
 8008090:	4628      	mov	r0, r5
 8008092:	f7fc fd7d 	bl	8004b90 <ip_output>
  pbuf_free(p);
 8008096:	4628      	mov	r0, r5
 8008098:	f7fd fc1d 	bl	80058d6 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 800809c:	b003      	add	sp, #12
 800809e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80080a2:	bf00      	nop
 80080a4:	2000b110 	.word	0x2000b110

080080a8 <tcp_rexmit_rto>:
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 80080a8:	6f02      	ldr	r2, [r0, #112]	; 0x70
 80080aa:	b10a      	cbz	r2, 80080b0 <tcp_rexmit_rto+0x8>
{
 80080ac:	b508      	push	{r3, lr}
 80080ae:	e001      	b.n	80080b4 <tcp_rexmit_rto+0xc>
 80080b0:	4770      	bx	lr
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 80080b2:	461a      	mov	r2, r3
 80080b4:	6813      	ldr	r3, [r2, #0]
 80080b6:	2b00      	cmp	r3, #0
 80080b8:	d1fb      	bne.n	80080b2 <tcp_rexmit_rto+0xa>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 80080ba:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80080bc:	6013      	str	r3, [r2, #0]
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 80080be:	6f03      	ldr	r3, [r0, #112]	; 0x70
 80080c0:	66c3      	str	r3, [r0, #108]	; 0x6c
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 80080c2:	2200      	movs	r2, #0
 80080c4:	6702      	str	r2, [r0, #112]	; 0x70
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
 80080c6:	f890 3046 	ldrb.w	r3, [r0, #70]	; 0x46
 80080ca:	3301      	adds	r3, #1
 80080cc:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 80080d0:	6382      	str	r2, [r0, #56]	; 0x38

  /* Do the actual retransmission */
  tcp_output(pcb);
 80080d2:	f7ff fe3f 	bl	8007d54 <tcp_output>
 80080d6:	bd08      	pop	{r3, pc}

080080d8 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 80080d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 80080da:	6f06      	ldr	r6, [r0, #112]	; 0x70
 80080dc:	b316      	cbz	r6, 8008124 <tcp_rexmit+0x4c>
 80080de:	4607      	mov	r7, r0
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
 80080e0:	6833      	ldr	r3, [r6, #0]
 80080e2:	6703      	str	r3, [r0, #112]	; 0x70

  cur_seg = &(pcb->unsent);
 80080e4:	f100 056c 	add.w	r5, r0, #108	; 0x6c
  while (*cur_seg &&
 80080e8:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80080ea:	b17b      	cbz	r3, 800810c <tcp_rexmit+0x34>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 80080ec:	68db      	ldr	r3, [r3, #12]
 80080ee:	6858      	ldr	r0, [r3, #4]
 80080f0:	f7fc f98c 	bl	800440c <lwip_ntohl>
 80080f4:	4604      	mov	r4, r0
 80080f6:	68f3      	ldr	r3, [r6, #12]
 80080f8:	6858      	ldr	r0, [r3, #4]
 80080fa:	f7fc f987 	bl	800440c <lwip_ntohl>
 80080fe:	1a20      	subs	r0, r4, r0
  while (*cur_seg &&
 8008100:	2800      	cmp	r0, #0
 8008102:	da03      	bge.n	800810c <tcp_rexmit+0x34>
      cur_seg = &((*cur_seg)->next );
 8008104:	682d      	ldr	r5, [r5, #0]
  while (*cur_seg &&
 8008106:	682b      	ldr	r3, [r5, #0]
 8008108:	2b00      	cmp	r3, #0
 800810a:	d1ef      	bne.n	80080ec <tcp_rexmit+0x14>
  }
  seg->next = *cur_seg;
 800810c:	682b      	ldr	r3, [r5, #0]
 800810e:	6033      	str	r3, [r6, #0]
  *cur_seg = seg;
 8008110:	602e      	str	r6, [r5, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 8008112:	6833      	ldr	r3, [r6, #0]
 8008114:	b13b      	cbz	r3, 8008126 <tcp_rexmit+0x4e>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 8008116:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 800811a:	3301      	adds	r3, #1
 800811c:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 8008120:	2300      	movs	r3, #0
 8008122:	63bb      	str	r3, [r7, #56]	; 0x38
 8008124:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pcb->unsent_oversize = 0;
 8008126:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 800812a:	e7f4      	b.n	8008116 <tcp_rexmit+0x3e>

0800812c <tcp_rexmit_fast>:
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 800812c:	6f03      	ldr	r3, [r0, #112]	; 0x70
 800812e:	b11b      	cbz	r3, 8008138 <tcp_rexmit_fast+0xc>
 8008130:	7f83      	ldrb	r3, [r0, #30]
 8008132:	f013 0f04 	tst.w	r3, #4
 8008136:	d000      	beq.n	800813a <tcp_rexmit_fast+0xe>
 8008138:	4770      	bx	lr
{
 800813a:	b510      	push	{r4, lr}
 800813c:	4604      	mov	r4, r0
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
 800813e:	f7ff ffcb 	bl	80080d8 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
 8008142:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
 8008146:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
 800814a:	4293      	cmp	r3, r2
      pcb->ssthresh = pcb->snd_wnd / 2;
 800814c:	bf87      	ittee	hi
 800814e:	0852      	lsrhi	r2, r2, #1
 8008150:	f8a4 204e 	strhhi.w	r2, [r4, #78]	; 0x4e
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
 8008154:	085b      	lsrls	r3, r3, #1
 8008156:	f8a4 304e 	strhls.w	r3, [r4, #78]	; 0x4e
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 800815a:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800815c:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
 8008160:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 8008164:	bfbc      	itt	lt
 8008166:	005a      	lsllt	r2, r3, #1
 8008168:	f8a4 204e 	strhlt.w	r2, [r4, #78]	; 0x4e
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 800816c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8008170:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
 8008174:	4413      	add	r3, r2
 8008176:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    pcb->flags |= TF_INFR;
 800817a:	7fa3      	ldrb	r3, [r4, #30]
 800817c:	f043 0304 	orr.w	r3, r3, #4
 8008180:	77a3      	strb	r3, [r4, #30]
 8008182:	bd10      	pop	{r4, pc}

08008184 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 8008184:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008186:	b083      	sub	sp, #12
 8008188:	4604      	mov	r4, r0
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 800818a:	6d00      	ldr	r0, [r0, #80]	; 0x50
 800818c:	3801      	subs	r0, #1
 800818e:	f7fc f931 	bl	80043f4 <lwip_htonl>
 8008192:	4603      	mov	r3, r0
 8008194:	2200      	movs	r2, #0
 8008196:	4611      	mov	r1, r2
 8008198:	4620      	mov	r0, r4
 800819a:	f7ff fcd1 	bl	8007b40 <tcp_output_alloc_header>
  if(p == NULL) {
 800819e:	b1e8      	cbz	r0, 80081dc <tcp_keepalive+0x58>
 80081a0:	4605      	mov	r5, r0
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 80081a2:	6847      	ldr	r7, [r0, #4]

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 80081a4:	1d26      	adds	r6, r4, #4
 80081a6:	8903      	ldrh	r3, [r0, #8]
 80081a8:	9300      	str	r3, [sp, #0]
 80081aa:	2306      	movs	r3, #6
 80081ac:	4632      	mov	r2, r6
 80081ae:	4621      	mov	r1, r4
 80081b0:	f7fc faae 	bl	8004710 <inet_chksum_pseudo>
 80081b4:	8238      	strh	r0, [r7, #16]
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 80081b6:	4a0a      	ldr	r2, [pc, #40]	; (80081e0 <tcp_keepalive+0x5c>)
 80081b8:	f8b2 3090 	ldrh.w	r3, [r2, #144]	; 0x90
 80081bc:	3301      	adds	r3, #1
 80081be:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 80081c2:	7aa3      	ldrb	r3, [r4, #10]
 80081c4:	2206      	movs	r2, #6
 80081c6:	9201      	str	r2, [sp, #4]
 80081c8:	2200      	movs	r2, #0
 80081ca:	9200      	str	r2, [sp, #0]
 80081cc:	4632      	mov	r2, r6
 80081ce:	4621      	mov	r1, r4
 80081d0:	4628      	mov	r0, r5
 80081d2:	f7fc fcdd 	bl	8004b90 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 80081d6:	4628      	mov	r0, r5
 80081d8:	f7fd fb7d 	bl	80058d6 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 80081dc:	b003      	add	sp, #12
 80081de:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80081e0:	2000b110 	.word	0x2000b110

080081e4 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 80081e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80081e6:	b083      	sub	sp, #12
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
 80081e8:	6f05      	ldr	r5, [r0, #112]	; 0x70

  if(seg == NULL) {
 80081ea:	b1fd      	cbz	r5, 800822c <tcp_zero_window_probe+0x48>
 80081ec:	4604      	mov	r4, r0
  }
  if(seg == NULL) {
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 80081ee:	68eb      	ldr	r3, [r5, #12]
 80081f0:	8998      	ldrh	r0, [r3, #12]
 80081f2:	f7fc f8fa 	bl	80043ea <lwip_ntohs>
 80081f6:	f010 0f01 	tst.w	r0, #1
 80081fa:	d001      	beq.n	8008200 <tcp_zero_window_probe+0x1c>
 80081fc:	892b      	ldrh	r3, [r5, #8]
 80081fe:	b1c3      	cbz	r3, 8008232 <tcp_zero_window_probe+0x4e>
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 8008200:	68eb      	ldr	r3, [r5, #12]
 8008202:	685b      	ldr	r3, [r3, #4]
 8008204:	2201      	movs	r2, #1
 8008206:	2100      	movs	r1, #0
 8008208:	4620      	mov	r0, r4
 800820a:	f7ff fc99 	bl	8007b40 <tcp_output_alloc_header>
  if(p == NULL) {
 800820e:	4606      	mov	r6, r0
 8008210:	2800      	cmp	r0, #0
 8008212:	d03e      	beq.n	8008292 <tcp_zero_window_probe+0xae>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8008214:	6877      	ldr	r7, [r6, #4]
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 8008216:	6868      	ldr	r0, [r5, #4]
 8008218:	8903      	ldrh	r3, [r0, #8]
 800821a:	892a      	ldrh	r2, [r5, #8]
 800821c:	1a9b      	subs	r3, r3, r2
 800821e:	b29b      	uxth	r3, r3
 8008220:	2201      	movs	r2, #1
 8008222:	f107 0114 	add.w	r1, r7, #20
 8008226:	f7fd fce9 	bl	8005bfc <pbuf_copy_partial>
 800822a:	e015      	b.n	8008258 <tcp_zero_window_probe+0x74>
    seg = pcb->unsent;
 800822c:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
  if(seg == NULL) {
 800822e:	b385      	cbz	r5, 8008292 <tcp_zero_window_probe+0xae>
 8008230:	e7dc      	b.n	80081ec <tcp_zero_window_probe+0x8>
  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 8008232:	68eb      	ldr	r3, [r5, #12]
 8008234:	685b      	ldr	r3, [r3, #4]
 8008236:	2200      	movs	r2, #0
 8008238:	4611      	mov	r1, r2
 800823a:	4620      	mov	r0, r4
 800823c:	f7ff fc80 	bl	8007b40 <tcp_output_alloc_header>
  if(p == NULL) {
 8008240:	4606      	mov	r6, r0
 8008242:	b330      	cbz	r0, 8008292 <tcp_zero_window_probe+0xae>
  tcphdr = (struct tcp_hdr *)p->payload;
 8008244:	6877      	ldr	r7, [r6, #4]
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 8008246:	f9b7 500c 	ldrsh.w	r5, [r7, #12]
 800824a:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 800824e:	2011      	movs	r0, #17
 8008250:	f7fc f8c6 	bl	80043e0 <lwip_htons>
 8008254:	4328      	orrs	r0, r5
 8008256:	81b8      	strh	r0, [r7, #12]
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 8008258:	1d25      	adds	r5, r4, #4
 800825a:	8933      	ldrh	r3, [r6, #8]
 800825c:	9300      	str	r3, [sp, #0]
 800825e:	2306      	movs	r3, #6
 8008260:	462a      	mov	r2, r5
 8008262:	4621      	mov	r1, r4
 8008264:	4630      	mov	r0, r6
 8008266:	f7fc fa53 	bl	8004710 <inet_chksum_pseudo>
 800826a:	8238      	strh	r0, [r7, #16]
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 800826c:	4a0a      	ldr	r2, [pc, #40]	; (8008298 <tcp_zero_window_probe+0xb4>)
 800826e:	f8b2 3090 	ldrh.w	r3, [r2, #144]	; 0x90
 8008272:	3301      	adds	r3, #1
 8008274:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 8008278:	7aa3      	ldrb	r3, [r4, #10]
 800827a:	2206      	movs	r2, #6
 800827c:	9201      	str	r2, [sp, #4]
 800827e:	2200      	movs	r2, #0
 8008280:	9200      	str	r2, [sp, #0]
 8008282:	462a      	mov	r2, r5
 8008284:	4621      	mov	r1, r4
 8008286:	4630      	mov	r0, r6
 8008288:	f7fc fc82 	bl	8004b90 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 800828c:	4630      	mov	r0, r6
 800828e:	f7fd fb22 	bl	80058d6 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 8008292:	b003      	add	sp, #12
 8008294:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008296:	bf00      	nop
 8008298:	2000b110 	.word	0x2000b110

0800829c <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 800829c:	b570      	push	{r4, r5, r6, lr}
 800829e:	4604      	mov	r4, r0
 80082a0:	460e      	mov	r6, r1
 80082a2:	4615      	mov	r5, r2
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 80082a4:	2007      	movs	r0, #7
 80082a6:	f7fd f9e9 	bl	800567c <memp_malloc>
  if (timeout == NULL) {
 80082aa:	2800      	cmp	r0, #0
 80082ac:	d030      	beq.n	8008310 <sys_timeout+0x74>
 80082ae:	4601      	mov	r1, r0
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
 80082b0:	2300      	movs	r3, #0
 80082b2:	6003      	str	r3, [r0, #0]
  timeout->h = handler;
 80082b4:	6086      	str	r6, [r0, #8]
  timeout->arg = arg;
 80082b6:	60c5      	str	r5, [r0, #12]
  timeout->time = msecs;
 80082b8:	6044      	str	r4, [r0, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 80082ba:	4b16      	ldr	r3, [pc, #88]	; (8008314 <sys_timeout+0x78>)
 80082bc:	681d      	ldr	r5, [r3, #0]
 80082be:	b1a5      	cbz	r5, 80082ea <sys_timeout+0x4e>
    next_timeout = timeout;
    return;
  }

  if (next_timeout->time > msecs) {
 80082c0:	6868      	ldr	r0, [r5, #4]
 80082c2:	4284      	cmp	r4, r0
 80082c4:	d313      	bcc.n	80082ee <sys_timeout+0x52>
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
      timeout->time -= t->time;
 80082c6:	1a20      	subs	r0, r4, r0
 80082c8:	6048      	str	r0, [r1, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 80082ca:	682a      	ldr	r2, [r5, #0]
 80082cc:	b1f2      	cbz	r2, 800830c <sys_timeout+0x70>
 80082ce:	6853      	ldr	r3, [r2, #4]
 80082d0:	4298      	cmp	r0, r3
 80082d2:	d312      	bcc.n	80082fa <sys_timeout+0x5e>
      timeout->time -= t->time;
 80082d4:	6848      	ldr	r0, [r1, #4]
 80082d6:	6853      	ldr	r3, [r2, #4]
 80082d8:	1ac0      	subs	r0, r0, r3
 80082da:	6048      	str	r0, [r1, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 80082dc:	6813      	ldr	r3, [r2, #0]
 80082de:	b18b      	cbz	r3, 8008304 <sys_timeout+0x68>
 80082e0:	685c      	ldr	r4, [r3, #4]
 80082e2:	42a0      	cmp	r0, r4
 80082e4:	d30b      	bcc.n	80082fe <sys_timeout+0x62>
 80082e6:	461a      	mov	r2, r3
 80082e8:	e7f4      	b.n	80082d4 <sys_timeout+0x38>
    next_timeout = timeout;
 80082ea:	6018      	str	r0, [r3, #0]
    return;
 80082ec:	bd70      	pop	{r4, r5, r6, pc}
    next_timeout->time -= msecs;
 80082ee:	1b00      	subs	r0, r0, r4
 80082f0:	6068      	str	r0, [r5, #4]
    timeout->next = next_timeout;
 80082f2:	600d      	str	r5, [r1, #0]
    next_timeout = timeout;
 80082f4:	4b07      	ldr	r3, [pc, #28]	; (8008314 <sys_timeout+0x78>)
 80082f6:	6019      	str	r1, [r3, #0]
 80082f8:	bd70      	pop	{r4, r5, r6, pc}
      if (t->next == NULL || t->next->time > timeout->time) {
 80082fa:	4613      	mov	r3, r2
 80082fc:	462a      	mov	r2, r5
        if (t->next != NULL) {
          t->next->time -= timeout->time;
 80082fe:	685c      	ldr	r4, [r3, #4]
 8008300:	1a20      	subs	r0, r4, r0
 8008302:	6058      	str	r0, [r3, #4]
        }
        timeout->next = t->next;
 8008304:	6813      	ldr	r3, [r2, #0]
 8008306:	600b      	str	r3, [r1, #0]
        t->next = timeout;
 8008308:	6011      	str	r1, [r2, #0]
        break;
 800830a:	bd70      	pop	{r4, r5, r6, pc}
      if (t->next == NULL || t->next->time > timeout->time) {
 800830c:	462a      	mov	r2, r5
 800830e:	e7f9      	b.n	8008304 <sys_timeout+0x68>
 8008310:	bd70      	pop	{r4, r5, r6, pc}
 8008312:	bf00      	nop
 8008314:	200077b4 	.word	0x200077b4

08008318 <tcp_timer_needed>:
{
 8008318:	b508      	push	{r3, lr}
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 800831a:	4b0a      	ldr	r3, [pc, #40]	; (8008344 <tcp_timer_needed+0x2c>)
 800831c:	681b      	ldr	r3, [r3, #0]
 800831e:	b953      	cbnz	r3, 8008336 <tcp_timer_needed+0x1e>
 8008320:	4b09      	ldr	r3, [pc, #36]	; (8008348 <tcp_timer_needed+0x30>)
 8008322:	681b      	ldr	r3, [r3, #0]
 8008324:	b143      	cbz	r3, 8008338 <tcp_timer_needed+0x20>
    tcpip_tcp_timer_active = 1;
 8008326:	2201      	movs	r2, #1
 8008328:	4b06      	ldr	r3, [pc, #24]	; (8008344 <tcp_timer_needed+0x2c>)
 800832a:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 800832c:	2200      	movs	r2, #0
 800832e:	4907      	ldr	r1, [pc, #28]	; (800834c <tcp_timer_needed+0x34>)
 8008330:	20fa      	movs	r0, #250	; 0xfa
 8008332:	f7ff ffb3 	bl	800829c <sys_timeout>
 8008336:	bd08      	pop	{r3, pc}
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 8008338:	4b05      	ldr	r3, [pc, #20]	; (8008350 <tcp_timer_needed+0x38>)
 800833a:	681b      	ldr	r3, [r3, #0]
 800833c:	2b00      	cmp	r3, #0
 800833e:	d1f2      	bne.n	8008326 <tcp_timer_needed+0xe>
 8008340:	e7f9      	b.n	8008336 <tcp_timer_needed+0x1e>
 8008342:	bf00      	nop
 8008344:	200077b8 	.word	0x200077b8
 8008348:	2000b22c 	.word	0x2000b22c
 800834c:	08008355 	.word	0x08008355
 8008350:	2000b240 	.word	0x2000b240

08008354 <tcpip_tcp_timer>:
{
 8008354:	b508      	push	{r3, lr}
  tcp_tmr();
 8008356:	f7fe f88b 	bl	8006470 <tcp_tmr>
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 800835a:	4b08      	ldr	r3, [pc, #32]	; (800837c <tcpip_tcp_timer+0x28>)
 800835c:	681b      	ldr	r3, [r3, #0]
 800835e:	b12b      	cbz	r3, 800836c <tcpip_tcp_timer+0x18>
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8008360:	2200      	movs	r2, #0
 8008362:	4907      	ldr	r1, [pc, #28]	; (8008380 <tcpip_tcp_timer+0x2c>)
 8008364:	20fa      	movs	r0, #250	; 0xfa
 8008366:	f7ff ff99 	bl	800829c <sys_timeout>
 800836a:	bd08      	pop	{r3, pc}
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 800836c:	4b05      	ldr	r3, [pc, #20]	; (8008384 <tcpip_tcp_timer+0x30>)
 800836e:	681b      	ldr	r3, [r3, #0]
 8008370:	2b00      	cmp	r3, #0
 8008372:	d1f5      	bne.n	8008360 <tcpip_tcp_timer+0xc>
    tcpip_tcp_timer_active = 0;
 8008374:	2200      	movs	r2, #0
 8008376:	4b04      	ldr	r3, [pc, #16]	; (8008388 <tcpip_tcp_timer+0x34>)
 8008378:	601a      	str	r2, [r3, #0]
 800837a:	bd08      	pop	{r3, pc}
 800837c:	2000b22c 	.word	0x2000b22c
 8008380:	08008355 	.word	0x08008355
 8008384:	2000b240 	.word	0x2000b240
 8008388:	200077b8 	.word	0x200077b8

0800838c <sys_timeouts_init>:
{
 800838c:	b508      	push	{r3, lr}
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 800838e:	2200      	movs	r2, #0
 8008390:	4907      	ldr	r1, [pc, #28]	; (80083b0 <sys_timeouts_init+0x24>)
 8008392:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008396:	f7ff ff81 	bl	800829c <sys_timeout>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 800839a:	2200      	movs	r2, #0
 800839c:	4905      	ldr	r1, [pc, #20]	; (80083b4 <sys_timeouts_init+0x28>)
 800839e:	f241 3088 	movw	r0, #5000	; 0x1388
 80083a2:	f7ff ff7b 	bl	800829c <sys_timeout>
  timeouts_last_time = sys_now();
 80083a6:	f7fb f98c 	bl	80036c2 <sys_now>
 80083aa:	4b03      	ldr	r3, [pc, #12]	; (80083b8 <sys_timeouts_init+0x2c>)
 80083ac:	6018      	str	r0, [r3, #0]
 80083ae:	bd08      	pop	{r3, pc}
 80083b0:	080083d5 	.word	0x080083d5
 80083b4:	080083bd 	.word	0x080083bd
 80083b8:	200077bc 	.word	0x200077bc

080083bc <arp_timer>:
{
 80083bc:	b508      	push	{r3, lr}
  etharp_tmr();
 80083be:	f000 fb61 	bl	8008a84 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 80083c2:	2200      	movs	r2, #0
 80083c4:	4902      	ldr	r1, [pc, #8]	; (80083d0 <arp_timer+0x14>)
 80083c6:	f241 3088 	movw	r0, #5000	; 0x1388
 80083ca:	f7ff ff67 	bl	800829c <sys_timeout>
 80083ce:	bd08      	pop	{r3, pc}
 80083d0:	080083bd 	.word	0x080083bd

080083d4 <ip_reass_timer>:
{
 80083d4:	b508      	push	{r3, lr}
  ip_reass_tmr();
 80083d6:	f7fc fcb1 	bl	8004d3c <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 80083da:	2200      	movs	r2, #0
 80083dc:	4902      	ldr	r1, [pc, #8]	; (80083e8 <ip_reass_timer+0x14>)
 80083de:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80083e2:	f7ff ff5b 	bl	800829c <sys_timeout>
 80083e6:	bd08      	pop	{r3, pc}
 80083e8:	080083d5 	.word	0x080083d5

080083ec <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 80083ec:	4770      	bx	lr
	...

080083f0 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 80083f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80083f4:	b085      	sub	sp, #20
 80083f6:	4604      	mov	r4, r0
 80083f8:	4689      	mov	r9, r1
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
 80083fa:	4a7c      	ldr	r2, [pc, #496]	; (80085ec <udp_input+0x1fc>)
 80083fc:	f8b2 307a 	ldrh.w	r3, [r2, #122]	; 0x7a
 8008400:	3301      	adds	r3, #1
 8008402:	f8a2 307a 	strh.w	r3, [r2, #122]	; 0x7a

  iphdr = (struct ip_hdr *)p->payload;
 8008406:	f8d0 8004 	ldr.w	r8, [r0, #4]
 800840a:	f898 1000 	ldrb.w	r1, [r8]
 800840e:	f001 010f 	and.w	r1, r1, #15

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 8008412:	8903      	ldrh	r3, [r0, #8]
 8008414:	1c8a      	adds	r2, r1, #2
 8008416:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 800841a:	db04      	blt.n	8008426 <udp_input+0x36>
 800841c:	0089      	lsls	r1, r1, #2
 800841e:	4249      	negs	r1, r1
 8008420:	f7fd fa1b 	bl	800585a <pbuf_header>
 8008424:	b180      	cbz	r0, 8008448 <udp_input+0x58>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
 8008426:	4b71      	ldr	r3, [pc, #452]	; (80085ec <udp_input+0x1fc>)
 8008428:	f8b3 2082 	ldrh.w	r2, [r3, #130]	; 0x82
 800842c:	3201      	adds	r2, #1
 800842e:	f8a3 2082 	strh.w	r2, [r3, #130]	; 0x82
    UDP_STATS_INC(udp.drop);
 8008432:	f8b3 207e 	ldrh.w	r2, [r3, #126]	; 0x7e
 8008436:	3201      	adds	r2, #1
 8008438:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
    snmp_inc_udpinerrors();
    pbuf_free(p);
 800843c:	4620      	mov	r0, r4
 800843e:	f7fd fa4a 	bl	80058d6 <pbuf_free>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
 8008442:	b005      	add	sp, #20
 8008444:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  udphdr = (struct udp_hdr *)p->payload;
 8008448:	f8d4 a004 	ldr.w	sl, [r4, #4]
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 800844c:	4649      	mov	r1, r9
 800844e:	4b68      	ldr	r3, [pc, #416]	; (80085f0 <udp_input+0x200>)
 8008450:	6818      	ldr	r0, [r3, #0]
 8008452:	f7fc fbc1 	bl	8004bd8 <ip4_addr_isbroadcast>
 8008456:	4607      	mov	r7, r0
  src = ntohs(udphdr->src);
 8008458:	f8ba 0000 	ldrh.w	r0, [sl]
 800845c:	f7fb ffc5 	bl	80043ea <lwip_ntohs>
 8008460:	4605      	mov	r5, r0
  dest = ntohs(udphdr->dest);
 8008462:	f8ba 0002 	ldrh.w	r0, [sl, #2]
 8008466:	f7fb ffc0 	bl	80043ea <lwip_ntohs>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800846a:	4b62      	ldr	r3, [pc, #392]	; (80085f4 <udp_input+0x204>)
 800846c:	f8d3 e000 	ldr.w	lr, [r3]
 8008470:	f1be 0f00 	cmp.w	lr, #0
 8008474:	d049      	beq.n	800850a <udp_input+0x11a>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 8008476:	4b5e      	ldr	r3, [pc, #376]	; (80085f0 <udp_input+0x200>)
 8008478:	f8d3 c000 	ldr.w	ip, [r3]
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 800847c:	4b5e      	ldr	r3, [pc, #376]	; (80085f8 <udp_input+0x208>)
 800847e:	f8d3 b000 	ldr.w	fp, [r3]
 8008482:	4673      	mov	r3, lr
 8008484:	2600      	movs	r6, #0
 8008486:	4632      	mov	r2, r6
 8008488:	9403      	str	r4, [sp, #12]
 800848a:	e0a2      	b.n	80085d2 <udp_input+0x1e2>
          if ((uncon_pcb == NULL) && 
 800848c:	7c19      	ldrb	r1, [r3, #16]
 800848e:	f001 0104 	and.w	r1, r1, #4
 8008492:	2900      	cmp	r1, #0
 8008494:	bf08      	it	eq
 8008496:	461e      	moveq	r6, r3
 8008498:	e091      	b.n	80085be <udp_input+0x1ce>
          (pcb->remote_port == src) &&
 800849a:	f113 0f04 	cmn.w	r3, #4
 800849e:	d004      	beq.n	80084aa <udp_input+0xba>
          (ip_addr_isany(&pcb->remote_ip) ||
 80084a0:	6859      	ldr	r1, [r3, #4]
 80084a2:	b111      	cbz	r1, 80084aa <udp_input+0xba>
 80084a4:	4559      	cmp	r1, fp
 80084a6:	f040 808e 	bne.w	80085c6 <udp_input+0x1d6>
 80084aa:	9c03      	ldr	r4, [sp, #12]
        if (prev != NULL) {
 80084ac:	b142      	cbz	r2, 80084c0 <udp_input+0xd0>
          prev->next = pcb->next;
 80084ae:	68d9      	ldr	r1, [r3, #12]
 80084b0:	60d1      	str	r1, [r2, #12]
          pcb->next = udp_pcbs;
 80084b2:	f8c3 e00c 	str.w	lr, [r3, #12]
          udp_pcbs = pcb;
 80084b6:	4a4f      	ldr	r2, [pc, #316]	; (80085f4 <udp_input+0x204>)
 80084b8:	6013      	str	r3, [r2, #0]
    if (pcb == NULL) {
 80084ba:	b14b      	cbz	r3, 80084d0 <udp_input+0xe0>
 80084bc:	461e      	mov	r6, r3
 80084be:	e008      	b.n	80084d2 <udp_input+0xe2>
          UDP_STATS_INC(udp.cachehit);
 80084c0:	494a      	ldr	r1, [pc, #296]	; (80085ec <udp_input+0x1fc>)
 80084c2:	f8b1 208e 	ldrh.w	r2, [r1, #142]	; 0x8e
 80084c6:	3201      	adds	r2, #1
 80084c8:	f8a1 208e 	strh.w	r2, [r1, #142]	; 0x8e
 80084cc:	e7f5      	b.n	80084ba <udp_input+0xca>
 80084ce:	9c03      	ldr	r4, [sp, #12]
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 80084d0:	b1de      	cbz	r6, 800850a <udp_input+0x11a>
      if (udphdr->chksum != 0) {
 80084d2:	f8ba 3006 	ldrh.w	r3, [sl, #6]
 80084d6:	b143      	cbz	r3, 80084ea <udp_input+0xfa>
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 80084d8:	8923      	ldrh	r3, [r4, #8]
 80084da:	9300      	str	r3, [sp, #0]
 80084dc:	2311      	movs	r3, #17
 80084de:	4a44      	ldr	r2, [pc, #272]	; (80085f0 <udp_input+0x200>)
 80084e0:	4945      	ldr	r1, [pc, #276]	; (80085f8 <udp_input+0x208>)
 80084e2:	4620      	mov	r0, r4
 80084e4:	f7fc f914 	bl	8004710 <inet_chksum_pseudo>
 80084e8:	b9d8      	cbnz	r0, 8008522 <udp_input+0x132>
    if(pbuf_header(p, -UDP_HLEN)) {
 80084ea:	f06f 0107 	mvn.w	r1, #7
 80084ee:	4620      	mov	r0, r4
 80084f0:	f7fd f9b3 	bl	800585a <pbuf_header>
 80084f4:	bb20      	cbnz	r0, 8008540 <udp_input+0x150>
    if (pcb != NULL) {
 80084f6:	b38e      	cbz	r6, 800855c <udp_input+0x16c>
      if (pcb->recv != NULL) {
 80084f8:	69b7      	ldr	r7, [r6, #24]
 80084fa:	b35f      	cbz	r7, 8008554 <udp_input+0x164>
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 80084fc:	69f0      	ldr	r0, [r6, #28]
 80084fe:	9500      	str	r5, [sp, #0]
 8008500:	4b3d      	ldr	r3, [pc, #244]	; (80085f8 <udp_input+0x208>)
 8008502:	4622      	mov	r2, r4
 8008504:	4631      	mov	r1, r6
 8008506:	47b8      	blx	r7
 8008508:	e79b      	b.n	8008442 <udp_input+0x52>
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 800850a:	f8d9 2004 	ldr.w	r2, [r9, #4]
 800850e:	4b38      	ldr	r3, [pc, #224]	; (80085f0 <udp_input+0x200>)
 8008510:	681b      	ldr	r3, [r3, #0]
 8008512:	429a      	cmp	r2, r3
 8008514:	d003      	beq.n	800851e <udp_input+0x12e>
    pbuf_free(p);
 8008516:	4620      	mov	r0, r4
 8008518:	f7fd f9dd 	bl	80058d6 <pbuf_free>
}
 800851c:	e791      	b.n	8008442 <udp_input+0x52>
 800851e:	2600      	movs	r6, #0
 8008520:	e7d7      	b.n	80084d2 <udp_input+0xe2>
          UDP_STATS_INC(udp.chkerr);
 8008522:	4b32      	ldr	r3, [pc, #200]	; (80085ec <udp_input+0x1fc>)
 8008524:	f8b3 2080 	ldrh.w	r2, [r3, #128]	; 0x80
 8008528:	3201      	adds	r2, #1
 800852a:	f8a3 2080 	strh.w	r2, [r3, #128]	; 0x80
          UDP_STATS_INC(udp.drop);
 800852e:	f8b3 207e 	ldrh.w	r2, [r3, #126]	; 0x7e
 8008532:	3201      	adds	r2, #1
 8008534:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
          pbuf_free(p);
 8008538:	4620      	mov	r0, r4
 800853a:	f7fd f9cc 	bl	80058d6 <pbuf_free>
          goto end;
 800853e:	e780      	b.n	8008442 <udp_input+0x52>
      UDP_STATS_INC(udp.drop);
 8008540:	4a2a      	ldr	r2, [pc, #168]	; (80085ec <udp_input+0x1fc>)
 8008542:	f8b2 307e 	ldrh.w	r3, [r2, #126]	; 0x7e
 8008546:	3301      	adds	r3, #1
 8008548:	f8a2 307e 	strh.w	r3, [r2, #126]	; 0x7e
      pbuf_free(p);
 800854c:	4620      	mov	r0, r4
 800854e:	f7fd f9c2 	bl	80058d6 <pbuf_free>
      goto end;
 8008552:	e776      	b.n	8008442 <udp_input+0x52>
        pbuf_free(p);
 8008554:	4620      	mov	r0, r4
 8008556:	f7fd f9be 	bl	80058d6 <pbuf_free>
        goto end;
 800855a:	e772      	b.n	8008442 <udp_input+0x52>
      if (!broadcast &&
 800855c:	b997      	cbnz	r7, 8008584 <udp_input+0x194>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 800855e:	4b24      	ldr	r3, [pc, #144]	; (80085f0 <udp_input+0x200>)
 8008560:	681b      	ldr	r3, [r3, #0]
 8008562:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      if (!broadcast &&
 8008566:	2be0      	cmp	r3, #224	; 0xe0
 8008568:	d00c      	beq.n	8008584 <udp_input+0x194>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
 800856a:	f898 1000 	ldrb.w	r1, [r8]
 800856e:	f001 010f 	and.w	r1, r1, #15
 8008572:	3102      	adds	r1, #2
 8008574:	0089      	lsls	r1, r1, #2
 8008576:	4620      	mov	r0, r4
 8008578:	f7fd f96f 	bl	800585a <pbuf_header>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
 800857c:	2103      	movs	r1, #3
 800857e:	4620      	mov	r0, r4
 8008580:	f7fc f87e 	bl	8004680 <icmp_dest_unreach>
      UDP_STATS_INC(udp.proterr);
 8008584:	4b19      	ldr	r3, [pc, #100]	; (80085ec <udp_input+0x1fc>)
 8008586:	f8b3 2088 	ldrh.w	r2, [r3, #136]	; 0x88
 800858a:	3201      	adds	r2, #1
 800858c:	f8a3 2088 	strh.w	r2, [r3, #136]	; 0x88
      UDP_STATS_INC(udp.drop);
 8008590:	f8b3 207e 	ldrh.w	r2, [r3, #126]	; 0x7e
 8008594:	3201      	adds	r2, #1
 8008596:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
      pbuf_free(p);
 800859a:	4620      	mov	r0, r4
 800859c:	f7fd f99b 	bl	80058d6 <pbuf_free>
 80085a0:	e74f      	b.n	8008442 <udp_input+0x52>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 80085a2:	6819      	ldr	r1, [r3, #0]
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 80085a4:	458c      	cmp	ip, r1
 80085a6:	d007      	beq.n	80085b8 <udp_input+0x1c8>
            (broadcast &&
 80085a8:	b133      	cbz	r3, 80085b8 <udp_input+0x1c8>
             (ip_addr_isany(&pcb->local_ip) ||
 80085aa:	b129      	cbz	r1, 80085b8 <udp_input+0x1c8>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
 80085ac:	ea8c 0401 	eor.w	r4, ip, r1
             (ip_addr_isany(&pcb->local_ip) ||
 80085b0:	f8d9 1008 	ldr.w	r1, [r9, #8]
 80085b4:	420c      	tst	r4, r1
 80085b6:	d106      	bne.n	80085c6 <udp_input+0x1d6>
          if ((uncon_pcb == NULL) && 
 80085b8:	2e00      	cmp	r6, #0
 80085ba:	f43f af67 	beq.w	800848c <udp_input+0x9c>
      if ((local_match != 0) &&
 80085be:	8a99      	ldrh	r1, [r3, #20]
 80085c0:	42a9      	cmp	r1, r5
 80085c2:	f43f af6a 	beq.w	800849a <udp_input+0xaa>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80085c6:	68d9      	ldr	r1, [r3, #12]
 80085c8:	461a      	mov	r2, r3
 80085ca:	2900      	cmp	r1, #0
 80085cc:	f43f af7f 	beq.w	80084ce <udp_input+0xde>
 80085d0:	460b      	mov	r3, r1
      if (pcb->local_port == dest) {
 80085d2:	8a59      	ldrh	r1, [r3, #18]
 80085d4:	4281      	cmp	r1, r0
 80085d6:	d1f6      	bne.n	80085c6 <udp_input+0x1d6>
        if (
 80085d8:	2f00      	cmp	r7, #0
 80085da:	d1e2      	bne.n	80085a2 <udp_input+0x1b2>
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 80085dc:	2b00      	cmp	r3, #0
 80085de:	d0eb      	beq.n	80085b8 <udp_input+0x1c8>
 80085e0:	6819      	ldr	r1, [r3, #0]
 80085e2:	2900      	cmp	r1, #0
 80085e4:	d0e8      	beq.n	80085b8 <udp_input+0x1c8>
 80085e6:	4561      	cmp	r1, ip
 80085e8:	d1ed      	bne.n	80085c6 <udp_input+0x1d6>
 80085ea:	e7e5      	b.n	80085b8 <udp_input+0x1c8>
 80085ec:	2000b110 	.word	0x2000b110
 80085f0:	200089d8 	.word	0x200089d8
 80085f4:	2000b248 	.word	0x2000b248
 80085f8:	200089d0 	.word	0x200089d0

080085fc <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 80085fc:	b5f0      	push	{r4, r5, r6, r7, lr}
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80085fe:	4b34      	ldr	r3, [pc, #208]	; (80086d0 <udp_bind+0xd4>)
 8008600:	681b      	ldr	r3, [r3, #0]
 8008602:	b1cb      	cbz	r3, 8008638 <udp_bind+0x3c>
 8008604:	2600      	movs	r6, #0
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
 8008606:	2701      	movs	r7, #1
 8008608:	e002      	b.n	8008610 <udp_bind+0x14>
 800860a:	463e      	mov	r6, r7
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800860c:	68db      	ldr	r3, [r3, #12]
 800860e:	b1a3      	cbz	r3, 800863a <udp_bind+0x3e>
    if (pcb == ipcb) {
 8008610:	4298      	cmp	r0, r3
 8008612:	d0fa      	beq.n	800860a <udp_bind+0xe>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 8008614:	8a5c      	ldrh	r4, [r3, #18]
 8008616:	4294      	cmp	r4, r2
 8008618:	d1f8      	bne.n	800860c <udp_bind+0x10>
 800861a:	2b00      	cmp	r3, #0
 800861c:	d04a      	beq.n	80086b4 <udp_bind+0xb8>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
 800861e:	681c      	ldr	r4, [r3, #0]
 8008620:	2c00      	cmp	r4, #0
 8008622:	d04a      	beq.n	80086ba <udp_bind+0xbe>
 8008624:	2900      	cmp	r1, #0
 8008626:	d04b      	beq.n	80086c0 <udp_bind+0xc4>
           ip_addr_isany(ipaddr) ||
 8008628:	680d      	ldr	r5, [r1, #0]
 800862a:	2d00      	cmp	r5, #0
 800862c:	d04b      	beq.n	80086c6 <udp_bind+0xca>
 800862e:	42ac      	cmp	r4, r5
 8008630:	d1ec      	bne.n	800860c <udp_bind+0x10>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
 8008632:	f06f 0007 	mvn.w	r0, #7
 8008636:	bdf0      	pop	{r4, r5, r6, r7, pc}
  rebind = 0;
 8008638:	2600      	movs	r6, #0
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
 800863a:	b159      	cbz	r1, 8008654 <udp_bind+0x58>
 800863c:	680b      	ldr	r3, [r1, #0]
 800863e:	6003      	str	r3, [r0, #0]

  /* no port specified? */
  if (port == 0) {
 8008640:	b152      	cbz	r2, 8008658 <udp_bind+0x5c>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
 8008642:	8242      	strh	r2, [r0, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 8008644:	2e00      	cmp	r6, #0
 8008646:	d141      	bne.n	80086cc <udp_bind+0xd0>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 8008648:	4b21      	ldr	r3, [pc, #132]	; (80086d0 <udp_bind+0xd4>)
 800864a:	681a      	ldr	r2, [r3, #0]
 800864c:	60c2      	str	r2, [r0, #12]
    udp_pcbs = pcb;
 800864e:	6018      	str	r0, [r3, #0]
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
 8008650:	2000      	movs	r0, #0
 8008652:	bdf0      	pop	{r4, r5, r6, r7, pc}
  ip_addr_set(&pcb->local_ip, ipaddr);
 8008654:	2300      	movs	r3, #0
 8008656:	e7f2      	b.n	800863e <udp_bind+0x42>
 8008658:	4b1e      	ldr	r3, [pc, #120]	; (80086d4 <udp_bind+0xd8>)
 800865a:	8819      	ldrh	r1, [r3, #0]
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800865c:	4b1c      	ldr	r3, [pc, #112]	; (80086d0 <udp_bind+0xd4>)
 800865e:	681c      	ldr	r4, [r3, #0]
 8008660:	f44f 4580 	mov.w	r5, #16384	; 0x4000
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 8008664:	f64f 77ff 	movw	r7, #65535	; 0xffff
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8008668:	f44f 4e40 	mov.w	lr, #49152	; 0xc000
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 800866c:	42b9      	cmp	r1, r7
 800866e:	bf1a      	itte	ne
 8008670:	3101      	addne	r1, #1
 8008672:	b289      	uxthne	r1, r1
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8008674:	4671      	moveq	r1, lr
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008676:	b18c      	cbz	r4, 800869c <udp_bind+0xa0>
    if (pcb->local_port == udp_port) {
 8008678:	8a63      	ldrh	r3, [r4, #18]
 800867a:	428b      	cmp	r3, r1
 800867c:	d005      	beq.n	800868a <udp_bind+0x8e>
 800867e:	4623      	mov	r3, r4
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008680:	68db      	ldr	r3, [r3, #12]
 8008682:	b173      	cbz	r3, 80086a2 <udp_bind+0xa6>
    if (pcb->local_port == udp_port) {
 8008684:	8a5a      	ldrh	r2, [r3, #18]
 8008686:	428a      	cmp	r2, r1
 8008688:	d1fa      	bne.n	8008680 <udp_bind+0x84>
 800868a:	3d01      	subs	r5, #1
 800868c:	b2ad      	uxth	r5, r5
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 800868e:	2d00      	cmp	r5, #0
 8008690:	d1ec      	bne.n	800866c <udp_bind+0x70>
 8008692:	4b10      	ldr	r3, [pc, #64]	; (80086d4 <udp_bind+0xd8>)
 8008694:	8019      	strh	r1, [r3, #0]
      return ERR_USE;
 8008696:	f06f 0007 	mvn.w	r0, #7
 800869a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800869c:	4b0d      	ldr	r3, [pc, #52]	; (80086d4 <udp_bind+0xd8>)
 800869e:	8019      	strh	r1, [r3, #0]
 80086a0:	e001      	b.n	80086a6 <udp_bind+0xaa>
 80086a2:	4b0c      	ldr	r3, [pc, #48]	; (80086d4 <udp_bind+0xd8>)
 80086a4:	8019      	strh	r1, [r3, #0]
  return udp_port;
 80086a6:	4b0b      	ldr	r3, [pc, #44]	; (80086d4 <udp_bind+0xd8>)
 80086a8:	881a      	ldrh	r2, [r3, #0]
    if (port == 0) {
 80086aa:	2a00      	cmp	r2, #0
 80086ac:	d1c9      	bne.n	8008642 <udp_bind+0x46>
      return ERR_USE;
 80086ae:	f06f 0007 	mvn.w	r0, #7
 80086b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return ERR_USE;
 80086b4:	f06f 0007 	mvn.w	r0, #7
 80086b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80086ba:	f06f 0007 	mvn.w	r0, #7
 80086be:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80086c0:	f06f 0007 	mvn.w	r0, #7
 80086c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80086c6:	f06f 0007 	mvn.w	r0, #7
 80086ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return ERR_OK;
 80086cc:	2000      	movs	r0, #0
}
 80086ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80086d0:	2000b248 	.word	0x2000b248
 80086d4:	20000150 	.word	0x20000150

080086d8 <udp_sendto_if>:
{
 80086d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80086dc:	b084      	sub	sp, #16
 80086de:	4604      	mov	r4, r0
 80086e0:	460f      	mov	r7, r1
 80086e2:	4691      	mov	r9, r2
 80086e4:	469a      	mov	sl, r3
 80086e6:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
  if (pcb->local_port == 0) {
 80086ea:	8a43      	ldrh	r3, [r0, #18]
 80086ec:	b933      	cbnz	r3, 80086fc <udp_sendto_if+0x24>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 80086ee:	2200      	movs	r2, #0
 80086f0:	4601      	mov	r1, r0
 80086f2:	f7ff ff83 	bl	80085fc <udp_bind>
    if (err != ERR_OK) {
 80086f6:	4605      	mov	r5, r0
 80086f8:	2800      	cmp	r0, #0
 80086fa:	d145      	bne.n	8008788 <udp_sendto_if+0xb0>
  if (pbuf_header(p, UDP_HLEN)) {
 80086fc:	2108      	movs	r1, #8
 80086fe:	4638      	mov	r0, r7
 8008700:	f7fd f8ab 	bl	800585a <pbuf_header>
 8008704:	b168      	cbz	r0, 8008722 <udp_sendto_if+0x4a>
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 8008706:	2200      	movs	r2, #0
 8008708:	2108      	movs	r1, #8
 800870a:	2001      	movs	r0, #1
 800870c:	f7fd f912 	bl	8005934 <pbuf_alloc>
    if (q == NULL) {
 8008710:	4606      	mov	r6, r0
 8008712:	2800      	cmp	r0, #0
 8008714:	d057      	beq.n	80087c6 <udp_sendto_if+0xee>
    if (p->tot_len != 0) {
 8008716:	893b      	ldrh	r3, [r7, #8]
 8008718:	b123      	cbz	r3, 8008724 <udp_sendto_if+0x4c>
      pbuf_chain(q, p);
 800871a:	4639      	mov	r1, r7
 800871c:	f7fd f9f6 	bl	8005b0c <pbuf_chain>
 8008720:	e000      	b.n	8008724 <udp_sendto_if+0x4c>
    q = p;
 8008722:	463e      	mov	r6, r7
  udphdr = (struct udp_hdr *)q->payload;
 8008724:	6875      	ldr	r5, [r6, #4]
  udphdr->src = htons(pcb->local_port);
 8008726:	8a60      	ldrh	r0, [r4, #18]
 8008728:	f7fb fe5a 	bl	80043e0 <lwip_htons>
 800872c:	8028      	strh	r0, [r5, #0]
  udphdr->dest = htons(dst_port);
 800872e:	4650      	mov	r0, sl
 8008730:	f7fb fe56 	bl	80043e0 <lwip_htons>
 8008734:	8068      	strh	r0, [r5, #2]
  udphdr->chksum = 0x0000; 
 8008736:	2300      	movs	r3, #0
 8008738:	71ab      	strb	r3, [r5, #6]
 800873a:	71eb      	strb	r3, [r5, #7]
  if (ip_addr_isany(&pcb->local_ip)) {
 800873c:	46a2      	mov	sl, r4
 800873e:	b10c      	cbz	r4, 8008744 <udp_sendto_if+0x6c>
 8008740:	6823      	ldr	r3, [r4, #0]
 8008742:	bb2b      	cbnz	r3, 8008790 <udp_sendto_if+0xb8>
    src_ip = &(netif->ip_addr);
 8008744:	f108 0a04 	add.w	sl, r8, #4
    udphdr->len = htons(q->tot_len);
 8008748:	8930      	ldrh	r0, [r6, #8]
 800874a:	f7fb fe49 	bl	80043e0 <lwip_htons>
 800874e:	80a8      	strh	r0, [r5, #4]
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 8008750:	7c23      	ldrb	r3, [r4, #16]
 8008752:	f013 0f01 	tst.w	r3, #1
 8008756:	d027      	beq.n	80087a8 <udp_sendto_if+0xd0>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 8008758:	7aa3      	ldrb	r3, [r4, #10]
 800875a:	f8cd 8008 	str.w	r8, [sp, #8]
 800875e:	2211      	movs	r2, #17
 8008760:	9201      	str	r2, [sp, #4]
 8008762:	7a62      	ldrb	r2, [r4, #9]
 8008764:	9200      	str	r2, [sp, #0]
 8008766:	464a      	mov	r2, r9
 8008768:	4651      	mov	r1, sl
 800876a:	4630      	mov	r0, r6
 800876c:	f7fc f98e 	bl	8004a8c <ip_output_if>
 8008770:	4605      	mov	r5, r0
  if (q != p) {
 8008772:	42be      	cmp	r6, r7
 8008774:	d002      	beq.n	800877c <udp_sendto_if+0xa4>
    pbuf_free(q);
 8008776:	4630      	mov	r0, r6
 8008778:	f7fd f8ad 	bl	80058d6 <pbuf_free>
  UDP_STATS_INC(udp.xmit);
 800877c:	4a15      	ldr	r2, [pc, #84]	; (80087d4 <udp_sendto_if+0xfc>)
 800877e:	f8b2 3078 	ldrh.w	r3, [r2, #120]	; 0x78
 8008782:	3301      	adds	r3, #1
 8008784:	f8a2 3078 	strh.w	r3, [r2, #120]	; 0x78
}
 8008788:	4628      	mov	r0, r5
 800878a:	b004      	add	sp, #16
 800878c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 8008790:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8008794:	4293      	cmp	r3, r2
 8008796:	d0d7      	beq.n	8008748 <udp_sendto_if+0x70>
      if (q != p) {
 8008798:	42be      	cmp	r6, r7
 800879a:	d017      	beq.n	80087cc <udp_sendto_if+0xf4>
        pbuf_free(q);
 800879c:	4630      	mov	r0, r6
 800879e:	f7fd f89a 	bl	80058d6 <pbuf_free>
      return ERR_VAL;
 80087a2:	f06f 0505 	mvn.w	r5, #5
 80087a6:	e7ef      	b.n	8008788 <udp_sendto_if+0xb0>
        udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
 80087a8:	8933      	ldrh	r3, [r6, #8]
 80087aa:	9300      	str	r3, [sp, #0]
 80087ac:	2311      	movs	r3, #17
 80087ae:	464a      	mov	r2, r9
 80087b0:	4651      	mov	r1, sl
 80087b2:	4630      	mov	r0, r6
 80087b4:	f7fb ffac 	bl	8004710 <inet_chksum_pseudo>
      udphdr->chksum = udpchksum;
 80087b8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80087bc:	2800      	cmp	r0, #0
 80087be:	bf08      	it	eq
 80087c0:	4618      	moveq	r0, r3
 80087c2:	80e8      	strh	r0, [r5, #6]
 80087c4:	e7c8      	b.n	8008758 <udp_sendto_if+0x80>
      return ERR_MEM;
 80087c6:	f04f 35ff 	mov.w	r5, #4294967295
 80087ca:	e7dd      	b.n	8008788 <udp_sendto_if+0xb0>
      return ERR_VAL;
 80087cc:	f06f 0505 	mvn.w	r5, #5
 80087d0:	e7da      	b.n	8008788 <udp_sendto_if+0xb0>
 80087d2:	bf00      	nop
 80087d4:	2000b110 	.word	0x2000b110

080087d8 <udp_sendto>:
{
 80087d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80087da:	b083      	sub	sp, #12
 80087dc:	4605      	mov	r5, r0
 80087de:	460e      	mov	r6, r1
 80087e0:	4614      	mov	r4, r2
 80087e2:	461f      	mov	r7, r3
  netif = ip_route(dst_ip);
 80087e4:	4610      	mov	r0, r2
 80087e6:	f7fc f80b 	bl	8004800 <ip_route>
  if (netif == NULL) {
 80087ea:	b140      	cbz	r0, 80087fe <udp_sendto+0x26>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 80087ec:	9000      	str	r0, [sp, #0]
 80087ee:	463b      	mov	r3, r7
 80087f0:	4622      	mov	r2, r4
 80087f2:	4631      	mov	r1, r6
 80087f4:	4628      	mov	r0, r5
 80087f6:	f7ff ff6f 	bl	80086d8 <udp_sendto_if>
}
 80087fa:	b003      	add	sp, #12
 80087fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    UDP_STATS_INC(udp.rterr);
 80087fe:	4a04      	ldr	r2, [pc, #16]	; (8008810 <udp_sendto+0x38>)
 8008800:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 8008804:	3301      	adds	r3, #1
 8008806:	f8a2 3086 	strh.w	r3, [r2, #134]	; 0x86
    return ERR_RTE;
 800880a:	f06f 0003 	mvn.w	r0, #3
 800880e:	e7f4      	b.n	80087fa <udp_sendto+0x22>
 8008810:	2000b110 	.word	0x2000b110

08008814 <udp_recv>:
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
 8008814:	6181      	str	r1, [r0, #24]
  pcb->recv_arg = recv_arg;
 8008816:	61c2      	str	r2, [r0, #28]
 8008818:	4770      	bx	lr
	...

0800881c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 800881c:	b508      	push	{r3, lr}
 800881e:	4601      	mov	r1, r0
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 8008820:	4b0b      	ldr	r3, [pc, #44]	; (8008850 <udp_remove+0x34>)
 8008822:	681a      	ldr	r2, [r3, #0]
 8008824:	4282      	cmp	r2, r0
 8008826:	d001      	beq.n	800882c <udp_remove+0x10>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8008828:	b942      	cbnz	r2, 800883c <udp_remove+0x20>
 800882a:	e002      	b.n	8008832 <udp_remove+0x16>
    udp_pcbs = udp_pcbs->next;
 800882c:	68d2      	ldr	r2, [r2, #12]
 800882e:	4b08      	ldr	r3, [pc, #32]	; (8008850 <udp_remove+0x34>)
 8008830:	601a      	str	r2, [r3, #0]
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 8008832:	2001      	movs	r0, #1
 8008834:	f7fc ff58 	bl	80056e8 <memp_free>
 8008838:	bd08      	pop	{r3, pc}
{
 800883a:	461a      	mov	r2, r3
      if (pcb2->next != NULL && pcb2->next == pcb) {
 800883c:	68d3      	ldr	r3, [r2, #12]
 800883e:	2b00      	cmp	r3, #0
 8008840:	d0f7      	beq.n	8008832 <udp_remove+0x16>
 8008842:	4299      	cmp	r1, r3
 8008844:	d1f9      	bne.n	800883a <udp_remove+0x1e>
        pcb2->next = pcb->next;
 8008846:	68cb      	ldr	r3, [r1, #12]
 8008848:	60d3      	str	r3, [r2, #12]
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 800884a:	2b00      	cmp	r3, #0
 800884c:	d1f5      	bne.n	800883a <udp_remove+0x1e>
 800884e:	e7f0      	b.n	8008832 <udp_remove+0x16>
 8008850:	2000b248 	.word	0x2000b248

08008854 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 8008854:	b510      	push	{r4, lr}
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 8008856:	2001      	movs	r0, #1
 8008858:	f7fc ff10 	bl	800567c <memp_malloc>
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 800885c:	4604      	mov	r4, r0
 800885e:	b128      	cbz	r0, 800886c <udp_new+0x18>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 8008860:	2220      	movs	r2, #32
 8008862:	2100      	movs	r1, #0
 8008864:	f000 fc4e 	bl	8009104 <memset>
    pcb->ttl = UDP_TTL;
 8008868:	23ff      	movs	r3, #255	; 0xff
 800886a:	72a3      	strb	r3, [r4, #10]
  }
  return pcb;
}
 800886c:	4620      	mov	r0, r4
 800886e:	bd10      	pop	{r4, pc}

08008870 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 8008870:	b510      	push	{r4, lr}
 8008872:	4604      	mov	r4, r0
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8008874:	eb00 0280 	add.w	r2, r0, r0, lsl #2
 8008878:	4b09      	ldr	r3, [pc, #36]	; (80088a0 <etharp_free_entry+0x30>)
 800887a:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 800887e:	b138      	cbz	r0, 8008890 <etharp_free_entry+0x20>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8008880:	f7fd f829 	bl	80058d6 <pbuf_free>
    arp_table[i].q = NULL;
 8008884:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 8008888:	009b      	lsls	r3, r3, #2
 800888a:	2100      	movs	r1, #0
 800888c:	4a04      	ldr	r2, [pc, #16]	; (80088a0 <etharp_free_entry+0x30>)
 800888e:	50d1      	str	r1, [r2, r3]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8008890:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8008894:	4b02      	ldr	r3, [pc, #8]	; (80088a0 <etharp_free_entry+0x30>)
 8008896:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 800889a:	2300      	movs	r3, #0
 800889c:	74a3      	strb	r3, [r4, #18]
 800889e:	bd10      	pop	{r4, pc}
 80088a0:	200077c0 	.word	0x200077c0

080088a4 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
 80088a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80088a8:	b083      	sub	sp, #12
 80088aa:	4a3f      	ldr	r2, [pc, #252]	; (80089a8 <etharp_find_entry+0x104>)
 80088ac:	2300      	movs	r3, #0
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u8_t age_queue = 0;
 80088ae:	4698      	mov	r8, r3
  s8_t old_queue = ARP_TABLE_SIZE;
 80088b0:	f04f 0e0a 	mov.w	lr, #10
  u8_t i = 0, age_pending = 0, age_stable = 0;
 80088b4:	469c      	mov	ip, r3
  s8_t empty = ARP_TABLE_SIZE;
 80088b6:	4675      	mov	r5, lr
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 80088b8:	46f1      	mov	r9, lr
 80088ba:	46f2      	mov	sl, lr
 80088bc:	9301      	str	r3, [sp, #4]
 80088be:	e005      	b.n	80088cc <etharp_find_entry+0x28>
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80088c0:	b957      	cbnz	r7, 80088d8 <etharp_find_entry+0x34>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 80088c2:	b25d      	sxtb	r5, r3
 80088c4:	3301      	adds	r3, #1
 80088c6:	3214      	adds	r2, #20
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 80088c8:	2b0a      	cmp	r3, #10
 80088ca:	d02e      	beq.n	800892a <etharp_find_entry+0x86>
 80088cc:	4614      	mov	r4, r2
    u8_t state = arp_table[i].state;
 80088ce:	7c97      	ldrb	r7, [r2, #18]
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 80088d0:	2d0a      	cmp	r5, #10
 80088d2:	d0f5      	beq.n	80088c0 <etharp_find_entry+0x1c>
    } else if (state != ETHARP_STATE_EMPTY) {
 80088d4:	2f00      	cmp	r7, #0
 80088d6:	d0f5      	beq.n	80088c4 <etharp_find_entry+0x20>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 80088d8:	b120      	cbz	r0, 80088e4 <etharp_find_entry+0x40>
 80088da:	6806      	ldr	r6, [r0, #0]
 80088dc:	46b3      	mov	fp, r6
 80088de:	6866      	ldr	r6, [r4, #4]
 80088e0:	45b3      	cmp	fp, r6
 80088e2:	d00f      	beq.n	8008904 <etharp_find_entry+0x60>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 80088e4:	2f01      	cmp	r7, #1
 80088e6:	d00f      	beq.n	8008908 <etharp_find_entry+0x64>
            old_pending = i;
            age_pending = arp_table[i].ctime;
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
 80088e8:	f1a7 0b02 	sub.w	fp, r7, #2
 80088ec:	fa5f fb8b 	uxtb.w	fp, fp
 80088f0:	f1bb 0f01 	cmp.w	fp, #1
 80088f4:	d8e6      	bhi.n	80088c4 <etharp_find_entry+0x20>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 80088f6:	7ce4      	ldrb	r4, [r4, #19]
 80088f8:	4564      	cmp	r4, ip
            old_stable = i;
 80088fa:	bf24      	itt	cs
 80088fc:	fa4f f983 	sxtbcs.w	r9, r3
            age_stable = arp_table[i].ctime;
 8008900:	46a4      	movcs	ip, r4
 8008902:	e7df      	b.n	80088c4 <etharp_find_entry+0x20>
        return i;
 8008904:	b258      	sxtb	r0, r3
 8008906:	e02a      	b.n	800895e <etharp_find_entry+0xba>
        if (arp_table[i].q != NULL) {
 8008908:	6827      	ldr	r7, [r4, #0]
 800890a:	b137      	cbz	r7, 800891a <etharp_find_entry+0x76>
          if (arp_table[i].ctime >= age_queue) {
 800890c:	7ce4      	ldrb	r4, [r4, #19]
 800890e:	4544      	cmp	r4, r8
 8008910:	d3d8      	bcc.n	80088c4 <etharp_find_entry+0x20>
            old_queue = i;
 8008912:	fa4f fe83 	sxtb.w	lr, r3
            age_queue = arp_table[i].ctime;
 8008916:	46a0      	mov	r8, r4
 8008918:	e7d4      	b.n	80088c4 <etharp_find_entry+0x20>
          if (arp_table[i].ctime >= age_pending) {
 800891a:	7ce4      	ldrb	r4, [r4, #19]
 800891c:	9e01      	ldr	r6, [sp, #4]
 800891e:	42b4      	cmp	r4, r6
 8008920:	d3d0      	bcc.n	80088c4 <etharp_find_entry+0x20>
            old_pending = i;
 8008922:	fa4f fa83 	sxtb.w	sl, r3
            age_pending = arp_table[i].ctime;
 8008926:	9401      	str	r4, [sp, #4]
 8008928:	e7cc      	b.n	80088c4 <etharp_find_entry+0x20>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 800892a:	f011 0f02 	tst.w	r1, #2
 800892e:	d131      	bne.n	8008994 <etharp_find_entry+0xf0>
 8008930:	4604      	mov	r4, r0
 8008932:	2d0a      	cmp	r5, #10
 8008934:	d016      	beq.n	8008964 <etharp_find_entry+0xc0>
   * 
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 8008936:	2d09      	cmp	r5, #9
 8008938:	dc17      	bgt.n	800896a <etharp_find_entry+0xc6>
    i = empty;
 800893a:	b2ed      	uxtb	r5, r5
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 800893c:	462b      	mov	r3, r5
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 800893e:	b134      	cbz	r4, 800894e <etharp_find_entry+0xaa>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
 8008940:	6820      	ldr	r0, [r4, #0]
 8008942:	eb05 0285 	add.w	r2, r5, r5, lsl #2
 8008946:	4918      	ldr	r1, [pc, #96]	; (80089a8 <etharp_find_entry+0x104>)
 8008948:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 800894c:	6050      	str	r0, [r2, #4]
  }
  arp_table[i].ctime = 0;
 800894e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8008952:	4a15      	ldr	r2, [pc, #84]	; (80089a8 <etharp_find_entry+0x104>)
 8008954:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008958:	2200      	movs	r2, #0
 800895a:	74da      	strb	r2, [r3, #19]
  return (err_t)i;
 800895c:	b268      	sxtb	r0, r5
}
 800895e:	b003      	add	sp, #12
 8008960:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 8008964:	f011 0f01 	tst.w	r1, #1
 8008968:	d017      	beq.n	800899a <etharp_find_entry+0xf6>
    if (old_stable < ARP_TABLE_SIZE) {
 800896a:	f1b9 0f09 	cmp.w	r9, #9
 800896e:	dc05      	bgt.n	800897c <etharp_find_entry+0xd8>
      i = old_stable;
 8008970:	fa5f f589 	uxtb.w	r5, r9
    etharp_free_entry(i);
 8008974:	4628      	mov	r0, r5
 8008976:	f7ff ff7b 	bl	8008870 <etharp_free_entry>
 800897a:	e7df      	b.n	800893c <etharp_find_entry+0x98>
    } else if (old_pending < ARP_TABLE_SIZE) {
 800897c:	f1ba 0f09 	cmp.w	sl, #9
 8008980:	dc02      	bgt.n	8008988 <etharp_find_entry+0xe4>
      i = old_pending;
 8008982:	fa5f f58a 	uxtb.w	r5, sl
 8008986:	e7f5      	b.n	8008974 <etharp_find_entry+0xd0>
    } else if (old_queue < ARP_TABLE_SIZE) {
 8008988:	f1be 0f09 	cmp.w	lr, #9
 800898c:	dc08      	bgt.n	80089a0 <etharp_find_entry+0xfc>
      i = old_queue;
 800898e:	fa5f f58e 	uxtb.w	r5, lr
 8008992:	e7ef      	b.n	8008974 <etharp_find_entry+0xd0>
    return (s8_t)ERR_MEM;
 8008994:	f04f 30ff 	mov.w	r0, #4294967295
 8008998:	e7e1      	b.n	800895e <etharp_find_entry+0xba>
 800899a:	f04f 30ff 	mov.w	r0, #4294967295
 800899e:	e7de      	b.n	800895e <etharp_find_entry+0xba>
      return (s8_t)ERR_MEM;
 80089a0:	f04f 30ff 	mov.w	r0, #4294967295
 80089a4:	e7db      	b.n	800895e <etharp_find_entry+0xba>
 80089a6:	bf00      	nop
 80089a8:	200077c0 	.word	0x200077c0

080089ac <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
 80089ac:	b538      	push	{r3, r4, r5, lr}
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 80089ae:	684c      	ldr	r4, [r1, #4]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 80089b0:	681d      	ldr	r5, [r3, #0]
 80089b2:	6025      	str	r5, [r4, #0]
 80089b4:	889b      	ldrh	r3, [r3, #4]
 80089b6:	80a3      	strh	r3, [r4, #4]
  ETHADDR16_COPY(&ethhdr->src, src);
 80089b8:	6813      	ldr	r3, [r2, #0]
 80089ba:	f8c4 3006 	str.w	r3, [r4, #6]
 80089be:	8893      	ldrh	r3, [r2, #4]
 80089c0:	8163      	strh	r3, [r4, #10]
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 80089c2:	2308      	movs	r3, #8
 80089c4:	7323      	strb	r3, [r4, #12]
 80089c6:	2300      	movs	r3, #0
 80089c8:	7363      	strb	r3, [r4, #13]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 80089ca:	6983      	ldr	r3, [r0, #24]
 80089cc:	4798      	blx	r3
}
 80089ce:	bd38      	pop	{r3, r4, r5, pc}

080089d0 <etharp_update_arp_entry>:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 80089d0:	2900      	cmp	r1, #0
 80089d2:	d045      	beq.n	8008a60 <etharp_update_arp_entry+0x90>
{
 80089d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80089d6:	4604      	mov	r4, r0
 80089d8:	460e      	mov	r6, r1
  if (ip_addr_isany(ipaddr) ||
 80089da:	6808      	ldr	r0, [r1, #0]
 80089dc:	2800      	cmp	r0, #0
 80089de:	d043      	beq.n	8008a68 <etharp_update_arp_entry+0x98>
 80089e0:	461f      	mov	r7, r3
 80089e2:	4615      	mov	r5, r2
      ip_addr_isbroadcast(ipaddr, netif) ||
 80089e4:	4621      	mov	r1, r4
 80089e6:	f7fc f8f7 	bl	8004bd8 <ip4_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
 80089ea:	2800      	cmp	r0, #0
 80089ec:	d13f      	bne.n	8008a6e <etharp_update_arp_entry+0x9e>
      ip_addr_ismulticast(ipaddr)) {
 80089ee:	6832      	ldr	r2, [r6, #0]
 80089f0:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
      ip_addr_isbroadcast(ipaddr, netif) ||
 80089f4:	2ae0      	cmp	r2, #224	; 0xe0
 80089f6:	d03d      	beq.n	8008a74 <etharp_update_arp_entry+0xa4>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
 80089f8:	4639      	mov	r1, r7
 80089fa:	4630      	mov	r0, r6
 80089fc:	f7ff ff52 	bl	80088a4 <etharp_find_entry>
  /* bail out if no entry could be found */
  if (i < 0) {
 8008a00:	1e01      	subs	r1, r0, #0
 8008a02:	db2b      	blt.n	8008a5c <etharp_update_arp_entry+0x8c>
    return (err_t)i;
  }

#if ETHARP_SUPPORT_STATIC_ENTRIES
  if (flags & ETHARP_FLAG_STATIC_ENTRY) {
 8008a04:	f017 0f04 	tst.w	r7, #4
    /* record static type */
    arp_table[i].state = ETHARP_STATE_STATIC;
 8008a08:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 8008a0c:	4a1c      	ldr	r2, [pc, #112]	; (8008a80 <etharp_update_arp_entry+0xb0>)
 8008a0e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008a12:	bf14      	ite	ne
 8008a14:	2204      	movne	r2, #4
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 8008a16:	2202      	moveq	r2, #2
 8008a18:	749a      	strb	r2, [r3, #18]
  }

  /* record network interface */
  arp_table[i].netif = netif;
 8008a1a:	4e19      	ldr	r6, [pc, #100]	; (8008a80 <etharp_update_arp_entry+0xb0>)
 8008a1c:	008b      	lsls	r3, r1, #2
 8008a1e:	185a      	adds	r2, r3, r1
 8008a20:	0092      	lsls	r2, r2, #2
 8008a22:	18b7      	adds	r7, r6, r2
 8008a24:	60bc      	str	r4, [r7, #8]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 8008a26:	4613      	mov	r3, r2
 8008a28:	330c      	adds	r3, #12
 8008a2a:	eb06 0e03 	add.w	lr, r6, r3
 8008a2e:	6828      	ldr	r0, [r5, #0]
 8008a30:	50f0      	str	r0, [r6, r3]
 8008a32:	88ab      	ldrh	r3, [r5, #4]
 8008a34:	f8ae 3004 	strh.w	r3, [lr, #4]
  /* reset time stamp */
  arp_table[i].ctime = 0;
 8008a38:	2300      	movs	r3, #0
 8008a3a:	74fb      	strb	r3, [r7, #19]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
 8008a3c:	58b6      	ldr	r6, [r6, r2]
 8008a3e:	b1e6      	cbz	r6, 8008a7a <etharp_update_arp_entry+0xaa>
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
 8008a40:	461f      	mov	r7, r3
 8008a42:	4b0f      	ldr	r3, [pc, #60]	; (8008a80 <etharp_update_arp_entry+0xb0>)
 8008a44:	509f      	str	r7, [r3, r2]
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
 8008a46:	462b      	mov	r3, r5
 8008a48:	f104 0223 	add.w	r2, r4, #35	; 0x23
 8008a4c:	4631      	mov	r1, r6
 8008a4e:	4620      	mov	r0, r4
 8008a50:	f7ff ffac 	bl	80089ac <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
 8008a54:	4630      	mov	r0, r6
 8008a56:	f7fc ff3e 	bl	80058d6 <pbuf_free>
  }
  return ERR_OK;
 8008a5a:	4639      	mov	r1, r7
}
 8008a5c:	4608      	mov	r0, r1
 8008a5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return ERR_ARG;
 8008a60:	f06f 010d 	mvn.w	r1, #13
}
 8008a64:	4608      	mov	r0, r1
 8008a66:	4770      	bx	lr
    return ERR_ARG;
 8008a68:	f06f 010d 	mvn.w	r1, #13
 8008a6c:	e7f6      	b.n	8008a5c <etharp_update_arp_entry+0x8c>
 8008a6e:	f06f 010d 	mvn.w	r1, #13
 8008a72:	e7f3      	b.n	8008a5c <etharp_update_arp_entry+0x8c>
 8008a74:	f06f 010d 	mvn.w	r1, #13
 8008a78:	e7f0      	b.n	8008a5c <etharp_update_arp_entry+0x8c>
  return ERR_OK;
 8008a7a:	2100      	movs	r1, #0
 8008a7c:	e7ee      	b.n	8008a5c <etharp_update_arp_entry+0x8c>
 8008a7e:	bf00      	nop
 8008a80:	200077c0 	.word	0x200077c0

08008a84 <etharp_tmr>:
{
 8008a84:	b570      	push	{r4, r5, r6, lr}
 8008a86:	4c0f      	ldr	r4, [pc, #60]	; (8008ac4 <etharp_tmr+0x40>)
 8008a88:	2500      	movs	r5, #0
        arp_table[i].state = ETHARP_STATE_STABLE;
 8008a8a:	2602      	movs	r6, #2
 8008a8c:	e007      	b.n	8008a9e <etharp_tmr+0x1a>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 8008a8e:	2b01      	cmp	r3, #1
 8008a90:	d901      	bls.n	8008a96 <etharp_tmr+0x12>
        etharp_free_entry(i);
 8008a92:	f7ff feed 	bl	8008870 <etharp_free_entry>
 8008a96:	3501      	adds	r5, #1
 8008a98:	3414      	adds	r4, #20
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8008a9a:	2d0a      	cmp	r5, #10
 8008a9c:	d010      	beq.n	8008ac0 <etharp_tmr+0x3c>
    u8_t state = arp_table[i].state;
 8008a9e:	4628      	mov	r0, r5
 8008aa0:	7ca2      	ldrb	r2, [r4, #18]
    if (state != ETHARP_STATE_EMPTY
 8008aa2:	f012 0ffb 	tst.w	r2, #251	; 0xfb
 8008aa6:	d0f6      	beq.n	8008a96 <etharp_tmr+0x12>
      arp_table[i].ctime++;
 8008aa8:	7ce3      	ldrb	r3, [r4, #19]
 8008aaa:	3301      	adds	r3, #1
 8008aac:	b2db      	uxtb	r3, r3
 8008aae:	74e3      	strb	r3, [r4, #19]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 8008ab0:	2bef      	cmp	r3, #239	; 0xef
 8008ab2:	d8ee      	bhi.n	8008a92 <etharp_tmr+0xe>
 8008ab4:	2a01      	cmp	r2, #1
 8008ab6:	d0ea      	beq.n	8008a8e <etharp_tmr+0xa>
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
 8008ab8:	2a03      	cmp	r2, #3
        arp_table[i].state = ETHARP_STATE_STABLE;
 8008aba:	bf08      	it	eq
 8008abc:	74a6      	strbeq	r6, [r4, #18]
 8008abe:	e7ea      	b.n	8008a96 <etharp_tmr+0x12>
}
 8008ac0:	bd70      	pop	{r4, r5, r6, pc}
 8008ac2:	bf00      	nop
 8008ac4:	200077c0 	.word	0x200077c0

08008ac8 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
 8008ac8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008acc:	4605      	mov	r5, r0
 8008ace:	4688      	mov	r8, r1
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 8008ad0:	f100 0623 	add.w	r6, r0, #35	; 0x23
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 8008ad4:	2200      	movs	r2, #0
 8008ad6:	212a      	movs	r1, #42	; 0x2a
 8008ad8:	2003      	movs	r0, #3
 8008ada:	f7fc ff2b 	bl	8005934 <pbuf_alloc>
  if (p == NULL) {
 8008ade:	2800      	cmp	r0, #0
 8008ae0:	d03c      	beq.n	8008b5c <etharp_request+0x94>
 8008ae2:	4607      	mov	r7, r0
  ethhdr = (struct eth_hdr *)p->payload;
 8008ae4:	6844      	ldr	r4, [r0, #4]
  hdr->opcode = htons(opcode);
 8008ae6:	2001      	movs	r0, #1
 8008ae8:	f7fb fc7a 	bl	80043e0 <lwip_htons>
 8008aec:	82a0      	strh	r0, [r4, #20]
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 8008aee:	6833      	ldr	r3, [r6, #0]
 8008af0:	f8c4 3016 	str.w	r3, [r4, #22]
 8008af4:	88b3      	ldrh	r3, [r6, #4]
 8008af6:	8363      	strh	r3, [r4, #26]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 8008af8:	4b1c      	ldr	r3, [pc, #112]	; (8008b6c <etharp_request+0xa4>)
 8008afa:	6818      	ldr	r0, [r3, #0]
 8008afc:	6220      	str	r0, [r4, #32]
 8008afe:	889b      	ldrh	r3, [r3, #4]
 8008b00:	84a3      	strh	r3, [r4, #36]	; 0x24
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 8008b02:	4b1b      	ldr	r3, [pc, #108]	; (8008b70 <etharp_request+0xa8>)
 8008b04:	6818      	ldr	r0, [r3, #0]
 8008b06:	6020      	str	r0, [r4, #0]
 8008b08:	889b      	ldrh	r3, [r3, #4]
 8008b0a:	80a3      	strh	r3, [r4, #4]
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
 8008b0c:	6833      	ldr	r3, [r6, #0]
 8008b0e:	f8c4 3006 	str.w	r3, [r4, #6]
 8008b12:	88b3      	ldrh	r3, [r6, #4]
 8008b14:	8163      	strh	r3, [r4, #10]
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 8008b16:	686b      	ldr	r3, [r5, #4]
 8008b18:	61e3      	str	r3, [r4, #28]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 8008b1a:	f8d8 3000 	ldr.w	r3, [r8]
 8008b1e:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 8008b22:	2200      	movs	r2, #0
 8008b24:	73a2      	strb	r2, [r4, #14]
 8008b26:	2301      	movs	r3, #1
 8008b28:	73e3      	strb	r3, [r4, #15]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 8008b2a:	2308      	movs	r3, #8
 8008b2c:	7423      	strb	r3, [r4, #16]
 8008b2e:	7462      	strb	r2, [r4, #17]
  hdr->hwlen = ETHARP_HWADDR_LEN;
 8008b30:	2206      	movs	r2, #6
 8008b32:	74a2      	strb	r2, [r4, #18]
  hdr->protolen = sizeof(ip_addr_t);
 8008b34:	2204      	movs	r2, #4
 8008b36:	74e2      	strb	r2, [r4, #19]
  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 8008b38:	7323      	strb	r3, [r4, #12]
 8008b3a:	2306      	movs	r3, #6
 8008b3c:	7363      	strb	r3, [r4, #13]
  result = netif->linkoutput(netif, p);
 8008b3e:	69ab      	ldr	r3, [r5, #24]
 8008b40:	4639      	mov	r1, r7
 8008b42:	4628      	mov	r0, r5
 8008b44:	4798      	blx	r3
 8008b46:	4604      	mov	r4, r0
  ETHARP_STATS_INC(etharp.xmit);
 8008b48:	4a0a      	ldr	r2, [pc, #40]	; (8008b74 <etharp_request+0xac>)
 8008b4a:	8b13      	ldrh	r3, [r2, #24]
 8008b4c:	3301      	adds	r3, #1
 8008b4e:	8313      	strh	r3, [r2, #24]
  pbuf_free(p);
 8008b50:	4638      	mov	r0, r7
 8008b52:	f7fc fec0 	bl	80058d6 <pbuf_free>
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
 8008b56:	4620      	mov	r0, r4
 8008b58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ETHARP_STATS_INC(etharp.memerr);
 8008b5c:	4a05      	ldr	r2, [pc, #20]	; (8008b74 <etharp_request+0xac>)
 8008b5e:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8008b60:	3301      	adds	r3, #1
 8008b62:	8493      	strh	r3, [r2, #36]	; 0x24
    return ERR_MEM;
 8008b64:	f04f 34ff 	mov.w	r4, #4294967295
 8008b68:	e7f5      	b.n	8008b56 <etharp_request+0x8e>
 8008b6a:	bf00      	nop
 8008b6c:	08009298 	.word	0x08009298
 8008b70:	08009290 	.word	0x08009290
 8008b74:	2000b110 	.word	0x2000b110

08008b78 <etharp_output_to_arp_index>:
{
 8008b78:	b570      	push	{r4, r5, r6, lr}
 8008b7a:	4605      	mov	r5, r0
 8008b7c:	460e      	mov	r6, r1
 8008b7e:	4614      	mov	r4, r2
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 8008b80:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8008b84:	4b15      	ldr	r3, [pc, #84]	; (8008bdc <etharp_output_to_arp_index+0x64>)
 8008b86:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 8008b8a:	7c9b      	ldrb	r3, [r3, #18]
 8008b8c:	2b02      	cmp	r3, #2
 8008b8e:	d00c      	beq.n	8008baa <etharp_output_to_arp_index+0x32>
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 8008b90:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8008b94:	4b11      	ldr	r3, [pc, #68]	; (8008bdc <etharp_output_to_arp_index+0x64>)
 8008b96:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8008b9a:	330c      	adds	r3, #12
 8008b9c:	f105 0223 	add.w	r2, r5, #35	; 0x23
 8008ba0:	4631      	mov	r1, r6
 8008ba2:	4628      	mov	r0, r5
 8008ba4:	f7ff ff02 	bl	80089ac <etharp_send_ip>
}
 8008ba8:	bd70      	pop	{r4, r5, r6, pc}
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
 8008baa:	4613      	mov	r3, r2
 8008bac:	4a0b      	ldr	r2, [pc, #44]	; (8008bdc <etharp_output_to_arp_index+0x64>)
 8008bae:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 8008bb2:	7cdb      	ldrb	r3, [r3, #19]
 8008bb4:	2be3      	cmp	r3, #227	; 0xe3
 8008bb6:	d9eb      	bls.n	8008b90 <etharp_output_to_arp_index+0x18>
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 8008bb8:	eb04 0184 	add.w	r1, r4, r4, lsl #2
 8008bbc:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8008bc0:	3104      	adds	r1, #4
 8008bc2:	f7ff ff81 	bl	8008ac8 <etharp_request>
 8008bc6:	2800      	cmp	r0, #0
 8008bc8:	d1e2      	bne.n	8008b90 <etharp_output_to_arp_index+0x18>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
 8008bca:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 8008bce:	4a03      	ldr	r2, [pc, #12]	; (8008bdc <etharp_output_to_arp_index+0x64>)
 8008bd0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008bd4:	2203      	movs	r2, #3
 8008bd6:	749a      	strb	r2, [r3, #18]
 8008bd8:	e7da      	b.n	8008b90 <etharp_output_to_arp_index+0x18>
 8008bda:	bf00      	nop
 8008bdc:	200077c0 	.word	0x200077c0

08008be0 <etharp_query>:
{
 8008be0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008be4:	4606      	mov	r6, r0
 8008be6:	460d      	mov	r5, r1
 8008be8:	4617      	mov	r7, r2
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 8008bea:	4601      	mov	r1, r0
 8008bec:	6828      	ldr	r0, [r5, #0]
 8008bee:	f7fb fff3 	bl	8004bd8 <ip4_addr_isbroadcast>
 8008bf2:	2800      	cmp	r0, #0
 8008bf4:	d16c      	bne.n	8008cd0 <etharp_query+0xf0>
      ip_addr_ismulticast(ipaddr) ||
 8008bf6:	682b      	ldr	r3, [r5, #0]
 8008bf8:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 8008bfc:	2ae0      	cmp	r2, #224	; 0xe0
 8008bfe:	d06a      	beq.n	8008cd6 <etharp_query+0xf6>
      ip_addr_ismulticast(ipaddr) ||
 8008c00:	2d00      	cmp	r5, #0
 8008c02:	d06b      	beq.n	8008cdc <etharp_query+0xfc>
      ip_addr_isany(ipaddr)) {
 8008c04:	2b00      	cmp	r3, #0
 8008c06:	d06c      	beq.n	8008ce2 <etharp_query+0x102>
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
 8008c08:	2101      	movs	r1, #1
 8008c0a:	4628      	mov	r0, r5
 8008c0c:	f7ff fe4a 	bl	80088a4 <etharp_find_entry>
  if (i < 0) {
 8008c10:	1e04      	subs	r4, r0, #0
 8008c12:	db36      	blt.n	8008c82 <etharp_query+0xa2>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 8008c14:	46a0      	mov	r8, r4
 8008c16:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 8008c1a:	4a44      	ldr	r2, [pc, #272]	; (8008d2c <etharp_query+0x14c>)
 8008c1c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008c20:	7c9b      	ldrb	r3, [r3, #18]
 8008c22:	2b00      	cmp	r3, #0
 8008c24:	d133      	bne.n	8008c8e <etharp_query+0xae>
    arp_table[i].state = ETHARP_STATE_PENDING;
 8008c26:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 8008c2a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008c2e:	2201      	movs	r2, #1
 8008c30:	749a      	strb	r2, [r3, #18]
    result = etharp_request(netif, ipaddr);
 8008c32:	4629      	mov	r1, r5
 8008c34:	4630      	mov	r0, r6
 8008c36:	f7ff ff47 	bl	8008ac8 <etharp_request>
    if (q == NULL) {
 8008c3a:	2f00      	cmp	r7, #0
 8008c3c:	d054      	beq.n	8008ce8 <etharp_query+0x108>
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 8008c3e:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 8008c42:	4a3a      	ldr	r2, [pc, #232]	; (8008d2c <etharp_query+0x14c>)
 8008c44:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008c48:	7c9b      	ldrb	r3, [r3, #18]
 8008c4a:	2b01      	cmp	r3, #1
 8008c4c:	d824      	bhi.n	8008c98 <etharp_query+0xb8>
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 8008c4e:	2b01      	cmp	r3, #1
 8008c50:	d14c      	bne.n	8008cec <etharp_query+0x10c>
      if(p->type != PBUF_ROM) {
 8008c52:	7b3b      	ldrb	r3, [r7, #12]
 8008c54:	2b01      	cmp	r3, #1
 8008c56:	d154      	bne.n	8008d02 <etharp_query+0x122>
 8008c58:	463b      	mov	r3, r7
      p = p->next;
 8008c5a:	681b      	ldr	r3, [r3, #0]
    while (p) {
 8008c5c:	2b00      	cmp	r3, #0
 8008c5e:	d052      	beq.n	8008d06 <etharp_query+0x126>
      if(p->type != PBUF_ROM) {
 8008c60:	7b1a      	ldrb	r2, [r3, #12]
 8008c62:	2a01      	cmp	r2, #1
 8008c64:	d0f9      	beq.n	8008c5a <etharp_query+0x7a>
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 8008c66:	2200      	movs	r2, #0
 8008c68:	8919      	ldrh	r1, [r3, #8]
 8008c6a:	2003      	movs	r0, #3
 8008c6c:	f7fc fe62 	bl	8005934 <pbuf_alloc>
      if(p != NULL) {
 8008c70:	4604      	mov	r4, r0
 8008c72:	b330      	cbz	r0, 8008cc2 <etharp_query+0xe2>
        if (pbuf_copy(p, q) != ERR_OK) {
 8008c74:	4639      	mov	r1, r7
 8008c76:	4620      	mov	r0, r4
 8008c78:	f7fc ff50 	bl	8005b1c <pbuf_copy>
 8008c7c:	b9f0      	cbnz	r0, 8008cbc <etharp_query+0xdc>
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 8008c7e:	4627      	mov	r7, r4
 8008c80:	e044      	b.n	8008d0c <etharp_query+0x12c>
    if (q) {
 8008c82:	b1c7      	cbz	r7, 8008cb6 <etharp_query+0xd6>
      ETHARP_STATS_INC(etharp.memerr);
 8008c84:	4a2a      	ldr	r2, [pc, #168]	; (8008d30 <etharp_query+0x150>)
 8008c86:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8008c88:	3301      	adds	r3, #1
 8008c8a:	8493      	strh	r3, [r2, #36]	; 0x24
 8008c8c:	e013      	b.n	8008cb6 <etharp_query+0xd6>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 8008c8e:	2b01      	cmp	r3, #1
 8008c90:	d0cf      	beq.n	8008c32 <etharp_query+0x52>
 8008c92:	b36f      	cbz	r7, 8008cf0 <etharp_query+0x110>
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 8008c94:	2b01      	cmp	r3, #1
 8008c96:	d931      	bls.n	8008cfc <etharp_query+0x11c>
    ETHARP_SET_HINT(netif, i);
 8008c98:	4b26      	ldr	r3, [pc, #152]	; (8008d34 <etharp_query+0x154>)
 8008c9a:	701c      	strb	r4, [r3, #0]
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 8008c9c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8008ca0:	4b22      	ldr	r3, [pc, #136]	; (8008d2c <etharp_query+0x14c>)
 8008ca2:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8008ca6:	330c      	adds	r3, #12
 8008ca8:	f106 0223 	add.w	r2, r6, #35	; 0x23
 8008cac:	4639      	mov	r1, r7
 8008cae:	4630      	mov	r0, r6
 8008cb0:	f7ff fe7c 	bl	80089ac <etharp_send_ip>
 8008cb4:	4604      	mov	r4, r0
}
 8008cb6:	4620      	mov	r0, r4
 8008cb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          pbuf_free(p);
 8008cbc:	4620      	mov	r0, r4
 8008cbe:	f7fc fe0a 	bl	80058d6 <pbuf_free>
      ETHARP_STATS_INC(etharp.memerr);
 8008cc2:	4a1b      	ldr	r2, [pc, #108]	; (8008d30 <etharp_query+0x150>)
 8008cc4:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8008cc6:	3301      	adds	r3, #1
 8008cc8:	8493      	strh	r3, [r2, #36]	; 0x24
      result = ERR_MEM;
 8008cca:	f04f 34ff 	mov.w	r4, #4294967295
 8008cce:	e7f2      	b.n	8008cb6 <etharp_query+0xd6>
    return ERR_ARG;
 8008cd0:	f06f 040d 	mvn.w	r4, #13
 8008cd4:	e7ef      	b.n	8008cb6 <etharp_query+0xd6>
 8008cd6:	f06f 040d 	mvn.w	r4, #13
 8008cda:	e7ec      	b.n	8008cb6 <etharp_query+0xd6>
 8008cdc:	f06f 040d 	mvn.w	r4, #13
 8008ce0:	e7e9      	b.n	8008cb6 <etharp_query+0xd6>
 8008ce2:	f06f 040d 	mvn.w	r4, #13
 8008ce6:	e7e6      	b.n	8008cb6 <etharp_query+0xd6>
    result = etharp_request(netif, ipaddr);
 8008ce8:	4604      	mov	r4, r0
 8008cea:	e7e4      	b.n	8008cb6 <etharp_query+0xd6>
 8008cec:	4604      	mov	r4, r0
 8008cee:	e7e2      	b.n	8008cb6 <etharp_query+0xd6>
 8008cf0:	4629      	mov	r1, r5
 8008cf2:	4630      	mov	r0, r6
 8008cf4:	f7ff fee8 	bl	8008ac8 <etharp_request>
 8008cf8:	4604      	mov	r4, r0
 8008cfa:	e7dc      	b.n	8008cb6 <etharp_query+0xd6>
  err_t result = ERR_MEM;
 8008cfc:	f04f 34ff 	mov.w	r4, #4294967295
 8008d00:	e7d9      	b.n	8008cb6 <etharp_query+0xd6>
      if(p->type != PBUF_ROM) {
 8008d02:	463b      	mov	r3, r7
 8008d04:	e7af      	b.n	8008c66 <etharp_query+0x86>
      pbuf_ref(p);
 8008d06:	4638      	mov	r0, r7
 8008d08:	f7fc fee2 	bl	8005ad0 <pbuf_ref>
      if (arp_table[i].q != NULL) {
 8008d0c:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 8008d10:	4a06      	ldr	r2, [pc, #24]	; (8008d2c <etharp_query+0x14c>)
 8008d12:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8008d16:	b108      	cbz	r0, 8008d1c <etharp_query+0x13c>
        pbuf_free(arp_table[i].q);
 8008d18:	f7fc fddd 	bl	80058d6 <pbuf_free>
      arp_table[i].q = p;
 8008d1c:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 8008d20:	4b02      	ldr	r3, [pc, #8]	; (8008d2c <etharp_query+0x14c>)
 8008d22:	f843 7028 	str.w	r7, [r3, r8, lsl #2]
      result = ERR_OK;
 8008d26:	2400      	movs	r4, #0
 8008d28:	e7c5      	b.n	8008cb6 <etharp_query+0xd6>
 8008d2a:	bf00      	nop
 8008d2c:	200077c0 	.word	0x200077c0
 8008d30:	2000b110 	.word	0x2000b110
 8008d34:	20007888 	.word	0x20007888

08008d38 <etharp_output>:
{
 8008d38:	b570      	push	{r4, r5, r6, lr}
 8008d3a:	b082      	sub	sp, #8
 8008d3c:	4605      	mov	r5, r0
 8008d3e:	460e      	mov	r6, r1
 8008d40:	4614      	mov	r4, r2
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 8008d42:	210e      	movs	r1, #14
 8008d44:	4630      	mov	r0, r6
 8008d46:	f7fc fd88 	bl	800585a <pbuf_header>
 8008d4a:	2800      	cmp	r0, #0
 8008d4c:	d12f      	bne.n	8008dae <etharp_output+0x76>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
 8008d4e:	4629      	mov	r1, r5
 8008d50:	6820      	ldr	r0, [r4, #0]
 8008d52:	f7fb ff41 	bl	8004bd8 <ip4_addr_isbroadcast>
 8008d56:	2800      	cmp	r0, #0
 8008d58:	d168      	bne.n	8008e2c <etharp_output+0xf4>
  } else if (ip_addr_ismulticast(ipaddr)) {
 8008d5a:	6823      	ldr	r3, [r4, #0]
 8008d5c:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8008d60:	2ae0      	cmp	r2, #224	; 0xe0
 8008d62:	d02b      	beq.n	8008dbc <etharp_output+0x84>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 8008d64:	686a      	ldr	r2, [r5, #4]
 8008d66:	405a      	eors	r2, r3
 8008d68:	68a9      	ldr	r1, [r5, #8]
 8008d6a:	420a      	tst	r2, r1
 8008d6c:	d00a      	beq.n	8008d84 <etharp_output+0x4c>
        !ip_addr_islinklocal(ipaddr)) {
 8008d6e:	b29b      	uxth	r3, r3
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 8008d70:	f64f 62a9 	movw	r2, #65193	; 0xfea9
 8008d74:	4293      	cmp	r3, r2
 8008d76:	d005      	beq.n	8008d84 <etharp_output+0x4c>
        if (!ip_addr_isany(&netif->gw)) {
 8008d78:	f115 040c 	adds.w	r4, r5, #12
 8008d7c:	d05f      	beq.n	8008e3e <etharp_output+0x106>
 8008d7e:	68eb      	ldr	r3, [r5, #12]
 8008d80:	2b00      	cmp	r3, #0
 8008d82:	d05f      	beq.n	8008e44 <etharp_output+0x10c>
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 8008d84:	4b31      	ldr	r3, [pc, #196]	; (8008e4c <etharp_output+0x114>)
 8008d86:	781a      	ldrb	r2, [r3, #0]
 8008d88:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 8008d8c:	4b30      	ldr	r3, [pc, #192]	; (8008e50 <etharp_output+0x118>)
 8008d8e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8008d92:	7c9b      	ldrb	r3, [r3, #18]
 8008d94:	2b01      	cmp	r3, #1
 8008d96:	d907      	bls.n	8008da8 <etharp_output+0x70>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 8008d98:	460b      	mov	r3, r1
 8008d9a:	492d      	ldr	r1, [pc, #180]	; (8008e50 <etharp_output+0x118>)
 8008d9c:	eb01 0383 	add.w	r3, r1, r3, lsl #2
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 8008da0:	6821      	ldr	r1, [r4, #0]
 8008da2:	685b      	ldr	r3, [r3, #4]
 8008da4:	4299      	cmp	r1, r3
 8008da6:	d01f      	beq.n	8008de8 <etharp_output+0xb0>
 8008da8:	4b29      	ldr	r3, [pc, #164]	; (8008e50 <etharp_output+0x118>)
{
 8008daa:	2200      	movs	r2, #0
 8008dac:	e029      	b.n	8008e02 <etharp_output+0xca>
    LINK_STATS_INC(link.lenerr);
 8008dae:	4a29      	ldr	r2, [pc, #164]	; (8008e54 <etharp_output+0x11c>)
 8008db0:	8953      	ldrh	r3, [r2, #10]
 8008db2:	3301      	adds	r3, #1
 8008db4:	8153      	strh	r3, [r2, #10]
    return ERR_BUF;
 8008db6:	f06f 0001 	mvn.w	r0, #1
 8008dba:	e03e      	b.n	8008e3a <etharp_output+0x102>
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 8008dbc:	2301      	movs	r3, #1
 8008dbe:	f88d 3000 	strb.w	r3, [sp]
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
 8008dc2:	2300      	movs	r3, #0
 8008dc4:	f88d 3001 	strb.w	r3, [sp, #1]
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 8008dc8:	235e      	movs	r3, #94	; 0x5e
 8008dca:	f88d 3002 	strb.w	r3, [sp, #2]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 8008dce:	7863      	ldrb	r3, [r4, #1]
 8008dd0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8008dd4:	f88d 3003 	strb.w	r3, [sp, #3]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 8008dd8:	78a3      	ldrb	r3, [r4, #2]
 8008dda:	f88d 3004 	strb.w	r3, [sp, #4]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 8008dde:	78e3      	ldrb	r3, [r4, #3]
 8008de0:	f88d 3005 	strb.w	r3, [sp, #5]
    dest = &mcastaddr;
 8008de4:	466b      	mov	r3, sp
 8008de6:	e022      	b.n	8008e2e <etharp_output+0xf6>
          ETHARP_STATS_INC(etharp.cachehit);
 8008de8:	491a      	ldr	r1, [pc, #104]	; (8008e54 <etharp_output+0x11c>)
 8008dea:	8dcb      	ldrh	r3, [r1, #46]	; 0x2e
 8008dec:	3301      	adds	r3, #1
 8008dee:	85cb      	strh	r3, [r1, #46]	; 0x2e
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 8008df0:	4631      	mov	r1, r6
 8008df2:	4628      	mov	r0, r5
 8008df4:	f7ff fec0 	bl	8008b78 <etharp_output_to_arp_index>
 8008df8:	e01f      	b.n	8008e3a <etharp_output+0x102>
 8008dfa:	3201      	adds	r2, #1
 8008dfc:	3314      	adds	r3, #20
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 8008dfe:	2a0a      	cmp	r2, #10
 8008e00:	d00e      	beq.n	8008e20 <etharp_output+0xe8>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 8008e02:	7c99      	ldrb	r1, [r3, #18]
 8008e04:	2901      	cmp	r1, #1
 8008e06:	d9f8      	bls.n	8008dfa <etharp_output+0xc2>
 8008e08:	6820      	ldr	r0, [r4, #0]
 8008e0a:	6859      	ldr	r1, [r3, #4]
 8008e0c:	4288      	cmp	r0, r1
 8008e0e:	d1f4      	bne.n	8008dfa <etharp_output+0xc2>
        ETHARP_SET_HINT(netif, i);
 8008e10:	b2d2      	uxtb	r2, r2
 8008e12:	4b0e      	ldr	r3, [pc, #56]	; (8008e4c <etharp_output+0x114>)
 8008e14:	701a      	strb	r2, [r3, #0]
        return etharp_output_to_arp_index(netif, q, i);
 8008e16:	4631      	mov	r1, r6
 8008e18:	4628      	mov	r0, r5
 8008e1a:	f7ff fead 	bl	8008b78 <etharp_output_to_arp_index>
 8008e1e:	e00c      	b.n	8008e3a <etharp_output+0x102>
    return etharp_query(netif, dst_addr, q);
 8008e20:	4632      	mov	r2, r6
 8008e22:	4621      	mov	r1, r4
 8008e24:	4628      	mov	r0, r5
 8008e26:	f7ff fedb 	bl	8008be0 <etharp_query>
 8008e2a:	e006      	b.n	8008e3a <etharp_output+0x102>
    dest = (struct eth_addr *)&ethbroadcast;
 8008e2c:	4b0a      	ldr	r3, [pc, #40]	; (8008e58 <etharp_output+0x120>)
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
 8008e2e:	f105 0223 	add.w	r2, r5, #35	; 0x23
 8008e32:	4631      	mov	r1, r6
 8008e34:	4628      	mov	r0, r5
 8008e36:	f7ff fdb9 	bl	80089ac <etharp_send_ip>
}
 8008e3a:	b002      	add	sp, #8
 8008e3c:	bd70      	pop	{r4, r5, r6, pc}
          return ERR_RTE;
 8008e3e:	f06f 0003 	mvn.w	r0, #3
 8008e42:	e7fa      	b.n	8008e3a <etharp_output+0x102>
 8008e44:	f06f 0003 	mvn.w	r0, #3
 8008e48:	e7f7      	b.n	8008e3a <etharp_output+0x102>
 8008e4a:	bf00      	nop
 8008e4c:	20007888 	.word	0x20007888
 8008e50:	200077c0 	.word	0x200077c0
 8008e54:	2000b110 	.word	0x2000b110
 8008e58:	08009290 	.word	0x08009290

08008e5c <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 8008e5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008e60:	b082      	sub	sp, #8
 8008e62:	4604      	mov	r4, r0
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 8008e64:	8945      	ldrh	r5, [r0, #10]
 8008e66:	2d0e      	cmp	r5, #14
 8008e68:	d80d      	bhi.n	8008e86 <ethernet_input+0x2a>
    /* a packet with only an ethernet header (or less) is not valid for us */
    ETHARP_STATS_INC(etharp.proterr);
 8008e6a:	4b70      	ldr	r3, [pc, #448]	; (800902c <ethernet_input+0x1d0>)
 8008e6c:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8008e6e:	3201      	adds	r2, #1
 8008e70:	851a      	strh	r2, [r3, #40]	; 0x28
    ETHARP_STATS_INC(etharp.drop);
 8008e72:	8bda      	ldrh	r2, [r3, #30]
 8008e74:	3201      	adds	r2, #1
 8008e76:	83da      	strh	r2, [r3, #30]
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 8008e78:	4620      	mov	r0, r4
 8008e7a:	f7fc fd2c 	bl	80058d6 <pbuf_free>
  return ERR_OK;
}
 8008e7e:	2000      	movs	r0, #0
 8008e80:	b002      	add	sp, #8
 8008e82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008e86:	460f      	mov	r7, r1
  ethhdr = (struct eth_hdr *)p->payload;
 8008e88:	6846      	ldr	r6, [r0, #4]
  type = ethhdr->type;
 8008e8a:	f8b6 800c 	ldrh.w	r8, [r6, #12]
  if (ethhdr->dest.addr[0] & 1) {
 8008e8e:	7833      	ldrb	r3, [r6, #0]
 8008e90:	f013 0f01 	tst.w	r3, #1
 8008e94:	d00b      	beq.n	8008eae <ethernet_input+0x52>
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
 8008e96:	2b01      	cmp	r3, #1
 8008e98:	d017      	beq.n	8008eca <ethernet_input+0x6e>
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 8008e9a:	2206      	movs	r2, #6
 8008e9c:	4964      	ldr	r1, [pc, #400]	; (8009030 <ethernet_input+0x1d4>)
 8008e9e:	4630      	mov	r0, r6
 8008ea0:	f000 f916 	bl	80090d0 <memcmp>
 8008ea4:	b918      	cbnz	r0, 8008eae <ethernet_input+0x52>
      p->flags |= PBUF_FLAG_LLBCAST;
 8008ea6:	7b63      	ldrb	r3, [r4, #13]
 8008ea8:	f043 0308 	orr.w	r3, r3, #8
 8008eac:	7363      	strb	r3, [r4, #13]
  switch (type) {
 8008eae:	f1b8 0f08 	cmp.w	r8, #8
 8008eb2:	d015      	beq.n	8008ee0 <ethernet_input+0x84>
 8008eb4:	f5b8 6fc1 	cmp.w	r8, #1544	; 0x608
 8008eb8:	d023      	beq.n	8008f02 <ethernet_input+0xa6>
      ETHARP_STATS_INC(etharp.proterr);
 8008eba:	4b5c      	ldr	r3, [pc, #368]	; (800902c <ethernet_input+0x1d0>)
 8008ebc:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8008ebe:	3201      	adds	r2, #1
 8008ec0:	851a      	strh	r2, [r3, #40]	; 0x28
      ETHARP_STATS_INC(etharp.drop);
 8008ec2:	8bda      	ldrh	r2, [r3, #30]
 8008ec4:	3201      	adds	r2, #1
 8008ec6:	83da      	strh	r2, [r3, #30]
      goto free_and_return;
 8008ec8:	e7d6      	b.n	8008e78 <ethernet_input+0x1c>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 8008eca:	7873      	ldrb	r3, [r6, #1]
 8008ecc:	2b00      	cmp	r3, #0
 8008ece:	d1ee      	bne.n	8008eae <ethernet_input+0x52>
 8008ed0:	78b3      	ldrb	r3, [r6, #2]
 8008ed2:	2b5e      	cmp	r3, #94	; 0x5e
 8008ed4:	d1eb      	bne.n	8008eae <ethernet_input+0x52>
        p->flags |= PBUF_FLAG_LLMCAST;
 8008ed6:	7b43      	ldrb	r3, [r0, #13]
 8008ed8:	f043 0310 	orr.w	r3, r3, #16
 8008edc:	7343      	strb	r3, [r0, #13]
 8008ede:	e7e6      	b.n	8008eae <ethernet_input+0x52>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 8008ee0:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8008ee4:	f013 0f20 	tst.w	r3, #32
 8008ee8:	d0c6      	beq.n	8008e78 <ethernet_input+0x1c>
      if(pbuf_header(p, -ip_hdr_offset)) {
 8008eea:	f06f 010d 	mvn.w	r1, #13
 8008eee:	4620      	mov	r0, r4
 8008ef0:	f7fc fcb3 	bl	800585a <pbuf_header>
 8008ef4:	2800      	cmp	r0, #0
 8008ef6:	d1bf      	bne.n	8008e78 <ethernet_input+0x1c>
        ip_input(p, netif);
 8008ef8:	4639      	mov	r1, r7
 8008efa:	4620      	mov	r0, r4
 8008efc:	f7fb fcaa 	bl	8004854 <ip_input>
      break;
 8008f00:	e7bd      	b.n	8008e7e <ethernet_input+0x22>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 8008f02:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8008f06:	f013 0f20 	tst.w	r3, #32
 8008f0a:	d0b5      	beq.n	8008e78 <ethernet_input+0x1c>
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 8008f0c:	2f00      	cmp	r7, #0
 8008f0e:	d0b6      	beq.n	8008e7e <ethernet_input+0x22>
  if (p->len < SIZEOF_ETHARP_PACKET) {
 8008f10:	2d29      	cmp	r5, #41	; 0x29
 8008f12:	d90e      	bls.n	8008f32 <ethernet_input+0xd6>
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 8008f14:	89f3      	ldrh	r3, [r6, #14]
 8008f16:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008f1a:	d015      	beq.n	8008f48 <ethernet_input+0xec>
    ETHARP_STATS_INC(etharp.proterr);
 8008f1c:	4b43      	ldr	r3, [pc, #268]	; (800902c <ethernet_input+0x1d0>)
 8008f1e:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8008f20:	3201      	adds	r2, #1
 8008f22:	851a      	strh	r2, [r3, #40]	; 0x28
    ETHARP_STATS_INC(etharp.drop);
 8008f24:	8bda      	ldrh	r2, [r3, #30]
 8008f26:	3201      	adds	r2, #1
 8008f28:	83da      	strh	r2, [r3, #30]
    pbuf_free(p);
 8008f2a:	4620      	mov	r0, r4
 8008f2c:	f7fc fcd3 	bl	80058d6 <pbuf_free>
 8008f30:	e7a5      	b.n	8008e7e <ethernet_input+0x22>
    ETHARP_STATS_INC(etharp.lenerr);
 8008f32:	4b3e      	ldr	r3, [pc, #248]	; (800902c <ethernet_input+0x1d0>)
 8008f34:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 8008f36:	3201      	adds	r2, #1
 8008f38:	845a      	strh	r2, [r3, #34]	; 0x22
    ETHARP_STATS_INC(etharp.drop);
 8008f3a:	8bda      	ldrh	r2, [r3, #30]
 8008f3c:	3201      	adds	r2, #1
 8008f3e:	83da      	strh	r2, [r3, #30]
    pbuf_free(p);
 8008f40:	4620      	mov	r0, r4
 8008f42:	f7fc fcc8 	bl	80058d6 <pbuf_free>
 8008f46:	e79a      	b.n	8008e7e <ethernet_input+0x22>
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 8008f48:	7cb3      	ldrb	r3, [r6, #18]
 8008f4a:	2b06      	cmp	r3, #6
 8008f4c:	d1e6      	bne.n	8008f1c <ethernet_input+0xc0>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 8008f4e:	7cf3      	ldrb	r3, [r6, #19]
 8008f50:	2b04      	cmp	r3, #4
 8008f52:	d1e3      	bne.n	8008f1c <ethernet_input+0xc0>
      (hdr->protolen != sizeof(ip_addr_t)) ||
 8008f54:	8a33      	ldrh	r3, [r6, #16]
 8008f56:	2b08      	cmp	r3, #8
 8008f58:	d1e0      	bne.n	8008f1c <ethernet_input+0xc0>
  ETHARP_STATS_INC(etharp.recv);
 8008f5a:	4a34      	ldr	r2, [pc, #208]	; (800902c <ethernet_input+0x1d0>)
 8008f5c:	8b53      	ldrh	r3, [r2, #26]
 8008f5e:	3301      	adds	r3, #1
 8008f60:	8353      	strh	r3, [r2, #26]
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 8008f62:	69f3      	ldr	r3, [r6, #28]
 8008f64:	9301      	str	r3, [sp, #4]
  if (ip_addr_isany(&netif->ip_addr)) {
 8008f66:	f117 0f04 	cmn.w	r7, #4
 8008f6a:	d03a      	beq.n	8008fe2 <ethernet_input+0x186>
 8008f6c:	687b      	ldr	r3, [r7, #4]
 8008f6e:	b3c3      	cbz	r3, 8008fe2 <ethernet_input+0x186>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008f70:	f106 0516 	add.w	r5, r6, #22
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 8008f74:	f8d6 2026 	ldr.w	r2, [r6, #38]	; 0x26
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008f78:	429a      	cmp	r2, r3
 8008f7a:	d148      	bne.n	800900e <ethernet_input+0x1b2>
 8008f7c:	2301      	movs	r3, #1
 8008f7e:	462a      	mov	r2, r5
 8008f80:	a901      	add	r1, sp, #4
 8008f82:	4638      	mov	r0, r7
 8008f84:	f7ff fd24 	bl	80089d0 <etharp_update_arp_entry>
  switch (hdr->opcode) {
 8008f88:	8ab3      	ldrh	r3, [r6, #20]
 8008f8a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008f8e:	d003      	beq.n	8008f98 <ethernet_input+0x13c>
 8008f90:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008f94:	d037      	beq.n	8009006 <ethernet_input+0x1aa>
 8008f96:	e032      	b.n	8008ffe <ethernet_input+0x1a2>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
 8008f98:	46b8      	mov	r8, r7
      hdr->opcode = htons(ARP_REPLY);
 8008f9a:	2002      	movs	r0, #2
 8008f9c:	f7fb fa20 	bl	80043e0 <lwip_htons>
 8008fa0:	82b0      	strh	r0, [r6, #20]
      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 8008fa2:	69f3      	ldr	r3, [r6, #28]
 8008fa4:	f8c6 3026 	str.w	r3, [r6, #38]	; 0x26
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
 8008fa8:	687b      	ldr	r3, [r7, #4]
 8008faa:	61f3      	str	r3, [r6, #28]
      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
 8008fac:	682b      	ldr	r3, [r5, #0]
 8008fae:	6233      	str	r3, [r6, #32]
 8008fb0:	88ab      	ldrh	r3, [r5, #4]
 8008fb2:	84b3      	strh	r3, [r6, #36]	; 0x24
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
 8008fb4:	682b      	ldr	r3, [r5, #0]
 8008fb6:	6033      	str	r3, [r6, #0]
 8008fb8:	88ab      	ldrh	r3, [r5, #4]
 8008fba:	80b3      	strh	r3, [r6, #4]
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
 8008fbc:	f858 3f23 	ldr.w	r3, [r8, #35]!
 8008fc0:	f8c6 3016 	str.w	r3, [r6, #22]
 8008fc4:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8008fc8:	80ab      	strh	r3, [r5, #4]
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
 8008fca:	f8d8 3000 	ldr.w	r3, [r8]
 8008fce:	f8c6 3006 	str.w	r3, [r6, #6]
 8008fd2:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8008fd6:	8173      	strh	r3, [r6, #10]
      netif->linkoutput(netif, p);
 8008fd8:	69bb      	ldr	r3, [r7, #24]
 8008fda:	4621      	mov	r1, r4
 8008fdc:	4638      	mov	r0, r7
 8008fde:	4798      	blx	r3
 8008fe0:	e011      	b.n	8009006 <ethernet_input+0x1aa>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008fe2:	2302      	movs	r3, #2
 8008fe4:	f106 0216 	add.w	r2, r6, #22
 8008fe8:	a901      	add	r1, sp, #4
 8008fea:	4638      	mov	r0, r7
 8008fec:	f7ff fcf0 	bl	80089d0 <etharp_update_arp_entry>
  switch (hdr->opcode) {
 8008ff0:	8ab3      	ldrh	r3, [r6, #20]
 8008ff2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008ff6:	d006      	beq.n	8009006 <ethernet_input+0x1aa>
 8008ff8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008ffc:	d003      	beq.n	8009006 <ethernet_input+0x1aa>
    ETHARP_STATS_INC(etharp.err);
 8008ffe:	4a0b      	ldr	r2, [pc, #44]	; (800902c <ethernet_input+0x1d0>)
 8009000:	8d93      	ldrh	r3, [r2, #44]	; 0x2c
 8009002:	3301      	adds	r3, #1
 8009004:	8593      	strh	r3, [r2, #44]	; 0x2c
  pbuf_free(p);
 8009006:	4620      	mov	r0, r4
 8009008:	f7fc fc65 	bl	80058d6 <pbuf_free>
 800900c:	e737      	b.n	8008e7e <ethernet_input+0x22>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 800900e:	2302      	movs	r3, #2
 8009010:	462a      	mov	r2, r5
 8009012:	a901      	add	r1, sp, #4
 8009014:	4638      	mov	r0, r7
 8009016:	f7ff fcdb 	bl	80089d0 <etharp_update_arp_entry>
  switch (hdr->opcode) {
 800901a:	8ab3      	ldrh	r3, [r6, #20]
 800901c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009020:	d0f1      	beq.n	8009006 <ethernet_input+0x1aa>
 8009022:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8009026:	d0ee      	beq.n	8009006 <ethernet_input+0x1aa>
 8009028:	e7e9      	b.n	8008ffe <ethernet_input+0x1a2>
 800902a:	bf00      	nop
 800902c:	2000b110 	.word	0x2000b110
 8009030:	08009290 	.word	0x08009290

08009034 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 8009034:	f8df d034 	ldr.w	sp, [pc, #52]	; 800906c <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8009038:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800903a:	e003      	b.n	8009044 <LoopCopyDataInit>

0800903c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800903c:	4b0c      	ldr	r3, [pc, #48]	; (8009070 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800903e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8009040:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8009042:	3104      	adds	r1, #4

08009044 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8009044:	480b      	ldr	r0, [pc, #44]	; (8009074 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8009046:	4b0c      	ldr	r3, [pc, #48]	; (8009078 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8009048:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800904a:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800904c:	d3f6      	bcc.n	800903c <CopyDataInit>
  ldr  r2, =_sbss
 800904e:	4a0b      	ldr	r2, [pc, #44]	; (800907c <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8009050:	e002      	b.n	8009058 <LoopFillZerobss>

08009052 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8009052:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8009054:	f842 3b04 	str.w	r3, [r2], #4

08009058 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8009058:	4b09      	ldr	r3, [pc, #36]	; (8009080 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800905a:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800905c:	d3f9      	bcc.n	8009052 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800905e:	f7fa fcf5 	bl	8003a4c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8009062:	f000 f811 	bl	8009088 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8009066:	f7fa fc43 	bl	80038f0 <main>
  bx  lr    
 800906a:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 800906c:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8009070:	080092b0 	.word	0x080092b0
  ldr  r0, =_sdata
 8009074:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8009078:	20000154 	.word	0x20000154
  ldr  r2, =_sbss
 800907c:	20000158 	.word	0x20000158
  ldr  r3, = _ebss
 8009080:	2000b24c 	.word	0x2000b24c

08009084 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8009084:	e7fe      	b.n	8009084 <ADC_IRQHandler>
	...

08009088 <__libc_init_array>:
 8009088:	b570      	push	{r4, r5, r6, lr}
 800908a:	4e0d      	ldr	r6, [pc, #52]	; (80090c0 <__libc_init_array+0x38>)
 800908c:	4c0d      	ldr	r4, [pc, #52]	; (80090c4 <__libc_init_array+0x3c>)
 800908e:	1ba4      	subs	r4, r4, r6
 8009090:	10a4      	asrs	r4, r4, #2
 8009092:	2500      	movs	r5, #0
 8009094:	42a5      	cmp	r5, r4
 8009096:	d109      	bne.n	80090ac <__libc_init_array+0x24>
 8009098:	4e0b      	ldr	r6, [pc, #44]	; (80090c8 <__libc_init_array+0x40>)
 800909a:	4c0c      	ldr	r4, [pc, #48]	; (80090cc <__libc_init_array+0x44>)
 800909c:	f000 f83a 	bl	8009114 <_init>
 80090a0:	1ba4      	subs	r4, r4, r6
 80090a2:	10a4      	asrs	r4, r4, #2
 80090a4:	2500      	movs	r5, #0
 80090a6:	42a5      	cmp	r5, r4
 80090a8:	d105      	bne.n	80090b6 <__libc_init_array+0x2e>
 80090aa:	bd70      	pop	{r4, r5, r6, pc}
 80090ac:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80090b0:	4798      	blx	r3
 80090b2:	3501      	adds	r5, #1
 80090b4:	e7ee      	b.n	8009094 <__libc_init_array+0xc>
 80090b6:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80090ba:	4798      	blx	r3
 80090bc:	3501      	adds	r5, #1
 80090be:	e7f2      	b.n	80090a6 <__libc_init_array+0x1e>
 80090c0:	080092a8 	.word	0x080092a8
 80090c4:	080092a8 	.word	0x080092a8
 80090c8:	080092a8 	.word	0x080092a8
 80090cc:	080092ac 	.word	0x080092ac

080090d0 <memcmp>:
 80090d0:	b510      	push	{r4, lr}
 80090d2:	3901      	subs	r1, #1
 80090d4:	4402      	add	r2, r0
 80090d6:	4290      	cmp	r0, r2
 80090d8:	d101      	bne.n	80090de <memcmp+0xe>
 80090da:	2000      	movs	r0, #0
 80090dc:	bd10      	pop	{r4, pc}
 80090de:	f810 3b01 	ldrb.w	r3, [r0], #1
 80090e2:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80090e6:	42a3      	cmp	r3, r4
 80090e8:	d0f5      	beq.n	80090d6 <memcmp+0x6>
 80090ea:	1b18      	subs	r0, r3, r4
 80090ec:	bd10      	pop	{r4, pc}

080090ee <memcpy>:
 80090ee:	b510      	push	{r4, lr}
 80090f0:	1e43      	subs	r3, r0, #1
 80090f2:	440a      	add	r2, r1
 80090f4:	4291      	cmp	r1, r2
 80090f6:	d100      	bne.n	80090fa <memcpy+0xc>
 80090f8:	bd10      	pop	{r4, pc}
 80090fa:	f811 4b01 	ldrb.w	r4, [r1], #1
 80090fe:	f803 4f01 	strb.w	r4, [r3, #1]!
 8009102:	e7f7      	b.n	80090f4 <memcpy+0x6>

08009104 <memset>:
 8009104:	4402      	add	r2, r0
 8009106:	4603      	mov	r3, r0
 8009108:	4293      	cmp	r3, r2
 800910a:	d100      	bne.n	800910e <memset+0xa>
 800910c:	4770      	bx	lr
 800910e:	f803 1b01 	strb.w	r1, [r3], #1
 8009112:	e7f9      	b.n	8009108 <memset+0x4>

08009114 <_init>:
 8009114:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009116:	bf00      	nop
 8009118:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800911a:	bc08      	pop	{r3}
 800911c:	469e      	mov	lr, r3
 800911e:	4770      	bx	lr

08009120 <_fini>:
 8009120:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009122:	bf00      	nop
 8009124:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009126:	bc08      	pop	{r3}
 8009128:	469e      	mov	lr, r3
 800912a:	4770      	bx	lr

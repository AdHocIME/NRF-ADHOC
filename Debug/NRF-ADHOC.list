
NRF-ADHOC.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00008d34  08000198  08000198  00010198  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000168  08008ecc  08008ecc  00018ecc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08009034  08009034  00019034  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  0800903c  0800903c  0001903c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  08009040  08009040  00019040  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000150  20000000  08009044  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000aab0  20000150  08009194  00020150  2**3
                  ALLOC
  8 ._user_heap_stack 00000600  2000ac00  08009194  0002ac00  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00020150  2**0
                  CONTENTS, READONLY
 10 .debug_info   000369d9  00000000  00000000  00020180  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000747b  00000000  00000000  00056b59  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000103c6  00000000  00000000  0005dfd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 000012b8  00000000  00000000  0006e3a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00001480  00000000  00000000  0006f658  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000bf5c  00000000  00000000  00070ad8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00005fde  00000000  00000000  0007ca34  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  00082a12  2**0
                  CONTENTS, READONLY
 18 .debug_frame  000032b0  00000000  00000000  00082a90  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	; (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	; (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	; (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000150 	.word	0x20000150
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08008eb4 	.word	0x08008eb4

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	; (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	; (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	; (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	20000154 	.word	0x20000154
 80001d4:	08008eb4 	.word	0x08008eb4

080001d8 <strcmp>:
 80001d8:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001dc:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001e0:	2a01      	cmp	r2, #1
 80001e2:	bf28      	it	cs
 80001e4:	429a      	cmpcs	r2, r3
 80001e6:	d0f7      	beq.n	80001d8 <strcmp>
 80001e8:	1ad0      	subs	r0, r2, r3
 80001ea:	4770      	bx	lr

080001ec <strlen>:
 80001ec:	4603      	mov	r3, r0
 80001ee:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001f2:	2a00      	cmp	r2, #0
 80001f4:	d1fb      	bne.n	80001ee <strlen+0x2>
 80001f6:	1a18      	subs	r0, r3, r0
 80001f8:	3801      	subs	r0, #1
 80001fa:	4770      	bx	lr

080001fc <__aeabi_ldivmod>:
 80001fc:	b97b      	cbnz	r3, 800021e <__aeabi_ldivmod+0x22>
 80001fe:	b972      	cbnz	r2, 800021e <__aeabi_ldivmod+0x22>
 8000200:	2900      	cmp	r1, #0
 8000202:	bfbe      	ittt	lt
 8000204:	2000      	movlt	r0, #0
 8000206:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 800020a:	e006      	blt.n	800021a <__aeabi_ldivmod+0x1e>
 800020c:	bf08      	it	eq
 800020e:	2800      	cmpeq	r0, #0
 8000210:	bf1c      	itt	ne
 8000212:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 8000216:	f04f 30ff 	movne.w	r0, #4294967295
 800021a:	f000 b9c5 	b.w	80005a8 <__aeabi_idiv0>
 800021e:	f1ad 0c08 	sub.w	ip, sp, #8
 8000222:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000226:	2900      	cmp	r1, #0
 8000228:	db09      	blt.n	800023e <__aeabi_ldivmod+0x42>
 800022a:	2b00      	cmp	r3, #0
 800022c:	db1a      	blt.n	8000264 <__aeabi_ldivmod+0x68>
 800022e:	f000 f84d 	bl	80002cc <__udivmoddi4>
 8000232:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000236:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800023a:	b004      	add	sp, #16
 800023c:	4770      	bx	lr
 800023e:	4240      	negs	r0, r0
 8000240:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000244:	2b00      	cmp	r3, #0
 8000246:	db1b      	blt.n	8000280 <__aeabi_ldivmod+0x84>
 8000248:	f000 f840 	bl	80002cc <__udivmoddi4>
 800024c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000250:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000254:	b004      	add	sp, #16
 8000256:	4240      	negs	r0, r0
 8000258:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800025c:	4252      	negs	r2, r2
 800025e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000262:	4770      	bx	lr
 8000264:	4252      	negs	r2, r2
 8000266:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800026a:	f000 f82f 	bl	80002cc <__udivmoddi4>
 800026e:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000272:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000276:	b004      	add	sp, #16
 8000278:	4240      	negs	r0, r0
 800027a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800027e:	4770      	bx	lr
 8000280:	4252      	negs	r2, r2
 8000282:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000286:	f000 f821 	bl	80002cc <__udivmoddi4>
 800028a:	f8dd e004 	ldr.w	lr, [sp, #4]
 800028e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000292:	b004      	add	sp, #16
 8000294:	4252      	negs	r2, r2
 8000296:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800029a:	4770      	bx	lr

0800029c <__aeabi_uldivmod>:
 800029c:	b953      	cbnz	r3, 80002b4 <__aeabi_uldivmod+0x18>
 800029e:	b94a      	cbnz	r2, 80002b4 <__aeabi_uldivmod+0x18>
 80002a0:	2900      	cmp	r1, #0
 80002a2:	bf08      	it	eq
 80002a4:	2800      	cmpeq	r0, #0
 80002a6:	bf1c      	itt	ne
 80002a8:	f04f 31ff 	movne.w	r1, #4294967295
 80002ac:	f04f 30ff 	movne.w	r0, #4294967295
 80002b0:	f000 b97a 	b.w	80005a8 <__aeabi_idiv0>
 80002b4:	f1ad 0c08 	sub.w	ip, sp, #8
 80002b8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002bc:	f000 f806 	bl	80002cc <__udivmoddi4>
 80002c0:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002c4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002c8:	b004      	add	sp, #16
 80002ca:	4770      	bx	lr

080002cc <__udivmoddi4>:
 80002cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002d0:	468c      	mov	ip, r1
 80002d2:	460d      	mov	r5, r1
 80002d4:	4604      	mov	r4, r0
 80002d6:	9e08      	ldr	r6, [sp, #32]
 80002d8:	2b00      	cmp	r3, #0
 80002da:	d151      	bne.n	8000380 <__udivmoddi4+0xb4>
 80002dc:	428a      	cmp	r2, r1
 80002de:	4617      	mov	r7, r2
 80002e0:	d96d      	bls.n	80003be <__udivmoddi4+0xf2>
 80002e2:	fab2 fe82 	clz	lr, r2
 80002e6:	f1be 0f00 	cmp.w	lr, #0
 80002ea:	d00b      	beq.n	8000304 <__udivmoddi4+0x38>
 80002ec:	f1ce 0c20 	rsb	ip, lr, #32
 80002f0:	fa01 f50e 	lsl.w	r5, r1, lr
 80002f4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80002f8:	fa02 f70e 	lsl.w	r7, r2, lr
 80002fc:	ea4c 0c05 	orr.w	ip, ip, r5
 8000300:	fa00 f40e 	lsl.w	r4, r0, lr
 8000304:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 8000308:	0c25      	lsrs	r5, r4, #16
 800030a:	fbbc f8fa 	udiv	r8, ip, sl
 800030e:	fa1f f987 	uxth.w	r9, r7
 8000312:	fb0a cc18 	mls	ip, sl, r8, ip
 8000316:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 800031a:	fb08 f309 	mul.w	r3, r8, r9
 800031e:	42ab      	cmp	r3, r5
 8000320:	d90a      	bls.n	8000338 <__udivmoddi4+0x6c>
 8000322:	19ed      	adds	r5, r5, r7
 8000324:	f108 32ff 	add.w	r2, r8, #4294967295
 8000328:	f080 8123 	bcs.w	8000572 <__udivmoddi4+0x2a6>
 800032c:	42ab      	cmp	r3, r5
 800032e:	f240 8120 	bls.w	8000572 <__udivmoddi4+0x2a6>
 8000332:	f1a8 0802 	sub.w	r8, r8, #2
 8000336:	443d      	add	r5, r7
 8000338:	1aed      	subs	r5, r5, r3
 800033a:	b2a4      	uxth	r4, r4
 800033c:	fbb5 f0fa 	udiv	r0, r5, sl
 8000340:	fb0a 5510 	mls	r5, sl, r0, r5
 8000344:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000348:	fb00 f909 	mul.w	r9, r0, r9
 800034c:	45a1      	cmp	r9, r4
 800034e:	d909      	bls.n	8000364 <__udivmoddi4+0x98>
 8000350:	19e4      	adds	r4, r4, r7
 8000352:	f100 33ff 	add.w	r3, r0, #4294967295
 8000356:	f080 810a 	bcs.w	800056e <__udivmoddi4+0x2a2>
 800035a:	45a1      	cmp	r9, r4
 800035c:	f240 8107 	bls.w	800056e <__udivmoddi4+0x2a2>
 8000360:	3802      	subs	r0, #2
 8000362:	443c      	add	r4, r7
 8000364:	eba4 0409 	sub.w	r4, r4, r9
 8000368:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 800036c:	2100      	movs	r1, #0
 800036e:	2e00      	cmp	r6, #0
 8000370:	d061      	beq.n	8000436 <__udivmoddi4+0x16a>
 8000372:	fa24 f40e 	lsr.w	r4, r4, lr
 8000376:	2300      	movs	r3, #0
 8000378:	6034      	str	r4, [r6, #0]
 800037a:	6073      	str	r3, [r6, #4]
 800037c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000380:	428b      	cmp	r3, r1
 8000382:	d907      	bls.n	8000394 <__udivmoddi4+0xc8>
 8000384:	2e00      	cmp	r6, #0
 8000386:	d054      	beq.n	8000432 <__udivmoddi4+0x166>
 8000388:	2100      	movs	r1, #0
 800038a:	e886 0021 	stmia.w	r6, {r0, r5}
 800038e:	4608      	mov	r0, r1
 8000390:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000394:	fab3 f183 	clz	r1, r3
 8000398:	2900      	cmp	r1, #0
 800039a:	f040 808e 	bne.w	80004ba <__udivmoddi4+0x1ee>
 800039e:	42ab      	cmp	r3, r5
 80003a0:	d302      	bcc.n	80003a8 <__udivmoddi4+0xdc>
 80003a2:	4282      	cmp	r2, r0
 80003a4:	f200 80fa 	bhi.w	800059c <__udivmoddi4+0x2d0>
 80003a8:	1a84      	subs	r4, r0, r2
 80003aa:	eb65 0503 	sbc.w	r5, r5, r3
 80003ae:	2001      	movs	r0, #1
 80003b0:	46ac      	mov	ip, r5
 80003b2:	2e00      	cmp	r6, #0
 80003b4:	d03f      	beq.n	8000436 <__udivmoddi4+0x16a>
 80003b6:	e886 1010 	stmia.w	r6, {r4, ip}
 80003ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003be:	b912      	cbnz	r2, 80003c6 <__udivmoddi4+0xfa>
 80003c0:	2701      	movs	r7, #1
 80003c2:	fbb7 f7f2 	udiv	r7, r7, r2
 80003c6:	fab7 fe87 	clz	lr, r7
 80003ca:	f1be 0f00 	cmp.w	lr, #0
 80003ce:	d134      	bne.n	800043a <__udivmoddi4+0x16e>
 80003d0:	1beb      	subs	r3, r5, r7
 80003d2:	0c3a      	lsrs	r2, r7, #16
 80003d4:	fa1f fc87 	uxth.w	ip, r7
 80003d8:	2101      	movs	r1, #1
 80003da:	fbb3 f8f2 	udiv	r8, r3, r2
 80003de:	0c25      	lsrs	r5, r4, #16
 80003e0:	fb02 3318 	mls	r3, r2, r8, r3
 80003e4:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 80003e8:	fb0c f308 	mul.w	r3, ip, r8
 80003ec:	42ab      	cmp	r3, r5
 80003ee:	d907      	bls.n	8000400 <__udivmoddi4+0x134>
 80003f0:	19ed      	adds	r5, r5, r7
 80003f2:	f108 30ff 	add.w	r0, r8, #4294967295
 80003f6:	d202      	bcs.n	80003fe <__udivmoddi4+0x132>
 80003f8:	42ab      	cmp	r3, r5
 80003fa:	f200 80d1 	bhi.w	80005a0 <__udivmoddi4+0x2d4>
 80003fe:	4680      	mov	r8, r0
 8000400:	1aed      	subs	r5, r5, r3
 8000402:	b2a3      	uxth	r3, r4
 8000404:	fbb5 f0f2 	udiv	r0, r5, r2
 8000408:	fb02 5510 	mls	r5, r2, r0, r5
 800040c:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000410:	fb0c fc00 	mul.w	ip, ip, r0
 8000414:	45a4      	cmp	ip, r4
 8000416:	d907      	bls.n	8000428 <__udivmoddi4+0x15c>
 8000418:	19e4      	adds	r4, r4, r7
 800041a:	f100 33ff 	add.w	r3, r0, #4294967295
 800041e:	d202      	bcs.n	8000426 <__udivmoddi4+0x15a>
 8000420:	45a4      	cmp	ip, r4
 8000422:	f200 80b8 	bhi.w	8000596 <__udivmoddi4+0x2ca>
 8000426:	4618      	mov	r0, r3
 8000428:	eba4 040c 	sub.w	r4, r4, ip
 800042c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000430:	e79d      	b.n	800036e <__udivmoddi4+0xa2>
 8000432:	4631      	mov	r1, r6
 8000434:	4630      	mov	r0, r6
 8000436:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800043a:	f1ce 0420 	rsb	r4, lr, #32
 800043e:	fa05 f30e 	lsl.w	r3, r5, lr
 8000442:	fa07 f70e 	lsl.w	r7, r7, lr
 8000446:	fa20 f804 	lsr.w	r8, r0, r4
 800044a:	0c3a      	lsrs	r2, r7, #16
 800044c:	fa25 f404 	lsr.w	r4, r5, r4
 8000450:	ea48 0803 	orr.w	r8, r8, r3
 8000454:	fbb4 f1f2 	udiv	r1, r4, r2
 8000458:	ea4f 4518 	mov.w	r5, r8, lsr #16
 800045c:	fb02 4411 	mls	r4, r2, r1, r4
 8000460:	fa1f fc87 	uxth.w	ip, r7
 8000464:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 8000468:	fb01 f30c 	mul.w	r3, r1, ip
 800046c:	42ab      	cmp	r3, r5
 800046e:	fa00 f40e 	lsl.w	r4, r0, lr
 8000472:	d909      	bls.n	8000488 <__udivmoddi4+0x1bc>
 8000474:	19ed      	adds	r5, r5, r7
 8000476:	f101 30ff 	add.w	r0, r1, #4294967295
 800047a:	f080 808a 	bcs.w	8000592 <__udivmoddi4+0x2c6>
 800047e:	42ab      	cmp	r3, r5
 8000480:	f240 8087 	bls.w	8000592 <__udivmoddi4+0x2c6>
 8000484:	3902      	subs	r1, #2
 8000486:	443d      	add	r5, r7
 8000488:	1aeb      	subs	r3, r5, r3
 800048a:	fa1f f588 	uxth.w	r5, r8
 800048e:	fbb3 f0f2 	udiv	r0, r3, r2
 8000492:	fb02 3310 	mls	r3, r2, r0, r3
 8000496:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 800049a:	fb00 f30c 	mul.w	r3, r0, ip
 800049e:	42ab      	cmp	r3, r5
 80004a0:	d907      	bls.n	80004b2 <__udivmoddi4+0x1e6>
 80004a2:	19ed      	adds	r5, r5, r7
 80004a4:	f100 38ff 	add.w	r8, r0, #4294967295
 80004a8:	d26f      	bcs.n	800058a <__udivmoddi4+0x2be>
 80004aa:	42ab      	cmp	r3, r5
 80004ac:	d96d      	bls.n	800058a <__udivmoddi4+0x2be>
 80004ae:	3802      	subs	r0, #2
 80004b0:	443d      	add	r5, r7
 80004b2:	1aeb      	subs	r3, r5, r3
 80004b4:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80004b8:	e78f      	b.n	80003da <__udivmoddi4+0x10e>
 80004ba:	f1c1 0720 	rsb	r7, r1, #32
 80004be:	fa22 f807 	lsr.w	r8, r2, r7
 80004c2:	408b      	lsls	r3, r1
 80004c4:	fa05 f401 	lsl.w	r4, r5, r1
 80004c8:	ea48 0303 	orr.w	r3, r8, r3
 80004cc:	fa20 fe07 	lsr.w	lr, r0, r7
 80004d0:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 80004d4:	40fd      	lsrs	r5, r7
 80004d6:	ea4e 0e04 	orr.w	lr, lr, r4
 80004da:	fbb5 f9fc 	udiv	r9, r5, ip
 80004de:	ea4f 441e 	mov.w	r4, lr, lsr #16
 80004e2:	fb0c 5519 	mls	r5, ip, r9, r5
 80004e6:	fa1f f883 	uxth.w	r8, r3
 80004ea:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 80004ee:	fb09 f408 	mul.w	r4, r9, r8
 80004f2:	42ac      	cmp	r4, r5
 80004f4:	fa02 f201 	lsl.w	r2, r2, r1
 80004f8:	fa00 fa01 	lsl.w	sl, r0, r1
 80004fc:	d908      	bls.n	8000510 <__udivmoddi4+0x244>
 80004fe:	18ed      	adds	r5, r5, r3
 8000500:	f109 30ff 	add.w	r0, r9, #4294967295
 8000504:	d243      	bcs.n	800058e <__udivmoddi4+0x2c2>
 8000506:	42ac      	cmp	r4, r5
 8000508:	d941      	bls.n	800058e <__udivmoddi4+0x2c2>
 800050a:	f1a9 0902 	sub.w	r9, r9, #2
 800050e:	441d      	add	r5, r3
 8000510:	1b2d      	subs	r5, r5, r4
 8000512:	fa1f fe8e 	uxth.w	lr, lr
 8000516:	fbb5 f0fc 	udiv	r0, r5, ip
 800051a:	fb0c 5510 	mls	r5, ip, r0, r5
 800051e:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 8000522:	fb00 f808 	mul.w	r8, r0, r8
 8000526:	45a0      	cmp	r8, r4
 8000528:	d907      	bls.n	800053a <__udivmoddi4+0x26e>
 800052a:	18e4      	adds	r4, r4, r3
 800052c:	f100 35ff 	add.w	r5, r0, #4294967295
 8000530:	d229      	bcs.n	8000586 <__udivmoddi4+0x2ba>
 8000532:	45a0      	cmp	r8, r4
 8000534:	d927      	bls.n	8000586 <__udivmoddi4+0x2ba>
 8000536:	3802      	subs	r0, #2
 8000538:	441c      	add	r4, r3
 800053a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800053e:	eba4 0408 	sub.w	r4, r4, r8
 8000542:	fba0 8902 	umull	r8, r9, r0, r2
 8000546:	454c      	cmp	r4, r9
 8000548:	46c6      	mov	lr, r8
 800054a:	464d      	mov	r5, r9
 800054c:	d315      	bcc.n	800057a <__udivmoddi4+0x2ae>
 800054e:	d012      	beq.n	8000576 <__udivmoddi4+0x2aa>
 8000550:	b156      	cbz	r6, 8000568 <__udivmoddi4+0x29c>
 8000552:	ebba 030e 	subs.w	r3, sl, lr
 8000556:	eb64 0405 	sbc.w	r4, r4, r5
 800055a:	fa04 f707 	lsl.w	r7, r4, r7
 800055e:	40cb      	lsrs	r3, r1
 8000560:	431f      	orrs	r7, r3
 8000562:	40cc      	lsrs	r4, r1
 8000564:	6037      	str	r7, [r6, #0]
 8000566:	6074      	str	r4, [r6, #4]
 8000568:	2100      	movs	r1, #0
 800056a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800056e:	4618      	mov	r0, r3
 8000570:	e6f8      	b.n	8000364 <__udivmoddi4+0x98>
 8000572:	4690      	mov	r8, r2
 8000574:	e6e0      	b.n	8000338 <__udivmoddi4+0x6c>
 8000576:	45c2      	cmp	sl, r8
 8000578:	d2ea      	bcs.n	8000550 <__udivmoddi4+0x284>
 800057a:	ebb8 0e02 	subs.w	lr, r8, r2
 800057e:	eb69 0503 	sbc.w	r5, r9, r3
 8000582:	3801      	subs	r0, #1
 8000584:	e7e4      	b.n	8000550 <__udivmoddi4+0x284>
 8000586:	4628      	mov	r0, r5
 8000588:	e7d7      	b.n	800053a <__udivmoddi4+0x26e>
 800058a:	4640      	mov	r0, r8
 800058c:	e791      	b.n	80004b2 <__udivmoddi4+0x1e6>
 800058e:	4681      	mov	r9, r0
 8000590:	e7be      	b.n	8000510 <__udivmoddi4+0x244>
 8000592:	4601      	mov	r1, r0
 8000594:	e778      	b.n	8000488 <__udivmoddi4+0x1bc>
 8000596:	3802      	subs	r0, #2
 8000598:	443c      	add	r4, r7
 800059a:	e745      	b.n	8000428 <__udivmoddi4+0x15c>
 800059c:	4608      	mov	r0, r1
 800059e:	e708      	b.n	80003b2 <__udivmoddi4+0xe6>
 80005a0:	f1a8 0802 	sub.w	r8, r8, #2
 80005a4:	443d      	add	r5, r7
 80005a6:	e72b      	b.n	8000400 <__udivmoddi4+0x134>

080005a8 <__aeabi_idiv0>:
 80005a8:	4770      	bx	lr
 80005aa:	bf00      	nop

080005ac <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80005ac:	b510      	push	{r4, lr}
 80005ae:	4604      	mov	r4, r0
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 80005b0:	4b0e      	ldr	r3, [pc, #56]	; (80005ec <HAL_InitTick+0x40>)
 80005b2:	7818      	ldrb	r0, [r3, #0]
 80005b4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80005b8:	fbb3 f3f0 	udiv	r3, r3, r0
 80005bc:	4a0c      	ldr	r2, [pc, #48]	; (80005f0 <HAL_InitTick+0x44>)
 80005be:	6810      	ldr	r0, [r2, #0]
 80005c0:	fbb0 f0f3 	udiv	r0, r0, r3
 80005c4:	f000 f8a6 	bl	8000714 <HAL_SYSTICK_Config>
 80005c8:	b968      	cbnz	r0, 80005e6 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80005ca:	2c0f      	cmp	r4, #15
 80005cc:	d901      	bls.n	80005d2 <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 80005ce:	2001      	movs	r0, #1
  }

  /* Return function status */
  return HAL_OK;
}
 80005d0:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 80005d2:	2200      	movs	r2, #0
 80005d4:	4621      	mov	r1, r4
 80005d6:	f04f 30ff 	mov.w	r0, #4294967295
 80005da:	f000 f85f 	bl	800069c <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 80005de:	4b05      	ldr	r3, [pc, #20]	; (80005f4 <HAL_InitTick+0x48>)
 80005e0:	601c      	str	r4, [r3, #0]
  return HAL_OK;
 80005e2:	2000      	movs	r0, #0
 80005e4:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80005e6:	2001      	movs	r0, #1
 80005e8:	bd10      	pop	{r4, pc}
 80005ea:	bf00      	nop
 80005ec:	20000000 	.word	0x20000000
 80005f0:	2000010c 	.word	0x2000010c
 80005f4:	20000004 	.word	0x20000004

080005f8 <HAL_Init>:
{
 80005f8:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80005fa:	4b0b      	ldr	r3, [pc, #44]	; (8000628 <HAL_Init+0x30>)
 80005fc:	681a      	ldr	r2, [r3, #0]
 80005fe:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000602:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8000604:	681a      	ldr	r2, [r3, #0]
 8000606:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800060a:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800060c:	681a      	ldr	r2, [r3, #0]
 800060e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000612:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000614:	2003      	movs	r0, #3
 8000616:	f000 f82f 	bl	8000678 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 800061a:	2000      	movs	r0, #0
 800061c:	f7ff ffc6 	bl	80005ac <HAL_InitTick>
  HAL_MspInit();
 8000620:	f003 f84c 	bl	80036bc <HAL_MspInit>
}
 8000624:	2000      	movs	r0, #0
 8000626:	bd08      	pop	{r3, pc}
 8000628:	40023c00 	.word	0x40023c00

0800062c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 800062c:	4a03      	ldr	r2, [pc, #12]	; (800063c <HAL_IncTick+0x10>)
 800062e:	6811      	ldr	r1, [r2, #0]
 8000630:	4b03      	ldr	r3, [pc, #12]	; (8000640 <HAL_IncTick+0x14>)
 8000632:	781b      	ldrb	r3, [r3, #0]
 8000634:	440b      	add	r3, r1
 8000636:	6013      	str	r3, [r2, #0]
 8000638:	4770      	bx	lr
 800063a:	bf00      	nop
 800063c:	2000729c 	.word	0x2000729c
 8000640:	20000000 	.word	0x20000000

08000644 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000644:	4b01      	ldr	r3, [pc, #4]	; (800064c <HAL_GetTick+0x8>)
 8000646:	6818      	ldr	r0, [r3, #0]
}
 8000648:	4770      	bx	lr
 800064a:	bf00      	nop
 800064c:	2000729c 	.word	0x2000729c

08000650 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000650:	b538      	push	{r3, r4, r5, lr}
 8000652:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000654:	f7ff fff6 	bl	8000644 <HAL_GetTick>
 8000658:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800065a:	f1b4 3fff 	cmp.w	r4, #4294967295
 800065e:	d002      	beq.n	8000666 <HAL_Delay+0x16>
  {
    wait += (uint32_t)(uwTickFreq);
 8000660:	4b04      	ldr	r3, [pc, #16]	; (8000674 <HAL_Delay+0x24>)
 8000662:	781b      	ldrb	r3, [r3, #0]
 8000664:	441c      	add	r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 8000666:	f7ff ffed 	bl	8000644 <HAL_GetTick>
 800066a:	1b40      	subs	r0, r0, r5
 800066c:	4284      	cmp	r4, r0
 800066e:	d8fa      	bhi.n	8000666 <HAL_Delay+0x16>
  {
  }
}
 8000670:	bd38      	pop	{r3, r4, r5, pc}
 8000672:	bf00      	nop
 8000674:	20000000 	.word	0x20000000

08000678 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000678:	4a07      	ldr	r2, [pc, #28]	; (8000698 <HAL_NVIC_SetPriorityGrouping+0x20>)
 800067a:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800067c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000680:	041b      	lsls	r3, r3, #16
 8000682:	0c1b      	lsrs	r3, r3, #16
 8000684:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000688:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 800068c:	0200      	lsls	r0, r0, #8
 800068e:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 8000692:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8000694:	60d3      	str	r3, [r2, #12]
 8000696:	4770      	bx	lr
 8000698:	e000ed00 	.word	0xe000ed00

0800069c <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800069c:	b430      	push	{r4, r5}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800069e:	4b15      	ldr	r3, [pc, #84]	; (80006f4 <HAL_NVIC_SetPriority+0x58>)
 80006a0:	68dc      	ldr	r4, [r3, #12]
 80006a2:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80006a6:	f1c4 0307 	rsb	r3, r4, #7
 80006aa:	2b04      	cmp	r3, #4
 80006ac:	bf28      	it	cs
 80006ae:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80006b0:	1d25      	adds	r5, r4, #4
 80006b2:	2d06      	cmp	r5, #6
 80006b4:	bf8c      	ite	hi
 80006b6:	1ee5      	subhi	r5, r4, #3
 80006b8:	2500      	movls	r5, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80006ba:	2401      	movs	r4, #1
 80006bc:	fa04 f303 	lsl.w	r3, r4, r3
 80006c0:	3b01      	subs	r3, #1
 80006c2:	4019      	ands	r1, r3
 80006c4:	40a9      	lsls	r1, r5
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80006c6:	40ac      	lsls	r4, r5
 80006c8:	3c01      	subs	r4, #1
 80006ca:	4022      	ands	r2, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80006cc:	4311      	orrs	r1, r2
  if ((int32_t)(IRQn) < 0)
 80006ce:	2800      	cmp	r0, #0
 80006d0:	db09      	blt.n	80006e6 <HAL_NVIC_SetPriority+0x4a>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006d2:	0109      	lsls	r1, r1, #4
 80006d4:	b2c9      	uxtb	r1, r1
 80006d6:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80006da:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 80006de:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80006e2:	bc30      	pop	{r4, r5}
 80006e4:	4770      	bx	lr
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006e6:	f000 000f 	and.w	r0, r0, #15
 80006ea:	0109      	lsls	r1, r1, #4
 80006ec:	b2c9      	uxtb	r1, r1
 80006ee:	4b02      	ldr	r3, [pc, #8]	; (80006f8 <HAL_NVIC_SetPriority+0x5c>)
 80006f0:	5419      	strb	r1, [r3, r0]
 80006f2:	e7f6      	b.n	80006e2 <HAL_NVIC_SetPriority+0x46>
 80006f4:	e000ed00 	.word	0xe000ed00
 80006f8:	e000ed14 	.word	0xe000ed14

080006fc <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80006fc:	0942      	lsrs	r2, r0, #5
 80006fe:	f000 001f 	and.w	r0, r0, #31
 8000702:	2301      	movs	r3, #1
 8000704:	fa03 f000 	lsl.w	r0, r3, r0
 8000708:	4b01      	ldr	r3, [pc, #4]	; (8000710 <HAL_NVIC_EnableIRQ+0x14>)
 800070a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 800070e:	4770      	bx	lr
 8000710:	e000e100 	.word	0xe000e100

08000714 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000714:	3801      	subs	r0, #1
 8000716:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800071a:	d20a      	bcs.n	8000732 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800071c:	4b06      	ldr	r3, [pc, #24]	; (8000738 <HAL_SYSTICK_Config+0x24>)
 800071e:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000720:	21f0      	movs	r1, #240	; 0xf0
 8000722:	4a06      	ldr	r2, [pc, #24]	; (800073c <HAL_SYSTICK_Config+0x28>)
 8000724:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000728:	2000      	movs	r0, #0
 800072a:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800072c:	2207      	movs	r2, #7
 800072e:	601a      	str	r2, [r3, #0]
 8000730:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000732:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000734:	4770      	bx	lr
 8000736:	bf00      	nop
 8000738:	e000e010 	.word	0xe000e010
 800073c:	e000ed00 	.word	0xe000ed00

08000740 <HAL_SYSTICK_CLKSourceConfig>:
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000740:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000742:	4a04      	ldr	r2, [pc, #16]	; (8000754 <HAL_SYSTICK_CLKSourceConfig+0x14>)
 8000744:	6813      	ldr	r3, [r2, #0]
 8000746:	bf0c      	ite	eq
 8000748:	f043 0304 	orreq.w	r3, r3, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 800074c:	f023 0304 	bicne.w	r3, r3, #4
 8000750:	6013      	str	r3, [r2, #0]
 8000752:	4770      	bx	lr
 8000754:	e000e010 	.word	0xe000e010

08000758 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8000758:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 800075a:	f003 f81b 	bl	8003794 <HAL_SYSTICK_Callback>
 800075e:	bd08      	pop	{r3, pc}

08000760 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000760:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000764:	b083      	sub	sp, #12
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000766:	2600      	movs	r6, #0
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 8000768:	f04f 0e01 	mov.w	lr, #1
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800076c:	f04f 0903 	mov.w	r9, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000770:	f8df c180 	ldr.w	ip, [pc, #384]	; 80008f4 <HAL_GPIO_Init+0x194>

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000774:	f8df a180 	ldr.w	sl, [pc, #384]	; 80008f8 <HAL_GPIO_Init+0x198>
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000778:	4f5c      	ldr	r7, [pc, #368]	; (80008ec <HAL_GPIO_Init+0x18c>)
 800077a:	e052      	b.n	8000822 <HAL_GPIO_Init+0xc2>
        temp = GPIOx->AFR[position >> 3U];
 800077c:	08f4      	lsrs	r4, r6, #3
 800077e:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8000782:	6a25      	ldr	r5, [r4, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8000784:	f006 0207 	and.w	r2, r6, #7
 8000788:	ea4f 0b82 	mov.w	fp, r2, lsl #2
 800078c:	220f      	movs	r2, #15
 800078e:	fa02 f20b 	lsl.w	r2, r2, fp
 8000792:	ea25 0502 	bic.w	r5, r5, r2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8000796:	690a      	ldr	r2, [r1, #16]
 8000798:	fa02 f20b 	lsl.w	r2, r2, fp
 800079c:	432a      	orrs	r2, r5
        GPIOx->AFR[position >> 3U] = temp;
 800079e:	6222      	str	r2, [r4, #32]
 80007a0:	e04b      	b.n	800083a <HAL_GPIO_Init+0xda>
        temp = GPIOx->OSPEEDR; 
 80007a2:	6882      	ldr	r2, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80007a4:	ea04 0b02 	and.w	fp, r4, r2
        temp |= (GPIO_Init->Speed << (position * 2U));
 80007a8:	68ca      	ldr	r2, [r1, #12]
 80007aa:	40aa      	lsls	r2, r5
 80007ac:	ea42 020b 	orr.w	r2, r2, fp
        GPIOx->OSPEEDR = temp;
 80007b0:	6082      	str	r2, [r0, #8]
        temp = GPIOx->OTYPER;
 80007b2:	6842      	ldr	r2, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80007b4:	ea22 0b03 	bic.w	fp, r2, r3
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80007b8:	684a      	ldr	r2, [r1, #4]
 80007ba:	f3c2 1300 	ubfx	r3, r2, #4, #1
 80007be:	40b3      	lsls	r3, r6
 80007c0:	ea43 030b 	orr.w	r3, r3, fp
        GPIOx->OTYPER = temp;
 80007c4:	6043      	str	r3, [r0, #4]
 80007c6:	e04c      	b.n	8000862 <HAL_GPIO_Init+0x102>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80007c8:	2200      	movs	r2, #0
 80007ca:	40a2      	lsls	r2, r4
 80007cc:	432a      	orrs	r2, r5
        SYSCFG->EXTICR[position >> 2U] = temp;
 80007ce:	609a      	str	r2, [r3, #8]
        temp = EXTI->IMR;
 80007d0:	683b      	ldr	r3, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 80007d2:	ea6f 0408 	mvn.w	r4, r8
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80007d6:	684a      	ldr	r2, [r1, #4]
 80007d8:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 80007dc:	bf0c      	ite	eq
 80007de:	4023      	andeq	r3, r4
        {
          temp |= iocurrent;
 80007e0:	ea48 0303 	orrne.w	r3, r8, r3
        }
        EXTI->IMR = temp;
 80007e4:	603b      	str	r3, [r7, #0]

        temp = EXTI->EMR;
 80007e6:	687a      	ldr	r2, [r7, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80007e8:	684b      	ldr	r3, [r1, #4]
 80007ea:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 80007ee:	bf0c      	ite	eq
 80007f0:	4022      	andeq	r2, r4
        {
          temp |= iocurrent;
 80007f2:	ea48 0202 	orrne.w	r2, r8, r2
        }
        EXTI->EMR = temp;
 80007f6:	607a      	str	r2, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 80007f8:	68ba      	ldr	r2, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80007fa:	684b      	ldr	r3, [r1, #4]
 80007fc:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 8000800:	bf0c      	ite	eq
 8000802:	4022      	andeq	r2, r4
        {
          temp |= iocurrent;
 8000804:	ea48 0202 	orrne.w	r2, r8, r2
        }
        EXTI->RTSR = temp;
 8000808:	60ba      	str	r2, [r7, #8]

        temp = EXTI->FTSR;
 800080a:	68fb      	ldr	r3, [r7, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800080c:	684a      	ldr	r2, [r1, #4]
 800080e:	f412 1f00 	tst.w	r2, #2097152	; 0x200000
        temp &= ~((uint32_t)iocurrent);
 8000812:	bf0c      	ite	eq
 8000814:	4023      	andeq	r3, r4
        {
          temp |= iocurrent;
 8000816:	ea48 0303 	orrne.w	r3, r8, r3
        }
        EXTI->FTSR = temp;
 800081a:	60fb      	str	r3, [r7, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800081c:	3601      	adds	r6, #1
 800081e:	2e10      	cmp	r6, #16
 8000820:	d060      	beq.n	80008e4 <HAL_GPIO_Init+0x184>
    ioposition = 0x01U << position;
 8000822:	fa0e f306 	lsl.w	r3, lr, r6
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000826:	680a      	ldr	r2, [r1, #0]
 8000828:	ea03 0802 	and.w	r8, r3, r2
    if(iocurrent == ioposition)
 800082c:	4543      	cmp	r3, r8
 800082e:	d1f5      	bne.n	800081c <HAL_GPIO_Init+0xbc>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000830:	684a      	ldr	r2, [r1, #4]
 8000832:	f022 0210 	bic.w	r2, r2, #16
 8000836:	2a02      	cmp	r2, #2
 8000838:	d0a0      	beq.n	800077c <HAL_GPIO_Init+0x1c>
      temp = GPIOx->MODER;
 800083a:	6802      	ldr	r2, [r0, #0]
 800083c:	0075      	lsls	r5, r6, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800083e:	fa09 f405 	lsl.w	r4, r9, r5
 8000842:	43e4      	mvns	r4, r4
 8000844:	ea02 0b04 	and.w	fp, r2, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000848:	684a      	ldr	r2, [r1, #4]
 800084a:	f002 0203 	and.w	r2, r2, #3
 800084e:	40aa      	lsls	r2, r5
 8000850:	ea42 020b 	orr.w	r2, r2, fp
      GPIOx->MODER = temp;
 8000854:	6002      	str	r2, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000856:	684a      	ldr	r2, [r1, #4]
 8000858:	f022 0210 	bic.w	r2, r2, #16
 800085c:	3a01      	subs	r2, #1
 800085e:	2a01      	cmp	r2, #1
 8000860:	d99f      	bls.n	80007a2 <HAL_GPIO_Init+0x42>
      temp = GPIOx->PUPDR;
 8000862:	68c3      	ldr	r3, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8000864:	401c      	ands	r4, r3
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8000866:	688b      	ldr	r3, [r1, #8]
 8000868:	fa03 f505 	lsl.w	r5, r3, r5
 800086c:	4325      	orrs	r5, r4
      GPIOx->PUPDR = temp;
 800086e:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000870:	684b      	ldr	r3, [r1, #4]
 8000872:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8000876:	d0d1      	beq.n	800081c <HAL_GPIO_Init+0xbc>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000878:	2300      	movs	r3, #0
 800087a:	9301      	str	r3, [sp, #4]
 800087c:	f8dc 3044 	ldr.w	r3, [ip, #68]	; 0x44
 8000880:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000884:	f8cc 3044 	str.w	r3, [ip, #68]	; 0x44
 8000888:	f8dc 3044 	ldr.w	r3, [ip, #68]	; 0x44
 800088c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000890:	9301      	str	r3, [sp, #4]
 8000892:	9b01      	ldr	r3, [sp, #4]
 8000894:	f026 0303 	bic.w	r3, r6, #3
 8000898:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800089c:	f503 339c 	add.w	r3, r3, #79872	; 0x13800
        temp = SYSCFG->EXTICR[position >> 2U];
 80008a0:	689d      	ldr	r5, [r3, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 80008a2:	f006 0203 	and.w	r2, r6, #3
 80008a6:	0094      	lsls	r4, r2, #2
 80008a8:	220f      	movs	r2, #15
 80008aa:	40a2      	lsls	r2, r4
 80008ac:	ea25 0502 	bic.w	r5, r5, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80008b0:	4550      	cmp	r0, sl
 80008b2:	d089      	beq.n	80007c8 <HAL_GPIO_Init+0x68>
 80008b4:	4a0e      	ldr	r2, [pc, #56]	; (80008f0 <HAL_GPIO_Init+0x190>)
 80008b6:	4290      	cmp	r0, r2
 80008b8:	d00e      	beq.n	80008d8 <HAL_GPIO_Init+0x178>
 80008ba:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80008be:	4290      	cmp	r0, r2
 80008c0:	d00c      	beq.n	80008dc <HAL_GPIO_Init+0x17c>
 80008c2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80008c6:	4290      	cmp	r0, r2
 80008c8:	d00a      	beq.n	80008e0 <HAL_GPIO_Init+0x180>
 80008ca:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80008ce:	4290      	cmp	r0, r2
 80008d0:	bf0c      	ite	eq
 80008d2:	2204      	moveq	r2, #4
 80008d4:	2207      	movne	r2, #7
 80008d6:	e778      	b.n	80007ca <HAL_GPIO_Init+0x6a>
 80008d8:	4672      	mov	r2, lr
 80008da:	e776      	b.n	80007ca <HAL_GPIO_Init+0x6a>
 80008dc:	2202      	movs	r2, #2
 80008de:	e774      	b.n	80007ca <HAL_GPIO_Init+0x6a>
 80008e0:	464a      	mov	r2, r9
 80008e2:	e772      	b.n	80007ca <HAL_GPIO_Init+0x6a>
      }
    }
  }
}
 80008e4:	b003      	add	sp, #12
 80008e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80008ea:	bf00      	nop
 80008ec:	40013c00 	.word	0x40013c00
 80008f0:	40020400 	.word	0x40020400
 80008f4:	40023800 	.word	0x40023800
 80008f8:	40020000 	.word	0x40020000

080008fc <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80008fc:	b912      	cbnz	r2, 8000904 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 80008fe:	0409      	lsls	r1, r1, #16
 8000900:	6181      	str	r1, [r0, #24]
 8000902:	4770      	bx	lr
    GPIOx->BSRR = GPIO_Pin;
 8000904:	6181      	str	r1, [r0, #24]
 8000906:	4770      	bx	lr

08000908 <HAL_PCD_Init>:
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8000908:	2800      	cmp	r0, #0
 800090a:	d065      	beq.n	80009d8 <HAL_PCD_Init+0xd0>
{ 
 800090c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800090e:	b08b      	sub	sp, #44	; 0x2c
 8000910:	4605      	mov	r5, r0
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 8000912:	2303      	movs	r3, #3
 8000914:	f880 33b9 	strb.w	r3, [r0, #953]	; 0x3b9
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);
 8000918:	f002 ffca 	bl	80038b0 <HAL_PCD_MspInit>

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 800091c:	6828      	ldr	r0, [r5, #0]
 800091e:	f001 f8cf 	bl	8001ac0 <USB_DisableGlobalInt>
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 8000922:	462c      	mov	r4, r5
 8000924:	f854 7b10 	ldr.w	r7, [r4], #16
 8000928:	466e      	mov	r6, sp
 800092a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800092c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800092e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000930:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000932:	e894 0003 	ldmia.w	r4, {r0, r1}
 8000936:	e886 0003 	stmia.w	r6, {r0, r1}
 800093a:	1d2b      	adds	r3, r5, #4
 800093c:	cb0e      	ldmia	r3, {r1, r2, r3}
 800093e:	4638      	mov	r0, r7
 8000940:	f001 f87a 	bl	8001a38 <USB_CoreInit>
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8000944:	2100      	movs	r1, #0
 8000946:	6828      	ldr	r0, [r5, #0]
 8000948:	f001 f8c0 	bl	8001acc <USB_SetCurrentMode>
 800094c:	462b      	mov	r3, r5
 800094e:	462a      	mov	r2, r5
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8000950:	2100      	movs	r1, #0
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 8000952:	2001      	movs	r0, #1
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000954:	460c      	mov	r4, r1
   hpcd->IN_ep[i].is_in = 1U;
 8000956:	f882 0039 	strb.w	r0, [r2, #57]	; 0x39
   hpcd->IN_ep[i].num = i;
 800095a:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
   hpcd->IN_ep[i].tx_fifo_num = i;
 800095e:	87d1      	strh	r1, [r2, #62]	; 0x3e
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000960:	f882 403b 	strb.w	r4, [r2, #59]	; 0x3b
   hpcd->IN_ep[i].maxpacket = 0U;
 8000964:	6414      	str	r4, [r2, #64]	; 0x40
   hpcd->IN_ep[i].xfer_buff = 0U;
 8000966:	6454      	str	r4, [r2, #68]	; 0x44
   hpcd->IN_ep[i].xfer_len = 0U;
 8000968:	64d4      	str	r4, [r2, #76]	; 0x4c
 for (i = 0U; i < 15U; i++)
 800096a:	3101      	adds	r1, #1
 800096c:	321c      	adds	r2, #28
 800096e:	290f      	cmp	r1, #15
 8000970:	d1f1      	bne.n	8000956 <HAL_PCD_Init+0x4e>
 8000972:	2100      	movs	r1, #0
 }
 
 for (i = 0U; i < 15U; i++)
 {
   hpcd->OUT_ep[i].is_in = 0U;
 8000974:	460a      	mov	r2, r1
 8000976:	f883 21f9 	strb.w	r2, [r3, #505]	; 0x1f9
   hpcd->OUT_ep[i].num = i;
 800097a:	f883 11f8 	strb.w	r1, [r3, #504]	; 0x1f8
   hpcd->IN_ep[i].tx_fifo_num = i;
 800097e:	87d9      	strh	r1, [r3, #62]	; 0x3e
   /* Control until ep is activated */
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8000980:	f883 21fb 	strb.w	r2, [r3, #507]	; 0x1fb
   hpcd->OUT_ep[i].maxpacket = 0U;
 8000984:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
   hpcd->OUT_ep[i].xfer_buff = 0U;
 8000988:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
   hpcd->OUT_ep[i].xfer_len = 0U;
 800098c:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000990:	682c      	ldr	r4, [r5, #0]
 8000992:	f101 0040 	add.w	r0, r1, #64	; 0x40
 8000996:	eb04 0480 	add.w	r4, r4, r0, lsl #2
 800099a:	6062      	str	r2, [r4, #4]
 for (i = 0U; i < 15U; i++)
 800099c:	3101      	adds	r1, #1
 800099e:	331c      	adds	r3, #28
 80009a0:	290f      	cmp	r1, #15
 80009a2:	d1e8      	bne.n	8000976 <HAL_PCD_Init+0x6e>
 }
 
 /* Init Device */
 USB_DevInit(hpcd->Instance, hpcd->Init);
 80009a4:	462c      	mov	r4, r5
 80009a6:	f854 7b10 	ldr.w	r7, [r4], #16
 80009aa:	466e      	mov	r6, sp
 80009ac:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80009ae:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80009b0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80009b2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80009b4:	e894 0003 	ldmia.w	r4, {r0, r1}
 80009b8:	e886 0003 	stmia.w	r6, {r0, r1}
 80009bc:	1d2b      	adds	r3, r5, #4
 80009be:	cb0e      	ldmia	r3, {r1, r2, r3}
 80009c0:	4638      	mov	r0, r7
 80009c2:	f001 f899 	bl	8001af8 <USB_DevInit>
 
 hpcd->State= HAL_PCD_STATE_READY;
 80009c6:	2301      	movs	r3, #1
 80009c8:	f885 33b9 	strb.w	r3, [r5, #953]	; 0x3b9
 {
   HAL_PCDEx_ActivateBCD(hpcd);
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 80009cc:	6828      	ldr	r0, [r5, #0]
 80009ce:	f001 fc71 	bl	80022b4 <USB_DevDisconnect>
 return HAL_OK;
 80009d2:	2000      	movs	r0, #0
}
 80009d4:	b00b      	add	sp, #44	; 0x2c
 80009d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_ERROR;
 80009d8:	2001      	movs	r0, #1
 80009da:	4770      	bx	lr

080009dc <HAL_PCD_Start>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 80009dc:	f890 33b8 	ldrb.w	r3, [r0, #952]	; 0x3b8
 80009e0:	2b01      	cmp	r3, #1
 80009e2:	d101      	bne.n	80009e8 <HAL_PCD_Start+0xc>
 80009e4:	2002      	movs	r0, #2
 80009e6:	4770      	bx	lr
{ 
 80009e8:	b510      	push	{r4, lr}
 80009ea:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 80009ec:	2301      	movs	r3, #1
 80009ee:	f880 33b8 	strb.w	r3, [r0, #952]	; 0x3b8
  USB_DevConnect (hpcd->Instance);  
 80009f2:	6800      	ldr	r0, [r0, #0]
 80009f4:	f001 fc52 	bl	800229c <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 80009f8:	6820      	ldr	r0, [r4, #0]
 80009fa:	f001 f85b 	bl	8001ab4 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd); 
 80009fe:	2000      	movs	r0, #0
 8000a00:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 8000a04:	bd10      	pop	{r4, pc}
	...

08000a08 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8000a08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000a0c:	b089      	sub	sp, #36	; 0x24
 8000a0e:	4604      	mov	r4, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8000a10:	f8d0 8000 	ldr.w	r8, [r0]
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000U;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8000a14:	4640      	mov	r0, r8
 8000a16:	f001 fc89 	bl	800232c <USB_GetMode>
 8000a1a:	b110      	cbz	r0, 8000a22 <HAL_PCD_IRQHandler+0x1a>
        HAL_PCD_DisconnectCallback(hpcd);
      }
      hpcd->Instance->GOTGINT |= temp;
    }
  }
}
 8000a1c:	b009      	add	sp, #36	; 0x24
 8000a1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000a22:	4681      	mov	r9, r0
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
 8000a24:	6820      	ldr	r0, [r4, #0]
 8000a26:	f001 fc51 	bl	80022cc <USB_ReadInterrupts>
 8000a2a:	2800      	cmp	r0, #0
 8000a2c:	d0f6      	beq.n	8000a1c <HAL_PCD_IRQHandler+0x14>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8000a2e:	6820      	ldr	r0, [r4, #0]
 8000a30:	f001 fc4c 	bl	80022cc <USB_ReadInterrupts>
 8000a34:	f010 0f02 	tst.w	r0, #2
 8000a38:	d004      	beq.n	8000a44 <HAL_PCD_IRQHandler+0x3c>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8000a3a:	6822      	ldr	r2, [r4, #0]
 8000a3c:	6953      	ldr	r3, [r2, #20]
 8000a3e:	f003 0302 	and.w	r3, r3, #2
 8000a42:	6153      	str	r3, [r2, #20]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8000a44:	6820      	ldr	r0, [r4, #0]
 8000a46:	f001 fc41 	bl	80022cc <USB_ReadInterrupts>
 8000a4a:	f410 2f00 	tst.w	r0, #524288	; 0x80000
 8000a4e:	d176      	bne.n	8000b3e <HAL_PCD_IRQHandler+0x136>
  uint32_t i = 0U, ep_intr = 0U, epint = 0U, epnum = 0U;
 8000a50:	46ca      	mov	sl, r9
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8000a52:	6820      	ldr	r0, [r4, #0]
 8000a54:	f001 fc3a 	bl	80022cc <USB_ReadInterrupts>
 8000a58:	f410 2f80 	tst.w	r0, #262144	; 0x40000
 8000a5c:	f040 80ca 	bne.w	8000bf4 <HAL_PCD_IRQHandler+0x1ec>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8000a60:	6820      	ldr	r0, [r4, #0]
 8000a62:	f001 fc33 	bl	80022cc <USB_ReadInterrupts>
 8000a66:	2800      	cmp	r0, #0
 8000a68:	f2c0 8181 	blt.w	8000d6e <HAL_PCD_IRQHandler+0x366>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 8000a6c:	6820      	ldr	r0, [r4, #0]
 8000a6e:	f001 fc2d 	bl	80022cc <USB_ReadInterrupts>
 8000a72:	f410 6f00 	tst.w	r0, #2048	; 0x800
 8000a76:	d00a      	beq.n	8000a8e <HAL_PCD_IRQHandler+0x86>
      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8000a78:	f8d8 3808 	ldr.w	r3, [r8, #2056]	; 0x808
 8000a7c:	f013 0f01 	tst.w	r3, #1
 8000a80:	f040 8184 	bne.w	8000d8c <HAL_PCD_IRQHandler+0x384>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8000a84:	6822      	ldr	r2, [r4, #0]
 8000a86:	6953      	ldr	r3, [r2, #20]
 8000a88:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8000a8c:	6153      	str	r3, [r2, #20]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8000a8e:	6820      	ldr	r0, [r4, #0]
 8000a90:	f001 fc1c 	bl	80022cc <USB_ReadInterrupts>
 8000a94:	f410 5f80 	tst.w	r0, #4096	; 0x1000
 8000a98:	f040 817c 	bne.w	8000d94 <HAL_PCD_IRQHandler+0x38c>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8000a9c:	6820      	ldr	r0, [r4, #0]
 8000a9e:	f001 fc15 	bl	80022cc <USB_ReadInterrupts>
 8000aa2:	f410 5f00 	tst.w	r0, #8192	; 0x2000
 8000aa6:	f040 81bb 	bne.w	8000e20 <HAL_PCD_IRQHandler+0x418>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8000aaa:	6820      	ldr	r0, [r4, #0]
 8000aac:	f001 fc0e 	bl	80022cc <USB_ReadInterrupts>
 8000ab0:	f010 0f10 	tst.w	r0, #16
 8000ab4:	d015      	beq.n	8000ae2 <HAL_PCD_IRQHandler+0xda>
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000ab6:	6822      	ldr	r2, [r4, #0]
 8000ab8:	6993      	ldr	r3, [r2, #24]
 8000aba:	f023 0310 	bic.w	r3, r3, #16
 8000abe:	6193      	str	r3, [r2, #24]
      temp = USBx->GRXSTSP;
 8000ac0:	f8d8 5020 	ldr.w	r5, [r8, #32]
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8000ac4:	f005 060f 	and.w	r6, r5, #15
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 8000ac8:	f3c5 4343 	ubfx	r3, r5, #17, #4
 8000acc:	2b02      	cmp	r3, #2
 8000ace:	f000 8237 	beq.w	8000f40 <HAL_PCD_IRQHandler+0x538>
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_SETUP_UPDT)
 8000ad2:	2b06      	cmp	r3, #6
 8000ad4:	f000 8254 	beq.w	8000f80 <HAL_PCD_IRQHandler+0x578>
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000ad8:	6822      	ldr	r2, [r4, #0]
 8000ada:	6993      	ldr	r3, [r2, #24]
 8000adc:	f043 0310 	orr.w	r3, r3, #16
 8000ae0:	6193      	str	r3, [r2, #24]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8000ae2:	6820      	ldr	r0, [r4, #0]
 8000ae4:	f001 fbf2 	bl	80022cc <USB_ReadInterrupts>
 8000ae8:	f010 0f08 	tst.w	r0, #8
 8000aec:	f040 825a 	bne.w	8000fa4 <HAL_PCD_IRQHandler+0x59c>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8000af0:	6820      	ldr	r0, [r4, #0]
 8000af2:	f001 fbeb 	bl	80022cc <USB_ReadInterrupts>
 8000af6:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
 8000afa:	f040 825c 	bne.w	8000fb6 <HAL_PCD_IRQHandler+0x5ae>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8000afe:	6820      	ldr	r0, [r4, #0]
 8000b00:	f001 fbe4 	bl	80022cc <USB_ReadInterrupts>
 8000b04:	f410 1f00 	tst.w	r0, #2097152	; 0x200000
 8000b08:	f040 8260 	bne.w	8000fcc <HAL_PCD_IRQHandler+0x5c4>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8000b0c:	6820      	ldr	r0, [r4, #0]
 8000b0e:	f001 fbdd 	bl	80022cc <USB_ReadInterrupts>
 8000b12:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 8000b16:	f040 8264 	bne.w	8000fe2 <HAL_PCD_IRQHandler+0x5da>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8000b1a:	6820      	ldr	r0, [r4, #0]
 8000b1c:	f001 fbd6 	bl	80022cc <USB_ReadInterrupts>
 8000b20:	f010 0f04 	tst.w	r0, #4
 8000b24:	f43f af7a 	beq.w	8000a1c <HAL_PCD_IRQHandler+0x14>
      temp = hpcd->Instance->GOTGINT;
 8000b28:	6823      	ldr	r3, [r4, #0]
 8000b2a:	685d      	ldr	r5, [r3, #4]
      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8000b2c:	f015 0f04 	tst.w	r5, #4
 8000b30:	f040 8260 	bne.w	8000ff4 <HAL_PCD_IRQHandler+0x5ec>
      hpcd->Instance->GOTGINT |= temp;
 8000b34:	6823      	ldr	r3, [r4, #0]
 8000b36:	685a      	ldr	r2, [r3, #4]
 8000b38:	4315      	orrs	r5, r2
 8000b3a:	605d      	str	r5, [r3, #4]
 8000b3c:	e76e      	b.n	8000a1c <HAL_PCD_IRQHandler+0x14>
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8000b3e:	6820      	ldr	r0, [r4, #0]
 8000b40:	f001 fbc8 	bl	80022d4 <USB_ReadDevAllOutEpInterrupt>
      while ( ep_intr )
 8000b44:	4605      	mov	r5, r0
 8000b46:	2800      	cmp	r0, #0
 8000b48:	d052      	beq.n	8000bf0 <HAL_PCD_IRQHandler+0x1e8>
 8000b4a:	f508 6630 	add.w	r6, r8, #2816	; 0xb00
 8000b4e:	4627      	mov	r7, r4
 8000b50:	46ca      	mov	sl, r9
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8000b52:	f8cd 8008 	str.w	r8, [sp, #8]
 8000b56:	e01b      	b.n	8000b90 <HAL_PCD_IRQHandler+0x188>
              hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
 8000b58:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 8000b5c:	6933      	ldr	r3, [r6, #16]
 8000b5e:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8000b62:	1ad3      	subs	r3, r2, r3
 8000b64:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
              hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
 8000b68:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 8000b6c:	4413      	add	r3, r2
 8000b6e:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
 8000b72:	e01f      	b.n	8000bb4 <HAL_PCD_IRQHandler+0x1ac>
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8000b74:	f018 0f08 	tst.w	r8, #8
 8000b78:	d131      	bne.n	8000bde <HAL_PCD_IRQHandler+0x1d6>
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8000b7a:	f018 0f10 	tst.w	r8, #16
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8000b7e:	bf1c      	itt	ne
 8000b80:	2310      	movne	r3, #16
 8000b82:	60b3      	strne	r3, [r6, #8]
        epnum++;
 8000b84:	f10a 0a01 	add.w	sl, sl, #1
 8000b88:	3620      	adds	r6, #32
 8000b8a:	371c      	adds	r7, #28
      while ( ep_intr )
 8000b8c:	086d      	lsrs	r5, r5, #1
 8000b8e:	d02c      	beq.n	8000bea <HAL_PCD_IRQHandler+0x1e2>
        if (ep_intr & 0x1U)
 8000b90:	f015 0f01 	tst.w	r5, #1
 8000b94:	d0f6      	beq.n	8000b84 <HAL_PCD_IRQHandler+0x17c>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8000b96:	fa5f fb8a 	uxtb.w	fp, sl
 8000b9a:	4659      	mov	r1, fp
 8000b9c:	6820      	ldr	r0, [r4, #0]
 8000b9e:	f001 fba9 	bl	80022f4 <USB_ReadDevOutEPInterrupt>
 8000ba2:	4680      	mov	r8, r0
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8000ba4:	f010 0f01 	tst.w	r0, #1
 8000ba8:	d0e4      	beq.n	8000b74 <HAL_PCD_IRQHandler+0x16c>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8000baa:	2301      	movs	r3, #1
 8000bac:	60b3      	str	r3, [r6, #8]
            if(hpcd->Init.dma_enable == 1U)
 8000bae:	6923      	ldr	r3, [r4, #16]
 8000bb0:	2b01      	cmp	r3, #1
 8000bb2:	d0d1      	beq.n	8000b58 <HAL_PCD_IRQHandler+0x150>
            HAL_PCD_DataOutStageCallback(hpcd, epnum);
 8000bb4:	4659      	mov	r1, fp
 8000bb6:	4620      	mov	r0, r4
 8000bb8:	f002 fec0 	bl	800393c <HAL_PCD_DataOutStageCallback>
            if(hpcd->Init.dma_enable == 1U)
 8000bbc:	6923      	ldr	r3, [r4, #16]
 8000bbe:	2b01      	cmp	r3, #1
 8000bc0:	d1d8      	bne.n	8000b74 <HAL_PCD_IRQHandler+0x16c>
              if((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8000bc2:	f1ba 0f00 	cmp.w	sl, #0
 8000bc6:	d1d5      	bne.n	8000b74 <HAL_PCD_IRQHandler+0x16c>
 8000bc8:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
 8000bcc:	2b00      	cmp	r3, #0
 8000bce:	d1d1      	bne.n	8000b74 <HAL_PCD_IRQHandler+0x16c>
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8000bd0:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 8000bd4:	2101      	movs	r1, #1
 8000bd6:	6820      	ldr	r0, [r4, #0]
 8000bd8:	f001 fbc8 	bl	800236c <USB_EP0_OutStart>
 8000bdc:	e7ca      	b.n	8000b74 <HAL_PCD_IRQHandler+0x16c>
            HAL_PCD_SetupStageCallback(hpcd);
 8000bde:	4620      	mov	r0, r4
 8000be0:	f002 fea4 	bl	800392c <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8000be4:	2308      	movs	r3, #8
 8000be6:	60b3      	str	r3, [r6, #8]
 8000be8:	e7c7      	b.n	8000b7a <HAL_PCD_IRQHandler+0x172>
 8000bea:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8000bee:	e730      	b.n	8000a52 <HAL_PCD_IRQHandler+0x4a>
      epnum = 0U;
 8000bf0:	4682      	mov	sl, r0
 8000bf2:	e72e      	b.n	8000a52 <HAL_PCD_IRQHandler+0x4a>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8000bf4:	6820      	ldr	r0, [r4, #0]
 8000bf6:	f001 fb75 	bl	80022e4 <USB_ReadDevAllInEpInterrupt>
      while ( ep_intr )
 8000bfa:	4683      	mov	fp, r0
 8000bfc:	2800      	cmp	r0, #0
 8000bfe:	f000 80b4 	beq.w	8000d6a <HAL_PCD_IRQHandler+0x362>
 8000c02:	f8cd 8014 	str.w	r8, [sp, #20]
 8000c06:	f508 6710 	add.w	r7, r8, #2304	; 0x900
 8000c0a:	46ca      	mov	sl, r9
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8000c0c:	f8cd 8018 	str.w	r8, [sp, #24]
 8000c10:	46a0      	mov	r8, r4
 8000c12:	f8cd 901c 	str.w	r9, [sp, #28]
 8000c16:	e026      	b.n	8000c66 <HAL_PCD_IRQHandler+0x25e>
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
 8000c18:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 8000c1c:	f8d8 2040 	ldr.w	r2, [r8, #64]	; 0x40
 8000c20:	4413      	add	r3, r2
 8000c22:	f8c8 3044 	str.w	r3, [r8, #68]	; 0x44
 8000c26:	e03c      	b.n	8000ca2 <HAL_PCD_IRQHandler+0x29a>
           if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8000c28:	f015 0f08 	tst.w	r5, #8
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8000c2c:	bf1c      	itt	ne
 8000c2e:	2308      	movne	r3, #8
 8000c30:	60bb      	strne	r3, [r7, #8]
          if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8000c32:	f015 0f10 	tst.w	r5, #16
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8000c36:	bf1c      	itt	ne
 8000c38:	2310      	movne	r3, #16
 8000c3a:	60bb      	strne	r3, [r7, #8]
          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8000c3c:	f015 0f40 	tst.w	r5, #64	; 0x40
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8000c40:	bf1c      	itt	ne
 8000c42:	2340      	movne	r3, #64	; 0x40
 8000c44:	60bb      	strne	r3, [r7, #8]
          if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8000c46:	f015 0f02 	tst.w	r5, #2
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8000c4a:	bf1c      	itt	ne
 8000c4c:	2302      	movne	r3, #2
 8000c4e:	60bb      	strne	r3, [r7, #8]
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8000c50:	f015 0f80 	tst.w	r5, #128	; 0x80
 8000c54:	d139      	bne.n	8000cca <HAL_PCD_IRQHandler+0x2c2>
        epnum++;
 8000c56:	f10a 0a01 	add.w	sl, sl, #1
 8000c5a:	f108 081c 	add.w	r8, r8, #28
 8000c5e:	3720      	adds	r7, #32
      while ( ep_intr )
 8000c60:	ea5f 0b5b 	movs.w	fp, fp, lsr #1
 8000c64:	d07c      	beq.n	8000d60 <HAL_PCD_IRQHandler+0x358>
        if (ep_intr & 0x1U) /* In ITR */
 8000c66:	f01b 0f01 	tst.w	fp, #1
 8000c6a:	d0f4      	beq.n	8000c56 <HAL_PCD_IRQHandler+0x24e>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 8000c6c:	fa5f f38a 	uxtb.w	r3, sl
 8000c70:	9302      	str	r3, [sp, #8]
 8000c72:	4619      	mov	r1, r3
 8000c74:	6820      	ldr	r0, [r4, #0]
 8000c76:	f001 fb47 	bl	8002308 <USB_ReadDevInEPInterrupt>
 8000c7a:	4605      	mov	r5, r0
           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8000c7c:	f010 0f01 	tst.w	r0, #1
 8000c80:	d0d2      	beq.n	8000c28 <HAL_PCD_IRQHandler+0x220>
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000c82:	9b05      	ldr	r3, [sp, #20]
 8000c84:	f503 6200 	add.w	r2, r3, #2048	; 0x800
 8000c88:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
            fifoemptymsk = 0x1U << epnum;
 8000c8c:	2101      	movs	r1, #1
 8000c8e:	fa01 f10a 	lsl.w	r1, r1, sl
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000c92:	ea23 0301 	bic.w	r3, r3, r1
 8000c96:	6353      	str	r3, [r2, #52]	; 0x34
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8000c98:	2301      	movs	r3, #1
 8000c9a:	60bb      	str	r3, [r7, #8]
            if (hpcd->Init.dma_enable == 1U)
 8000c9c:	6923      	ldr	r3, [r4, #16]
 8000c9e:	2b01      	cmp	r3, #1
 8000ca0:	d0ba      	beq.n	8000c18 <HAL_PCD_IRQHandler+0x210>
            HAL_PCD_DataInStageCallback(hpcd, epnum);
 8000ca2:	9902      	ldr	r1, [sp, #8]
 8000ca4:	4620      	mov	r0, r4
 8000ca6:	f002 fe55 	bl	8003954 <HAL_PCD_DataInStageCallback>
            if (hpcd->Init.dma_enable == 1U)
 8000caa:	6923      	ldr	r3, [r4, #16]
 8000cac:	2b01      	cmp	r3, #1
 8000cae:	d1bb      	bne.n	8000c28 <HAL_PCD_IRQHandler+0x220>
              if((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8000cb0:	f1ba 0f00 	cmp.w	sl, #0
 8000cb4:	d1b8      	bne.n	8000c28 <HAL_PCD_IRQHandler+0x220>
 8000cb6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8000cb8:	2b00      	cmp	r3, #0
 8000cba:	d1b5      	bne.n	8000c28 <HAL_PCD_IRQHandler+0x220>
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8000cbc:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 8000cc0:	2101      	movs	r1, #1
 8000cc2:	6820      	ldr	r0, [r4, #0]
 8000cc4:	f001 fb52 	bl	800236c <USB_EP0_OutStart>
 8000cc8:	e7ae      	b.n	8000c28 <HAL_PCD_IRQHandler+0x220>
  * @param  epnum  endpoint number   
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 8000cca:	6823      	ldr	r3, [r4, #0]
 8000ccc:	4618      	mov	r0, r3
 8000cce:	9304      	str	r3, [sp, #16]
 8000cd0:	4646      	mov	r6, r8
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 8000cd2:	f8d8 504c 	ldr.w	r5, [r8, #76]	; 0x4c
 8000cd6:	f8d8 2050 	ldr.w	r2, [r8, #80]	; 0x50
 8000cda:	1aab      	subs	r3, r5, r2
 8000cdc:	f8d8 1040 	ldr.w	r1, [r8, #64]	; 0x40
 8000ce0:	428b      	cmp	r3, r1
 8000ce2:	bf28      	it	cs
 8000ce4:	460b      	movcs	r3, r1
 8000ce6:	9303      	str	r3, [sp, #12]
  }
  
  
  len32b = (len + 3U) / 4U;
 
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000ce8:	f500 6910 	add.w	r9, r0, #2304	; 0x900
 8000cec:	eb09 194a 	add.w	r9, r9, sl, lsl #5
 8000cf0:	f8d9 1018 	ldr.w	r1, [r9, #24]
  len32b = (len + 3U) / 4U;
 8000cf4:	3303      	adds	r3, #3
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000cf6:	b289      	uxth	r1, r1
 8000cf8:	ebb1 0f93 	cmp.w	r1, r3, lsr #2
 8000cfc:	d922      	bls.n	8000d44 <HAL_PCD_IRQHandler+0x33c>
 8000cfe:	4295      	cmp	r5, r2
 8000d00:	d920      	bls.n	8000d44 <HAL_PCD_IRQHandler+0x33c>
          (ep->xfer_count < ep->xfer_len) &&
 8000d02:	b1fd      	cbz	r5, 8000d44 <HAL_PCD_IRQHandler+0x33c>
            (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 8000d04:	1aad      	subs	r5, r5, r2
 8000d06:	6c33      	ldr	r3, [r6, #64]	; 0x40
 8000d08:	429d      	cmp	r5, r3
 8000d0a:	bf28      	it	cs
 8000d0c:	461d      	movcs	r5, r3
 8000d0e:	9503      	str	r5, [sp, #12]
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 8000d10:	7c23      	ldrb	r3, [r4, #16]
 8000d12:	9300      	str	r3, [sp, #0]
 8000d14:	b2ab      	uxth	r3, r5
 8000d16:	9a02      	ldr	r2, [sp, #8]
 8000d18:	6c71      	ldr	r1, [r6, #68]	; 0x44
 8000d1a:	9804      	ldr	r0, [sp, #16]
 8000d1c:	f001 fa2e 	bl	800217c <USB_WritePacket>
    
    ep->xfer_buff  += len;
 8000d20:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8000d22:	442b      	add	r3, r5
 8000d24:	6473      	str	r3, [r6, #68]	; 0x44
    ep->xfer_count += len;
 8000d26:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8000d28:	442a      	add	r2, r5
 8000d2a:	6532      	str	r2, [r6, #80]	; 0x50
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000d2c:	f8d9 3018 	ldr.w	r3, [r9, #24]
    len32b = (len + 3U) / 4U;
 8000d30:	3503      	adds	r5, #3
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000d32:	b29b      	uxth	r3, r3
 8000d34:	ebb3 0f95 	cmp.w	r3, r5, lsr #2
 8000d38:	d904      	bls.n	8000d44 <HAL_PCD_IRQHandler+0x33c>
          (ep->xfer_count < ep->xfer_len) &&
 8000d3a:	6cf5      	ldr	r5, [r6, #76]	; 0x4c
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000d3c:	4295      	cmp	r5, r2
 8000d3e:	d901      	bls.n	8000d44 <HAL_PCD_IRQHandler+0x33c>
          (ep->xfer_count < ep->xfer_len) &&
 8000d40:	2d00      	cmp	r5, #0
 8000d42:	d1df      	bne.n	8000d04 <HAL_PCD_IRQHandler+0x2fc>
  }
  
  if(len <= 0U)
 8000d44:	9b03      	ldr	r3, [sp, #12]
 8000d46:	2b00      	cmp	r3, #0
 8000d48:	d185      	bne.n	8000c56 <HAL_PCD_IRQHandler+0x24e>
  {
    fifoemptymsk = 0x1U << epnum;
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000d4a:	9b04      	ldr	r3, [sp, #16]
 8000d4c:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
    fifoemptymsk = 0x1U << epnum;
 8000d50:	2101      	movs	r1, #1
 8000d52:	fa01 f10a 	lsl.w	r1, r1, sl
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000d56:	ea22 0201 	bic.w	r2, r2, r1
 8000d5a:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
 8000d5e:	e77a      	b.n	8000c56 <HAL_PCD_IRQHandler+0x24e>
 8000d60:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8000d64:	f8dd 901c 	ldr.w	r9, [sp, #28]
 8000d68:	e67a      	b.n	8000a60 <HAL_PCD_IRQHandler+0x58>
      epnum = 0U;
 8000d6a:	4682      	mov	sl, r0
 8000d6c:	e678      	b.n	8000a60 <HAL_PCD_IRQHandler+0x58>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8000d6e:	f8d8 3804 	ldr.w	r3, [r8, #2052]	; 0x804
 8000d72:	f023 0301 	bic.w	r3, r3, #1
 8000d76:	f8c8 3804 	str.w	r3, [r8, #2052]	; 0x804
        HAL_PCD_ResumeCallback(hpcd);
 8000d7a:	4620      	mov	r0, r4
 8000d7c:	f002 fe22 	bl	80039c4 <HAL_PCD_ResumeCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8000d80:	6822      	ldr	r2, [r4, #0]
 8000d82:	6953      	ldr	r3, [r2, #20]
 8000d84:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8000d88:	6153      	str	r3, [r2, #20]
 8000d8a:	e66f      	b.n	8000a6c <HAL_PCD_IRQHandler+0x64>
        HAL_PCD_SuspendCallback(hpcd);
 8000d8c:	4620      	mov	r0, r4
 8000d8e:	f002 fe01 	bl	8003994 <HAL_PCD_SuspendCallback>
 8000d92:	e677      	b.n	8000a84 <HAL_PCD_IRQHandler+0x7c>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 8000d94:	f508 6500 	add.w	r5, r8, #2048	; 0x800
 8000d98:	686b      	ldr	r3, [r5, #4]
 8000d9a:	f023 0301 	bic.w	r3, r3, #1
 8000d9e:	606b      	str	r3, [r5, #4]
      USB_FlushTxFifo(hpcd->Instance , 0x10U);
 8000da0:	2110      	movs	r1, #16
 8000da2:	6820      	ldr	r0, [r4, #0]
 8000da4:	f000 ff56 	bl	8001c54 <USB_FlushTxFifo>
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000da8:	6863      	ldr	r3, [r4, #4]
 8000daa:	b15b      	cbz	r3, 8000dc4 <HAL_PCD_IRQHandler+0x3bc>
 8000dac:	f508 6310 	add.w	r3, r8, #2304	; 0x900
        USBx_INEP(i)->DIEPINT = 0xFFU;
 8000db0:	22ff      	movs	r2, #255	; 0xff
 8000db2:	609a      	str	r2, [r3, #8]
        USBx_OUTEP(i)->DOEPINT = 0xFFU;
 8000db4:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000db8:	f109 0901 	add.w	r9, r9, #1
 8000dbc:	3320      	adds	r3, #32
 8000dbe:	6861      	ldr	r1, [r4, #4]
 8000dc0:	4549      	cmp	r1, r9
 8000dc2:	d8f6      	bhi.n	8000db2 <HAL_PCD_IRQHandler+0x3aa>
      USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8000dc4:	f04f 33ff 	mov.w	r3, #4294967295
 8000dc8:	61ab      	str	r3, [r5, #24]
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8000dca:	69eb      	ldr	r3, [r5, #28]
 8000dcc:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8000dd0:	61eb      	str	r3, [r5, #28]
      if(hpcd->Init.use_dedicated_ep1)
 8000dd2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000dd4:	b1db      	cbz	r3, 8000e0e <HAL_PCD_IRQHandler+0x406>
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
 8000dd6:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 8000dda:	f043 030b 	orr.w	r3, r3, #11
 8000dde:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
 8000de2:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8000de4:	f043 030b 	orr.w	r3, r3, #11
 8000de8:	646b      	str	r3, [r5, #68]	; 0x44
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8000dea:	f8d8 3800 	ldr.w	r3, [r8, #2048]	; 0x800
 8000dee:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8000df2:	f8c8 3800 	str.w	r3, [r8, #2048]	; 0x800
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8000df6:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 8000dfa:	7c21      	ldrb	r1, [r4, #16]
 8000dfc:	6820      	ldr	r0, [r4, #0]
 8000dfe:	f001 fab5 	bl	800236c <USB_EP0_OutStart>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8000e02:	6822      	ldr	r2, [r4, #0]
 8000e04:	6953      	ldr	r3, [r2, #20]
 8000e06:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000e0a:	6153      	str	r3, [r2, #20]
 8000e0c:	e646      	b.n	8000a9c <HAL_PCD_IRQHandler+0x94>
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 8000e0e:	696b      	ldr	r3, [r5, #20]
 8000e10:	f043 030b 	orr.w	r3, r3, #11
 8000e14:	616b      	str	r3, [r5, #20]
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 8000e16:	692b      	ldr	r3, [r5, #16]
 8000e18:	f043 030b 	orr.w	r3, r3, #11
 8000e1c:	612b      	str	r3, [r5, #16]
 8000e1e:	e7e4      	b.n	8000dea <HAL_PCD_IRQHandler+0x3e2>
      USB_ActivateSetup(hpcd->Instance);
 8000e20:	6820      	ldr	r0, [r4, #0]
 8000e22:	f001 fa87 	bl	8002334 <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8000e26:	6822      	ldr	r2, [r4, #0]
 8000e28:	68d3      	ldr	r3, [r2, #12]
 8000e2a:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8000e2e:	60d3      	str	r3, [r2, #12]
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
 8000e30:	6820      	ldr	r0, [r4, #0]
 8000e32:	f000 ff38 	bl	8001ca6 <USB_GetDevSpeed>
 8000e36:	b990      	cbnz	r0, 8000e5e <HAL_PCD_IRQHandler+0x456>
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
 8000e38:	2300      	movs	r3, #0
 8000e3a:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8000e3c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000e40:	6163      	str	r3, [r4, #20]
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000e42:	6822      	ldr	r2, [r4, #0]
 8000e44:	68d3      	ldr	r3, [r2, #12]
 8000e46:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 8000e4a:	60d3      	str	r3, [r2, #12]
      HAL_PCD_ResetCallback(hpcd);
 8000e4c:	4620      	mov	r0, r4
 8000e4e:	f002 fd92 	bl	8003976 <HAL_PCD_ResetCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8000e52:	6822      	ldr	r2, [r4, #0]
 8000e54:	6953      	ldr	r3, [r2, #20]
 8000e56:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8000e5a:	6153      	str	r3, [r2, #20]
 8000e5c:	e625      	b.n	8000aaa <HAL_PCD_IRQHandler+0xa2>
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 8000e5e:	2303      	movs	r3, #3
 8000e60:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8000e62:	2340      	movs	r3, #64	; 0x40
 8000e64:	6163      	str	r3, [r4, #20]
        hclk = HAL_RCC_GetHCLKFreq();
 8000e66:	f000 fd29 	bl	80018bc <HAL_RCC_GetHCLKFreq>
        if((hclk >= 14200000U)&&(hclk < 15000000U))
 8000e6a:	4b64      	ldr	r3, [pc, #400]	; (8000ffc <HAL_PCD_IRQHandler+0x5f4>)
 8000e6c:	4403      	add	r3, r0
 8000e6e:	4a64      	ldr	r2, [pc, #400]	; (8001000 <HAL_PCD_IRQHandler+0x5f8>)
 8000e70:	4293      	cmp	r3, r2
 8000e72:	d805      	bhi.n	8000e80 <HAL_PCD_IRQHandler+0x478>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xFU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000e74:	6822      	ldr	r2, [r4, #0]
 8000e76:	68d3      	ldr	r3, [r2, #12]
 8000e78:	f443 5370 	orr.w	r3, r3, #15360	; 0x3c00
 8000e7c:	60d3      	str	r3, [r2, #12]
 8000e7e:	e7e5      	b.n	8000e4c <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 15000000U)&&(hclk < 16000000U))
 8000e80:	4b60      	ldr	r3, [pc, #384]	; (8001004 <HAL_PCD_IRQHandler+0x5fc>)
 8000e82:	4403      	add	r3, r0
 8000e84:	4a60      	ldr	r2, [pc, #384]	; (8001008 <HAL_PCD_IRQHandler+0x600>)
 8000e86:	4293      	cmp	r3, r2
 8000e88:	d805      	bhi.n	8000e96 <HAL_PCD_IRQHandler+0x48e>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xEU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000e8a:	6822      	ldr	r2, [r4, #0]
 8000e8c:	68d3      	ldr	r3, [r2, #12]
 8000e8e:	f443 5360 	orr.w	r3, r3, #14336	; 0x3800
 8000e92:	60d3      	str	r3, [r2, #12]
 8000e94:	e7da      	b.n	8000e4c <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 16000000U)&&(hclk < 17200000U))
 8000e96:	f5a0 0374 	sub.w	r3, r0, #15990784	; 0xf40000
 8000e9a:	f5a3 5310 	sub.w	r3, r3, #9216	; 0x2400
 8000e9e:	4a5b      	ldr	r2, [pc, #364]	; (800100c <HAL_PCD_IRQHandler+0x604>)
 8000ea0:	4293      	cmp	r3, r2
 8000ea2:	d805      	bhi.n	8000eb0 <HAL_PCD_IRQHandler+0x4a8>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xDU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000ea4:	6822      	ldr	r2, [r4, #0]
 8000ea6:	68d3      	ldr	r3, [r2, #12]
 8000ea8:	f443 5350 	orr.w	r3, r3, #13312	; 0x3400
 8000eac:	60d3      	str	r3, [r2, #12]
 8000eae:	e7cd      	b.n	8000e4c <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 17200000U)&&(hclk < 18500000U))
 8000eb0:	f1a0 7383 	sub.w	r3, r0, #17170432	; 0x1060000
 8000eb4:	f5a3 43e7 	sub.w	r3, r3, #29568	; 0x7380
 8000eb8:	4a55      	ldr	r2, [pc, #340]	; (8001010 <HAL_PCD_IRQHandler+0x608>)
 8000eba:	4293      	cmp	r3, r2
 8000ebc:	d805      	bhi.n	8000eca <HAL_PCD_IRQHandler+0x4c2>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xCU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000ebe:	6822      	ldr	r2, [r4, #0]
 8000ec0:	68d3      	ldr	r3, [r2, #12]
 8000ec2:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 8000ec6:	60d3      	str	r3, [r2, #12]
 8000ec8:	e7c0      	b.n	8000e4c <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 18500000U)&&(hclk < 20000000U))
 8000eca:	4b52      	ldr	r3, [pc, #328]	; (8001014 <HAL_PCD_IRQHandler+0x60c>)
 8000ecc:	4403      	add	r3, r0
 8000ece:	4a52      	ldr	r2, [pc, #328]	; (8001018 <HAL_PCD_IRQHandler+0x610>)
 8000ed0:	4293      	cmp	r3, r2
 8000ed2:	d805      	bhi.n	8000ee0 <HAL_PCD_IRQHandler+0x4d8>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xBU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000ed4:	6822      	ldr	r2, [r4, #0]
 8000ed6:	68d3      	ldr	r3, [r2, #12]
 8000ed8:	f443 5330 	orr.w	r3, r3, #11264	; 0x2c00
 8000edc:	60d3      	str	r3, [r2, #12]
 8000ede:	e7b5      	b.n	8000e4c <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 20000000U)&&(hclk < 21800000U))
 8000ee0:	4b4e      	ldr	r3, [pc, #312]	; (800101c <HAL_PCD_IRQHandler+0x614>)
 8000ee2:	4403      	add	r3, r0
 8000ee4:	4a4e      	ldr	r2, [pc, #312]	; (8001020 <HAL_PCD_IRQHandler+0x618>)
 8000ee6:	4293      	cmp	r3, r2
 8000ee8:	d805      	bhi.n	8000ef6 <HAL_PCD_IRQHandler+0x4ee>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xAU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000eea:	6822      	ldr	r2, [r4, #0]
 8000eec:	68d3      	ldr	r3, [r2, #12]
 8000eee:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
 8000ef2:	60d3      	str	r3, [r2, #12]
 8000ef4:	e7aa      	b.n	8000e4c <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 21800000U)&&(hclk < 24000000U))
 8000ef6:	4b4b      	ldr	r3, [pc, #300]	; (8001024 <HAL_PCD_IRQHandler+0x61c>)
 8000ef8:	4403      	add	r3, r0
 8000efa:	4a4b      	ldr	r2, [pc, #300]	; (8001028 <HAL_PCD_IRQHandler+0x620>)
 8000efc:	4293      	cmp	r3, r2
 8000efe:	d805      	bhi.n	8000f0c <HAL_PCD_IRQHandler+0x504>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x9U << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000f00:	6822      	ldr	r2, [r4, #0]
 8000f02:	68d3      	ldr	r3, [r2, #12]
 8000f04:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 8000f08:	60d3      	str	r3, [r2, #12]
 8000f0a:	e79f      	b.n	8000e4c <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 24000000U)&&(hclk < 27700000U))
 8000f0c:	f1a0 73b7 	sub.w	r3, r0, #23986176	; 0x16e0000
 8000f10:	f5a3 5358 	sub.w	r3, r3, #13824	; 0x3600
 8000f14:	4a45      	ldr	r2, [pc, #276]	; (800102c <HAL_PCD_IRQHandler+0x624>)
 8000f16:	4293      	cmp	r3, r2
 8000f18:	d805      	bhi.n	8000f26 <HAL_PCD_IRQHandler+0x51e>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x8U << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000f1a:	6822      	ldr	r2, [r4, #0]
 8000f1c:	68d3      	ldr	r3, [r2, #12]
 8000f1e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000f22:	60d3      	str	r3, [r2, #12]
 8000f24:	e792      	b.n	8000e4c <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 27700000U)&&(hclk < 32000000U))
 8000f26:	4b42      	ldr	r3, [pc, #264]	; (8001030 <HAL_PCD_IRQHandler+0x628>)
 8000f28:	4403      	add	r3, r0
 8000f2a:	4a42      	ldr	r2, [pc, #264]	; (8001034 <HAL_PCD_IRQHandler+0x62c>)
 8000f2c:	4293      	cmp	r3, r2
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x7U << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000f2e:	6822      	ldr	r2, [r4, #0]
 8000f30:	68d3      	ldr	r3, [r2, #12]
 8000f32:	bf94      	ite	ls
 8000f34:	f443 53e0 	orrls.w	r3, r3, #7168	; 0x1c00
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x6U << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000f38:	f443 53c0 	orrhi.w	r3, r3, #6144	; 0x1800
 8000f3c:	60d3      	str	r3, [r2, #12]
 8000f3e:	e785      	b.n	8000e4c <HAL_PCD_IRQHandler+0x444>
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 8000f40:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8000f44:	421d      	tst	r5, r3
 8000f46:	f43f adc7 	beq.w	8000ad8 <HAL_PCD_IRQHandler+0xd0>
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4U);
 8000f4a:	092d      	lsrs	r5, r5, #4
 8000f4c:	ea4f 09c6 	mov.w	r9, r6, lsl #3
 8000f50:	eba9 0706 	sub.w	r7, r9, r6
 8000f54:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 8000f58:	f3c5 020a 	ubfx	r2, r5, #0, #11
 8000f5c:	f8d7 1204 	ldr.w	r1, [r7, #516]	; 0x204
 8000f60:	4640      	mov	r0, r8
 8000f62:	f001 f921 	bl	80021a8 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8000f66:	f3c5 050a 	ubfx	r5, r5, #0, #11
 8000f6a:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 8000f6e:	442b      	add	r3, r5
 8000f70:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8000f74:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 8000f78:	441d      	add	r5, r3
 8000f7a:	f8c7 5210 	str.w	r5, [r7, #528]	; 0x210
 8000f7e:	e5ab      	b.n	8000ad8 <HAL_PCD_IRQHandler+0xd0>
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8000f80:	2208      	movs	r2, #8
 8000f82:	f504 716f 	add.w	r1, r4, #956	; 0x3bc
 8000f86:	4640      	mov	r0, r8
 8000f88:	f001 f90e 	bl	80021a8 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8000f8c:	00f2      	lsls	r2, r6, #3
 8000f8e:	1b91      	subs	r1, r2, r6
 8000f90:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8000f94:	f3c5 130a 	ubfx	r3, r5, #4, #11
 8000f98:	f8d1 2210 	ldr.w	r2, [r1, #528]	; 0x210
 8000f9c:	4413      	add	r3, r2
 8000f9e:	f8c1 3210 	str.w	r3, [r1, #528]	; 0x210
 8000fa2:	e599      	b.n	8000ad8 <HAL_PCD_IRQHandler+0xd0>
      HAL_PCD_SOFCallback(hpcd);
 8000fa4:	4620      	mov	r0, r4
 8000fa6:	f002 fce0 	bl	800396a <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8000faa:	6822      	ldr	r2, [r4, #0]
 8000fac:	6953      	ldr	r3, [r2, #20]
 8000fae:	f003 0308 	and.w	r3, r3, #8
 8000fb2:	6153      	str	r3, [r2, #20]
 8000fb4:	e59c      	b.n	8000af0 <HAL_PCD_IRQHandler+0xe8>
      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
 8000fb6:	fa5f f18a 	uxtb.w	r1, sl
 8000fba:	4620      	mov	r0, r4
 8000fbc:	f002 fd0e 	bl	80039dc <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8000fc0:	6822      	ldr	r2, [r4, #0]
 8000fc2:	6953      	ldr	r3, [r2, #20]
 8000fc4:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8000fc8:	6153      	str	r3, [r2, #20]
 8000fca:	e598      	b.n	8000afe <HAL_PCD_IRQHandler+0xf6>
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
 8000fcc:	fa5f f18a 	uxtb.w	r1, sl
 8000fd0:	4620      	mov	r0, r4
 8000fd2:	f002 fcfd 	bl	80039d0 <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8000fd6:	6822      	ldr	r2, [r4, #0]
 8000fd8:	6953      	ldr	r3, [r2, #20]
 8000fda:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8000fde:	6153      	str	r3, [r2, #20]
 8000fe0:	e594      	b.n	8000b0c <HAL_PCD_IRQHandler+0x104>
      HAL_PCD_ConnectCallback(hpcd);
 8000fe2:	4620      	mov	r0, r4
 8000fe4:	f002 fd00 	bl	80039e8 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8000fe8:	6822      	ldr	r2, [r4, #0]
 8000fea:	6953      	ldr	r3, [r2, #20]
 8000fec:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8000ff0:	6153      	str	r3, [r2, #20]
 8000ff2:	e592      	b.n	8000b1a <HAL_PCD_IRQHandler+0x112>
        HAL_PCD_DisconnectCallback(hpcd);
 8000ff4:	4620      	mov	r0, r4
 8000ff6:	f002 fcfd 	bl	80039f4 <HAL_PCD_DisconnectCallback>
 8000ffa:	e59b      	b.n	8000b34 <HAL_PCD_IRQHandler+0x12c>
 8000ffc:	ff275340 	.word	0xff275340
 8001000:	000c34ff 	.word	0x000c34ff
 8001004:	ff1b1e40 	.word	0xff1b1e40
 8001008:	000f423f 	.word	0x000f423f
 800100c:	00124f7f 	.word	0x00124f7f
 8001010:	0013d61f 	.word	0x0013d61f
 8001014:	fee5b660 	.word	0xfee5b660
 8001018:	0016e35f 	.word	0x0016e35f
 800101c:	feced300 	.word	0xfeced300
 8001020:	001b773f 	.word	0x001b773f
 8001024:	feb35bc0 	.word	0xfeb35bc0
 8001028:	002191bf 	.word	0x002191bf
 800102c:	0038751f 	.word	0x0038751f
 8001030:	fe5954e0 	.word	0xfe5954e0
 8001034:	00419cdf 	.word	0x00419cdf

08001038 <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd); 
 8001038:	f890 33b8 	ldrb.w	r3, [r0, #952]	; 0x3b8
 800103c:	2b01      	cmp	r3, #1
 800103e:	d101      	bne.n	8001044 <HAL_PCD_SetAddress+0xc>
 8001040:	2002      	movs	r0, #2
 8001042:	4770      	bx	lr
{
 8001044:	b510      	push	{r4, lr}
 8001046:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8001048:	2301      	movs	r3, #1
 800104a:	f880 33b8 	strb.w	r3, [r0, #952]	; 0x3b8
  USB_SetDevAddress(hpcd->Instance, address);
 800104e:	6800      	ldr	r0, [r0, #0]
 8001050:	f001 f914 	bl	800227c <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);   
 8001054:	2000      	movs	r0, #0
 8001056:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 800105a:	bd10      	pop	{r4, pc}

0800105c <HAL_PCD_EP_Open>:
{
 800105c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((ep_addr & 0x80) == 0x80)
 800105e:	f011 0f80 	tst.w	r1, #128	; 0x80
 8001062:	d11d      	bne.n	80010a0 <HAL_PCD_EP_Open+0x44>
 8001064:	f001 047f 	and.w	r4, r1, #127	; 0x7f
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001068:	00e5      	lsls	r5, r4, #3
 800106a:	1b29      	subs	r1, r5, r4
 800106c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8001070:	f501 71fc 	add.w	r1, r1, #504	; 0x1f8
  ep->num   = ep_addr & 0x7F;
 8001074:	1b2e      	subs	r6, r5, r4
 8001076:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 800107a:	f886 41f8 	strb.w	r4, [r6, #504]	; 0x1f8
  ep->is_in = (0x80 & ep_addr) != 0;
 800107e:	2700      	movs	r7, #0
 8001080:	f886 71f9 	strb.w	r7, [r6, #505]	; 0x1f9
  ep->maxpacket = ep_mps;
 8001084:	f8c6 2200 	str.w	r2, [r6, #512]	; 0x200
  ep->type = ep_type;
 8001088:	f886 31fb 	strb.w	r3, [r6, #507]	; 0x1fb
  if (ep_type == EP_TYPE_BULK )
 800108c:	2b02      	cmp	r3, #2
    ep->data_pid_start = 0U;
 800108e:	bf04      	itt	eq
 8001090:	2300      	moveq	r3, #0
 8001092:	710b      	strbeq	r3, [r1, #4]
  __HAL_LOCK(hpcd); 
 8001094:	f890 33b8 	ldrb.w	r3, [r0, #952]	; 0x3b8
 8001098:	2b01      	cmp	r3, #1
 800109a:	d115      	bne.n	80010c8 <HAL_PCD_EP_Open+0x6c>
 800109c:	2002      	movs	r0, #2
}
 800109e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80010a0:	f001 047f 	and.w	r4, r1, #127	; 0x7f
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 80010a4:	00e5      	lsls	r5, r4, #3
 80010a6:	1b29      	subs	r1, r5, r4
 80010a8:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 80010ac:	3138      	adds	r1, #56	; 0x38
  ep->num   = ep_addr & 0x7F;
 80010ae:	1b2e      	subs	r6, r5, r4
 80010b0:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 80010b4:	f886 4038 	strb.w	r4, [r6, #56]	; 0x38
  ep->is_in = (0x80 & ep_addr) != 0;
 80010b8:	2701      	movs	r7, #1
 80010ba:	f886 7039 	strb.w	r7, [r6, #57]	; 0x39
  ep->maxpacket = ep_mps;
 80010be:	6432      	str	r2, [r6, #64]	; 0x40
  ep->type = ep_type;
 80010c0:	f886 303b 	strb.w	r3, [r6, #59]	; 0x3b
    ep->tx_fifo_num = ep->num;
 80010c4:	87f4      	strh	r4, [r6, #62]	; 0x3e
 80010c6:	e7e1      	b.n	800108c <HAL_PCD_EP_Open+0x30>
 80010c8:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 80010ca:	2301      	movs	r3, #1
 80010cc:	f880 33b8 	strb.w	r3, [r0, #952]	; 0x3b8
  USB_ActivateEndpoint(hpcd->Instance , ep);
 80010d0:	6800      	ldr	r0, [r0, #0]
 80010d2:	f000 fe07 	bl	8001ce4 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 80010d6:	2000      	movs	r0, #0
 80010d8:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return ret;
 80010dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080010de <HAL_PCD_EP_Close>:
  if ((ep_addr & 0x80) == 0x80)
 80010de:	b24a      	sxtb	r2, r1
 80010e0:	2a00      	cmp	r2, #0
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 80010e2:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 80010e6:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80010ea:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80010ee:	bfb4      	ite	lt
 80010f0:	3338      	addlt	r3, #56	; 0x38
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 80010f2:	f503 73fc 	addge.w	r3, r3, #504	; 0x1f8
  ep->num   = ep_addr & 0x7F;
 80010f6:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 80010fa:	7019      	strb	r1, [r3, #0]
  ep->is_in = (0x80 & ep_addr) != 0;
 80010fc:	0fd2      	lsrs	r2, r2, #31
 80010fe:	705a      	strb	r2, [r3, #1]
  __HAL_LOCK(hpcd); 
 8001100:	f890 23b8 	ldrb.w	r2, [r0, #952]	; 0x3b8
 8001104:	2a01      	cmp	r2, #1
 8001106:	d101      	bne.n	800110c <HAL_PCD_EP_Close+0x2e>
 8001108:	2002      	movs	r0, #2
 800110a:	4770      	bx	lr
{  
 800110c:	b510      	push	{r4, lr}
 800110e:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8001110:	2201      	movs	r2, #1
 8001112:	f880 23b8 	strb.w	r2, [r0, #952]	; 0x3b8
  USB_DeactivateEndpoint(hpcd->Instance , ep);
 8001116:	4619      	mov	r1, r3
 8001118:	6800      	ldr	r0, [r0, #0]
 800111a:	f000 fe29 	bl	8001d70 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 800111e:	2000      	movs	r0, #0
 8001120:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 8001124:	bd10      	pop	{r4, pc}

08001126 <HAL_PCD_EP_Receive>:
{
 8001126:	b538      	push	{r3, r4, r5, lr}
 8001128:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 800112c:	00ec      	lsls	r4, r5, #3
 800112e:	1b61      	subs	r1, r4, r5
 8001130:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8001134:	f501 71fc 	add.w	r1, r1, #504	; 0x1f8
  ep->xfer_buff = pBuf;  
 8001138:	1b64      	subs	r4, r4, r5
 800113a:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 800113e:	f8c4 2204 	str.w	r2, [r4, #516]	; 0x204
  ep->xfer_len = len;
 8001142:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
  ep->xfer_count = 0U;
 8001146:	2300      	movs	r3, #0
 8001148:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
  ep->is_in = 0U;
 800114c:	f884 31f9 	strb.w	r3, [r4, #505]	; 0x1f9
  ep->num = ep_addr & 0x7F;
 8001150:	f884 51f8 	strb.w	r5, [r4, #504]	; 0x1f8
  if (hpcd->Init.dma_enable == 1U)
 8001154:	6903      	ldr	r3, [r0, #16]
 8001156:	2b01      	cmp	r3, #1
 8001158:	d006      	beq.n	8001168 <HAL_PCD_EP_Receive+0x42>
  if ((ep_addr & 0x7F) == 0)
 800115a:	b165      	cbz	r5, 8001176 <HAL_PCD_EP_Receive+0x50>
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 800115c:	b2da      	uxtb	r2, r3
 800115e:	6800      	ldr	r0, [r0, #0]
 8001160:	f000 fe6c 	bl	8001e3c <USB_EPStartXfer>
}
 8001164:	2000      	movs	r0, #0
 8001166:	bd38      	pop	{r3, r4, r5, pc}
    ep->dma_addr = (uint32_t)pBuf;  
 8001168:	ebc5 04c5 	rsb	r4, r5, r5, lsl #3
 800116c:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8001170:	f8c4 2208 	str.w	r2, [r4, #520]	; 0x208
 8001174:	e7f1      	b.n	800115a <HAL_PCD_EP_Receive+0x34>
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001176:	b2da      	uxtb	r2, r3
 8001178:	6800      	ldr	r0, [r0, #0]
 800117a:	f000 ff65 	bl	8002048 <USB_EP0StartXfer>
 800117e:	e7f1      	b.n	8001164 <HAL_PCD_EP_Receive+0x3e>

08001180 <HAL_PCD_EP_Transmit>:
{
 8001180:	b538      	push	{r3, r4, r5, lr}
 8001182:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001186:	00ec      	lsls	r4, r5, #3
 8001188:	1b61      	subs	r1, r4, r5
 800118a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 800118e:	3138      	adds	r1, #56	; 0x38
  ep->xfer_buff = pBuf;  
 8001190:	1b64      	subs	r4, r4, r5
 8001192:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8001196:	6462      	str	r2, [r4, #68]	; 0x44
  ep->xfer_len = len;
 8001198:	64e3      	str	r3, [r4, #76]	; 0x4c
  ep->xfer_count = 0U;
 800119a:	2300      	movs	r3, #0
 800119c:	6523      	str	r3, [r4, #80]	; 0x50
  ep->is_in = 1U;
 800119e:	2301      	movs	r3, #1
 80011a0:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  ep->num = ep_addr & 0x7F;
 80011a4:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
  if (hpcd->Init.dma_enable == 1U)
 80011a8:	6903      	ldr	r3, [r0, #16]
 80011aa:	2b01      	cmp	r3, #1
 80011ac:	d006      	beq.n	80011bc <HAL_PCD_EP_Transmit+0x3c>
  if ((ep_addr & 0x7F) == 0)
 80011ae:	b15d      	cbz	r5, 80011c8 <HAL_PCD_EP_Transmit+0x48>
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 80011b0:	b2da      	uxtb	r2, r3
 80011b2:	6800      	ldr	r0, [r0, #0]
 80011b4:	f000 fe42 	bl	8001e3c <USB_EPStartXfer>
}
 80011b8:	2000      	movs	r0, #0
 80011ba:	bd38      	pop	{r3, r4, r5, pc}
    ep->dma_addr = (uint32_t)pBuf;  
 80011bc:	ebc5 04c5 	rsb	r4, r5, r5, lsl #3
 80011c0:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 80011c4:	64a2      	str	r2, [r4, #72]	; 0x48
 80011c6:	e7f2      	b.n	80011ae <HAL_PCD_EP_Transmit+0x2e>
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 80011c8:	b2da      	uxtb	r2, r3
 80011ca:	6800      	ldr	r0, [r0, #0]
 80011cc:	f000 ff3c 	bl	8002048 <USB_EP0StartXfer>
 80011d0:	e7f2      	b.n	80011b8 <HAL_PCD_EP_Transmit+0x38>

080011d2 <HAL_PCD_EP_SetStall>:
{
 80011d2:	b538      	push	{r3, r4, r5, lr}
  if ((0x80 & ep_addr) == 0x80)
 80011d4:	b24a      	sxtb	r2, r1
 80011d6:	2a00      	cmp	r2, #0
 80011d8:	db12      	blt.n	8001200 <HAL_PCD_EP_SetStall+0x2e>
    ep = &hpcd->OUT_ep[ep_addr];
 80011da:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 80011de:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80011e2:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
  ep->is_stall = 1U;
 80011e6:	2401      	movs	r4, #1
 80011e8:	709c      	strb	r4, [r3, #2]
  ep->num   = ep_addr & 0x7F;
 80011ea:	f001 047f 	and.w	r4, r1, #127	; 0x7f
 80011ee:	701c      	strb	r4, [r3, #0]
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 80011f0:	0fd2      	lsrs	r2, r2, #31
 80011f2:	705a      	strb	r2, [r3, #1]
  __HAL_LOCK(hpcd); 
 80011f4:	f890 23b8 	ldrb.w	r2, [r0, #952]	; 0x3b8
 80011f8:	2a01      	cmp	r2, #1
 80011fa:	d109      	bne.n	8001210 <HAL_PCD_EP_SetStall+0x3e>
 80011fc:	2002      	movs	r0, #2
}
 80011fe:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001200:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8001204:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8001208:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800120c:	3338      	adds	r3, #56	; 0x38
 800120e:	e7ea      	b.n	80011e6 <HAL_PCD_EP_SetStall+0x14>
 8001210:	4605      	mov	r5, r0
  __HAL_LOCK(hpcd); 
 8001212:	2201      	movs	r2, #1
 8001214:	f880 23b8 	strb.w	r2, [r0, #952]	; 0x3b8
  USB_EPSetStall(hpcd->Instance , ep);
 8001218:	4619      	mov	r1, r3
 800121a:	6800      	ldr	r0, [r0, #0]
 800121c:	f000 ffd9 	bl	80021d2 <USB_EPSetStall>
  if((ep_addr & 0x7F) == 0)
 8001220:	b11c      	cbz	r4, 800122a <HAL_PCD_EP_SetStall+0x58>
  __HAL_UNLOCK(hpcd); 
 8001222:	2000      	movs	r0, #0
 8001224:	f885 03b8 	strb.w	r0, [r5, #952]	; 0x3b8
  return HAL_OK;
 8001228:	bd38      	pop	{r3, r4, r5, pc}
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 800122a:	f505 726f 	add.w	r2, r5, #956	; 0x3bc
 800122e:	7c29      	ldrb	r1, [r5, #16]
 8001230:	6828      	ldr	r0, [r5, #0]
 8001232:	f001 f89b 	bl	800236c <USB_EP0_OutStart>
 8001236:	e7f4      	b.n	8001222 <HAL_PCD_EP_SetStall+0x50>

08001238 <HAL_PCD_EP_ClrStall>:
{
 8001238:	b510      	push	{r4, lr}
  if ((0x80 & ep_addr) == 0x80)
 800123a:	b24a      	sxtb	r2, r1
 800123c:	2a00      	cmp	r2, #0
 800123e:	db12      	blt.n	8001266 <HAL_PCD_EP_ClrStall+0x2e>
    ep = &hpcd->OUT_ep[ep_addr];
 8001240:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8001244:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8001248:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
  ep->is_stall = 0U;
 800124c:	2400      	movs	r4, #0
 800124e:	709c      	strb	r4, [r3, #2]
  ep->num   = ep_addr & 0x7F;
 8001250:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8001254:	7019      	strb	r1, [r3, #0]
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8001256:	0fd2      	lsrs	r2, r2, #31
 8001258:	705a      	strb	r2, [r3, #1]
  __HAL_LOCK(hpcd); 
 800125a:	f890 23b8 	ldrb.w	r2, [r0, #952]	; 0x3b8
 800125e:	2a01      	cmp	r2, #1
 8001260:	d109      	bne.n	8001276 <HAL_PCD_EP_ClrStall+0x3e>
 8001262:	2002      	movs	r0, #2
}
 8001264:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001266:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 800126a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 800126e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8001272:	3338      	adds	r3, #56	; 0x38
 8001274:	e7ea      	b.n	800124c <HAL_PCD_EP_ClrStall+0x14>
 8001276:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8001278:	2201      	movs	r2, #1
 800127a:	f880 23b8 	strb.w	r2, [r0, #952]	; 0x3b8
  USB_EPClearStall(hpcd->Instance , ep);
 800127e:	4619      	mov	r1, r3
 8001280:	6800      	ldr	r0, [r0, #0]
 8001282:	f000 ffce 	bl	8002222 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd); 
 8001286:	2000      	movs	r0, #0
 8001288:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 800128c:	bd10      	pop	{r4, pc}

0800128e <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 800128e:	b430      	push	{r4, r5}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8001290:	6805      	ldr	r5, [r0, #0]
 8001292:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  
  if(fifo == 0)
 8001294:	b1e1      	cbz	r1, 80012d0 <HAL_PCDEx_SetTxFiFo+0x42>
 8001296:	460b      	mov	r3, r1
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
 8001298:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800129a:	eb04 4411 	add.w	r4, r4, r1, lsr #16
    for (i = 0; i < (fifo - 1); i++)
 800129e:	1e59      	subs	r1, r3, #1
 80012a0:	2900      	cmp	r1, #0
 80012a2:	dd0c      	ble.n	80012be <HAL_PCDEx_SetTxFiFo+0x30>
 80012a4:	2300      	movs	r3, #0
 80012a6:	4618      	mov	r0, r3
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16U);
 80012a8:	3340      	adds	r3, #64	; 0x40
 80012aa:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80012ae:	685b      	ldr	r3, [r3, #4]
 80012b0:	eb04 4413 	add.w	r4, r4, r3, lsr #16
    for (i = 0; i < (fifo - 1); i++)
 80012b4:	3001      	adds	r0, #1
 80012b6:	b2c0      	uxtb	r0, r0
 80012b8:	4603      	mov	r3, r0
 80012ba:	4288      	cmp	r0, r1
 80012bc:	dbf4      	blt.n	80012a8 <HAL_PCDEx_SetTxFiFo+0x1a>
    }
    
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1] = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);        
 80012be:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80012c2:	3140      	adds	r1, #64	; 0x40
 80012c4:	eb05 0581 	add.w	r5, r5, r1, lsl #2
 80012c8:	606c      	str	r4, [r5, #4]
  }
  
  return HAL_OK;
}
 80012ca:	2000      	movs	r0, #0
 80012cc:	bc30      	pop	{r4, r5}
 80012ce:	4770      	bx	lr
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
 80012d0:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80012d4:	62ac      	str	r4, [r5, #40]	; 0x28
 80012d6:	e7f8      	b.n	80012ca <HAL_PCDEx_SetTxFiFo+0x3c>

080012d8 <HAL_PCDEx_SetRxFiFo>:
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 80012d8:	6803      	ldr	r3, [r0, #0]
 80012da:	6259      	str	r1, [r3, #36]	; 0x24
  
  return HAL_OK;
}
 80012dc:	2000      	movs	r0, #0
 80012de:	4770      	bx	lr

080012e0 <HAL_RCC_OscConfig>:
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80012e0:	2800      	cmp	r0, #0
 80012e2:	f000 81bd 	beq.w	8001660 <HAL_RCC_OscConfig+0x380>
{
 80012e6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80012ea:	b082      	sub	sp, #8
 80012ec:	4604      	mov	r4, r0
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80012ee:	6803      	ldr	r3, [r0, #0]
 80012f0:	f013 0f01 	tst.w	r3, #1
 80012f4:	d03b      	beq.n	800136e <HAL_RCC_OscConfig+0x8e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 80012f6:	4ba8      	ldr	r3, [pc, #672]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 80012f8:	689b      	ldr	r3, [r3, #8]
 80012fa:	f003 030c 	and.w	r3, r3, #12
 80012fe:	2b04      	cmp	r3, #4
 8001300:	d02c      	beq.n	800135c <HAL_RCC_OscConfig+0x7c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001302:	4ba5      	ldr	r3, [pc, #660]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 8001304:	689b      	ldr	r3, [r3, #8]
 8001306:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 800130a:	2b08      	cmp	r3, #8
 800130c:	d021      	beq.n	8001352 <HAL_RCC_OscConfig+0x72>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800130e:	6863      	ldr	r3, [r4, #4]
 8001310:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001314:	d04f      	beq.n	80013b6 <HAL_RCC_OscConfig+0xd6>
 8001316:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800131a:	d052      	beq.n	80013c2 <HAL_RCC_OscConfig+0xe2>
 800131c:	4b9e      	ldr	r3, [pc, #632]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 800131e:	681a      	ldr	r2, [r3, #0]
 8001320:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001324:	601a      	str	r2, [r3, #0]
 8001326:	681a      	ldr	r2, [r3, #0]
 8001328:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800132c:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800132e:	6863      	ldr	r3, [r4, #4]
 8001330:	2b00      	cmp	r3, #0
 8001332:	d050      	beq.n	80013d6 <HAL_RCC_OscConfig+0xf6>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001334:	f7ff f986 	bl	8000644 <HAL_GetTick>
 8001338:	4606      	mov	r6, r0

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800133a:	4d97      	ldr	r5, [pc, #604]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 800133c:	682b      	ldr	r3, [r5, #0]
 800133e:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001342:	d114      	bne.n	800136e <HAL_RCC_OscConfig+0x8e>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001344:	f7ff f97e 	bl	8000644 <HAL_GetTick>
 8001348:	1b80      	subs	r0, r0, r6
 800134a:	2864      	cmp	r0, #100	; 0x64
 800134c:	d9f6      	bls.n	800133c <HAL_RCC_OscConfig+0x5c>
          {
            return HAL_TIMEOUT;
 800134e:	2003      	movs	r0, #3
 8001350:	e18b      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001352:	4b91      	ldr	r3, [pc, #580]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 8001354:	685b      	ldr	r3, [r3, #4]
 8001356:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 800135a:	d0d8      	beq.n	800130e <HAL_RCC_OscConfig+0x2e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800135c:	4b8e      	ldr	r3, [pc, #568]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 800135e:	681b      	ldr	r3, [r3, #0]
 8001360:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001364:	d003      	beq.n	800136e <HAL_RCC_OscConfig+0x8e>
 8001366:	6863      	ldr	r3, [r4, #4]
 8001368:	2b00      	cmp	r3, #0
 800136a:	f000 817b 	beq.w	8001664 <HAL_RCC_OscConfig+0x384>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800136e:	6823      	ldr	r3, [r4, #0]
 8001370:	f013 0f02 	tst.w	r3, #2
 8001374:	d055      	beq.n	8001422 <HAL_RCC_OscConfig+0x142>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8001376:	4b88      	ldr	r3, [pc, #544]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 8001378:	689b      	ldr	r3, [r3, #8]
 800137a:	f013 0f0c 	tst.w	r3, #12
 800137e:	d03e      	beq.n	80013fe <HAL_RCC_OscConfig+0x11e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001380:	4b85      	ldr	r3, [pc, #532]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 8001382:	689b      	ldr	r3, [r3, #8]
 8001384:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8001388:	2b08      	cmp	r3, #8
 800138a:	d033      	beq.n	80013f4 <HAL_RCC_OscConfig+0x114>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800138c:	68e3      	ldr	r3, [r4, #12]
 800138e:	2b00      	cmp	r3, #0
 8001390:	d068      	beq.n	8001464 <HAL_RCC_OscConfig+0x184>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001392:	2201      	movs	r2, #1
 8001394:	4b81      	ldr	r3, [pc, #516]	; (800159c <HAL_RCC_OscConfig+0x2bc>)
 8001396:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001398:	f7ff f954 	bl	8000644 <HAL_GetTick>
 800139c:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800139e:	4d7e      	ldr	r5, [pc, #504]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 80013a0:	682b      	ldr	r3, [r5, #0]
 80013a2:	f013 0f02 	tst.w	r3, #2
 80013a6:	d154      	bne.n	8001452 <HAL_RCC_OscConfig+0x172>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80013a8:	f7ff f94c 	bl	8000644 <HAL_GetTick>
 80013ac:	1b80      	subs	r0, r0, r6
 80013ae:	2802      	cmp	r0, #2
 80013b0:	d9f6      	bls.n	80013a0 <HAL_RCC_OscConfig+0xc0>
          {
            return HAL_TIMEOUT;
 80013b2:	2003      	movs	r0, #3
 80013b4:	e159      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80013b6:	4a78      	ldr	r2, [pc, #480]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 80013b8:	6813      	ldr	r3, [r2, #0]
 80013ba:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80013be:	6013      	str	r3, [r2, #0]
 80013c0:	e7b5      	b.n	800132e <HAL_RCC_OscConfig+0x4e>
 80013c2:	4b75      	ldr	r3, [pc, #468]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 80013c4:	681a      	ldr	r2, [r3, #0]
 80013c6:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80013ca:	601a      	str	r2, [r3, #0]
 80013cc:	681a      	ldr	r2, [r3, #0]
 80013ce:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80013d2:	601a      	str	r2, [r3, #0]
 80013d4:	e7ab      	b.n	800132e <HAL_RCC_OscConfig+0x4e>
        tickstart = HAL_GetTick();
 80013d6:	f7ff f935 	bl	8000644 <HAL_GetTick>
 80013da:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80013dc:	4d6e      	ldr	r5, [pc, #440]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 80013de:	682b      	ldr	r3, [r5, #0]
 80013e0:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80013e4:	d0c3      	beq.n	800136e <HAL_RCC_OscConfig+0x8e>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80013e6:	f7ff f92d 	bl	8000644 <HAL_GetTick>
 80013ea:	1b80      	subs	r0, r0, r6
 80013ec:	2864      	cmp	r0, #100	; 0x64
 80013ee:	d9f6      	bls.n	80013de <HAL_RCC_OscConfig+0xfe>
            return HAL_TIMEOUT;
 80013f0:	2003      	movs	r0, #3
 80013f2:	e13a      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80013f4:	4b68      	ldr	r3, [pc, #416]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 80013f6:	685b      	ldr	r3, [r3, #4]
 80013f8:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80013fc:	d1c6      	bne.n	800138c <HAL_RCC_OscConfig+0xac>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80013fe:	4b66      	ldr	r3, [pc, #408]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 8001400:	681b      	ldr	r3, [r3, #0]
 8001402:	f013 0f02 	tst.w	r3, #2
 8001406:	d004      	beq.n	8001412 <HAL_RCC_OscConfig+0x132>
 8001408:	68e3      	ldr	r3, [r4, #12]
 800140a:	2b01      	cmp	r3, #1
 800140c:	d001      	beq.n	8001412 <HAL_RCC_OscConfig+0x132>
        return HAL_ERROR;
 800140e:	2001      	movs	r0, #1
 8001410:	e12b      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001412:	4a61      	ldr	r2, [pc, #388]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 8001414:	6813      	ldr	r3, [r2, #0]
 8001416:	6921      	ldr	r1, [r4, #16]
 8001418:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800141c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001420:	6013      	str	r3, [r2, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001422:	6823      	ldr	r3, [r4, #0]
 8001424:	f013 0f08 	tst.w	r3, #8
 8001428:	d040      	beq.n	80014ac <HAL_RCC_OscConfig+0x1cc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800142a:	6963      	ldr	r3, [r4, #20]
 800142c:	b363      	cbz	r3, 8001488 <HAL_RCC_OscConfig+0x1a8>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800142e:	2201      	movs	r2, #1
 8001430:	4b5b      	ldr	r3, [pc, #364]	; (80015a0 <HAL_RCC_OscConfig+0x2c0>)
 8001432:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001434:	f7ff f906 	bl	8000644 <HAL_GetTick>
 8001438:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800143a:	4d57      	ldr	r5, [pc, #348]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 800143c:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800143e:	f013 0f02 	tst.w	r3, #2
 8001442:	d133      	bne.n	80014ac <HAL_RCC_OscConfig+0x1cc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001444:	f7ff f8fe 	bl	8000644 <HAL_GetTick>
 8001448:	1b80      	subs	r0, r0, r6
 800144a:	2802      	cmp	r0, #2
 800144c:	d9f6      	bls.n	800143c <HAL_RCC_OscConfig+0x15c>
        {
          return HAL_TIMEOUT;
 800144e:	2003      	movs	r0, #3
 8001450:	e10b      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001452:	4a51      	ldr	r2, [pc, #324]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 8001454:	6813      	ldr	r3, [r2, #0]
 8001456:	6921      	ldr	r1, [r4, #16]
 8001458:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800145c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001460:	6013      	str	r3, [r2, #0]
 8001462:	e7de      	b.n	8001422 <HAL_RCC_OscConfig+0x142>
        __HAL_RCC_HSI_DISABLE();
 8001464:	2200      	movs	r2, #0
 8001466:	4b4d      	ldr	r3, [pc, #308]	; (800159c <HAL_RCC_OscConfig+0x2bc>)
 8001468:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800146a:	f7ff f8eb 	bl	8000644 <HAL_GetTick>
 800146e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001470:	4d49      	ldr	r5, [pc, #292]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 8001472:	682b      	ldr	r3, [r5, #0]
 8001474:	f013 0f02 	tst.w	r3, #2
 8001478:	d0d3      	beq.n	8001422 <HAL_RCC_OscConfig+0x142>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800147a:	f7ff f8e3 	bl	8000644 <HAL_GetTick>
 800147e:	1b80      	subs	r0, r0, r6
 8001480:	2802      	cmp	r0, #2
 8001482:	d9f6      	bls.n	8001472 <HAL_RCC_OscConfig+0x192>
            return HAL_TIMEOUT;
 8001484:	2003      	movs	r0, #3
 8001486:	e0f0      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001488:	2200      	movs	r2, #0
 800148a:	4b45      	ldr	r3, [pc, #276]	; (80015a0 <HAL_RCC_OscConfig+0x2c0>)
 800148c:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800148e:	f7ff f8d9 	bl	8000644 <HAL_GetTick>
 8001492:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001494:	4d40      	ldr	r5, [pc, #256]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 8001496:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001498:	f013 0f02 	tst.w	r3, #2
 800149c:	d006      	beq.n	80014ac <HAL_RCC_OscConfig+0x1cc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800149e:	f7ff f8d1 	bl	8000644 <HAL_GetTick>
 80014a2:	1b80      	subs	r0, r0, r6
 80014a4:	2802      	cmp	r0, #2
 80014a6:	d9f6      	bls.n	8001496 <HAL_RCC_OscConfig+0x1b6>
        {
          return HAL_TIMEOUT;
 80014a8:	2003      	movs	r0, #3
 80014aa:	e0de      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80014ac:	6823      	ldr	r3, [r4, #0]
 80014ae:	f013 0f04 	tst.w	r3, #4
 80014b2:	d07a      	beq.n	80015aa <HAL_RCC_OscConfig+0x2ca>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80014b4:	4b38      	ldr	r3, [pc, #224]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 80014b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80014b8:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 80014bc:	d134      	bne.n	8001528 <HAL_RCC_OscConfig+0x248>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80014be:	2300      	movs	r3, #0
 80014c0:	9301      	str	r3, [sp, #4]
 80014c2:	4b35      	ldr	r3, [pc, #212]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 80014c4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80014c6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80014ca:	641a      	str	r2, [r3, #64]	; 0x40
 80014cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80014ce:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80014d2:	9301      	str	r3, [sp, #4]
 80014d4:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80014d6:	2501      	movs	r5, #1
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80014d8:	4b32      	ldr	r3, [pc, #200]	; (80015a4 <HAL_RCC_OscConfig+0x2c4>)
 80014da:	681b      	ldr	r3, [r3, #0]
 80014dc:	f413 7f80 	tst.w	r3, #256	; 0x100
 80014e0:	d024      	beq.n	800152c <HAL_RCC_OscConfig+0x24c>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80014e2:	68a3      	ldr	r3, [r4, #8]
 80014e4:	2b01      	cmp	r3, #1
 80014e6:	d035      	beq.n	8001554 <HAL_RCC_OscConfig+0x274>
 80014e8:	2b05      	cmp	r3, #5
 80014ea:	d039      	beq.n	8001560 <HAL_RCC_OscConfig+0x280>
 80014ec:	4b2a      	ldr	r3, [pc, #168]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 80014ee:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80014f0:	f022 0201 	bic.w	r2, r2, #1
 80014f4:	671a      	str	r2, [r3, #112]	; 0x70
 80014f6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80014f8:	f022 0204 	bic.w	r2, r2, #4
 80014fc:	671a      	str	r2, [r3, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80014fe:	68a3      	ldr	r3, [r4, #8]
 8001500:	2b00      	cmp	r3, #0
 8001502:	d037      	beq.n	8001574 <HAL_RCC_OscConfig+0x294>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001504:	f7ff f89e 	bl	8000644 <HAL_GetTick>
 8001508:	4680      	mov	r8, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800150a:	4e23      	ldr	r6, [pc, #140]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800150c:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001510:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8001512:	f013 0f02 	tst.w	r3, #2
 8001516:	d147      	bne.n	80015a8 <HAL_RCC_OscConfig+0x2c8>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001518:	f7ff f894 	bl	8000644 <HAL_GetTick>
 800151c:	eba0 0008 	sub.w	r0, r0, r8
 8001520:	42b8      	cmp	r0, r7
 8001522:	d9f5      	bls.n	8001510 <HAL_RCC_OscConfig+0x230>
        {
          return HAL_TIMEOUT;
 8001524:	2003      	movs	r0, #3
 8001526:	e0a0      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
    FlagStatus       pwrclkchanged = RESET;
 8001528:	2500      	movs	r5, #0
 800152a:	e7d5      	b.n	80014d8 <HAL_RCC_OscConfig+0x1f8>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800152c:	4a1d      	ldr	r2, [pc, #116]	; (80015a4 <HAL_RCC_OscConfig+0x2c4>)
 800152e:	6813      	ldr	r3, [r2, #0]
 8001530:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001534:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 8001536:	f7ff f885 	bl	8000644 <HAL_GetTick>
 800153a:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800153c:	4e19      	ldr	r6, [pc, #100]	; (80015a4 <HAL_RCC_OscConfig+0x2c4>)
 800153e:	6833      	ldr	r3, [r6, #0]
 8001540:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001544:	d1cd      	bne.n	80014e2 <HAL_RCC_OscConfig+0x202>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001546:	f7ff f87d 	bl	8000644 <HAL_GetTick>
 800154a:	1bc0      	subs	r0, r0, r7
 800154c:	2802      	cmp	r0, #2
 800154e:	d9f6      	bls.n	800153e <HAL_RCC_OscConfig+0x25e>
          return HAL_TIMEOUT;
 8001550:	2003      	movs	r0, #3
 8001552:	e08a      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001554:	4a10      	ldr	r2, [pc, #64]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 8001556:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8001558:	f043 0301 	orr.w	r3, r3, #1
 800155c:	6713      	str	r3, [r2, #112]	; 0x70
 800155e:	e7ce      	b.n	80014fe <HAL_RCC_OscConfig+0x21e>
 8001560:	4b0d      	ldr	r3, [pc, #52]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
 8001562:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001564:	f042 0204 	orr.w	r2, r2, #4
 8001568:	671a      	str	r2, [r3, #112]	; 0x70
 800156a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800156c:	f042 0201 	orr.w	r2, r2, #1
 8001570:	671a      	str	r2, [r3, #112]	; 0x70
 8001572:	e7c4      	b.n	80014fe <HAL_RCC_OscConfig+0x21e>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8001574:	f7ff f866 	bl	8000644 <HAL_GetTick>
 8001578:	4680      	mov	r8, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800157a:	4e07      	ldr	r6, [pc, #28]	; (8001598 <HAL_RCC_OscConfig+0x2b8>)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800157c:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001580:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8001582:	f013 0f02 	tst.w	r3, #2
 8001586:	d00f      	beq.n	80015a8 <HAL_RCC_OscConfig+0x2c8>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001588:	f7ff f85c 	bl	8000644 <HAL_GetTick>
 800158c:	eba0 0008 	sub.w	r0, r0, r8
 8001590:	42b8      	cmp	r0, r7
 8001592:	d9f5      	bls.n	8001580 <HAL_RCC_OscConfig+0x2a0>
        {
          return HAL_TIMEOUT;
 8001594:	2003      	movs	r0, #3
 8001596:	e068      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
 8001598:	40023800 	.word	0x40023800
 800159c:	42470000 	.word	0x42470000
 80015a0:	42470e80 	.word	0x42470e80
 80015a4:	40007000 	.word	0x40007000
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 80015a8:	b9e5      	cbnz	r5, 80015e4 <HAL_RCC_OscConfig+0x304>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80015aa:	69a3      	ldr	r3, [r4, #24]
 80015ac:	2b00      	cmp	r3, #0
 80015ae:	d05b      	beq.n	8001668 <HAL_RCC_OscConfig+0x388>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80015b0:	4a30      	ldr	r2, [pc, #192]	; (8001674 <HAL_RCC_OscConfig+0x394>)
 80015b2:	6892      	ldr	r2, [r2, #8]
 80015b4:	f002 020c 	and.w	r2, r2, #12
 80015b8:	2a08      	cmp	r2, #8
 80015ba:	d059      	beq.n	8001670 <HAL_RCC_OscConfig+0x390>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80015bc:	2b02      	cmp	r3, #2
 80015be:	d017      	beq.n	80015f0 <HAL_RCC_OscConfig+0x310>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80015c0:	2200      	movs	r2, #0
 80015c2:	4b2d      	ldr	r3, [pc, #180]	; (8001678 <HAL_RCC_OscConfig+0x398>)
 80015c4:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80015c6:	f7ff f83d 	bl	8000644 <HAL_GetTick>
 80015ca:	4605      	mov	r5, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80015cc:	4c29      	ldr	r4, [pc, #164]	; (8001674 <HAL_RCC_OscConfig+0x394>)
 80015ce:	6823      	ldr	r3, [r4, #0]
 80015d0:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80015d4:	d042      	beq.n	800165c <HAL_RCC_OscConfig+0x37c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80015d6:	f7ff f835 	bl	8000644 <HAL_GetTick>
 80015da:	1b40      	subs	r0, r0, r5
 80015dc:	2802      	cmp	r0, #2
 80015de:	d9f6      	bls.n	80015ce <HAL_RCC_OscConfig+0x2ee>
          {
            return HAL_TIMEOUT;
 80015e0:	2003      	movs	r0, #3
 80015e2:	e042      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
      __HAL_RCC_PWR_CLK_DISABLE();
 80015e4:	4a23      	ldr	r2, [pc, #140]	; (8001674 <HAL_RCC_OscConfig+0x394>)
 80015e6:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80015e8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80015ec:	6413      	str	r3, [r2, #64]	; 0x40
 80015ee:	e7dc      	b.n	80015aa <HAL_RCC_OscConfig+0x2ca>
        __HAL_RCC_PLL_DISABLE();
 80015f0:	2200      	movs	r2, #0
 80015f2:	4b21      	ldr	r3, [pc, #132]	; (8001678 <HAL_RCC_OscConfig+0x398>)
 80015f4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80015f6:	f7ff f825 	bl	8000644 <HAL_GetTick>
 80015fa:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80015fc:	4d1d      	ldr	r5, [pc, #116]	; (8001674 <HAL_RCC_OscConfig+0x394>)
 80015fe:	682b      	ldr	r3, [r5, #0]
 8001600:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001604:	d006      	beq.n	8001614 <HAL_RCC_OscConfig+0x334>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001606:	f7ff f81d 	bl	8000644 <HAL_GetTick>
 800160a:	1b80      	subs	r0, r0, r6
 800160c:	2802      	cmp	r0, #2
 800160e:	d9f6      	bls.n	80015fe <HAL_RCC_OscConfig+0x31e>
            return HAL_TIMEOUT;
 8001610:	2003      	movs	r0, #3
 8001612:	e02a      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8001614:	69e3      	ldr	r3, [r4, #28]
 8001616:	6a22      	ldr	r2, [r4, #32]
 8001618:	4313      	orrs	r3, r2
 800161a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800161c:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8001620:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001622:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001626:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001628:	0852      	lsrs	r2, r2, #1
 800162a:	3a01      	subs	r2, #1
 800162c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001630:	4a10      	ldr	r2, [pc, #64]	; (8001674 <HAL_RCC_OscConfig+0x394>)
 8001632:	6053      	str	r3, [r2, #4]
        __HAL_RCC_PLL_ENABLE();
 8001634:	2201      	movs	r2, #1
 8001636:	4b10      	ldr	r3, [pc, #64]	; (8001678 <HAL_RCC_OscConfig+0x398>)
 8001638:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800163a:	f7ff f803 	bl	8000644 <HAL_GetTick>
 800163e:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001640:	4c0c      	ldr	r4, [pc, #48]	; (8001674 <HAL_RCC_OscConfig+0x394>)
 8001642:	6823      	ldr	r3, [r4, #0]
 8001644:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001648:	d106      	bne.n	8001658 <HAL_RCC_OscConfig+0x378>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800164a:	f7fe fffb 	bl	8000644 <HAL_GetTick>
 800164e:	1b40      	subs	r0, r0, r5
 8001650:	2802      	cmp	r0, #2
 8001652:	d9f6      	bls.n	8001642 <HAL_RCC_OscConfig+0x362>
            return HAL_TIMEOUT;
 8001654:	2003      	movs	r0, #3
 8001656:	e008      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8001658:	2000      	movs	r0, #0
 800165a:	e006      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
 800165c:	2000      	movs	r0, #0
 800165e:	e004      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
    return HAL_ERROR;
 8001660:	2001      	movs	r0, #1
 8001662:	4770      	bx	lr
        return HAL_ERROR;
 8001664:	2001      	movs	r0, #1
 8001666:	e000      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
  return HAL_OK;
 8001668:	2000      	movs	r0, #0
}
 800166a:	b002      	add	sp, #8
 800166c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return HAL_ERROR;
 8001670:	2001      	movs	r0, #1
 8001672:	e7fa      	b.n	800166a <HAL_RCC_OscConfig+0x38a>
 8001674:	40023800 	.word	0x40023800
 8001678:	42470060 	.word	0x42470060

0800167c <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800167c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800167e:	4b31      	ldr	r3, [pc, #196]	; (8001744 <HAL_RCC_GetSysClockFreq+0xc8>)
 8001680:	689b      	ldr	r3, [r3, #8]
 8001682:	f003 030c 	and.w	r3, r3, #12
 8001686:	2b04      	cmp	r3, #4
 8001688:	d003      	beq.n	8001692 <HAL_RCC_GetSysClockFreq+0x16>
 800168a:	2b08      	cmp	r3, #8
 800168c:	d003      	beq.n	8001696 <HAL_RCC_GetSysClockFreq+0x1a>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 800168e:	482e      	ldr	r0, [pc, #184]	; (8001748 <HAL_RCC_GetSysClockFreq+0xcc>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8001690:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      sysclockfreq = HSE_VALUE;
 8001692:	482e      	ldr	r0, [pc, #184]	; (800174c <HAL_RCC_GetSysClockFreq+0xd0>)
 8001694:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001696:	4b2b      	ldr	r3, [pc, #172]	; (8001744 <HAL_RCC_GetSysClockFreq+0xc8>)
 8001698:	685a      	ldr	r2, [r3, #4]
 800169a:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800169e:	685b      	ldr	r3, [r3, #4]
 80016a0:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80016a4:	d02a      	beq.n	80016fc <HAL_RCC_GetSysClockFreq+0x80>
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80016a6:	4b27      	ldr	r3, [pc, #156]	; (8001744 <HAL_RCC_GetSysClockFreq+0xc8>)
 80016a8:	685b      	ldr	r3, [r3, #4]
 80016aa:	f3c3 1388 	ubfx	r3, r3, #6, #9
 80016ae:	461e      	mov	r6, r3
 80016b0:	2700      	movs	r7, #0
 80016b2:	015c      	lsls	r4, r3, #5
 80016b4:	2500      	movs	r5, #0
 80016b6:	1ae4      	subs	r4, r4, r3
 80016b8:	eb65 0507 	sbc.w	r5, r5, r7
 80016bc:	01a9      	lsls	r1, r5, #6
 80016be:	ea41 6194 	orr.w	r1, r1, r4, lsr #26
 80016c2:	01a0      	lsls	r0, r4, #6
 80016c4:	1b00      	subs	r0, r0, r4
 80016c6:	eb61 0105 	sbc.w	r1, r1, r5
 80016ca:	00cb      	lsls	r3, r1, #3
 80016cc:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 80016d0:	00c4      	lsls	r4, r0, #3
 80016d2:	19a0      	adds	r0, r4, r6
 80016d4:	eb43 0107 	adc.w	r1, r3, r7
 80016d8:	024b      	lsls	r3, r1, #9
 80016da:	ea43 53d0 	orr.w	r3, r3, r0, lsr #23
 80016de:	0244      	lsls	r4, r0, #9
 80016e0:	4620      	mov	r0, r4
 80016e2:	4619      	mov	r1, r3
 80016e4:	2300      	movs	r3, #0
 80016e6:	f7fe fdd9 	bl	800029c <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 80016ea:	4b16      	ldr	r3, [pc, #88]	; (8001744 <HAL_RCC_GetSysClockFreq+0xc8>)
 80016ec:	685b      	ldr	r3, [r3, #4]
 80016ee:	f3c3 4301 	ubfx	r3, r3, #16, #2
 80016f2:	3301      	adds	r3, #1
 80016f4:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 80016f6:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
 80016fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80016fc:	4b11      	ldr	r3, [pc, #68]	; (8001744 <HAL_RCC_GetSysClockFreq+0xc8>)
 80016fe:	685b      	ldr	r3, [r3, #4]
 8001700:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8001704:	461e      	mov	r6, r3
 8001706:	2700      	movs	r7, #0
 8001708:	015c      	lsls	r4, r3, #5
 800170a:	2500      	movs	r5, #0
 800170c:	1ae4      	subs	r4, r4, r3
 800170e:	eb65 0507 	sbc.w	r5, r5, r7
 8001712:	01a9      	lsls	r1, r5, #6
 8001714:	ea41 6194 	orr.w	r1, r1, r4, lsr #26
 8001718:	01a0      	lsls	r0, r4, #6
 800171a:	1b00      	subs	r0, r0, r4
 800171c:	eb61 0105 	sbc.w	r1, r1, r5
 8001720:	00cb      	lsls	r3, r1, #3
 8001722:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8001726:	00c4      	lsls	r4, r0, #3
 8001728:	19a0      	adds	r0, r4, r6
 800172a:	eb43 0107 	adc.w	r1, r3, r7
 800172e:	028b      	lsls	r3, r1, #10
 8001730:	ea43 5390 	orr.w	r3, r3, r0, lsr #22
 8001734:	0284      	lsls	r4, r0, #10
 8001736:	4620      	mov	r0, r4
 8001738:	4619      	mov	r1, r3
 800173a:	2300      	movs	r3, #0
 800173c:	f7fe fdae 	bl	800029c <__aeabi_uldivmod>
 8001740:	e7d3      	b.n	80016ea <HAL_RCC_GetSysClockFreq+0x6e>
 8001742:	bf00      	nop
 8001744:	40023800 	.word	0x40023800
 8001748:	00f42400 	.word	0x00f42400
 800174c:	007a1200 	.word	0x007a1200

08001750 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 8001750:	2800      	cmp	r0, #0
 8001752:	f000 80a5 	beq.w	80018a0 <HAL_RCC_ClockConfig+0x150>
{
 8001756:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800175a:	4604      	mov	r4, r0
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800175c:	4b53      	ldr	r3, [pc, #332]	; (80018ac <HAL_RCC_ClockConfig+0x15c>)
 800175e:	681b      	ldr	r3, [r3, #0]
 8001760:	f003 030f 	and.w	r3, r3, #15
 8001764:	428b      	cmp	r3, r1
 8001766:	d20a      	bcs.n	800177e <HAL_RCC_ClockConfig+0x2e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001768:	b2cb      	uxtb	r3, r1
 800176a:	4a50      	ldr	r2, [pc, #320]	; (80018ac <HAL_RCC_ClockConfig+0x15c>)
 800176c:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800176e:	6813      	ldr	r3, [r2, #0]
 8001770:	f003 030f 	and.w	r3, r3, #15
 8001774:	4299      	cmp	r1, r3
 8001776:	d002      	beq.n	800177e <HAL_RCC_ClockConfig+0x2e>
      return HAL_ERROR;
 8001778:	2001      	movs	r0, #1
 800177a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800177e:	6823      	ldr	r3, [r4, #0]
 8001780:	f013 0f02 	tst.w	r3, #2
 8001784:	d017      	beq.n	80017b6 <HAL_RCC_ClockConfig+0x66>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001786:	f013 0f04 	tst.w	r3, #4
 800178a:	d004      	beq.n	8001796 <HAL_RCC_ClockConfig+0x46>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800178c:	4a48      	ldr	r2, [pc, #288]	; (80018b0 <HAL_RCC_ClockConfig+0x160>)
 800178e:	6893      	ldr	r3, [r2, #8]
 8001790:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 8001794:	6093      	str	r3, [r2, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001796:	6823      	ldr	r3, [r4, #0]
 8001798:	f013 0f08 	tst.w	r3, #8
 800179c:	d004      	beq.n	80017a8 <HAL_RCC_ClockConfig+0x58>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800179e:	4a44      	ldr	r2, [pc, #272]	; (80018b0 <HAL_RCC_ClockConfig+0x160>)
 80017a0:	6893      	ldr	r3, [r2, #8]
 80017a2:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 80017a6:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80017a8:	4a41      	ldr	r2, [pc, #260]	; (80018b0 <HAL_RCC_ClockConfig+0x160>)
 80017aa:	6893      	ldr	r3, [r2, #8]
 80017ac:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80017b0:	68a0      	ldr	r0, [r4, #8]
 80017b2:	4303      	orrs	r3, r0
 80017b4:	6093      	str	r3, [r2, #8]
 80017b6:	460d      	mov	r5, r1
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80017b8:	6823      	ldr	r3, [r4, #0]
 80017ba:	f013 0f01 	tst.w	r3, #1
 80017be:	d036      	beq.n	800182e <HAL_RCC_ClockConfig+0xde>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80017c0:	6862      	ldr	r2, [r4, #4]
 80017c2:	2a01      	cmp	r2, #1
 80017c4:	d023      	beq.n	800180e <HAL_RCC_ClockConfig+0xbe>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80017c6:	1e93      	subs	r3, r2, #2
 80017c8:	2b01      	cmp	r3, #1
 80017ca:	d928      	bls.n	800181e <HAL_RCC_ClockConfig+0xce>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80017cc:	4b38      	ldr	r3, [pc, #224]	; (80018b0 <HAL_RCC_ClockConfig+0x160>)
 80017ce:	681b      	ldr	r3, [r3, #0]
 80017d0:	f013 0f02 	tst.w	r3, #2
 80017d4:	d066      	beq.n	80018a4 <HAL_RCC_ClockConfig+0x154>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80017d6:	4936      	ldr	r1, [pc, #216]	; (80018b0 <HAL_RCC_ClockConfig+0x160>)
 80017d8:	688b      	ldr	r3, [r1, #8]
 80017da:	f023 0303 	bic.w	r3, r3, #3
 80017de:	4313      	orrs	r3, r2
 80017e0:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 80017e2:	f7fe ff2f 	bl	8000644 <HAL_GetTick>
 80017e6:	4680      	mov	r8, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80017e8:	4e31      	ldr	r6, [pc, #196]	; (80018b0 <HAL_RCC_ClockConfig+0x160>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80017ea:	f241 3788 	movw	r7, #5000	; 0x1388
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80017ee:	68b3      	ldr	r3, [r6, #8]
 80017f0:	f003 030c 	and.w	r3, r3, #12
 80017f4:	6862      	ldr	r2, [r4, #4]
 80017f6:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80017fa:	d018      	beq.n	800182e <HAL_RCC_ClockConfig+0xde>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80017fc:	f7fe ff22 	bl	8000644 <HAL_GetTick>
 8001800:	eba0 0008 	sub.w	r0, r0, r8
 8001804:	42b8      	cmp	r0, r7
 8001806:	d9f2      	bls.n	80017ee <HAL_RCC_ClockConfig+0x9e>
        return HAL_TIMEOUT;
 8001808:	2003      	movs	r0, #3
 800180a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800180e:	4b28      	ldr	r3, [pc, #160]	; (80018b0 <HAL_RCC_ClockConfig+0x160>)
 8001810:	681b      	ldr	r3, [r3, #0]
 8001812:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001816:	d1de      	bne.n	80017d6 <HAL_RCC_ClockConfig+0x86>
        return HAL_ERROR;
 8001818:	2001      	movs	r0, #1
 800181a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800181e:	4b24      	ldr	r3, [pc, #144]	; (80018b0 <HAL_RCC_ClockConfig+0x160>)
 8001820:	681b      	ldr	r3, [r3, #0]
 8001822:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001826:	d1d6      	bne.n	80017d6 <HAL_RCC_ClockConfig+0x86>
        return HAL_ERROR;
 8001828:	2001      	movs	r0, #1
 800182a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800182e:	4b1f      	ldr	r3, [pc, #124]	; (80018ac <HAL_RCC_ClockConfig+0x15c>)
 8001830:	681b      	ldr	r3, [r3, #0]
 8001832:	f003 030f 	and.w	r3, r3, #15
 8001836:	429d      	cmp	r5, r3
 8001838:	d20a      	bcs.n	8001850 <HAL_RCC_ClockConfig+0x100>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800183a:	b2ea      	uxtb	r2, r5
 800183c:	4b1b      	ldr	r3, [pc, #108]	; (80018ac <HAL_RCC_ClockConfig+0x15c>)
 800183e:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8001840:	681b      	ldr	r3, [r3, #0]
 8001842:	f003 030f 	and.w	r3, r3, #15
 8001846:	429d      	cmp	r5, r3
 8001848:	d002      	beq.n	8001850 <HAL_RCC_ClockConfig+0x100>
      return HAL_ERROR;
 800184a:	2001      	movs	r0, #1
}
 800184c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001850:	6823      	ldr	r3, [r4, #0]
 8001852:	f013 0f04 	tst.w	r3, #4
 8001856:	d006      	beq.n	8001866 <HAL_RCC_ClockConfig+0x116>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001858:	4a15      	ldr	r2, [pc, #84]	; (80018b0 <HAL_RCC_ClockConfig+0x160>)
 800185a:	6893      	ldr	r3, [r2, #8]
 800185c:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8001860:	68e1      	ldr	r1, [r4, #12]
 8001862:	430b      	orrs	r3, r1
 8001864:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001866:	6823      	ldr	r3, [r4, #0]
 8001868:	f013 0f08 	tst.w	r3, #8
 800186c:	d007      	beq.n	800187e <HAL_RCC_ClockConfig+0x12e>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800186e:	4a10      	ldr	r2, [pc, #64]	; (80018b0 <HAL_RCC_ClockConfig+0x160>)
 8001870:	6893      	ldr	r3, [r2, #8]
 8001872:	6921      	ldr	r1, [r4, #16]
 8001874:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001878:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800187c:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800187e:	f7ff fefd 	bl	800167c <HAL_RCC_GetSysClockFreq>
 8001882:	4b0b      	ldr	r3, [pc, #44]	; (80018b0 <HAL_RCC_ClockConfig+0x160>)
 8001884:	689b      	ldr	r3, [r3, #8]
 8001886:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800188a:	4a0a      	ldr	r2, [pc, #40]	; (80018b4 <HAL_RCC_ClockConfig+0x164>)
 800188c:	5cd3      	ldrb	r3, [r2, r3]
 800188e:	40d8      	lsrs	r0, r3
 8001890:	4b09      	ldr	r3, [pc, #36]	; (80018b8 <HAL_RCC_ClockConfig+0x168>)
 8001892:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 8001894:	2000      	movs	r0, #0
 8001896:	f7fe fe89 	bl	80005ac <HAL_InitTick>
  return HAL_OK;
 800189a:	2000      	movs	r0, #0
 800189c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return HAL_ERROR;
 80018a0:	2001      	movs	r0, #1
 80018a2:	4770      	bx	lr
        return HAL_ERROR;
 80018a4:	2001      	movs	r0, #1
 80018a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80018aa:	bf00      	nop
 80018ac:	40023c00 	.word	0x40023c00
 80018b0:	40023800 	.word	0x40023800
 80018b4:	08008f7c 	.word	0x08008f7c
 80018b8:	2000010c 	.word	0x2000010c

080018bc <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 80018bc:	4b01      	ldr	r3, [pc, #4]	; (80018c4 <HAL_RCC_GetHCLKFreq+0x8>)
 80018be:	6818      	ldr	r0, [r3, #0]
 80018c0:	4770      	bx	lr
 80018c2:	bf00      	nop
 80018c4:	2000010c 	.word	0x2000010c

080018c8 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80018c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80018ca:	b083      	sub	sp, #12
 80018cc:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 80018ce:	6803      	ldr	r3, [r0, #0]
 80018d0:	f013 0f05 	tst.w	r3, #5
 80018d4:	d10e      	bne.n	80018f4 <HAL_RCCEx_PeriphCLKConfig+0x2c>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 80018d6:	6823      	ldr	r3, [r4, #0]
 80018d8:	f013 0f02 	tst.w	r3, #2
 80018dc:	d138      	bne.n	8001950 <HAL_RCCEx_PeriphCLKConfig+0x88>
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }
#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 80018de:	6823      	ldr	r3, [r4, #0]
 80018e0:	f013 0f08 	tst.w	r3, #8
 80018e4:	f000 809b 	beq.w	8001a1e <HAL_RCCEx_PeriphCLKConfig+0x156>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 80018e8:	7d22      	ldrb	r2, [r4, #20]
 80018ea:	4b4e      	ldr	r3, [pc, #312]	; (8001a24 <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 80018ec:	601a      	str	r2, [r3, #0]
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 80018ee:	2000      	movs	r0, #0
}
 80018f0:	b003      	add	sp, #12
 80018f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_PLLI2S_DISABLE();
 80018f4:	2200      	movs	r2, #0
 80018f6:	4b4c      	ldr	r3, [pc, #304]	; (8001a28 <HAL_RCCEx_PeriphCLKConfig+0x160>)
 80018f8:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80018fa:	f7fe fea3 	bl	8000644 <HAL_GetTick>
 80018fe:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8001900:	4d4a      	ldr	r5, [pc, #296]	; (8001a2c <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001902:	682b      	ldr	r3, [r5, #0]
 8001904:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8001908:	d006      	beq.n	8001918 <HAL_RCCEx_PeriphCLKConfig+0x50>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 800190a:	f7fe fe9b 	bl	8000644 <HAL_GetTick>
 800190e:	1b80      	subs	r0, r0, r6
 8001910:	2802      	cmp	r0, #2
 8001912:	d9f6      	bls.n	8001902 <HAL_RCCEx_PeriphCLKConfig+0x3a>
        return HAL_TIMEOUT;
 8001914:	2003      	movs	r0, #3
 8001916:	e7eb      	b.n	80018f0 <HAL_RCCEx_PeriphCLKConfig+0x28>
    __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
 8001918:	68a2      	ldr	r2, [r4, #8]
 800191a:	68e3      	ldr	r3, [r4, #12]
 800191c:	071b      	lsls	r3, r3, #28
 800191e:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8001922:	6862      	ldr	r2, [r4, #4]
 8001924:	4313      	orrs	r3, r2
 8001926:	4a41      	ldr	r2, [pc, #260]	; (8001a2c <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001928:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 800192c:	2201      	movs	r2, #1
 800192e:	4b3e      	ldr	r3, [pc, #248]	; (8001a28 <HAL_RCCEx_PeriphCLKConfig+0x160>)
 8001930:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8001932:	f7fe fe87 	bl	8000644 <HAL_GetTick>
 8001936:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8001938:	4d3c      	ldr	r5, [pc, #240]	; (8001a2c <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800193a:	682b      	ldr	r3, [r5, #0]
 800193c:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8001940:	d1c9      	bne.n	80018d6 <HAL_RCCEx_PeriphCLKConfig+0xe>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8001942:	f7fe fe7f 	bl	8000644 <HAL_GetTick>
 8001946:	1b80      	subs	r0, r0, r6
 8001948:	2802      	cmp	r0, #2
 800194a:	d9f6      	bls.n	800193a <HAL_RCCEx_PeriphCLKConfig+0x72>
        return HAL_TIMEOUT;
 800194c:	2003      	movs	r0, #3
 800194e:	e7cf      	b.n	80018f0 <HAL_RCCEx_PeriphCLKConfig+0x28>
    __HAL_RCC_PWR_CLK_ENABLE();
 8001950:	2300      	movs	r3, #0
 8001952:	9301      	str	r3, [sp, #4]
 8001954:	4b35      	ldr	r3, [pc, #212]	; (8001a2c <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001956:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001958:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800195c:	641a      	str	r2, [r3, #64]	; 0x40
 800195e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001960:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001964:	9301      	str	r3, [sp, #4]
 8001966:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 8001968:	4a31      	ldr	r2, [pc, #196]	; (8001a30 <HAL_RCCEx_PeriphCLKConfig+0x168>)
 800196a:	6813      	ldr	r3, [r2, #0]
 800196c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001970:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8001972:	f7fe fe67 	bl	8000644 <HAL_GetTick>
 8001976:	4606      	mov	r6, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8001978:	4d2d      	ldr	r5, [pc, #180]	; (8001a30 <HAL_RCCEx_PeriphCLKConfig+0x168>)
 800197a:	682b      	ldr	r3, [r5, #0]
 800197c:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001980:	d106      	bne.n	8001990 <HAL_RCCEx_PeriphCLKConfig+0xc8>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8001982:	f7fe fe5f 	bl	8000644 <HAL_GetTick>
 8001986:	1b80      	subs	r0, r0, r6
 8001988:	2802      	cmp	r0, #2
 800198a:	d9f6      	bls.n	800197a <HAL_RCCEx_PeriphCLKConfig+0xb2>
        return HAL_TIMEOUT;
 800198c:	2003      	movs	r0, #3
 800198e:	e7af      	b.n	80018f0 <HAL_RCCEx_PeriphCLKConfig+0x28>
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8001990:	4b26      	ldr	r3, [pc, #152]	; (8001a2c <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001992:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8001994:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8001998:	d012      	beq.n	80019c0 <HAL_RCCEx_PeriphCLKConfig+0xf8>
 800199a:	6922      	ldr	r2, [r4, #16]
 800199c:	f402 7240 	and.w	r2, r2, #768	; 0x300
 80019a0:	4293      	cmp	r3, r2
 80019a2:	d00d      	beq.n	80019c0 <HAL_RCCEx_PeriphCLKConfig+0xf8>
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 80019a4:	4b21      	ldr	r3, [pc, #132]	; (8001a2c <HAL_RCCEx_PeriphCLKConfig+0x164>)
 80019a6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80019a8:	f422 7240 	bic.w	r2, r2, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 80019ac:	4921      	ldr	r1, [pc, #132]	; (8001a34 <HAL_RCCEx_PeriphCLKConfig+0x16c>)
 80019ae:	2001      	movs	r0, #1
 80019b0:	6008      	str	r0, [r1, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 80019b2:	2000      	movs	r0, #0
 80019b4:	6008      	str	r0, [r1, #0]
      RCC->BDCR = tmpreg1;
 80019b6:	671a      	str	r2, [r3, #112]	; 0x70
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 80019b8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80019ba:	f013 0f01 	tst.w	r3, #1
 80019be:	d112      	bne.n	80019e6 <HAL_RCCEx_PeriphCLKConfig+0x11e>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80019c0:	6923      	ldr	r3, [r4, #16]
 80019c2:	f403 7240 	and.w	r2, r3, #768	; 0x300
 80019c6:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 80019ca:	d01d      	beq.n	8001a08 <HAL_RCCEx_PeriphCLKConfig+0x140>
 80019cc:	4a17      	ldr	r2, [pc, #92]	; (8001a2c <HAL_RCCEx_PeriphCLKConfig+0x164>)
 80019ce:	6893      	ldr	r3, [r2, #8]
 80019d0:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 80019d4:	6093      	str	r3, [r2, #8]
 80019d6:	4a15      	ldr	r2, [pc, #84]	; (8001a2c <HAL_RCCEx_PeriphCLKConfig+0x164>)
 80019d8:	6f11      	ldr	r1, [r2, #112]	; 0x70
 80019da:	6923      	ldr	r3, [r4, #16]
 80019dc:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80019e0:	430b      	orrs	r3, r1
 80019e2:	6713      	str	r3, [r2, #112]	; 0x70
 80019e4:	e77b      	b.n	80018de <HAL_RCCEx_PeriphCLKConfig+0x16>
        tickstart = HAL_GetTick();
 80019e6:	f7fe fe2d 	bl	8000644 <HAL_GetTick>
 80019ea:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80019ec:	4d0f      	ldr	r5, [pc, #60]	; (8001a2c <HAL_RCCEx_PeriphCLKConfig+0x164>)
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80019ee:	f241 3688 	movw	r6, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80019f2:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80019f4:	f013 0f02 	tst.w	r3, #2
 80019f8:	d1e2      	bne.n	80019c0 <HAL_RCCEx_PeriphCLKConfig+0xf8>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80019fa:	f7fe fe23 	bl	8000644 <HAL_GetTick>
 80019fe:	1bc0      	subs	r0, r0, r7
 8001a00:	42b0      	cmp	r0, r6
 8001a02:	d9f6      	bls.n	80019f2 <HAL_RCCEx_PeriphCLKConfig+0x12a>
            return HAL_TIMEOUT;
 8001a04:	2003      	movs	r0, #3
 8001a06:	e773      	b.n	80018f0 <HAL_RCCEx_PeriphCLKConfig+0x28>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8001a08:	4908      	ldr	r1, [pc, #32]	; (8001a2c <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001a0a:	688a      	ldr	r2, [r1, #8]
 8001a0c:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8001a10:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8001a14:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001a18:	4313      	orrs	r3, r2
 8001a1a:	608b      	str	r3, [r1, #8]
 8001a1c:	e7db      	b.n	80019d6 <HAL_RCCEx_PeriphCLKConfig+0x10e>
  return HAL_OK;
 8001a1e:	2000      	movs	r0, #0
 8001a20:	e766      	b.n	80018f0 <HAL_RCCEx_PeriphCLKConfig+0x28>
 8001a22:	bf00      	nop
 8001a24:	424711e0 	.word	0x424711e0
 8001a28:	42470068 	.word	0x42470068
 8001a2c:	40023800 	.word	0x40023800
 8001a30:	40007000 	.word	0x40007000
 8001a34:	42470e40 	.word	0x42470e40

08001a38 <USB_CoreInit>:
  * @param  cfg  pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8001a38:	b084      	sub	sp, #16
 8001a3a:	b510      	push	{r4, lr}
 8001a3c:	4604      	mov	r4, r0
 8001a3e:	a803      	add	r0, sp, #12
 8001a40:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001a44:	9b08      	ldr	r3, [sp, #32]
 8001a46:	2b01      	cmp	r3, #1
 8001a48:	d011      	beq.n	8001a6e <USB_CoreInit+0x36>
    USB_CoreReset(USBx); 
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8001a4a:	68e3      	ldr	r3, [r4, #12]
 8001a4c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001a50:	60e3      	str	r3, [r4, #12]
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
 8001a52:	4620      	mov	r0, r4
 8001a54:	f000 fcae 	bl	80023b4 <USB_CoreReset>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 8001a58:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001a5c:	63a3      	str	r3, [r4, #56]	; 0x38
  }
 
  if(cfg.dma_enable == ENABLE)
 8001a5e:	9b06      	ldr	r3, [sp, #24]
 8001a60:	2b01      	cmp	r3, #1
 8001a62:	d01e      	beq.n	8001aa2 <USB_CoreInit+0x6a>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  }  

  return HAL_OK;
}
 8001a64:	2000      	movs	r0, #0
 8001a66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8001a6a:	b004      	add	sp, #16
 8001a6c:	4770      	bx	lr
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8001a6e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001a70:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001a74:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8001a76:	68e3      	ldr	r3, [r4, #12]
 8001a78:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 8001a7c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001a80:	60e3      	str	r3, [r4, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8001a82:	68e3      	ldr	r3, [r4, #12]
 8001a84:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8001a88:	60e3      	str	r3, [r4, #12]
    if(cfg.use_external_vbus == 1U)
 8001a8a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8001a8c:	2b01      	cmp	r3, #1
 8001a8e:	d003      	beq.n	8001a98 <USB_CoreInit+0x60>
    USB_CoreReset(USBx); 
 8001a90:	4620      	mov	r0, r4
 8001a92:	f000 fc8f 	bl	80023b4 <USB_CoreReset>
 8001a96:	e7e2      	b.n	8001a5e <USB_CoreInit+0x26>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8001a98:	68e3      	ldr	r3, [r4, #12]
 8001a9a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001a9e:	60e3      	str	r3, [r4, #12]
 8001aa0:	e7f6      	b.n	8001a90 <USB_CoreInit+0x58>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8001aa2:	68a3      	ldr	r3, [r4, #8]
 8001aa4:	f043 0306 	orr.w	r3, r3, #6
 8001aa8:	60a3      	str	r3, [r4, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8001aaa:	68a3      	ldr	r3, [r4, #8]
 8001aac:	f043 0320 	orr.w	r3, r3, #32
 8001ab0:	60a3      	str	r3, [r4, #8]
 8001ab2:	e7d7      	b.n	8001a64 <USB_CoreInit+0x2c>

08001ab4 <USB_EnableGlobalInt>:
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8001ab4:	6883      	ldr	r3, [r0, #8]
 8001ab6:	f043 0301 	orr.w	r3, r3, #1
 8001aba:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 8001abc:	2000      	movs	r0, #0
 8001abe:	4770      	bx	lr

08001ac0 <USB_DisableGlobalInt>:
  * @param  USBx  Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8001ac0:	6883      	ldr	r3, [r0, #8]
 8001ac2:	f023 0301 	bic.w	r3, r3, #1
 8001ac6:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 8001ac8:	2000      	movs	r0, #0
 8001aca:	4770      	bx	lr

08001acc <USB_SetCurrentMode>:
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
 8001acc:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 8001ace:	68c3      	ldr	r3, [r0, #12]
 8001ad0:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8001ad4:	60c3      	str	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 8001ad6:	2901      	cmp	r1, #1
 8001ad8:	d009      	beq.n	8001aee <USB_SetCurrentMode+0x22>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
 8001ada:	b919      	cbnz	r1, 8001ae4 <USB_SetCurrentMode+0x18>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
 8001adc:	68c3      	ldr	r3, [r0, #12]
 8001ade:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8001ae2:	60c3      	str	r3, [r0, #12]
  }
  HAL_Delay(50U);
 8001ae4:	2032      	movs	r0, #50	; 0x32
 8001ae6:	f7fe fdb3 	bl	8000650 <HAL_Delay>
  
  return HAL_OK;
}
 8001aea:	2000      	movs	r0, #0
 8001aec:	bd08      	pop	{r3, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
 8001aee:	68c3      	ldr	r3, [r0, #12]
 8001af0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8001af4:	60c3      	str	r3, [r0, #12]
 8001af6:	e7f5      	b.n	8001ae4 <USB_SetCurrentMode+0x18>

08001af8 <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8001af8:	b084      	sub	sp, #16
 8001afa:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001afe:	4604      	mov	r4, r0
 8001b00:	a80b      	add	r0, sp, #44	; 0x2c
 8001b02:	e880 000e 	stmia.w	r0, {r1, r2, r3}
 8001b06:	4688      	mov	r8, r1
 8001b08:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
 8001b0c:	f8dd b054 	ldr.w	fp, [sp, #84]	; 0x54
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  if (cfg.vbus_sensing_enable == 0U)
 8001b10:	f1bb 0f00 	cmp.w	fp, #0
 8001b14:	d172      	bne.n	8001bfc <USB_DevInit+0x104>
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 8001b16:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001b18:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001b1c:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx || STM32F413xx || STM32F423xx  */
  
  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 8001b1e:	2300      	movs	r3, #0
 8001b20:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
  
  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8001b24:	f504 6500 	add.w	r5, r4, #2048	; 0x800
 8001b28:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 8001b2c:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 8001b30:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8001b32:	2b01      	cmp	r3, #1
 8001b34:	d067      	beq.n	8001c06 <USB_DevInit+0x10e>
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 8001b36:	2103      	movs	r1, #3
 8001b38:	4620      	mov	r0, r4
 8001b3a:	f000 f8ad 	bl	8001c98 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 8001b3e:	2110      	movs	r1, #16
 8001b40:	4620      	mov	r0, r4
 8001b42:	f000 f887 	bl	8001c54 <USB_FlushTxFifo>
  USB_FlushRxFifo(USBx);
 8001b46:	4620      	mov	r0, r4
 8001b48:	f000 f896 	bl	8001c78 <USB_FlushRxFifo>
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 8001b4c:	2300      	movs	r3, #0
 8001b4e:	612b      	str	r3, [r5, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 8001b50:	616b      	str	r3, [r5, #20]
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8001b52:	f04f 32ff 	mov.w	r2, #4294967295
 8001b56:	61aa      	str	r2, [r5, #24]
  USBx_DEVICE->DAINTMSK = 0U;
 8001b58:	61eb      	str	r3, [r5, #28]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001b5a:	f1b8 0f00 	cmp.w	r8, #0
 8001b5e:	d028      	beq.n	8001bb2 <USB_DevInit+0xba>
 8001b60:	f504 6310 	add.w	r3, r4, #2304	; 0x900
 8001b64:	2200      	movs	r2, #0
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 8001b66:	4616      	mov	r6, r2
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8001b68:	f04f 4990 	mov.w	r9, #1207959552	; 0x48000000
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 8001b6c:	27ff      	movs	r7, #255	; 0xff
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8001b6e:	6818      	ldr	r0, [r3, #0]
 8001b70:	2800      	cmp	r0, #0
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8001b72:	bfb4      	ite	lt
 8001b74:	f8c3 9000 	strlt.w	r9, [r3]
      USBx_INEP(i)->DIEPCTL = 0U;
 8001b78:	601e      	strge	r6, [r3, #0]
    USBx_INEP(i)->DIEPTSIZ = 0U;
 8001b7a:	611e      	str	r6, [r3, #16]
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 8001b7c:	609f      	str	r7, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001b7e:	3201      	adds	r2, #1
 8001b80:	3320      	adds	r3, #32
 8001b82:	4542      	cmp	r2, r8
 8001b84:	d1f3      	bne.n	8001b6e <USB_DevInit+0x76>
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001b86:	b1a2      	cbz	r2, 8001bb2 <USB_DevInit+0xba>
 8001b88:	f504 6330 	add.w	r3, r4, #2816	; 0xb00
 8001b8c:	2100      	movs	r1, #0
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8001b8e:	460f      	mov	r7, r1
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8001b90:	f04f 4990 	mov.w	r9, #1207959552	; 0x48000000
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 8001b94:	f04f 08ff 	mov.w	r8, #255	; 0xff
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8001b98:	681e      	ldr	r6, [r3, #0]
 8001b9a:	2e00      	cmp	r6, #0
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8001b9c:	bfb4      	ite	lt
 8001b9e:	f8c3 9000 	strlt.w	r9, [r3]
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8001ba2:	601f      	strge	r7, [r3, #0]
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8001ba4:	611f      	str	r7, [r3, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 8001ba6:	f8c3 8008 	str.w	r8, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001baa:	3101      	adds	r1, #1
 8001bac:	3320      	adds	r3, #32
 8001bae:	428a      	cmp	r2, r1
 8001bb0:	d1f2      	bne.n	8001b98 <USB_DevInit+0xa0>
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8001bb2:	692b      	ldr	r3, [r5, #16]
 8001bb4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001bb8:	612b      	str	r3, [r5, #16]
  
  if (cfg.dma_enable == 1U)
 8001bba:	f1ba 0f01 	cmp.w	sl, #1
 8001bbe:	d02e      	beq.n	8001c1e <USB_DevInit+0x126>
    
    i= USBx_DEVICE->DTHRCTL;
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 8001bc0:	2300      	movs	r3, #0
 8001bc2:	61a3      	str	r3, [r4, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 8001bc4:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 8001bc8:	6163      	str	r3, [r4, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 8001bca:	f1ba 0f00 	cmp.w	sl, #0
 8001bce:	d103      	bne.n	8001bd8 <USB_DevInit+0xe0>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 8001bd0:	69a3      	ldr	r3, [r4, #24]
 8001bd2:	f043 0310 	orr.w	r3, r3, #16
 8001bd6:	61a3      	str	r3, [r4, #24]
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 8001bd8:	69a2      	ldr	r2, [r4, #24]
 8001bda:	4b1c      	ldr	r3, [pc, #112]	; (8001c4c <USB_DevInit+0x154>)
 8001bdc:	4313      	orrs	r3, r2
 8001bde:	61a3      	str	r3, [r4, #24]
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 8001be0:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8001be2:	b11b      	cbz	r3, 8001bec <USB_DevInit+0xf4>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8001be4:	69a3      	ldr	r3, [r4, #24]
 8001be6:	f043 0308 	orr.w	r3, r3, #8
 8001bea:	61a3      	str	r3, [r4, #24]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 8001bec:	f1bb 0f01 	cmp.w	fp, #1
 8001bf0:	d024      	beq.n	8001c3c <USB_DevInit+0x144>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
  }
  
  return HAL_OK;
}
 8001bf2:	2000      	movs	r0, #0
 8001bf4:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001bf8:	b004      	add	sp, #16
 8001bfa:	4770      	bx	lr
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 8001bfc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001bfe:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8001c02:	63a3      	str	r3, [r4, #56]	; 0x38
 8001c04:	e78b      	b.n	8001b1e <USB_DevInit+0x26>
    if(cfg.speed == USB_OTG_SPEED_HIGH)
 8001c06:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001c08:	b923      	cbnz	r3, 8001c14 <USB_DevInit+0x11c>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
 8001c0a:	2100      	movs	r1, #0
 8001c0c:	4620      	mov	r0, r4
 8001c0e:	f000 f843 	bl	8001c98 <USB_SetDevSpeed>
 8001c12:	e794      	b.n	8001b3e <USB_DevInit+0x46>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
 8001c14:	2101      	movs	r1, #1
 8001c16:	4620      	mov	r0, r4
 8001c18:	f000 f83e 	bl	8001c98 <USB_SetDevSpeed>
 8001c1c:	e78f      	b.n	8001b3e <USB_DevInit+0x46>
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 8001c1e:	4b0c      	ldr	r3, [pc, #48]	; (8001c50 <USB_DevInit+0x158>)
 8001c20:	632b      	str	r3, [r5, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 8001c22:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8001c24:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001c28:	f043 0303 	orr.w	r3, r3, #3
 8001c2c:	632b      	str	r3, [r5, #48]	; 0x30
    i= USBx_DEVICE->DTHRCTL;
 8001c2e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  USBx->GINTMSK = 0U;
 8001c30:	2300      	movs	r3, #0
 8001c32:	61a3      	str	r3, [r4, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 8001c34:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 8001c38:	6163      	str	r3, [r4, #20]
 8001c3a:	e7cd      	b.n	8001bd8 <USB_DevInit+0xe0>
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 8001c3c:	69a3      	ldr	r3, [r4, #24]
 8001c3e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8001c42:	f043 0304 	orr.w	r3, r3, #4
 8001c46:	61a3      	str	r3, [r4, #24]
 8001c48:	e7d3      	b.n	8001bf2 <USB_DevInit+0xfa>
 8001c4a:	bf00      	nop
 8001c4c:	803c3800 	.word	0x803c3800
 8001c50:	00800100 	.word	0x00800100

08001c54 <USB_FlushTxFifo>:
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 8001c54:	0189      	lsls	r1, r1, #6
 8001c56:	f041 0120 	orr.w	r1, r1, #32
 8001c5a:	6101      	str	r1, [r0, #16]
 8001c5c:	4b05      	ldr	r3, [pc, #20]	; (8001c74 <USB_FlushTxFifo+0x20>)
    if (++count > 200000)
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8001c5e:	6902      	ldr	r2, [r0, #16]
 8001c60:	f012 0f20 	tst.w	r2, #32
 8001c64:	d003      	beq.n	8001c6e <USB_FlushTxFifo+0x1a>
    if (++count > 200000)
 8001c66:	3b01      	subs	r3, #1
 8001c68:	d1f9      	bne.n	8001c5e <USB_FlushTxFifo+0xa>
      return HAL_TIMEOUT;
 8001c6a:	2003      	movs	r0, #3
  
  return HAL_OK;
}
 8001c6c:	4770      	bx	lr
  return HAL_OK;
 8001c6e:	2000      	movs	r0, #0
 8001c70:	4770      	bx	lr
 8001c72:	bf00      	nop
 8001c74:	00030d40 	.word	0x00030d40

08001c78 <USB_FlushRxFifo>:
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8001c78:	2310      	movs	r3, #16
 8001c7a:	6103      	str	r3, [r0, #16]
 8001c7c:	4b05      	ldr	r3, [pc, #20]	; (8001c94 <USB_FlushRxFifo+0x1c>)
    if (++count > 200000)
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8001c7e:	6902      	ldr	r2, [r0, #16]
 8001c80:	f012 0f10 	tst.w	r2, #16
 8001c84:	d003      	beq.n	8001c8e <USB_FlushRxFifo+0x16>
    if (++count > 200000)
 8001c86:	3b01      	subs	r3, #1
 8001c88:	d1f9      	bne.n	8001c7e <USB_FlushRxFifo+0x6>
      return HAL_TIMEOUT;
 8001c8a:	2003      	movs	r0, #3
  
  return HAL_OK;
}
 8001c8c:	4770      	bx	lr
  return HAL_OK;
 8001c8e:	2000      	movs	r0, #0
 8001c90:	4770      	bx	lr
 8001c92:	bf00      	nop
 8001c94:	00030d40 	.word	0x00030d40

08001c98 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 8001c98:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8001c9c:	4319      	orrs	r1, r3
 8001c9e:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  return HAL_OK;
}
 8001ca2:	2000      	movs	r0, #0
 8001ca4:	4770      	bx	lr

08001ca6 <USB_GetDevSpeed>:
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
  uint8_t speed = 0U;
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 8001ca6:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8001caa:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 8001cae:	f013 0f06 	tst.w	r3, #6
 8001cb2:	d011      	beq.n	8001cd8 <USB_GetDevSpeed+0x32>
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8001cb4:	6883      	ldr	r3, [r0, #8]
 8001cb6:	f003 0306 	and.w	r3, r3, #6
 8001cba:	2b02      	cmp	r3, #2
 8001cbc:	d00e      	beq.n	8001cdc <USB_GetDevSpeed+0x36>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
 8001cbe:	6883      	ldr	r3, [r0, #8]
 8001cc0:	f003 0306 	and.w	r3, r3, #6
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8001cc4:	2b06      	cmp	r3, #6
 8001cc6:	d00b      	beq.n	8001ce0 <USB_GetDevSpeed+0x3a>
  {
    speed = USB_OTG_SPEED_FULL;
  }
  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8001cc8:	6883      	ldr	r3, [r0, #8]
 8001cca:	f003 0306 	and.w	r3, r3, #6
  {
    speed = USB_OTG_SPEED_LOW;
 8001cce:	2b04      	cmp	r3, #4
 8001cd0:	bf14      	ite	ne
 8001cd2:	2000      	movne	r0, #0
 8001cd4:	2002      	moveq	r0, #2
 8001cd6:	4770      	bx	lr
    speed = USB_OTG_SPEED_HIGH;
 8001cd8:	2000      	movs	r0, #0
 8001cda:	4770      	bx	lr
    speed = USB_OTG_SPEED_FULL;
 8001cdc:	2003      	movs	r0, #3
 8001cde:	4770      	bx	lr
 8001ce0:	2003      	movs	r0, #3
  }
  
  return speed;
}
 8001ce2:	4770      	bx	lr

08001ce4 <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8001ce4:	b430      	push	{r4, r5}
  if (ep->is_in == 1U)
 8001ce6:	784b      	ldrb	r3, [r1, #1]
 8001ce8:	2b01      	cmp	r3, #1
 8001cea:	d020      	beq.n	8001d2e <USB_ActivateEndpoint+0x4a>
        ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
    } 
  }
  else
  {
     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U);
 8001cec:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 8001cf0:	780d      	ldrb	r5, [r1, #0]
 8001cf2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001cf6:	40ab      	lsls	r3, r5
 8001cf8:	4323      	orrs	r3, r4
 8001cfa:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
     
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8001cfe:	780a      	ldrb	r2, [r1, #0]
 8001d00:	0152      	lsls	r2, r2, #5
 8001d02:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
 8001d06:	5813      	ldr	r3, [r2, r0]
 8001d08:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8001d0c:	d10c      	bne.n	8001d28 <USB_ActivateEndpoint+0x44>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\
 8001d0e:	5814      	ldr	r4, [r2, r0]
 8001d10:	688b      	ldr	r3, [r1, #8]
 8001d12:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8001d16:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001d1a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001d1e:	78c9      	ldrb	r1, [r1, #3]
 8001d20:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 8001d24:	4323      	orrs	r3, r4
 8001d26:	5013      	str	r3, [r2, r0]
       (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
    } 
  }
  return HAL_OK;
}
 8001d28:	2000      	movs	r0, #0
 8001d2a:	bc30      	pop	{r4, r5}
 8001d2c:	4770      	bx	lr
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
 8001d2e:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 8001d32:	780d      	ldrb	r5, [r1, #0]
 8001d34:	40ab      	lsls	r3, r5
 8001d36:	b29b      	uxth	r3, r3
 8001d38:	4323      	orrs	r3, r4
 8001d3a:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8001d3e:	780c      	ldrb	r4, [r1, #0]
 8001d40:	0162      	lsls	r2, r4, #5
 8001d42:	f500 6010 	add.w	r0, r0, #2304	; 0x900
 8001d46:	5813      	ldr	r3, [r2, r0]
 8001d48:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8001d4c:	d1ec      	bne.n	8001d28 <USB_ActivateEndpoint+0x44>
      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\
 8001d4e:	5815      	ldr	r5, [r2, r0]
 8001d50:	688b      	ldr	r3, [r1, #8]
 8001d52:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8001d56:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001d5a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001d5e:	78c9      	ldrb	r1, [r1, #3]
 8001d60:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 8001d64:	ea43 5384 	orr.w	r3, r3, r4, lsl #22
 8001d68:	432b      	orrs	r3, r5
 8001d6a:	5013      	str	r3, [r2, r0]
 8001d6c:	e7dc      	b.n	8001d28 <USB_ActivateEndpoint+0x44>
	...

08001d70 <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8001d70:	b538      	push	{r3, r4, r5, lr}
  uint32_t count = 0U;
  
  /* Disable the IN endpoint */
  if (ep->is_in == 1U)
 8001d72:	784b      	ldrb	r3, [r1, #1]
 8001d74:	2b01      	cmp	r3, #1
 8001d76:	d01d      	beq.n	8001db4 <USB_DeactivateEndpoint+0x44>
 8001d78:	f500 6430 	add.w	r4, r0, #2816	; 0xb00
  
  }
  else /* Disable the OUT endpoint */
  {
    
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;  
 8001d7c:	780b      	ldrb	r3, [r1, #0]
 8001d7e:	015b      	lsls	r3, r3, #5
 8001d80:	591a      	ldr	r2, [r3, r4]
 8001d82:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001d86:	511a      	str	r2, [r3, r4]
    
    /* sets the NAK bit for the OUT endpoint */
    USBx_OUTEP(ep->num)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8001d88:	780b      	ldrb	r3, [r1, #0]
 8001d8a:	015b      	lsls	r3, r3, #5
 8001d8c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001d90:	511a      	str	r2, [r3, r4]
    
    /* Disable OUT endpoint */
    USBx_OUTEP(ep->num)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS;
 8001d92:	780b      	ldrb	r3, [r1, #0]
 8001d94:	015b      	lsls	r3, r3, #5
 8001d96:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001d9a:	511a      	str	r2, [r3, r4]
        return HAL_TIMEOUT;
      }
    }
    
    /*Wait for  EPDISD endpoint disabled interrupt*/ 
    while ((USBx_OUTEP(ep->num)->DOEPINT & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS);
 8001d9c:	780b      	ldrb	r3, [r1, #0]
 8001d9e:	eb04 1443 	add.w	r4, r4, r3, lsl #5
 8001da2:	4b25      	ldr	r3, [pc, #148]	; (8001e38 <USB_DeactivateEndpoint+0xc8>)
 8001da4:	68a2      	ldr	r2, [r4, #8]
 8001da6:	f012 0f10 	tst.w	r2, #16
 8001daa:	d032      	beq.n	8001e12 <USB_DeactivateEndpoint+0xa2>
      if (++count > 200000U)
 8001dac:	3b01      	subs	r3, #1
 8001dae:	d1f9      	bne.n	8001da4 <USB_DeactivateEndpoint+0x34>
        return HAL_TIMEOUT;
 8001db0:	2003      	movs	r0, #3
    
    /* Disable endpoint interrupts */
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));         
  }
  return HAL_OK;
}
 8001db2:	bd38      	pop	{r3, r4, r5, pc}
 8001db4:	f500 6410 	add.w	r4, r0, #2304	; 0x900
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_USBAEP;  
 8001db8:	780b      	ldrb	r3, [r1, #0]
 8001dba:	015b      	lsls	r3, r3, #5
 8001dbc:	591a      	ldr	r2, [r3, r4]
 8001dbe:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001dc2:	511a      	str	r2, [r3, r4]
    USBx_INEP(ep->num)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8001dc4:	780b      	ldrb	r3, [r1, #0]
 8001dc6:	015b      	lsls	r3, r3, #5
 8001dc8:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001dcc:	511a      	str	r2, [r3, r4]
    USBx_INEP(ep->num)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS;
 8001dce:	780b      	ldrb	r3, [r1, #0]
 8001dd0:	015b      	lsls	r3, r3, #5
 8001dd2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001dd6:	511a      	str	r2, [r3, r4]
    while ((USBx_INEP(ep->num)->DIEPINT & USB_OTG_DIEPCTL_EPDIS) == USB_OTG_DIEPCTL_EPDIS);
 8001dd8:	780b      	ldrb	r3, [r1, #0]
 8001dda:	eb04 1443 	add.w	r4, r4, r3, lsl #5
 8001dde:	4b16      	ldr	r3, [pc, #88]	; (8001e38 <USB_DeactivateEndpoint+0xc8>)
 8001de0:	68a2      	ldr	r2, [r4, #8]
 8001de2:	f012 4f80 	tst.w	r2, #1073741824	; 0x40000000
 8001de6:	d003      	beq.n	8001df0 <USB_DeactivateEndpoint+0x80>
      if (++count > 200000U)
 8001de8:	3b01      	subs	r3, #1
 8001dea:	d1f9      	bne.n	8001de0 <USB_DeactivateEndpoint+0x70>
        return HAL_TIMEOUT;
 8001dec:	2003      	movs	r0, #3
 8001dee:	bd38      	pop	{r3, r4, r5, pc}
 8001df0:	460d      	mov	r5, r1
 8001df2:	4604      	mov	r4, r0
    USB_FlushTxFifo(USBx , 0x10U);
 8001df4:	2110      	movs	r1, #16
 8001df6:	f7ff ff2d 	bl	8001c54 <USB_FlushTxFifo>
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));   
 8001dfa:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
 8001dfe:	7829      	ldrb	r1, [r5, #0]
 8001e00:	2301      	movs	r3, #1
 8001e02:	408b      	lsls	r3, r1
 8001e04:	b29b      	uxth	r3, r3
 8001e06:	ea22 0303 	bic.w	r3, r2, r3
 8001e0a:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
  return HAL_OK;
 8001e0e:	2000      	movs	r0, #0
 8001e10:	bd38      	pop	{r3, r4, r5, pc}
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 8001e12:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8001e16:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001e1a:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));         
 8001e1e:	f8d0 381c 	ldr.w	r3, [r0, #2076]	; 0x81c
 8001e22:	7809      	ldrb	r1, [r1, #0]
 8001e24:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001e28:	408a      	lsls	r2, r1
 8001e2a:	ea23 0302 	bic.w	r3, r3, r2
 8001e2e:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
  return HAL_OK;
 8001e32:	2000      	movs	r0, #0
 8001e34:	bd38      	pop	{r3, r4, r5, pc}
 8001e36:	bf00      	nop
 8001e38:	00030d40 	.word	0x00030d40

08001e3c <USB_EPStartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8001e3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001e3e:	b083      	sub	sp, #12
  uint16_t pktcnt = 0U;
  
  /* IN endpoint */
  if (ep->is_in == 1U)
 8001e40:	784b      	ldrb	r3, [r1, #1]
 8001e42:	2b01      	cmp	r3, #1
 8001e44:	d035      	beq.n	8001eb2 <USB_EPStartXfer+0x76>
 8001e46:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */  
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8001e4a:	780d      	ldrb	r5, [r1, #0]
 8001e4c:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8001e50:	692c      	ldr	r4, [r5, #16]
 8001e52:	0ce4      	lsrs	r4, r4, #19
 8001e54:	04e4      	lsls	r4, r4, #19
 8001e56:	612c      	str	r4, [r5, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 8001e58:	780d      	ldrb	r5, [r1, #0]
 8001e5a:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8001e5e:	692c      	ldr	r4, [r5, #16]
 8001e60:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 8001e64:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 8001e68:	612c      	str	r4, [r5, #16]

    if (ep->xfer_len == 0U)
 8001e6a:	694c      	ldr	r4, [r1, #20]
 8001e6c:	2c00      	cmp	r4, #0
 8001e6e:	f040 80b8 	bne.w	8001fe2 <USB_EPStartXfer+0x1a6>
    {
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8001e72:	780d      	ldrb	r5, [r1, #0]
 8001e74:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8001e78:	692e      	ldr	r6, [r5, #16]
 8001e7a:	688c      	ldr	r4, [r1, #8]
 8001e7c:	f3c4 0412 	ubfx	r4, r4, #0, #19
 8001e80:	4334      	orrs	r4, r6
 8001e82:	612c      	str	r4, [r5, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8001e84:	780c      	ldrb	r4, [r1, #0]
 8001e86:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8001e8a:	6925      	ldr	r5, [r4, #16]
 8001e8c:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 8001e90:	6125      	str	r5, [r4, #16]
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));
    }

    if (dma == 1U)
 8001e92:	2a01      	cmp	r2, #1
 8001e94:	f000 80c0 	beq.w	8002018 <USB_EPStartXfer+0x1dc>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
    }
    
    if (ep->type == EP_TYPE_ISOC)
 8001e98:	78ca      	ldrb	r2, [r1, #3]
 8001e9a:	2a01      	cmp	r2, #1
 8001e9c:	f000 80c2 	beq.w	8002024 <USB_EPStartXfer+0x1e8>
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
      }
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8001ea0:	780a      	ldrb	r2, [r1, #0]
 8001ea2:	0152      	lsls	r2, r2, #5
 8001ea4:	58d1      	ldr	r1, [r2, r3]
 8001ea6:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 8001eaa:	50d1      	str	r1, [r2, r3]
  }
  return HAL_OK;
}
 8001eac:	2000      	movs	r0, #0
 8001eae:	b003      	add	sp, #12
 8001eb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (ep->xfer_len == 0U)
 8001eb2:	694b      	ldr	r3, [r1, #20]
 8001eb4:	bb4b      	cbnz	r3, 8001f0a <USB_EPStartXfer+0xce>
 8001eb6:	f500 6310 	add.w	r3, r0, #2304	; 0x900
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001eba:	780d      	ldrb	r5, [r1, #0]
 8001ebc:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8001ec0:	692c      	ldr	r4, [r5, #16]
 8001ec2:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 8001ec6:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 8001eca:	612c      	str	r4, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8001ecc:	780c      	ldrb	r4, [r1, #0]
 8001ece:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8001ed2:	6925      	ldr	r5, [r4, #16]
 8001ed4:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 8001ed8:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 8001eda:	780c      	ldrb	r4, [r1, #0]
 8001edc:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8001ee0:	691c      	ldr	r4, [r3, #16]
 8001ee2:	0ce4      	lsrs	r4, r4, #19
 8001ee4:	04e4      	lsls	r4, r4, #19
 8001ee6:	611c      	str	r4, [r3, #16]
    if (dma == 1U)
 8001ee8:	2a01      	cmp	r2, #1
 8001eea:	d03d      	beq.n	8001f68 <USB_EPStartXfer+0x12c>
      if (ep->type != EP_TYPE_ISOC)
 8001eec:	78cb      	ldrb	r3, [r1, #3]
 8001eee:	2b01      	cmp	r3, #1
 8001ef0:	d066      	beq.n	8001fc0 <USB_EPStartXfer+0x184>
        if (ep->xfer_len > 0U)
 8001ef2:	694b      	ldr	r3, [r1, #20]
 8001ef4:	2b00      	cmp	r3, #0
 8001ef6:	d041      	beq.n	8001f7c <USB_EPStartXfer+0x140>
          USBx_DEVICE->DIEPEMPMSK |= 1U << ep->num;
 8001ef8:	f8d0 5834 	ldr.w	r5, [r0, #2100]	; 0x834
 8001efc:	780e      	ldrb	r6, [r1, #0]
 8001efe:	2301      	movs	r3, #1
 8001f00:	40b3      	lsls	r3, r6
 8001f02:	432b      	orrs	r3, r5
 8001f04:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
 8001f08:	e035      	b.n	8001f76 <USB_EPStartXfer+0x13a>
 8001f0a:	f500 6410 	add.w	r4, r0, #2304	; 0x900
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8001f0e:	780d      	ldrb	r5, [r1, #0]
 8001f10:	eb04 1545 	add.w	r5, r4, r5, lsl #5
 8001f14:	692b      	ldr	r3, [r5, #16]
 8001f16:	0cdb      	lsrs	r3, r3, #19
 8001f18:	04db      	lsls	r3, r3, #19
 8001f1a:	612b      	str	r3, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001f1c:	780d      	ldrb	r5, [r1, #0]
 8001f1e:	eb04 1545 	add.w	r5, r4, r5, lsl #5
 8001f22:	692b      	ldr	r3, [r5, #16]
 8001f24:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 8001f28:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 8001f2c:	612b      	str	r3, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;
 8001f2e:	780e      	ldrb	r6, [r1, #0]
 8001f30:	eb04 1646 	add.w	r6, r4, r6, lsl #5
 8001f34:	6937      	ldr	r7, [r6, #16]
 8001f36:	688d      	ldr	r5, [r1, #8]
 8001f38:	694b      	ldr	r3, [r1, #20]
 8001f3a:	442b      	add	r3, r5
 8001f3c:	3b01      	subs	r3, #1
 8001f3e:	fbb3 f3f5 	udiv	r3, r3, r5
 8001f42:	4d40      	ldr	r5, [pc, #256]	; (8002044 <USB_EPStartXfer+0x208>)
 8001f44:	ea05 43c3 	and.w	r3, r5, r3, lsl #19
 8001f48:	433b      	orrs	r3, r7
 8001f4a:	6133      	str	r3, [r6, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8001f4c:	780d      	ldrb	r5, [r1, #0]
 8001f4e:	eb04 1545 	add.w	r5, r4, r5, lsl #5
 8001f52:	692e      	ldr	r6, [r5, #16]
 8001f54:	694b      	ldr	r3, [r1, #20]
 8001f56:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8001f5a:	4333      	orrs	r3, r6
 8001f5c:	612b      	str	r3, [r5, #16]
      if (ep->type == EP_TYPE_ISOC)
 8001f5e:	78cb      	ldrb	r3, [r1, #3]
 8001f60:	2b01      	cmp	r3, #1
 8001f62:	d01e      	beq.n	8001fa2 <USB_EPStartXfer+0x166>
    if (dma == 1U)
 8001f64:	2a01      	cmp	r2, #1
 8001f66:	d1c4      	bne.n	8001ef2 <USB_EPStartXfer+0xb6>
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8001f68:	780c      	ldrb	r4, [r1, #0]
 8001f6a:	f500 6310 	add.w	r3, r0, #2304	; 0x900
 8001f6e:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8001f72:	690c      	ldr	r4, [r1, #16]
 8001f74:	615c      	str	r4, [r3, #20]
    if (ep->type == EP_TYPE_ISOC)
 8001f76:	78cb      	ldrb	r3, [r1, #3]
 8001f78:	2b01      	cmp	r3, #1
 8001f7a:	d021      	beq.n	8001fc0 <USB_EPStartXfer+0x184>
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8001f7c:	780b      	ldrb	r3, [r1, #0]
 8001f7e:	015b      	lsls	r3, r3, #5
 8001f80:	f500 6510 	add.w	r5, r0, #2304	; 0x900
 8001f84:	595c      	ldr	r4, [r3, r5]
 8001f86:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 8001f8a:	515c      	str	r4, [r3, r5]
    if (ep->type == EP_TYPE_ISOC)
 8001f8c:	78cb      	ldrb	r3, [r1, #3]
 8001f8e:	2b01      	cmp	r3, #1
 8001f90:	d18c      	bne.n	8001eac <USB_EPStartXfer+0x70>
 8001f92:	4614      	mov	r4, r2
      USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
 8001f94:	8a8b      	ldrh	r3, [r1, #20]
 8001f96:	780a      	ldrb	r2, [r1, #0]
 8001f98:	68c9      	ldr	r1, [r1, #12]
 8001f9a:	9400      	str	r4, [sp, #0]
 8001f9c:	f000 f8ee 	bl	800217c <USB_WritePacket>
 8001fa0:	e784      	b.n	8001eac <USB_EPStartXfer+0x70>
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
 8001fa2:	780b      	ldrb	r3, [r1, #0]
 8001fa4:	eb04 1343 	add.w	r3, r4, r3, lsl #5
 8001fa8:	691d      	ldr	r5, [r3, #16]
 8001faa:	f025 45c0 	bic.w	r5, r5, #1610612736	; 0x60000000
 8001fae:	611d      	str	r5, [r3, #16]
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); 
 8001fb0:	780b      	ldrb	r3, [r1, #0]
 8001fb2:	eb04 1443 	add.w	r4, r4, r3, lsl #5
 8001fb6:	6923      	ldr	r3, [r4, #16]
 8001fb8:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8001fbc:	6123      	str	r3, [r4, #16]
 8001fbe:	e793      	b.n	8001ee8 <USB_EPStartXfer+0xac>
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 8001fc0:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8001fc4:	f413 7f80 	tst.w	r3, #256	; 0x100
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8001fc8:	780b      	ldrb	r3, [r1, #0]
 8001fca:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8001fce:	f500 6510 	add.w	r5, r0, #2304	; 0x900
 8001fd2:	595c      	ldr	r4, [r3, r5]
 8001fd4:	bf0c      	ite	eq
 8001fd6:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8001fda:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
 8001fde:	515c      	str	r4, [r3, r5]
 8001fe0:	e7cc      	b.n	8001f7c <USB_EPStartXfer+0x140>
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
 8001fe2:	688d      	ldr	r5, [r1, #8]
 8001fe4:	442c      	add	r4, r5
 8001fe6:	3c01      	subs	r4, #1
 8001fe8:	fbb4 f4f5 	udiv	r4, r4, r5
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 8001fec:	780e      	ldrb	r6, [r1, #0]
 8001fee:	eb03 1646 	add.w	r6, r3, r6, lsl #5
 8001ff2:	6937      	ldr	r7, [r6, #16]
 8001ff4:	4d13      	ldr	r5, [pc, #76]	; (8002044 <USB_EPStartXfer+0x208>)
 8001ff6:	ea05 45c4 	and.w	r5, r5, r4, lsl #19
 8001ffa:	433d      	orrs	r5, r7
 8001ffc:	6135      	str	r5, [r6, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));
 8001ffe:	780e      	ldrb	r6, [r1, #0]
 8002000:	eb03 1646 	add.w	r6, r3, r6, lsl #5
 8002004:	6937      	ldr	r7, [r6, #16]
 8002006:	b2a4      	uxth	r4, r4
 8002008:	688d      	ldr	r5, [r1, #8]
 800200a:	fb05 f404 	mul.w	r4, r5, r4
 800200e:	f3c4 0412 	ubfx	r4, r4, #0, #19
 8002012:	433c      	orrs	r4, r7
 8002014:	6134      	str	r4, [r6, #16]
 8002016:	e73c      	b.n	8001e92 <USB_EPStartXfer+0x56>
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
 8002018:	780a      	ldrb	r2, [r1, #0]
 800201a:	eb03 1242 	add.w	r2, r3, r2, lsl #5
 800201e:	68cc      	ldr	r4, [r1, #12]
 8002020:	6154      	str	r4, [r2, #20]
 8002022:	e739      	b.n	8001e98 <USB_EPStartXfer+0x5c>
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 8002024:	f8d0 2808 	ldr.w	r2, [r0, #2056]	; 0x808
 8002028:	f412 7f80 	tst.w	r2, #256	; 0x100
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 800202c:	780a      	ldrb	r2, [r1, #0]
 800202e:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8002032:	58d0      	ldr	r0, [r2, r3]
 8002034:	bf0c      	ite	eq
 8002036:	f040 5000 	orreq.w	r0, r0, #536870912	; 0x20000000
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 800203a:	f040 5080 	orrne.w	r0, r0, #268435456	; 0x10000000
 800203e:	50d0      	str	r0, [r2, r3]
 8002040:	e72e      	b.n	8001ea0 <USB_EPStartXfer+0x64>
 8002042:	bf00      	nop
 8002044:	1ff80000 	.word	0x1ff80000

08002048 <USB_EP0StartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8002048:	b430      	push	{r4, r5}
  /* IN endpoint */
  if (ep->is_in == 1U)
 800204a:	784b      	ldrb	r3, [r1, #1]
 800204c:	2b01      	cmp	r3, #1
 800204e:	d030      	beq.n	80020b2 <USB_EP0StartXfer+0x6a>
 8002050:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8002054:	780c      	ldrb	r4, [r1, #0]
 8002056:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 800205a:	6923      	ldr	r3, [r4, #16]
 800205c:	0cdb      	lsrs	r3, r3, #19
 800205e:	04db      	lsls	r3, r3, #19
 8002060:	6123      	str	r3, [r4, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 8002062:	780c      	ldrb	r4, [r1, #0]
 8002064:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 8002068:	6923      	ldr	r3, [r4, #16]
 800206a:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 800206e:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 8002072:	6123      	str	r3, [r4, #16]
      
    if (ep->xfer_len > 0U)
 8002074:	694b      	ldr	r3, [r1, #20]
 8002076:	b10b      	cbz	r3, 800207c <USB_EP0StartXfer+0x34>
    {
      ep->xfer_len = ep->maxpacket;
 8002078:	688b      	ldr	r3, [r1, #8]
 800207a:	614b      	str	r3, [r1, #20]
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 800207c:	780b      	ldrb	r3, [r1, #0]
 800207e:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 8002082:	691c      	ldr	r4, [r3, #16]
 8002084:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 8002088:	611c      	str	r4, [r3, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 800208a:	780c      	ldrb	r4, [r1, #0]
 800208c:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 8002090:	6925      	ldr	r5, [r4, #16]
 8002092:	688b      	ldr	r3, [r1, #8]
 8002094:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002098:	432b      	orrs	r3, r5
 800209a:	6123      	str	r3, [r4, #16]
    

    if (dma == 1U)
 800209c:	2a01      	cmp	r2, #1
 800209e:	d067      	beq.n	8002170 <USB_EP0StartXfer+0x128>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
    }
    
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
 80020a0:	780b      	ldrb	r3, [r1, #0]
 80020a2:	015b      	lsls	r3, r3, #5
 80020a4:	581a      	ldr	r2, [r3, r0]
 80020a6:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80020aa:	501a      	str	r2, [r3, r0]
  }
  return HAL_OK;
}
 80020ac:	2000      	movs	r0, #0
 80020ae:	bc30      	pop	{r4, r5}
 80020b0:	4770      	bx	lr
    if (ep->xfer_len == 0U)
 80020b2:	694b      	ldr	r3, [r1, #20]
 80020b4:	bb73      	cbnz	r3, 8002114 <USB_EP0StartXfer+0xcc>
 80020b6:	f500 6310 	add.w	r3, r0, #2304	; 0x900
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 80020ba:	780d      	ldrb	r5, [r1, #0]
 80020bc:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 80020c0:	692c      	ldr	r4, [r5, #16]
 80020c2:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 80020c6:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 80020ca:	612c      	str	r4, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 80020cc:	780c      	ldrb	r4, [r1, #0]
 80020ce:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 80020d2:	6925      	ldr	r5, [r4, #16]
 80020d4:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 80020d8:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 80020da:	780c      	ldrb	r4, [r1, #0]
 80020dc:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 80020e0:	691c      	ldr	r4, [r3, #16]
 80020e2:	0ce4      	lsrs	r4, r4, #19
 80020e4:	04e4      	lsls	r4, r4, #19
 80020e6:	611c      	str	r4, [r3, #16]
 80020e8:	f500 6510 	add.w	r5, r0, #2304	; 0x900
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);     
 80020ec:	780b      	ldrb	r3, [r1, #0]
 80020ee:	015b      	lsls	r3, r3, #5
 80020f0:	595c      	ldr	r4, [r3, r5]
 80020f2:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80020f6:	515c      	str	r4, [r3, r5]
    if (dma == 1)
 80020f8:	2a01      	cmp	r2, #1
 80020fa:	d033      	beq.n	8002164 <USB_EP0StartXfer+0x11c>
      if (ep->xfer_len > 0U)
 80020fc:	694b      	ldr	r3, [r1, #20]
 80020fe:	2b00      	cmp	r3, #0
 8002100:	d0d4      	beq.n	80020ac <USB_EP0StartXfer+0x64>
        USBx_DEVICE->DIEPEMPMSK |= 1U << (ep->num);
 8002102:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 8002106:	7809      	ldrb	r1, [r1, #0]
 8002108:	2301      	movs	r3, #1
 800210a:	408b      	lsls	r3, r1
 800210c:	4313      	orrs	r3, r2
 800210e:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
 8002112:	e7cb      	b.n	80020ac <USB_EP0StartXfer+0x64>
 8002114:	f500 6310 	add.w	r3, r0, #2304	; 0x900
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8002118:	780d      	ldrb	r5, [r1, #0]
 800211a:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 800211e:	692c      	ldr	r4, [r5, #16]
 8002120:	0ce4      	lsrs	r4, r4, #19
 8002122:	04e4      	lsls	r4, r4, #19
 8002124:	612c      	str	r4, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8002126:	780d      	ldrb	r5, [r1, #0]
 8002128:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 800212c:	692c      	ldr	r4, [r5, #16]
 800212e:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 8002132:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 8002136:	612c      	str	r4, [r5, #16]
      if(ep->xfer_len > ep->maxpacket)
 8002138:	688c      	ldr	r4, [r1, #8]
 800213a:	694d      	ldr	r5, [r1, #20]
 800213c:	42a5      	cmp	r5, r4
        ep->xfer_len = ep->maxpacket;
 800213e:	bf88      	it	hi
 8002140:	614c      	strhi	r4, [r1, #20]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8002142:	780c      	ldrb	r4, [r1, #0]
 8002144:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8002148:	6925      	ldr	r5, [r4, #16]
 800214a:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800214e:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8002150:	780c      	ldrb	r4, [r1, #0]
 8002152:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8002156:	691d      	ldr	r5, [r3, #16]
 8002158:	694c      	ldr	r4, [r1, #20]
 800215a:	f3c4 0412 	ubfx	r4, r4, #0, #19
 800215e:	432c      	orrs	r4, r5
 8002160:	611c      	str	r4, [r3, #16]
 8002162:	e7c1      	b.n	80020e8 <USB_EP0StartXfer+0xa0>
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8002164:	780b      	ldrb	r3, [r1, #0]
 8002166:	eb05 1543 	add.w	r5, r5, r3, lsl #5
 800216a:	690b      	ldr	r3, [r1, #16]
 800216c:	616b      	str	r3, [r5, #20]
 800216e:	e79d      	b.n	80020ac <USB_EP0StartXfer+0x64>
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 8002170:	780b      	ldrb	r3, [r1, #0]
 8002172:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 8002176:	68ca      	ldr	r2, [r1, #12]
 8002178:	615a      	str	r2, [r3, #20]
 800217a:	e791      	b.n	80020a0 <USB_EP0StartXfer+0x58>

0800217c <USB_WritePacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 800217c:	b410      	push	{r4}
 800217e:	f89d 4004 	ldrb.w	r4, [sp, #4]
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
 8002182:	b96c      	cbnz	r4, 80021a0 <USB_WritePacket+0x24>
  {
    count32b =  (len + 3U) / 4U;
 8002184:	1cdc      	adds	r4, r3, #3
    for (i = 0U; i < count32b; i++, src += 4U)
 8002186:	08a4      	lsrs	r4, r4, #2
 8002188:	d00a      	beq.n	80021a0 <USB_WritePacket+0x24>
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 800218a:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 800218e:	eb00 3202 	add.w	r2, r0, r2, lsl #12
 8002192:	2300      	movs	r3, #0
 8002194:	f851 0b04 	ldr.w	r0, [r1], #4
 8002198:	6010      	str	r0, [r2, #0]
    for (i = 0U; i < count32b; i++, src += 4U)
 800219a:	3301      	adds	r3, #1
 800219c:	429c      	cmp	r4, r3
 800219e:	d1f9      	bne.n	8002194 <USB_WritePacket+0x18>
    }
  }
  return HAL_OK;
}
 80021a0:	2000      	movs	r0, #0
 80021a2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80021a6:	4770      	bx	lr

080021a8 <USB_ReadPacket>:
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
  uint32_t i=0U;
  uint32_t count32b = (len + 3U) / 4U;
 80021a8:	3203      	adds	r2, #3
  
  for ( i = 0U; i < count32b; i++, dest += 4U )
 80021aa:	0892      	lsrs	r2, r2, #2
 80021ac:	d00f      	beq.n	80021ce <USB_ReadPacket+0x26>
{
 80021ae:	b470      	push	{r4, r5, r6}
  for ( i = 0U; i < count32b; i++, dest += 4U )
 80021b0:	460c      	mov	r4, r1
 80021b2:	2300      	movs	r3, #0
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0U);
 80021b4:	f500 5680 	add.w	r6, r0, #4096	; 0x1000
 80021b8:	6835      	ldr	r5, [r6, #0]
 80021ba:	f844 5b04 	str.w	r5, [r4], #4
  for ( i = 0U; i < count32b; i++, dest += 4U )
 80021be:	3301      	adds	r3, #1
 80021c0:	429a      	cmp	r2, r3
 80021c2:	d1f9      	bne.n	80021b8 <USB_ReadPacket+0x10>
 80021c4:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    
  }
  return ((void *)dest);
}
 80021c8:	4608      	mov	r0, r1
 80021ca:	bc70      	pop	{r4, r5, r6}
 80021cc:	4770      	bx	lr
 80021ce:	4608      	mov	r0, r1
 80021d0:	4770      	bx	lr

080021d2 <USB_EPSetStall>:
  * @param  ep pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 80021d2:	784b      	ldrb	r3, [r1, #1]
 80021d4:	2b01      	cmp	r3, #1
 80021d6:	d012      	beq.n	80021fe <USB_EPSetStall+0x2c>
 80021d8:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
    } 
    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0U)
 80021dc:	780b      	ldrb	r3, [r1, #0]
 80021de:	015b      	lsls	r3, r3, #5
 80021e0:	581a      	ldr	r2, [r3, r0]
 80021e2:	2a00      	cmp	r2, #0
 80021e4:	db03      	blt.n	80021ee <USB_EPSetStall+0x1c>
    {
      USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
 80021e6:	581a      	ldr	r2, [r3, r0]
 80021e8:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 80021ec:	501a      	str	r2, [r3, r0]
    } 
    USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 80021ee:	780b      	ldrb	r3, [r1, #0]
 80021f0:	015b      	lsls	r3, r3, #5
 80021f2:	581a      	ldr	r2, [r3, r0]
 80021f4:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80021f8:	501a      	str	r2, [r3, r0]
  }
  return HAL_OK;
}
 80021fa:	2000      	movs	r0, #0
 80021fc:	4770      	bx	lr
 80021fe:	f500 6010 	add.w	r0, r0, #2304	; 0x900
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0U)
 8002202:	780b      	ldrb	r3, [r1, #0]
 8002204:	015b      	lsls	r3, r3, #5
 8002206:	581a      	ldr	r2, [r3, r0]
 8002208:	2a00      	cmp	r2, #0
 800220a:	db03      	blt.n	8002214 <USB_EPSetStall+0x42>
      USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); 
 800220c:	581a      	ldr	r2, [r3, r0]
 800220e:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8002212:	501a      	str	r2, [r3, r0]
    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8002214:	780b      	ldrb	r3, [r1, #0]
 8002216:	015b      	lsls	r3, r3, #5
 8002218:	581a      	ldr	r2, [r3, r0]
 800221a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800221e:	501a      	str	r2, [r3, r0]
 8002220:	e7eb      	b.n	80021fa <USB_EPSetStall+0x28>

08002222 <USB_EPClearStall>:
  * @param  ep pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 8002222:	784b      	ldrb	r3, [r1, #1]
 8002224:	2b01      	cmp	r3, #1
 8002226:	d00e      	beq.n	8002246 <USB_EPClearStall+0x24>
 8002228:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }    
  }
  else
  {
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 800222c:	780b      	ldrb	r3, [r1, #0]
 800222e:	015b      	lsls	r3, r3, #5
 8002230:	581a      	ldr	r2, [r3, r0]
 8002232:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002236:	501a      	str	r2, [r3, r0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8002238:	78cb      	ldrb	r3, [r1, #3]
 800223a:	3b02      	subs	r3, #2
 800223c:	b2db      	uxtb	r3, r3
 800223e:	2b01      	cmp	r3, #1
 8002240:	d915      	bls.n	800226e <USB_EPClearStall+0x4c>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }    
  }
  return HAL_OK;
}
 8002242:	2000      	movs	r0, #0
 8002244:	4770      	bx	lr
 8002246:	f500 6010 	add.w	r0, r0, #2304	; 0x900
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800224a:	780b      	ldrb	r3, [r1, #0]
 800224c:	015b      	lsls	r3, r3, #5
 800224e:	581a      	ldr	r2, [r3, r0]
 8002250:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002254:	501a      	str	r2, [r3, r0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8002256:	78cb      	ldrb	r3, [r1, #3]
 8002258:	3b02      	subs	r3, #2
 800225a:	b2db      	uxtb	r3, r3
 800225c:	2b01      	cmp	r3, #1
 800225e:	d8f0      	bhi.n	8002242 <USB_EPClearStall+0x20>
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8002260:	780b      	ldrb	r3, [r1, #0]
 8002262:	015b      	lsls	r3, r3, #5
 8002264:	581a      	ldr	r2, [r3, r0]
 8002266:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800226a:	501a      	str	r2, [r3, r0]
 800226c:	e7e9      	b.n	8002242 <USB_EPClearStall+0x20>
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 800226e:	780b      	ldrb	r3, [r1, #0]
 8002270:	015b      	lsls	r3, r3, #5
 8002272:	581a      	ldr	r2, [r3, r0]
 8002274:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002278:	501a      	str	r2, [r3, r0]
 800227a:	e7e2      	b.n	8002242 <USB_EPClearStall+0x20>

0800227c <USB_SetDevAddress>:
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
  USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
 800227c:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8002280:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8002284:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= (address << 4U) & USB_OTG_DCFG_DAD ;
 8002288:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800228c:	0109      	lsls	r1, r1, #4
 800228e:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 8002292:	4319      	orrs	r1, r3
 8002294:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  
  return HAL_OK;  
}
 8002298:	2000      	movs	r0, #0
 800229a:	4770      	bx	lr

0800229c <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
{
 800229c:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
 800229e:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80022a2:	f023 0302 	bic.w	r3, r3, #2
 80022a6:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 80022aa:	2003      	movs	r0, #3
 80022ac:	f7fe f9d0 	bl	8000650 <HAL_Delay>
  
  return HAL_OK;  
}
 80022b0:	2000      	movs	r0, #0
 80022b2:	bd08      	pop	{r3, pc}

080022b4 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
 80022b4:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
 80022b6:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80022ba:	f043 0302 	orr.w	r3, r3, #2
 80022be:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 80022c2:	2003      	movs	r0, #3
 80022c4:	f7fe f9c4 	bl	8000650 <HAL_Delay>
  
  return HAL_OK;  
}
 80022c8:	2000      	movs	r0, #0
 80022ca:	bd08      	pop	{r3, pc}

080022cc <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v = 0U;
  
  v = USBx->GINTSTS;
 80022cc:	6942      	ldr	r2, [r0, #20]
  v &= USBx->GINTMSK;
 80022ce:	6980      	ldr	r0, [r0, #24]
  return v;  
}
 80022d0:	4010      	ands	r0, r2
 80022d2:	4770      	bx	lr

080022d4 <USB_ReadDevAllOutEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 80022d4:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 80022d8:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  v &= USBx_DEVICE->DAINTMSK;
 80022dc:	69c0      	ldr	r0, [r0, #28]
 80022de:	4018      	ands	r0, r3
  return ((v & 0xffff0000U) >> 16U);
}
 80022e0:	0c00      	lsrs	r0, r0, #16
 80022e2:	4770      	bx	lr

080022e4 <USB_ReadDevAllInEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 80022e4:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 80022e8:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  v &= USBx_DEVICE->DAINTMSK;
 80022ec:	69c0      	ldr	r0, [r0, #28]
 80022ee:	4018      	ands	r0, r3
  return ((v & 0xFFFFU));
}
 80022f0:	b280      	uxth	r0, r0
 80022f2:	4770      	bx	lr

080022f4 <USB_ReadDevOutEPInterrupt>:
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 80022f4:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 80022f8:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 80022fc:	688a      	ldr	r2, [r1, #8]
  v &= USBx_DEVICE->DOEPMSK;
 80022fe:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 8002302:	6940      	ldr	r0, [r0, #20]
  return v;
}
 8002304:	4010      	ands	r0, r2
 8002306:	4770      	bx	lr

08002308 <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
 8002308:	b410      	push	{r4}
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
 800230a:	f8d0 4810 	ldr.w	r4, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 800230e:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  msk |= ((emp >> epnum) & 0x1U) << 7U;
  v = USBx_INEP(epnum)->DIEPINT & msk;
 8002312:	eb00 1041 	add.w	r0, r0, r1, lsl #5
 8002316:	f500 6010 	add.w	r0, r0, #2304	; 0x900
 800231a:	6880      	ldr	r0, [r0, #8]
  msk |= ((emp >> epnum) & 0x1U) << 7U;
 800231c:	40cb      	lsrs	r3, r1
 800231e:	01db      	lsls	r3, r3, #7
 8002320:	b2db      	uxtb	r3, r3
 8002322:	4323      	orrs	r3, r4
  return v;
}
 8002324:	4018      	ands	r0, r3
 8002326:	f85d 4b04 	ldr.w	r4, [sp], #4
 800232a:	4770      	bx	lr

0800232c <USB_GetMode>:
  *           0 : Host 
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
  return ((USBx->GINTSTS ) & 0x1U);
 800232c:	6940      	ldr	r0, [r0, #20]
}
 800232e:	f000 0001 	and.w	r0, r0, #1
 8002332:	4770      	bx	lr

08002334 <USB_ActivateSetup>:
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
{
  /* Set the MPS of the IN EP based on the enumeration speed */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8002334:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8002338:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 800233c:	f023 0307 	bic.w	r3, r3, #7
 8002340:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8002344:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8002348:	689a      	ldr	r2, [r3, #8]
 800234a:	f002 0206 	and.w	r2, r2, #6
 800234e:	2a04      	cmp	r2, #4
 8002350:	d005      	beq.n	800235e <USB_ActivateSetup+0x2a>
  {
    USBx_INEP(0U)->DIEPCTL |= 3U;
  }
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8002352:	685a      	ldr	r2, [r3, #4]
 8002354:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002358:	605a      	str	r2, [r3, #4]

  return HAL_OK;
}
 800235a:	2000      	movs	r0, #0
 800235c:	4770      	bx	lr
    USBx_INEP(0U)->DIEPCTL |= 3U;
 800235e:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 8002362:	f042 0203 	orr.w	r2, r2, #3
 8002366:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
 800236a:	e7f2      	b.n	8002352 <USB_ActivateSetup+0x1e>

0800236c <USB_EP0_OutStart>:
  *           1 : DMA feature used  
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
 800236c:	b410      	push	{r4}
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 800236e:	2400      	movs	r4, #0
 8002370:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
 8002374:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 8002378:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 800237c:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8002380:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 8002384:	f044 0418 	orr.w	r4, r4, #24
 8002388:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 800238c:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 8002390:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
 8002394:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1U)
 8002398:	2901      	cmp	r1, #1
 800239a:	d003      	beq.n	80023a4 <USB_EP0_OutStart+0x38>
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
  }
  
  return HAL_OK;  
}
 800239c:	2000      	movs	r0, #0
 800239e:	f85d 4b04 	ldr.w	r4, [sp], #4
 80023a2:	4770      	bx	lr
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 80023a4:	f8c0 2b14 	str.w	r2, [r0, #2836]	; 0xb14
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
 80023a8:	f04f 2380 	mov.w	r3, #2147516416	; 0x80008000
 80023ac:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 80023b0:	e7f4      	b.n	800239c <USB_EP0_OutStart+0x30>
	...

080023b4 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 80023b4:	4b0b      	ldr	r3, [pc, #44]	; (80023e4 <USB_CoreReset+0x30>)
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80023b6:	6902      	ldr	r2, [r0, #16]
 80023b8:	2a00      	cmp	r2, #0
 80023ba:	db03      	blt.n	80023c4 <USB_CoreReset+0x10>
    if (++count > 200000U)
 80023bc:	3b01      	subs	r3, #1
 80023be:	d1fa      	bne.n	80023b6 <USB_CoreReset+0x2>
      return HAL_TIMEOUT;
 80023c0:	2003      	movs	r0, #3
 80023c2:	4770      	bx	lr
  
  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 80023c4:	6903      	ldr	r3, [r0, #16]
 80023c6:	f043 0301 	orr.w	r3, r3, #1
 80023ca:	6103      	str	r3, [r0, #16]
 80023cc:	4b05      	ldr	r3, [pc, #20]	; (80023e4 <USB_CoreReset+0x30>)
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 80023ce:	6902      	ldr	r2, [r0, #16]
 80023d0:	f012 0f01 	tst.w	r2, #1
 80023d4:	d003      	beq.n	80023de <USB_CoreReset+0x2a>
    if (++count > 200000U)
 80023d6:	3b01      	subs	r3, #1
 80023d8:	d1f9      	bne.n	80023ce <USB_CoreReset+0x1a>
      return HAL_TIMEOUT;
 80023da:	2003      	movs	r0, #3
  
  return HAL_OK;
}
 80023dc:	4770      	bx	lr
  return HAL_OK;
 80023de:	2000      	movs	r0, #0
 80023e0:	4770      	bx	lr
 80023e2:	bf00      	nop
 80023e4:	00030d40 	.word	0x00030d40

080023e8 <usbd_rndis_sof>:
// Start Of Frame event management
static uint8_t usbd_rndis_sof(USBD_HandleTypeDef *pdev)
{
  //rndis_send();
  return USBD_OK;
}
 80023e8:	2000      	movs	r0, #0
 80023ea:	4770      	bx	lr

080023ec <rndis_iso_in_incomplete>:

static uint8_t rndis_iso_in_incomplete(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 80023ec:	2000      	movs	r0, #0
 80023ee:	4770      	bx	lr

080023f0 <rndis_iso_out_incomplete>:

static uint8_t rndis_iso_out_incomplete(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 80023f0:	2000      	movs	r0, #0
 80023f2:	4770      	bx	lr

080023f4 <usbd_rndis_GetDeviceQualifierDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
static uint8_t  *usbd_rndis_GetDeviceQualifierDesc (uint16_t *length)
{
  *length = sizeof (USBD_DeviceQualifierDesc);
 80023f4:	230a      	movs	r3, #10
 80023f6:	8003      	strh	r3, [r0, #0]
  return USBD_DeviceQualifierDesc;
}
 80023f8:	4800      	ldr	r0, [pc, #0]	; (80023fc <usbd_rndis_GetDeviceQualifierDesc+0x8>)
 80023fa:	4770      	bx	lr
 80023fc:	20000008 	.word	0x20000008

08002400 <usbd_rndis_GetCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *usbd_rndis_GetCfgDesc (uint16_t *length)
{
  *length = sizeof (usbd_rndis_CfgDesc);
 8002400:	2343      	movs	r3, #67	; 0x43
 8002402:	8003      	strh	r3, [r0, #0]
  return usbd_rndis_CfgDesc;
}
 8002404:	4800      	ldr	r0, [pc, #0]	; (8002408 <usbd_rndis_GetCfgDesc+0x8>)
 8002406:	4770      	bx	lr
 8002408:	2000005c 	.word	0x2000005c

0800240c <usbd_rndis_setup>:
{
 800240c:	b508      	push	{r3, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800240e:	780b      	ldrb	r3, [r1, #0]
 8002410:	f003 0260 	and.w	r2, r3, #96	; 0x60
 8002414:	2a20      	cmp	r2, #32
 8002416:	d107      	bne.n	8002428 <usbd_rndis_setup+0x1c>
    if (req->wLength != 0) // is data setup packet?
 8002418:	88ca      	ldrh	r2, [r1, #6]
 800241a:	b12a      	cbz	r2, 8002428 <usbd_rndis_setup+0x1c>
      if (req->bmRequest & 0x80)
 800241c:	f013 0f80 	tst.w	r3, #128	; 0x80
 8002420:	d104      	bne.n	800242c <usbd_rndis_setup+0x20>
        USBD_CtlPrepareRx (pdev,
 8002422:	4905      	ldr	r1, [pc, #20]	; (8002438 <usbd_rndis_setup+0x2c>)
 8002424:	f000 ff7c 	bl	8003320 <USBD_CtlPrepareRx>
}
 8002428:	2000      	movs	r0, #0
 800242a:	bd08      	pop	{r3, pc}
                          ((rndis_generic_msg_t *)encapsulated_buffer)->MessageLength);
 800242c:	4902      	ldr	r1, [pc, #8]	; (8002438 <usbd_rndis_setup+0x2c>)
 800242e:	684a      	ldr	r2, [r1, #4]
        USBD_CtlSendData (pdev,
 8002430:	b292      	uxth	r2, r2
 8002432:	f000 ff60 	bl	80032f6 <USBD_CtlSendData>
 8002436:	e7f7      	b.n	8002428 <usbd_rndis_setup+0x1c>
 8002438:	200078b8 	.word	0x200078b8

0800243c <usbd_rndis_deinit>:
{
 800243c:	b510      	push	{r4, lr}
 800243e:	4604      	mov	r4, r0
  USBD_LL_CloseEP(pdev,
 8002440:	2181      	movs	r1, #129	; 0x81
 8002442:	f001 fb2a 	bl	8003a9a <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev,
 8002446:	2182      	movs	r1, #130	; 0x82
 8002448:	4620      	mov	r0, r4
 800244a:	f001 fb26 	bl	8003a9a <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev,
 800244e:	2103      	movs	r1, #3
 8002450:	4620      	mov	r0, r4
 8002452:	f001 fb22 	bl	8003a9a <USBD_LL_CloseEP>
}
 8002456:	2000      	movs	r0, #0
 8002458:	bd10      	pop	{r4, pc}

0800245a <rndis_initialized_cb>:
{
 800245a:	4770      	bx	lr

0800245c <rndis_rx_start>:
  if (rndis_rx_started)
 800245c:	4b0a      	ldr	r3, [pc, #40]	; (8002488 <rndis_rx_start+0x2c>)
 800245e:	781b      	ldrb	r3, [r3, #0]
 8002460:	b10b      	cbz	r3, 8002466 <rndis_rx_start+0xa>
    return false;
 8002462:	2000      	movs	r0, #0
 8002464:	4770      	bx	lr
{
 8002466:	b510      	push	{r4, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002468:	b672      	cpsid	i
  rndis_rx_started = true;
 800246a:	2401      	movs	r4, #1
 800246c:	4b06      	ldr	r3, [pc, #24]	; (8002488 <rndis_rx_start+0x2c>)
 800246e:	701c      	strb	r4, [r3, #0]
  USBD_LL_PrepareReceive(pDev,
 8002470:	f240 6316 	movw	r3, #1558	; 0x616
 8002474:	4a05      	ldr	r2, [pc, #20]	; (800248c <rndis_rx_start+0x30>)
 8002476:	2103      	movs	r1, #3
 8002478:	4805      	ldr	r0, [pc, #20]	; (8002490 <rndis_rx_start+0x34>)
 800247a:	6800      	ldr	r0, [r0, #0]
 800247c:	f001 fb65 	bl	8003b4a <USBD_LL_PrepareReceive>
  __ASM volatile ("cpsie i" : : : "memory");
 8002480:	b662      	cpsie	i
  return true;
 8002482:	4620      	mov	r0, r4
 8002484:	bd10      	pop	{r4, pc}
 8002486:	bf00      	nop
 8002488:	200001b2 	.word	0x200001b2
 800248c:	200072a0 	.word	0x200072a0
 8002490:	20007930 	.word	0x20007930

08002494 <usbd_rndis_init>:
{
 8002494:	b510      	push	{r4, lr}
 8002496:	4604      	mov	r4, r0
  USBD_LL_OpenEP(pdev,
 8002498:	2308      	movs	r3, #8
 800249a:	2203      	movs	r2, #3
 800249c:	2181      	movs	r1, #129	; 0x81
 800249e:	f001 faec 	bl	8003a7a <USBD_LL_OpenEP>
  USBD_LL_OpenEP(pdev,
 80024a2:	2340      	movs	r3, #64	; 0x40
 80024a4:	2202      	movs	r2, #2
 80024a6:	2182      	movs	r1, #130	; 0x82
 80024a8:	4620      	mov	r0, r4
 80024aa:	f001 fae6 	bl	8003a7a <USBD_LL_OpenEP>
  USBD_LL_OpenEP(pdev,
 80024ae:	2340      	movs	r3, #64	; 0x40
 80024b0:	2202      	movs	r2, #2
 80024b2:	2103      	movs	r1, #3
 80024b4:	4620      	mov	r0, r4
 80024b6:	f001 fae0 	bl	8003a7a <USBD_LL_OpenEP>
  pDev = pdev;
 80024ba:	4b03      	ldr	r3, [pc, #12]	; (80024c8 <usbd_rndis_init+0x34>)
 80024bc:	601c      	str	r4, [r3, #0]
  rndis_rx_start();
 80024be:	f7ff ffcd 	bl	800245c <rndis_rx_start>
}
 80024c2:	2000      	movs	r0, #0
 80024c4:	bd10      	pop	{r4, pc}
 80024c6:	bf00      	nop
 80024c8:	20007930 	.word	0x20007930

080024cc <rndis_rx_size>:
  if (!rndis_rx_started)
 80024cc:	4b03      	ldr	r3, [pc, #12]	; (80024dc <rndis_rx_size+0x10>)
 80024ce:	781b      	ldrb	r3, [r3, #0]
 80024d0:	b913      	cbnz	r3, 80024d8 <rndis_rx_size+0xc>
    return rndis_rx_data_size;
 80024d2:	4b03      	ldr	r3, [pc, #12]	; (80024e0 <rndis_rx_size+0x14>)
 80024d4:	8818      	ldrh	r0, [r3, #0]
 80024d6:	4770      	bx	lr
    return 0;
 80024d8:	2000      	movs	r0, #0
}
 80024da:	4770      	bx	lr
 80024dc:	200001b2 	.word	0x200001b2
 80024e0:	200001b0 	.word	0x200001b0

080024e4 <rndis_rx_data>:
{
 80024e4:	b508      	push	{r3, lr}
  if (rndis_rx_size())
 80024e6:	f7ff fff1 	bl	80024cc <rndis_rx_size>
 80024ea:	2800      	cmp	r0, #0
}
 80024ec:	4801      	ldr	r0, [pc, #4]	; (80024f4 <rndis_rx_data+0x10>)
 80024ee:	bf08      	it	eq
 80024f0:	2000      	moveq	r0, #0
 80024f2:	bd08      	pop	{r3, pc}
 80024f4:	200072cc 	.word	0x200072cc

080024f8 <rndis_rx_ready_cb>:
{
 80024f8:	4770      	bx	lr
	...

080024fc <rndis_tx_start>:
{
 80024fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((rndis_tx_transmitting) || (size > ETH_MAX_PACKET_SIZE) || (size == 0))
 80024fe:	4b25      	ldr	r3, [pc, #148]	; (8002594 <rndis_tx_start+0x98>)
 8002500:	781b      	ldrb	r3, [r3, #0]
 8002502:	b92b      	cbnz	r3, 8002510 <rndis_tx_start+0x14>
 8002504:	1e4b      	subs	r3, r1, #1
 8002506:	b29b      	uxth	r3, r3
 8002508:	f240 52e9 	movw	r2, #1513	; 0x5e9
 800250c:	4293      	cmp	r3, r2
 800250e:	d905      	bls.n	800251c <rndis_tx_start+0x20>
    usb_eth_stat.txbad++;
 8002510:	4a21      	ldr	r2, [pc, #132]	; (8002598 <rndis_tx_start+0x9c>)
 8002512:	6893      	ldr	r3, [r2, #8]
 8002514:	3301      	adds	r3, #1
 8002516:	6093      	str	r3, [r2, #8]
    return false;
 8002518:	2000      	movs	r0, #0
 800251a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800251c:	460c      	mov	r4, r1
 800251e:	4605      	mov	r5, r0
  rndis_tx_transmitting = true;
 8002520:	2701      	movs	r7, #1
 8002522:	4b1c      	ldr	r3, [pc, #112]	; (8002594 <rndis_tx_start+0x98>)
 8002524:	701f      	strb	r7, [r3, #0]
  rndis_tx_ptr = data;
 8002526:	4b1d      	ldr	r3, [pc, #116]	; (800259c <rndis_tx_start+0xa0>)
 8002528:	6018      	str	r0, [r3, #0]
  rndis_tx_data_size = size;
 800252a:	4b1d      	ldr	r3, [pc, #116]	; (80025a0 <rndis_tx_start+0xa4>)
 800252c:	8019      	strh	r1, [r3, #0]
  memset(hdr, 0, RNDIS_HEADER_SIZE);
 800252e:	4e1d      	ldr	r6, [pc, #116]	; (80025a4 <rndis_tx_start+0xa8>)
 8002530:	222c      	movs	r2, #44	; 0x2c
 8002532:	2100      	movs	r1, #0
 8002534:	4630      	mov	r0, r6
 8002536:	f006 fcb5 	bl	8008ea4 <memset>
  hdr->MessageType = REMOTE_NDIS_PACKET_MSG;
 800253a:	6037      	str	r7, [r6, #0]
  hdr->MessageLength = RNDIS_HEADER_SIZE + size;
 800253c:	f104 072c 	add.w	r7, r4, #44	; 0x2c
 8002540:	6077      	str	r7, [r6, #4]
  hdr->DataOffset = RNDIS_HEADER_SIZE - offsetof(rndis_data_packet_t, DataOffset);
 8002542:	2324      	movs	r3, #36	; 0x24
 8002544:	60b3      	str	r3, [r6, #8]
  hdr->DataLength = size;
 8002546:	60f4      	str	r4, [r6, #12]
  if (sended > size)
 8002548:	2c13      	cmp	r4, #19
 800254a:	bf94      	ite	ls
 800254c:	4621      	movls	r1, r4
 800254e:	2114      	movhi	r1, #20
  memcpy(first + RNDIS_HEADER_SIZE, data, sended);
 8002550:	b2ce      	uxtb	r6, r1
 8002552:	4632      	mov	r2, r6
 8002554:	4629      	mov	r1, r5
 8002556:	4814      	ldr	r0, [pc, #80]	; (80025a8 <rndis_tx_start+0xac>)
 8002558:	f006 fc99 	bl	8008e8e <memcpy>
  rndis_tx_ptr += sended;
 800255c:	4435      	add	r5, r6
 800255e:	4b0f      	ldr	r3, [pc, #60]	; (800259c <rndis_tx_start+0xa0>)
 8002560:	601d      	str	r5, [r3, #0]
  rndis_tx_data_size -= sended;
 8002562:	1ba1      	subs	r1, r4, r6
 8002564:	4b0e      	ldr	r3, [pc, #56]	; (80025a0 <rndis_tx_start+0xa4>)
 8002566:	8019      	strh	r1, [r3, #0]
  if (hdr->MessageLength % RNDIS_DATA_IN_SZ == 0)
 8002568:	f017 0f3f 	tst.w	r7, #63	; 0x3f
 800256c:	d102      	bne.n	8002574 <rndis_tx_start+0x78>
    rndis_tx_ZLP = true;
 800256e:	2201      	movs	r2, #1
 8002570:	4b0e      	ldr	r3, [pc, #56]	; (80025ac <rndis_tx_start+0xb0>)
 8002572:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 8002574:	b672      	cpsid	i
  USBD_LL_Transmit (pDev,
 8002576:	2340      	movs	r3, #64	; 0x40
 8002578:	4a0a      	ldr	r2, [pc, #40]	; (80025a4 <rndis_tx_start+0xa8>)
 800257a:	2182      	movs	r1, #130	; 0x82
 800257c:	480c      	ldr	r0, [pc, #48]	; (80025b0 <rndis_tx_start+0xb4>)
 800257e:	6800      	ldr	r0, [r0, #0]
 8002580:	f001 fad6 	bl	8003b30 <USBD_LL_Transmit>
  __ASM volatile ("cpsie i" : : : "memory");
 8002584:	b662      	cpsie	i
  usb_eth_stat.txbad++;
 8002586:	4a04      	ldr	r2, [pc, #16]	; (8002598 <rndis_tx_start+0x9c>)
 8002588:	6893      	ldr	r3, [r2, #8]
 800258a:	3301      	adds	r3, #1
 800258c:	6093      	str	r3, [r2, #8]
  return true;
 800258e:	2001      	movs	r0, #1
}
 8002590:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002592:	bf00      	nop
 8002594:	200001bc 	.word	0x200001bc
 8002598:	200001c0 	.word	0x200001c0
 800259c:	200001b8 	.word	0x200001b8
 80025a0:	200001b6 	.word	0x200001b6
 80025a4:	2000016c 	.word	0x2000016c
 80025a8:	20000198 	.word	0x20000198
 80025ac:	200001b4 	.word	0x200001b4
 80025b0:	20007930 	.word	0x20007930

080025b4 <rndis_tx_started>:
}
 80025b4:	4b01      	ldr	r3, [pc, #4]	; (80025bc <rndis_tx_started+0x8>)
 80025b6:	7818      	ldrb	r0, [r3, #0]
 80025b8:	4770      	bx	lr
 80025ba:	bf00      	nop
 80025bc:	200001bc 	.word	0x200001bc

080025c0 <rndis_tx_ready_cb>:
{
 80025c0:	4770      	bx	lr
	...

080025c4 <usbd_rndis_data_in>:
  if (epnum == (RNDIS_DATA_IN_EP & 0x0F))
 80025c4:	f001 010f 	and.w	r1, r1, #15
 80025c8:	2902      	cmp	r1, #2
 80025ca:	d001      	beq.n	80025d0 <usbd_rndis_data_in+0xc>
}
 80025cc:	2000      	movs	r0, #0
 80025ce:	4770      	bx	lr
{
 80025d0:	b508      	push	{r3, lr}
    if (rndis_tx_data_size && rndis_tx_ptr)
 80025d2:	4b14      	ldr	r3, [pc, #80]	; (8002624 <usbd_rndis_data_in+0x60>)
 80025d4:	881b      	ldrh	r3, [r3, #0]
 80025d6:	b15b      	cbz	r3, 80025f0 <usbd_rndis_data_in+0x2c>
 80025d8:	4a13      	ldr	r2, [pc, #76]	; (8002628 <usbd_rndis_data_in+0x64>)
 80025da:	6812      	ldr	r2, [r2, #0]
 80025dc:	b142      	cbz	r2, 80025f0 <usbd_rndis_data_in+0x2c>
      USBD_LL_Transmit (pdev,
 80025de:	2182      	movs	r1, #130	; 0x82
 80025e0:	f001 faa6 	bl	8003b30 <USBD_LL_Transmit>
      rndis_tx_data_size = 0;
 80025e4:	2300      	movs	r3, #0
 80025e6:	4a0f      	ldr	r2, [pc, #60]	; (8002624 <usbd_rndis_data_in+0x60>)
 80025e8:	8013      	strh	r3, [r2, #0]
      rndis_tx_ptr = NULL;
 80025ea:	4a0f      	ldr	r2, [pc, #60]	; (8002628 <usbd_rndis_data_in+0x64>)
 80025ec:	6013      	str	r3, [r2, #0]
 80025ee:	e00e      	b.n	800260e <usbd_rndis_data_in+0x4a>
      if (rndis_tx_ZLP)
 80025f0:	4b0e      	ldr	r3, [pc, #56]	; (800262c <usbd_rndis_data_in+0x68>)
 80025f2:	781b      	ldrb	r3, [r3, #0]
 80025f4:	b96b      	cbnz	r3, 8002612 <usbd_rndis_data_in+0x4e>
        usb_eth_stat.txbad--;
 80025f6:	4b0e      	ldr	r3, [pc, #56]	; (8002630 <usbd_rndis_data_in+0x6c>)
 80025f8:	689a      	ldr	r2, [r3, #8]
 80025fa:	3a01      	subs	r2, #1
 80025fc:	609a      	str	r2, [r3, #8]
        usb_eth_stat.txok++;
 80025fe:	681a      	ldr	r2, [r3, #0]
 8002600:	3201      	adds	r2, #1
 8002602:	601a      	str	r2, [r3, #0]
        rndis_tx_transmitting = false;
 8002604:	2200      	movs	r2, #0
 8002606:	4b0b      	ldr	r3, [pc, #44]	; (8002634 <usbd_rndis_data_in+0x70>)
 8002608:	701a      	strb	r2, [r3, #0]
        rndis_tx_ready_cb();
 800260a:	f7ff ffd9 	bl	80025c0 <rndis_tx_ready_cb>
}
 800260e:	2000      	movs	r0, #0
 8002610:	bd08      	pop	{r3, pc}
        USBD_LL_Transmit (pdev,
 8002612:	2300      	movs	r3, #0
 8002614:	461a      	mov	r2, r3
 8002616:	2182      	movs	r1, #130	; 0x82
 8002618:	f001 fa8a 	bl	8003b30 <USBD_LL_Transmit>
        rndis_tx_ZLP = false;
 800261c:	2200      	movs	r2, #0
 800261e:	4b03      	ldr	r3, [pc, #12]	; (800262c <usbd_rndis_data_in+0x68>)
 8002620:	701a      	strb	r2, [r3, #0]
 8002622:	e7f4      	b.n	800260e <usbd_rndis_data_in+0x4a>
 8002624:	200001b6 	.word	0x200001b6
 8002628:	200001b8 	.word	0x200001b8
 800262c:	200001b4 	.word	0x200001b4
 8002630:	200001c0 	.word	0x200001c0
 8002634:	200001bc 	.word	0x200001bc

08002638 <handle_packet>:
{
 8002638:	b508      	push	{r3, lr}
  if (size < RNDIS_HEADER_SIZE)
 800263a:	292b      	cmp	r1, #43	; 0x2b
 800263c:	d907      	bls.n	800264e <handle_packet+0x16>
  if ((pheader->MessageType != REMOTE_NDIS_PACKET_MSG) ||
 800263e:	6803      	ldr	r3, [r0, #0]
 8002640:	2b01      	cmp	r3, #1
 8002642:	d009      	beq.n	8002658 <handle_packet+0x20>
    usb_eth_stat.rxbad++;
 8002644:	4a17      	ldr	r2, [pc, #92]	; (80026a4 <handle_packet+0x6c>)
 8002646:	68d3      	ldr	r3, [r2, #12]
 8002648:	3301      	adds	r3, #1
 800264a:	60d3      	str	r3, [r2, #12]
    return;
 800264c:	bd08      	pop	{r3, pc}
    usb_eth_stat.rxbad++;
 800264e:	4a15      	ldr	r2, [pc, #84]	; (80026a4 <handle_packet+0x6c>)
 8002650:	68d3      	ldr	r3, [r2, #12]
 8002652:	3301      	adds	r3, #1
 8002654:	60d3      	str	r3, [r2, #12]
    return;
 8002656:	bd08      	pop	{r3, pc}
      ((pheader->MessageLength != size) && (pheader->MessageLength != size - 1)))
 8002658:	6842      	ldr	r2, [r0, #4]
  if ((pheader->MessageType != REMOTE_NDIS_PACKET_MSG) ||
 800265a:	4291      	cmp	r1, r2
 800265c:	d002      	beq.n	8002664 <handle_packet+0x2c>
      ((pheader->MessageLength != size) && (pheader->MessageLength != size - 1)))
 800265e:	3901      	subs	r1, #1
 8002660:	428a      	cmp	r2, r1
 8002662:	d1ef      	bne.n	8002644 <handle_packet+0xc>
  if (pheader->DataOffset + offsetof(rndis_data_packet_t, DataOffset) + pheader->DataLength != size)
 8002664:	68c1      	ldr	r1, [r0, #12]
 8002666:	6883      	ldr	r3, [r0, #8]
 8002668:	440b      	add	r3, r1
 800266a:	3308      	adds	r3, #8
 800266c:	429a      	cmp	r2, r3
 800266e:	d004      	beq.n	800267a <handle_packet+0x42>
    usb_eth_stat.rxbad++;
 8002670:	4a0c      	ldr	r2, [pc, #48]	; (80026a4 <handle_packet+0x6c>)
 8002672:	68d3      	ldr	r3, [r2, #12]
 8002674:	3301      	adds	r3, #1
 8002676:	60d3      	str	r3, [r2, #12]
    return;
 8002678:	bd08      	pop	{r3, pc}
  if (!rndis_rx_started)
 800267a:	4b0b      	ldr	r3, [pc, #44]	; (80026a8 <handle_packet+0x70>)
 800267c:	781b      	ldrb	r3, [r3, #0]
 800267e:	b923      	cbnz	r3, 800268a <handle_packet+0x52>
    usb_eth_stat.rxbad++;
 8002680:	4a08      	ldr	r2, [pc, #32]	; (80026a4 <handle_packet+0x6c>)
 8002682:	68d3      	ldr	r3, [r2, #12]
 8002684:	3301      	adds	r3, #1
 8002686:	60d3      	str	r3, [r2, #12]
    return;
 8002688:	bd08      	pop	{r3, pc}
  rndis_rx_data_size = pheader->DataLength;
 800268a:	4b08      	ldr	r3, [pc, #32]	; (80026ac <handle_packet+0x74>)
 800268c:	8019      	strh	r1, [r3, #0]
  rndis_rx_started = false;
 800268e:	2200      	movs	r2, #0
 8002690:	4b05      	ldr	r3, [pc, #20]	; (80026a8 <handle_packet+0x70>)
 8002692:	701a      	strb	r2, [r3, #0]
  usb_eth_stat.rxok++;
 8002694:	4a03      	ldr	r2, [pc, #12]	; (80026a4 <handle_packet+0x6c>)
 8002696:	6853      	ldr	r3, [r2, #4]
 8002698:	3301      	adds	r3, #1
 800269a:	6053      	str	r3, [r2, #4]
  rndis_rx_ready_cb();
 800269c:	f7ff ff2c 	bl	80024f8 <rndis_rx_ready_cb>
 80026a0:	bd08      	pop	{r3, pc}
 80026a2:	bf00      	nop
 80026a4:	200001c0 	.word	0x200001c0
 80026a8:	200001b2 	.word	0x200001b2
 80026ac:	200001b0 	.word	0x200001b0

080026b0 <usbd_rndis_data_out>:
  if (epnum == RNDIS_DATA_OUT_EP)
 80026b0:	2903      	cmp	r1, #3
 80026b2:	d001      	beq.n	80026b8 <usbd_rndis_data_out+0x8>
}
 80026b4:	2000      	movs	r0, #0
 80026b6:	4770      	bx	lr
{
 80026b8:	b508      	push	{r3, lr}
    PCD_EPTypeDef *ep = &((PCD_HandleTypeDef*)pdev->pData)->OUT_ep[epnum];
 80026ba:	f8d0 3220 	ldr.w	r3, [r0, #544]	; 0x220
    handle_packet((rndis_data_packet_t*)rndis_rx_buffer, RNDIS_RX_BUFFER_SIZE - ep->xfer_len - RNDIS_DATA_OUT_SZ + ep->xfer_count);
 80026be:	f8d3 1264 	ldr.w	r1, [r3, #612]	; 0x264
 80026c2:	f201 51d6 	addw	r1, r1, #1494	; 0x5d6
 80026c6:	f8d3 3260 	ldr.w	r3, [r3, #608]	; 0x260
 80026ca:	1ac9      	subs	r1, r1, r3
 80026cc:	4802      	ldr	r0, [pc, #8]	; (80026d8 <usbd_rndis_data_out+0x28>)
 80026ce:	f7ff ffb3 	bl	8002638 <handle_packet>
}
 80026d2:	2000      	movs	r0, #0
 80026d4:	bd08      	pop	{r3, pc}
 80026d6:	bf00      	nop
 80026d8:	200072a0 	.word	0x200072a0

080026dc <response_available>:

void response_available(USBD_HandleTypeDef *pdev)
{
 80026dc:	b508      	push	{r3, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 80026de:	b672      	cpsid	i
  __disable_irq();
  USBD_LL_Transmit (pdev,
 80026e0:	2308      	movs	r3, #8
 80026e2:	4a03      	ldr	r2, [pc, #12]	; (80026f0 <response_available+0x14>)
 80026e4:	2181      	movs	r1, #129	; 0x81
 80026e6:	f001 fa23 	bl	8003b30 <USBD_LL_Transmit>
  __ASM volatile ("cpsie i" : : : "memory");
 80026ea:	b662      	cpsie	i
 80026ec:	bd08      	pop	{r3, pc}
 80026ee:	bf00      	nop
 80026f0:	08008ecc 	.word	0x08008ecc

080026f4 <rndis_query_cmplt32>:
{
 80026f4:	b570      	push	{r4, r5, r6, lr}
  c->MessageType = REMOTE_NDIS_QUERY_CMPLT;
 80026f6:	4b0e      	ldr	r3, [pc, #56]	; (8002730 <rndis_query_cmplt32+0x3c>)
 80026f8:	2400      	movs	r4, #0
 80026fa:	2504      	movs	r5, #4
 80026fc:	701d      	strb	r5, [r3, #0]
 80026fe:	705c      	strb	r4, [r3, #1]
 8002700:	709c      	strb	r4, [r3, #2]
 8002702:	f06f 067f 	mvn.w	r6, #127	; 0x7f
 8002706:	70de      	strb	r6, [r3, #3]
  c->MessageLength = sizeof(rndis_query_cmplt_t) + 4;
 8002708:	261c      	movs	r6, #28
 800270a:	711e      	strb	r6, [r3, #4]
 800270c:	715c      	strb	r4, [r3, #5]
 800270e:	719c      	strb	r4, [r3, #6]
 8002710:	71dc      	strb	r4, [r3, #7]
  c->InformationBufferLength = 4;
 8002712:	741d      	strb	r5, [r3, #16]
 8002714:	745c      	strb	r4, [r3, #17]
 8002716:	749c      	strb	r4, [r3, #18]
 8002718:	74dc      	strb	r4, [r3, #19]
  c->InformationBufferOffset = 16;
 800271a:	2510      	movs	r5, #16
 800271c:	751d      	strb	r5, [r3, #20]
 800271e:	755c      	strb	r4, [r3, #21]
 8002720:	759c      	strb	r4, [r3, #22]
 8002722:	75dc      	strb	r4, [r3, #23]
  c->Status = status;
 8002724:	60d9      	str	r1, [r3, #12]
  *(uint32_t *)(c + 1) = data;
 8002726:	619a      	str	r2, [r3, #24]
  response_available(pdev);
 8002728:	f7ff ffd8 	bl	80026dc <response_available>
 800272c:	bd70      	pop	{r4, r5, r6, pc}
 800272e:	bf00      	nop
 8002730:	200078b8 	.word	0x200078b8

08002734 <rndis_query_cmplt>:
{
 8002734:	b570      	push	{r4, r5, r6, lr}
 8002736:	4605      	mov	r5, r0
 8002738:	4616      	mov	r6, r2
  c->MessageType = REMOTE_NDIS_QUERY_CMPLT;
 800273a:	480e      	ldr	r0, [pc, #56]	; (8002774 <rndis_query_cmplt+0x40>)
 800273c:	2400      	movs	r4, #0
 800273e:	2204      	movs	r2, #4
 8002740:	7002      	strb	r2, [r0, #0]
 8002742:	7044      	strb	r4, [r0, #1]
 8002744:	7084      	strb	r4, [r0, #2]
 8002746:	f06f 027f 	mvn.w	r2, #127	; 0x7f
 800274a:	70c2      	strb	r2, [r0, #3]
  c->MessageLength = sizeof(rndis_query_cmplt_t) + size;
 800274c:	f103 0218 	add.w	r2, r3, #24
 8002750:	6042      	str	r2, [r0, #4]
  c->InformationBufferLength = size;
 8002752:	6103      	str	r3, [r0, #16]
  c->InformationBufferOffset = 16;
 8002754:	2210      	movs	r2, #16
 8002756:	7502      	strb	r2, [r0, #20]
 8002758:	7544      	strb	r4, [r0, #21]
 800275a:	7584      	strb	r4, [r0, #22]
 800275c:	75c4      	strb	r4, [r0, #23]
  c->Status = status;
 800275e:	60c1      	str	r1, [r0, #12]
  memcpy(c + 1, data, size);
 8002760:	461a      	mov	r2, r3
 8002762:	4631      	mov	r1, r6
 8002764:	3018      	adds	r0, #24
 8002766:	f006 fb92 	bl	8008e8e <memcpy>
  response_available(pdev);
 800276a:	4628      	mov	r0, r5
 800276c:	f7ff ffb6 	bl	80026dc <response_available>
 8002770:	bd70      	pop	{r4, r5, r6, pc}
 8002772:	bf00      	nop
 8002774:	200078b8 	.word	0x200078b8

08002778 <rndis_query>:
{
 8002778:	b508      	push	{r3, lr}
  switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 800277a:	4b88      	ldr	r3, [pc, #544]	; (800299c <rndis_query+0x224>)
 800277c:	68db      	ldr	r3, [r3, #12]
 800277e:	4a88      	ldr	r2, [pc, #544]	; (80029a0 <rndis_query+0x228>)
 8002780:	4293      	cmp	r3, r2
 8002782:	f000 8090 	beq.w	80028a6 <rndis_query+0x12e>
 8002786:	d919      	bls.n	80027bc <rndis_query+0x44>
 8002788:	f1b3 3f01 	cmp.w	r3, #16843009	; 0x1010101
 800278c:	f000 8091 	beq.w	80028b2 <rndis_query+0x13a>
 8002790:	d867      	bhi.n	8002862 <rndis_query+0xea>
 8002792:	4a84      	ldr	r2, [pc, #528]	; (80029a4 <rndis_query+0x22c>)
 8002794:	4293      	cmp	r3, r2
 8002796:	f000 80ee 	beq.w	8002976 <rndis_query+0x1fe>
 800279a:	d854      	bhi.n	8002846 <rndis_query+0xce>
 800279c:	4a82      	ldr	r2, [pc, #520]	; (80029a8 <rndis_query+0x230>)
 800279e:	4293      	cmp	r3, r2
 80027a0:	f000 80c0 	beq.w	8002924 <rndis_query+0x1ac>
 80027a4:	4a81      	ldr	r2, [pc, #516]	; (80029ac <rndis_query+0x234>)
 80027a6:	4293      	cmp	r3, r2
 80027a8:	f000 80df 	beq.w	800296a <rndis_query+0x1f2>
 80027ac:	4a80      	ldr	r2, [pc, #512]	; (80029b0 <rndis_query+0x238>)
 80027ae:	4293      	cmp	r3, r2
 80027b0:	d128      	bne.n	8002804 <rndis_query+0x8c>
  case OID_GEN_PHYSICAL_MEDIUM:        rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, NDIS_MEDIUM_802_3); return;
 80027b2:	2200      	movs	r2, #0
 80027b4:	4611      	mov	r1, r2
 80027b6:	f7ff ff9d 	bl	80026f4 <rndis_query_cmplt32>
 80027ba:	bd08      	pop	{r3, pc}
  switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 80027bc:	3a0c      	subs	r2, #12
 80027be:	4293      	cmp	r3, r2
 80027c0:	f000 80a5 	beq.w	800290e <rndis_query+0x196>
 80027c4:	d910      	bls.n	80027e8 <rndis_query+0x70>
 80027c6:	4a7b      	ldr	r2, [pc, #492]	; (80029b4 <rndis_query+0x23c>)
 80027c8:	4293      	cmp	r3, r2
 80027ca:	f000 8094 	beq.w	80028f6 <rndis_query+0x17e>
 80027ce:	d82a      	bhi.n	8002826 <rndis_query+0xae>
 80027d0:	3a02      	subs	r2, #2
 80027d2:	4293      	cmp	r3, r2
 80027d4:	f000 8083 	beq.w	80028de <rndis_query+0x166>
 80027d8:	f200 8087 	bhi.w	80028ea <rndis_query+0x172>
  case OID_GEN_RECEIVE_BLOCK_SIZE:     rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, ETH_MAX_PACKET_SIZE); return;
 80027dc:	f240 52ea 	movw	r2, #1514	; 0x5ea
 80027e0:	2100      	movs	r1, #0
 80027e2:	f7ff ff87 	bl	80026f4 <rndis_query_cmplt32>
 80027e6:	bd08      	pop	{r3, pc}
  switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 80027e8:	3a07      	subs	r2, #7
 80027ea:	4293      	cmp	r3, r2
 80027ec:	d067      	beq.n	80028be <rndis_query+0x146>
 80027ee:	d90f      	bls.n	8002810 <rndis_query+0x98>
 80027f0:	4a71      	ldr	r2, [pc, #452]	; (80029b8 <rndis_query+0x240>)
 80027f2:	4293      	cmp	r3, r2
 80027f4:	f000 8085 	beq.w	8002902 <rndis_query+0x18a>
 80027f8:	3201      	adds	r2, #1
 80027fa:	4293      	cmp	r3, r2
 80027fc:	d069      	beq.n	80028d2 <rndis_query+0x15a>
 80027fe:	3a03      	subs	r2, #3
 8002800:	4293      	cmp	r3, r2
 8002802:	d061      	beq.n	80028c8 <rndis_query+0x150>
  default:                             rndis_query_cmplt(pdev, RNDIS_STATUS_FAILURE, NULL, 0); return;
 8002804:	2300      	movs	r3, #0
 8002806:	461a      	mov	r2, r3
 8002808:	496c      	ldr	r1, [pc, #432]	; (80029bc <rndis_query+0x244>)
 800280a:	f7ff ff93 	bl	8002734 <rndis_query_cmplt>
 800280e:	bd08      	pop	{r3, pc}
  switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 8002810:	3a02      	subs	r2, #2
 8002812:	4293      	cmp	r3, r2
 8002814:	d041      	beq.n	800289a <rndis_query+0x122>
 8002816:	3201      	adds	r2, #1
 8002818:	4293      	cmp	r3, r2
 800281a:	d1f3      	bne.n	8002804 <rndis_query+0x8c>
  case OID_GEN_HARDWARE_STATUS:        rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, 0); return;
 800281c:	2200      	movs	r2, #0
 800281e:	4611      	mov	r1, r2
 8002820:	f7ff ff68 	bl	80026f4 <rndis_query_cmplt32>
 8002824:	bd08      	pop	{r3, pc}
  switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 8002826:	4a66      	ldr	r2, [pc, #408]	; (80029c0 <rndis_query+0x248>)
 8002828:	4293      	cmp	r3, r2
 800282a:	f000 808f 	beq.w	800294c <rndis_query+0x1d4>
 800282e:	3201      	adds	r2, #1
 8002830:	4293      	cmp	r3, r2
 8002832:	d072      	beq.n	800291a <rndis_query+0x1a2>
 8002834:	3a03      	subs	r2, #3
 8002836:	4293      	cmp	r3, r2
 8002838:	d1e4      	bne.n	8002804 <rndis_query+0x8c>
  case OID_GEN_MAXIMUM_TOTAL_SIZE:     rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, ETH_MAX_PACKET_SIZE); return;
 800283a:	f240 52ea 	movw	r2, #1514	; 0x5ea
 800283e:	2100      	movs	r1, #0
 8002840:	f7ff ff58 	bl	80026f4 <rndis_query_cmplt32>
 8002844:	bd08      	pop	{r3, pc}
  switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 8002846:	4a5f      	ldr	r2, [pc, #380]	; (80029c4 <rndis_query+0x24c>)
 8002848:	4293      	cmp	r3, r2
 800284a:	f000 809a 	beq.w	8002982 <rndis_query+0x20a>
 800284e:	f0c0 809e 	bcc.w	800298e <rndis_query+0x216>
 8002852:	3201      	adds	r2, #1
 8002854:	4293      	cmp	r3, r2
 8002856:	d1d5      	bne.n	8002804 <rndis_query+0x8c>
  case OID_GEN_RCV_NO_BUFFER:          rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, 0); return;
 8002858:	2200      	movs	r2, #0
 800285a:	4611      	mov	r1, r2
 800285c:	f7ff ff4a 	bl	80026f4 <rndis_query_cmplt32>
 8002860:	bd08      	pop	{r3, pc}
  switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 8002862:	4a59      	ldr	r2, [pc, #356]	; (80029c8 <rndis_query+0x250>)
 8002864:	4293      	cmp	r3, r2
 8002866:	d06c      	beq.n	8002942 <rndis_query+0x1ca>
 8002868:	d809      	bhi.n	800287e <rndis_query+0x106>
 800286a:	3a02      	subs	r2, #2
 800286c:	4293      	cmp	r3, r2
 800286e:	d063      	beq.n	8002938 <rndis_query+0x1c0>
 8002870:	d85d      	bhi.n	800292e <rndis_query+0x1b6>
  case OID_802_3_CURRENT_ADDRESS:      rndis_query_cmplt(pdev, RNDIS_STATUS_SUCCESS, &station_hwaddr, 6); return;
 8002872:	2306      	movs	r3, #6
 8002874:	4a55      	ldr	r2, [pc, #340]	; (80029cc <rndis_query+0x254>)
 8002876:	2100      	movs	r1, #0
 8002878:	f7ff ff5c 	bl	8002734 <rndis_query_cmplt>
 800287c:	bd08      	pop	{r3, pc}
  switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 800287e:	4a54      	ldr	r2, [pc, #336]	; (80029d0 <rndis_query+0x258>)
 8002880:	4293      	cmp	r3, r2
 8002882:	d068      	beq.n	8002956 <rndis_query+0x1de>
 8002884:	3201      	adds	r2, #1
 8002886:	4293      	cmp	r3, r2
 8002888:	d06a      	beq.n	8002960 <rndis_query+0x1e8>
 800288a:	3a02      	subs	r2, #2
 800288c:	4293      	cmp	r3, r2
 800288e:	d1b9      	bne.n	8002804 <rndis_query+0x8c>
  case OID_802_3_RCV_ERROR_ALIGNMENT:  rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, 0); return;
 8002890:	2200      	movs	r2, #0
 8002892:	4611      	mov	r1, r2
 8002894:	f7ff ff2e 	bl	80026f4 <rndis_query_cmplt32>
 8002898:	bd08      	pop	{r3, pc}
  case OID_GEN_SUPPORTED_LIST:         rndis_query_cmplt(pdev, RNDIS_STATUS_SUCCESS, OIDSupportedList, 4 * OID_LIST_LENGTH); return;
 800289a:	2358      	movs	r3, #88	; 0x58
 800289c:	4a4d      	ldr	r2, [pc, #308]	; (80029d4 <rndis_query+0x25c>)
 800289e:	2100      	movs	r1, #0
 80028a0:	f7ff ff48 	bl	8002734 <rndis_query_cmplt>
 80028a4:	bd08      	pop	{r3, pc}
  case OID_GEN_VENDOR_DRIVER_VERSION:  rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, 0x00001000);  return;
 80028a6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80028aa:	2100      	movs	r1, #0
 80028ac:	f7ff ff22 	bl	80026f4 <rndis_query_cmplt32>
 80028b0:	bd08      	pop	{r3, pc}
  case OID_802_3_PERMANENT_ADDRESS:    rndis_query_cmplt(pdev, RNDIS_STATUS_SUCCESS, &permanent_hwaddr, 6); return;
 80028b2:	2306      	movs	r3, #6
 80028b4:	4a48      	ldr	r2, [pc, #288]	; (80029d8 <rndis_query+0x260>)
 80028b6:	2100      	movs	r1, #0
 80028b8:	f7ff ff3c 	bl	8002734 <rndis_query_cmplt>
 80028bc:	bd08      	pop	{r3, pc}
  case OID_GEN_MEDIA_SUPPORTED:        rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, NDIS_MEDIUM_802_3); return;
 80028be:	2200      	movs	r2, #0
 80028c0:	4611      	mov	r1, r2
 80028c2:	f7ff ff17 	bl	80026f4 <rndis_query_cmplt32>
 80028c6:	bd08      	pop	{r3, pc}
  case OID_GEN_MEDIA_IN_USE:           rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, NDIS_MEDIUM_802_3); return;
 80028c8:	2200      	movs	r2, #0
 80028ca:	4611      	mov	r1, r2
 80028cc:	f7ff ff12 	bl	80026f4 <rndis_query_cmplt32>
 80028d0:	bd08      	pop	{r3, pc}
  case OID_GEN_LINK_SPEED:             rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, ETH_LINK_SPEED / 100); return;
 80028d2:	f640 12c4 	movw	r2, #2500	; 0x9c4
 80028d6:	2100      	movs	r1, #0
 80028d8:	f7ff ff0c 	bl	80026f4 <rndis_query_cmplt32>
 80028dc:	bd08      	pop	{r3, pc}
  case OID_GEN_VENDOR_ID:              rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, 0x00FFFFFF); return;
 80028de:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 80028e2:	2100      	movs	r1, #0
 80028e4:	f7ff ff06 	bl	80026f4 <rndis_query_cmplt32>
 80028e8:	bd08      	pop	{r3, pc}
  case OID_GEN_VENDOR_DESCRIPTION:     rndis_query_cmplt(pdev, RNDIS_STATUS_SUCCESS, rndis_vendor, strlen(rndis_vendor) + 1); return;
 80028ea:	2308      	movs	r3, #8
 80028ec:	4a3b      	ldr	r2, [pc, #236]	; (80029dc <rndis_query+0x264>)
 80028ee:	2100      	movs	r1, #0
 80028f0:	f7ff ff20 	bl	8002734 <rndis_query_cmplt>
 80028f4:	bd08      	pop	{r3, pc}
  case OID_GEN_CURRENT_PACKET_FILTER:  rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, oid_packet_filter); return;
 80028f6:	4b3a      	ldr	r3, [pc, #232]	; (80029e0 <rndis_query+0x268>)
 80028f8:	681a      	ldr	r2, [r3, #0]
 80028fa:	2100      	movs	r1, #0
 80028fc:	f7ff fefa 	bl	80026f4 <rndis_query_cmplt32>
 8002900:	bd08      	pop	{r3, pc}
  case OID_GEN_MAXIMUM_FRAME_SIZE:     rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, ETH_MAX_PACKET_SIZE - ETH_HEADER_SIZE); return;
 8002902:	f240 52dc 	movw	r2, #1500	; 0x5dc
 8002906:	2100      	movs	r1, #0
 8002908:	f7ff fef4 	bl	80026f4 <rndis_query_cmplt32>
 800290c:	bd08      	pop	{r3, pc}
  case OID_GEN_TRANSMIT_BLOCK_SIZE:    rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, ETH_MAX_PACKET_SIZE); return;
 800290e:	f240 52ea 	movw	r2, #1514	; 0x5ea
 8002912:	2100      	movs	r1, #0
 8002914:	f7ff feee 	bl	80026f4 <rndis_query_cmplt32>
 8002918:	bd08      	pop	{r3, pc}
  case OID_GEN_MEDIA_CONNECT_STATUS:   rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, NDIS_MEDIA_STATE_CONNECTED); return;
 800291a:	2200      	movs	r2, #0
 800291c:	4611      	mov	r1, r2
 800291e:	f7ff fee9 	bl	80026f4 <rndis_query_cmplt32>
 8002922:	bd08      	pop	{r3, pc}
  case OID_GEN_RNDIS_CONFIG_PARAMETER: rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, 0); return;
 8002924:	2200      	movs	r2, #0
 8002926:	4611      	mov	r1, r2
 8002928:	f7ff fee4 	bl	80026f4 <rndis_query_cmplt32>
 800292c:	bd08      	pop	{r3, pc}
  case OID_802_3_MAXIMUM_LIST_SIZE:    rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, 1); return;
 800292e:	2201      	movs	r2, #1
 8002930:	2100      	movs	r1, #0
 8002932:	f7ff fedf 	bl	80026f4 <rndis_query_cmplt32>
 8002936:	bd08      	pop	{r3, pc}
  case OID_802_3_MULTICAST_LIST:       rndis_query_cmplt32(pdev, RNDIS_STATUS_NOT_SUPPORTED, 0); return;
 8002938:	2200      	movs	r2, #0
 800293a:	492a      	ldr	r1, [pc, #168]	; (80029e4 <rndis_query+0x26c>)
 800293c:	f7ff feda 	bl	80026f4 <rndis_query_cmplt32>
 8002940:	bd08      	pop	{r3, pc}
  case OID_802_3_MAC_OPTIONS:          rndis_query_cmplt32(pdev, RNDIS_STATUS_NOT_SUPPORTED, 0); return;
 8002942:	2200      	movs	r2, #0
 8002944:	4927      	ldr	r1, [pc, #156]	; (80029e4 <rndis_query+0x26c>)
 8002946:	f7ff fed5 	bl	80026f4 <rndis_query_cmplt32>
 800294a:	bd08      	pop	{r3, pc}
  case OID_GEN_MAC_OPTIONS:            rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, /*MAC_OPT*/ 0); return;
 800294c:	2200      	movs	r2, #0
 800294e:	4611      	mov	r1, r2
 8002950:	f7ff fed0 	bl	80026f4 <rndis_query_cmplt32>
 8002954:	bd08      	pop	{r3, pc}
  case OID_802_3_XMIT_ONE_COLLISION:   rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, 0); return;
 8002956:	2200      	movs	r2, #0
 8002958:	4611      	mov	r1, r2
 800295a:	f7ff fecb 	bl	80026f4 <rndis_query_cmplt32>
 800295e:	bd08      	pop	{r3, pc}
  case OID_802_3_XMIT_MORE_COLLISIONS: rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, 0); return;
 8002960:	2200      	movs	r2, #0
 8002962:	4611      	mov	r1, r2
 8002964:	f7ff fec6 	bl	80026f4 <rndis_query_cmplt32>
 8002968:	bd08      	pop	{r3, pc}
  case OID_GEN_XMIT_OK:                rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, usb_eth_stat.txok); return;
 800296a:	4b1f      	ldr	r3, [pc, #124]	; (80029e8 <rndis_query+0x270>)
 800296c:	681a      	ldr	r2, [r3, #0]
 800296e:	2100      	movs	r1, #0
 8002970:	f7ff fec0 	bl	80026f4 <rndis_query_cmplt32>
 8002974:	bd08      	pop	{r3, pc}
  case OID_GEN_RCV_OK:                 rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, usb_eth_stat.rxok); return;
 8002976:	4b1c      	ldr	r3, [pc, #112]	; (80029e8 <rndis_query+0x270>)
 8002978:	685a      	ldr	r2, [r3, #4]
 800297a:	2100      	movs	r1, #0
 800297c:	f7ff feba 	bl	80026f4 <rndis_query_cmplt32>
 8002980:	bd08      	pop	{r3, pc}
  case OID_GEN_RCV_ERROR:              rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, usb_eth_stat.rxbad); return;
 8002982:	4b19      	ldr	r3, [pc, #100]	; (80029e8 <rndis_query+0x270>)
 8002984:	68da      	ldr	r2, [r3, #12]
 8002986:	2100      	movs	r1, #0
 8002988:	f7ff feb4 	bl	80026f4 <rndis_query_cmplt32>
 800298c:	bd08      	pop	{r3, pc}
  case OID_GEN_XMIT_ERROR:             rndis_query_cmplt32(pdev, RNDIS_STATUS_SUCCESS, usb_eth_stat.txbad); return;
 800298e:	4b16      	ldr	r3, [pc, #88]	; (80029e8 <rndis_query+0x270>)
 8002990:	689a      	ldr	r2, [r3, #8]
 8002992:	2100      	movs	r1, #0
 8002994:	f7ff feae 	bl	80026f4 <rndis_query_cmplt32>
 8002998:	bd08      	pop	{r3, pc}
 800299a:	bf00      	nop
 800299c:	200078b8 	.word	0x200078b8
 80029a0:	00010116 	.word	0x00010116
 80029a4:	00020102 	.word	0x00020102
 80029a8:	0001021b 	.word	0x0001021b
 80029ac:	00020101 	.word	0x00020101
 80029b0:	00010202 	.word	0x00010202
 80029b4:	0001010e 	.word	0x0001010e
 80029b8:	00010106 	.word	0x00010106
 80029bc:	c0000001 	.word	0xc0000001
 80029c0:	00010113 	.word	0x00010113
 80029c4:	00020104 	.word	0x00020104
 80029c8:	01010105 	.word	0x01010105
 80029cc:	2000001c 	.word	0x2000001c
 80029d0:	01020102 	.word	0x01020102
 80029d4:	08008ee4 	.word	0x08008ee4
 80029d8:	20000014 	.word	0x20000014
 80029dc:	08008f3c 	.word	0x08008f3c
 80029e0:	200001ac 	.word	0x200001ac
 80029e4:	c00000bb 	.word	0xc00000bb
 80029e8:	200001c0 	.word	0x200001c0

080029ec <rndis_handle_set_msg>:
{
 80029ec:	b510      	push	{r4, lr}
 80029ee:	4604      	mov	r4, r0
  oid = m->Oid;
 80029f0:	4b20      	ldr	r3, [pc, #128]	; (8002a74 <rndis_handle_set_msg+0x88>)
 80029f2:	68d9      	ldr	r1, [r3, #12]
  c->MessageType = REMOTE_NDIS_SET_CMPLT;
 80029f4:	2200      	movs	r2, #0
 80029f6:	2005      	movs	r0, #5
 80029f8:	7018      	strb	r0, [r3, #0]
 80029fa:	705a      	strb	r2, [r3, #1]
 80029fc:	709a      	strb	r2, [r3, #2]
 80029fe:	f06f 007f 	mvn.w	r0, #127	; 0x7f
 8002a02:	70d8      	strb	r0, [r3, #3]
  c->MessageLength = sizeof(rndis_set_cmplt_t);
 8002a04:	2010      	movs	r0, #16
 8002a06:	7118      	strb	r0, [r3, #4]
 8002a08:	715a      	strb	r2, [r3, #5]
 8002a0a:	719a      	strb	r2, [r3, #6]
 8002a0c:	71da      	strb	r2, [r3, #7]
  c->Status = RNDIS_STATUS_SUCCESS;
 8002a0e:	731a      	strb	r2, [r3, #12]
 8002a10:	735a      	strb	r2, [r3, #13]
 8002a12:	739a      	strb	r2, [r3, #14]
 8002a14:	73da      	strb	r2, [r3, #15]
  switch (oid)
 8002a16:	4b18      	ldr	r3, [pc, #96]	; (8002a78 <rndis_handle_set_msg+0x8c>)
 8002a18:	4299      	cmp	r1, r3
 8002a1a:	d01a      	beq.n	8002a52 <rndis_handle_set_msg+0x66>
 8002a1c:	d81d      	bhi.n	8002a5a <rndis_handle_set_msg+0x6e>
 8002a1e:	3b04      	subs	r3, #4
 8002a20:	4299      	cmp	r1, r3
 8002a22:	d10a      	bne.n	8002a3a <rndis_handle_set_msg+0x4e>
    oid_packet_filter = *INFBUF;
 8002a24:	4b13      	ldr	r3, [pc, #76]	; (8002a74 <rndis_handle_set_msg+0x88>)
 8002a26:	695a      	ldr	r2, [r3, #20]
 8002a28:	3308      	adds	r3, #8
 8002a2a:	58d3      	ldr	r3, [r2, r3]
 8002a2c:	4a13      	ldr	r2, [pc, #76]	; (8002a7c <rndis_handle_set_msg+0x90>)
 8002a2e:	6013      	str	r3, [r2, #0]
    if (oid_packet_filter)
 8002a30:	b1d3      	cbz	r3, 8002a68 <rndis_handle_set_msg+0x7c>
      rndis_state = rndis_data_initialized;
 8002a32:	2202      	movs	r2, #2
 8002a34:	4b12      	ldr	r3, [pc, #72]	; (8002a80 <rndis_handle_set_msg+0x94>)
 8002a36:	701a      	strb	r2, [r3, #0]
 8002a38:	e00b      	b.n	8002a52 <rndis_handle_set_msg+0x66>
  switch (oid)
 8002a3a:	3301      	adds	r3, #1
 8002a3c:	4299      	cmp	r1, r3
 8002a3e:	d008      	beq.n	8002a52 <rndis_handle_set_msg+0x66>
    c->Status = RNDIS_STATUS_FAILURE;
 8002a40:	4b0c      	ldr	r3, [pc, #48]	; (8002a74 <rndis_handle_set_msg+0x88>)
 8002a42:	2200      	movs	r2, #0
 8002a44:	2101      	movs	r1, #1
 8002a46:	7319      	strb	r1, [r3, #12]
 8002a48:	735a      	strb	r2, [r3, #13]
 8002a4a:	739a      	strb	r2, [r3, #14]
 8002a4c:	f06f 023f 	mvn.w	r2, #63	; 0x3f
 8002a50:	73da      	strb	r2, [r3, #15]
  response_available(pdev);
 8002a52:	4620      	mov	r0, r4
 8002a54:	f7ff fe42 	bl	80026dc <response_available>
 8002a58:	bd10      	pop	{r4, pc}
  switch (oid)
 8002a5a:	4b0a      	ldr	r3, [pc, #40]	; (8002a84 <rndis_handle_set_msg+0x98>)
 8002a5c:	4299      	cmp	r1, r3
 8002a5e:	d0f8      	beq.n	8002a52 <rndis_handle_set_msg+0x66>
 8002a60:	4b09      	ldr	r3, [pc, #36]	; (8002a88 <rndis_handle_set_msg+0x9c>)
 8002a62:	4299      	cmp	r1, r3
 8002a64:	d1ec      	bne.n	8002a40 <rndis_handle_set_msg+0x54>
 8002a66:	e7f4      	b.n	8002a52 <rndis_handle_set_msg+0x66>
      rndis_state = rndis_initialized;
 8002a68:	2201      	movs	r2, #1
 8002a6a:	4b05      	ldr	r3, [pc, #20]	; (8002a80 <rndis_handle_set_msg+0x94>)
 8002a6c:	701a      	strb	r2, [r3, #0]
      rndis_initialized_cb();
 8002a6e:	f7ff fcf4 	bl	800245a <rndis_initialized_cb>
 8002a72:	e7ee      	b.n	8002a52 <rndis_handle_set_msg+0x66>
 8002a74:	200078b8 	.word	0x200078b8
 8002a78:	00010112 	.word	0x00010112
 8002a7c:	200001ac 	.word	0x200001ac
 8002a80:	200001b3 	.word	0x200001b3
 8002a84:	0001021b 	.word	0x0001021b
 8002a88:	01010103 	.word	0x01010103

08002a8c <usbd_rndis_ep0_recv>:
{
 8002a8c:	b508      	push	{r3, lr}
  switch (((rndis_generic_msg_t *)encapsulated_buffer)->MessageType)
 8002a8e:	4b4b      	ldr	r3, [pc, #300]	; (8002bbc <usbd_rndis_ep0_recv+0x130>)
 8002a90:	681b      	ldr	r3, [r3, #0]
 8002a92:	3b02      	subs	r3, #2
 8002a94:	2b06      	cmp	r3, #6
 8002a96:	d857      	bhi.n	8002b48 <usbd_rndis_ep0_recv+0xbc>
 8002a98:	e8df f003 	tbb	[pc, r3]
 8002a9c:	5b585604 	.word	0x5b585604
 8002aa0:	565e      	.short	0x565e
 8002aa2:	7a          	.byte	0x7a
 8002aa3:	00          	.byte	0x00
      m->MessageType = REMOTE_NDIS_INITIALIZE_CMPLT;
 8002aa4:	4b45      	ldr	r3, [pc, #276]	; (8002bbc <usbd_rndis_ep0_recv+0x130>)
 8002aa6:	2200      	movs	r2, #0
 8002aa8:	2102      	movs	r1, #2
 8002aaa:	7019      	strb	r1, [r3, #0]
 8002aac:	705a      	strb	r2, [r3, #1]
 8002aae:	709a      	strb	r2, [r3, #2]
 8002ab0:	f06f 017f 	mvn.w	r1, #127	; 0x7f
 8002ab4:	70d9      	strb	r1, [r3, #3]
      m->MessageLength = sizeof(rndis_initialize_cmplt_t);
 8002ab6:	2134      	movs	r1, #52	; 0x34
 8002ab8:	7119      	strb	r1, [r3, #4]
 8002aba:	715a      	strb	r2, [r3, #5]
 8002abc:	719a      	strb	r2, [r3, #6]
 8002abe:	71da      	strb	r2, [r3, #7]
      m->MajorVersion = RNDIS_MAJOR_VERSION;
 8002ac0:	2101      	movs	r1, #1
 8002ac2:	7419      	strb	r1, [r3, #16]
 8002ac4:	745a      	strb	r2, [r3, #17]
 8002ac6:	749a      	strb	r2, [r3, #18]
 8002ac8:	74da      	strb	r2, [r3, #19]
      m->MinorVersion = RNDIS_MINOR_VERSION;
 8002aca:	751a      	strb	r2, [r3, #20]
 8002acc:	755a      	strb	r2, [r3, #21]
 8002ace:	759a      	strb	r2, [r3, #22]
 8002ad0:	75da      	strb	r2, [r3, #23]
      m->Status = RNDIS_STATUS_SUCCESS;
 8002ad2:	731a      	strb	r2, [r3, #12]
 8002ad4:	735a      	strb	r2, [r3, #13]
 8002ad6:	739a      	strb	r2, [r3, #14]
 8002ad8:	73da      	strb	r2, [r3, #15]
      m->DeviceFlags = RNDIS_DF_CONNECTIONLESS;
 8002ada:	7619      	strb	r1, [r3, #24]
 8002adc:	765a      	strb	r2, [r3, #25]
 8002ade:	769a      	strb	r2, [r3, #26]
 8002ae0:	76da      	strb	r2, [r3, #27]
      m->Medium = RNDIS_MEDIUM_802_3;
 8002ae2:	771a      	strb	r2, [r3, #28]
 8002ae4:	775a      	strb	r2, [r3, #29]
 8002ae6:	779a      	strb	r2, [r3, #30]
 8002ae8:	77da      	strb	r2, [r3, #31]
      m->MaxPacketsPerTransfer = 1;
 8002aea:	f883 1020 	strb.w	r1, [r3, #32]
 8002aee:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 8002af2:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8002af6:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
      m->MaxTransferSize = RNDIS_RX_BUFFER_SIZE;
 8002afa:	2116      	movs	r1, #22
 8002afc:	f883 1024 	strb.w	r1, [r3, #36]	; 0x24
 8002b00:	2106      	movs	r1, #6
 8002b02:	f883 1025 	strb.w	r1, [r3, #37]	; 0x25
 8002b06:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
 8002b0a:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
      m->PacketAlignmentFactor = 0;
 8002b0e:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 8002b12:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 8002b16:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
 8002b1a:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
      m->AfListOffset = 0;
 8002b1e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
 8002b22:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
 8002b26:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
 8002b2a:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
      m->AfListSize = 0;
 8002b2e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
 8002b32:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
 8002b36:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
 8002b3a:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
      rndis_state = rndis_initialized;
 8002b3e:	2201      	movs	r2, #1
 8002b40:	4b1f      	ldr	r3, [pc, #124]	; (8002bc0 <usbd_rndis_ep0_recv+0x134>)
 8002b42:	701a      	strb	r2, [r3, #0]
      response_available(pdev);
 8002b44:	f7ff fdca 	bl	80026dc <response_available>
}
 8002b48:	2000      	movs	r0, #0
 8002b4a:	bd08      	pop	{r3, pc}
    rndis_query(pdev);
 8002b4c:	f7ff fe14 	bl	8002778 <rndis_query>
    break;
 8002b50:	e7fa      	b.n	8002b48 <usbd_rndis_ep0_recv+0xbc>
    rndis_handle_set_msg(pdev);
 8002b52:	f7ff ff4b 	bl	80029ec <rndis_handle_set_msg>
    break;
 8002b56:	e7f7      	b.n	8002b48 <usbd_rndis_ep0_recv+0xbc>
      rndis_state = rndis_uninitialized;
 8002b58:	2200      	movs	r2, #0
 8002b5a:	4b19      	ldr	r3, [pc, #100]	; (8002bc0 <usbd_rndis_ep0_recv+0x134>)
 8002b5c:	701a      	strb	r2, [r3, #0]
      m->MessageType = REMOTE_NDIS_RESET_CMPLT;
 8002b5e:	4b17      	ldr	r3, [pc, #92]	; (8002bbc <usbd_rndis_ep0_recv+0x130>)
 8002b60:	2106      	movs	r1, #6
 8002b62:	7019      	strb	r1, [r3, #0]
 8002b64:	705a      	strb	r2, [r3, #1]
 8002b66:	709a      	strb	r2, [r3, #2]
 8002b68:	f06f 017f 	mvn.w	r1, #127	; 0x7f
 8002b6c:	70d9      	strb	r1, [r3, #3]
      m->MessageLength = sizeof(rndis_reset_cmplt_t);
 8002b6e:	2110      	movs	r1, #16
 8002b70:	7119      	strb	r1, [r3, #4]
 8002b72:	715a      	strb	r2, [r3, #5]
 8002b74:	719a      	strb	r2, [r3, #6]
 8002b76:	71da      	strb	r2, [r3, #7]
      m->Status = RNDIS_STATUS_SUCCESS;
 8002b78:	721a      	strb	r2, [r3, #8]
 8002b7a:	725a      	strb	r2, [r3, #9]
 8002b7c:	729a      	strb	r2, [r3, #10]
 8002b7e:	72da      	strb	r2, [r3, #11]
      m->AddressingReset = 1; /* Make it look like we did something */
 8002b80:	2101      	movs	r1, #1
 8002b82:	7319      	strb	r1, [r3, #12]
 8002b84:	735a      	strb	r2, [r3, #13]
 8002b86:	739a      	strb	r2, [r3, #14]
 8002b88:	73da      	strb	r2, [r3, #15]
      response_available(pdev);
 8002b8a:	f7ff fda7 	bl	80026dc <response_available>
    break;
 8002b8e:	e7db      	b.n	8002b48 <usbd_rndis_ep0_recv+0xbc>
      m->MessageType = REMOTE_NDIS_KEEPALIVE_CMPLT;
 8002b90:	4b0a      	ldr	r3, [pc, #40]	; (8002bbc <usbd_rndis_ep0_recv+0x130>)
 8002b92:	2200      	movs	r2, #0
 8002b94:	2108      	movs	r1, #8
 8002b96:	7019      	strb	r1, [r3, #0]
 8002b98:	705a      	strb	r2, [r3, #1]
 8002b9a:	709a      	strb	r2, [r3, #2]
 8002b9c:	f06f 017f 	mvn.w	r1, #127	; 0x7f
 8002ba0:	70d9      	strb	r1, [r3, #3]
      m->MessageLength = sizeof(rndis_keepalive_cmplt_t);
 8002ba2:	2110      	movs	r1, #16
 8002ba4:	7119      	strb	r1, [r3, #4]
 8002ba6:	715a      	strb	r2, [r3, #5]
 8002ba8:	719a      	strb	r2, [r3, #6]
 8002baa:	71da      	strb	r2, [r3, #7]
      m->Status = RNDIS_STATUS_SUCCESS;
 8002bac:	731a      	strb	r2, [r3, #12]
 8002bae:	735a      	strb	r2, [r3, #13]
 8002bb0:	739a      	strb	r2, [r3, #14]
 8002bb2:	73da      	strb	r2, [r3, #15]
    response_available(pdev);
 8002bb4:	f7ff fd92 	bl	80026dc <response_available>
    break;
 8002bb8:	e7c6      	b.n	8002b48 <usbd_rndis_ep0_recv+0xbc>
 8002bba:	bf00      	nop
 8002bbc:	200078b8 	.word	0x200078b8
 8002bc0:	200001b3 	.word	0x200001b3

08002bc4 <USBD_Init>:
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 8002bc4:	b198      	cbz	r0, 8002bee <USBD_Init+0x2a>
{
 8002bc6:	b508      	push	{r3, lr}
 8002bc8:	4603      	mov	r3, r0
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 8002bca:	f8d0 0214 	ldr.w	r0, [r0, #532]	; 0x214
 8002bce:	b110      	cbz	r0, 8002bd6 <USBD_Init+0x12>
  {
    pdev->pClass = NULL;
 8002bd0:	2000      	movs	r0, #0
 8002bd2:	f8c3 0214 	str.w	r0, [r3, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 8002bd6:	b109      	cbz	r1, 8002bdc <USBD_Init+0x18>
  {
    pdev->pDesc = pdesc;
 8002bd8:	f8c3 1210 	str.w	r1, [r3, #528]	; 0x210
 8002bdc:	4618      	mov	r0, r3
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 8002bde:	2301      	movs	r3, #1
 8002be0:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  pdev->id = id;
 8002be4:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 8002be6:	f000 ff0b 	bl	8003a00 <USBD_LL_Init>
  
  return USBD_OK; 
 8002bea:	2000      	movs	r0, #0
 8002bec:	bd08      	pop	{r3, pc}
    return USBD_FAIL; 
 8002bee:	2002      	movs	r0, #2
 8002bf0:	4770      	bx	lr

08002bf2 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 8002bf2:	b119      	cbz	r1, 8002bfc <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 8002bf4:	f8c0 1214 	str.w	r1, [r0, #532]	; 0x214
    status = USBD_OK;
 8002bf8:	2000      	movs	r0, #0
 8002bfa:	4770      	bx	lr
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 8002bfc:	2002      	movs	r0, #2
  }
  
  return status;
}
 8002bfe:	4770      	bx	lr

08002c00 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 8002c00:	b508      	push	{r3, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 8002c02:	f000 ff2d 	bl	8003a60 <USBD_LL_Start>
  
  return USBD_OK;  
}
 8002c06:	2000      	movs	r0, #0
 8002c08:	bd08      	pop	{r3, pc}

08002c0a <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8002c0a:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
 8002c0c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002c10:	b133      	cbz	r3, 8002c20 <USBD_SetClassConfig+0x16>
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 8002c12:	681b      	ldr	r3, [r3, #0]
 8002c14:	4798      	blx	r3
 8002c16:	2800      	cmp	r0, #0
    {
      ret = USBD_OK;
 8002c18:	bf14      	ite	ne
 8002c1a:	2002      	movne	r0, #2
 8002c1c:	2000      	moveq	r0, #0
 8002c1e:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef   ret = USBD_FAIL;
 8002c20:	2002      	movs	r0, #2
    }
  }
  return ret; 
}
 8002c22:	bd08      	pop	{r3, pc}

08002c24 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8002c24:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 8002c26:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002c2a:	685b      	ldr	r3, [r3, #4]
 8002c2c:	4798      	blx	r3
  return USBD_OK;
}
 8002c2e:	2000      	movs	r0, #0
 8002c30:	bd08      	pop	{r3, pc}

08002c32 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8002c32:	b538      	push	{r3, r4, r5, lr}
 8002c34:	4604      	mov	r4, r0

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8002c36:	f500 7502 	add.w	r5, r0, #520	; 0x208
 8002c3a:	4628      	mov	r0, r5
 8002c3c:	f000 f904 	bl	8002e48 <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 8002c40:	2301      	movs	r3, #1
 8002c42:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 8002c46:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
 8002c4a:	f8c4 31f8 	str.w	r3, [r4, #504]	; 0x1f8
  
  switch (pdev->request.bmRequest & 0x1F) 
 8002c4e:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
 8002c52:	f001 031f 	and.w	r3, r1, #31
 8002c56:	2b01      	cmp	r3, #1
 8002c58:	d00e      	beq.n	8002c78 <USBD_LL_SetupStage+0x46>
 8002c5a:	b13b      	cbz	r3, 8002c6c <USBD_LL_SetupStage+0x3a>
 8002c5c:	2b02      	cmp	r3, #2
 8002c5e:	d010      	beq.n	8002c82 <USBD_LL_SetupStage+0x50>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 8002c60:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8002c64:	4620      	mov	r0, r4
 8002c66:	f000 ff25 	bl	8003ab4 <USBD_LL_StallEP>
    break;
 8002c6a:	e003      	b.n	8002c74 <USBD_LL_SetupStage+0x42>
    USBD_StdDevReq (pdev, &pdev->request);
 8002c6c:	4629      	mov	r1, r5
 8002c6e:	4620      	mov	r0, r4
 8002c70:	f000 f908 	bl	8002e84 <USBD_StdDevReq>
  }  
  return USBD_OK;  
}
 8002c74:	2000      	movs	r0, #0
 8002c76:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdItfReq(pdev, &pdev->request);
 8002c78:	4629      	mov	r1, r5
 8002c7a:	4620      	mov	r0, r4
 8002c7c:	f000 fa7a 	bl	8003174 <USBD_StdItfReq>
    break;
 8002c80:	e7f8      	b.n	8002c74 <USBD_LL_SetupStage+0x42>
    USBD_StdEPReq(pdev, &pdev->request);   
 8002c82:	4629      	mov	r1, r5
 8002c84:	4620      	mov	r0, r4
 8002c86:	f000 fa91 	bl	80031ac <USBD_StdEPReq>
    break;
 8002c8a:	e7f3      	b.n	8002c74 <USBD_LL_SetupStage+0x42>

08002c8c <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 8002c8c:	b510      	push	{r4, lr}
 8002c8e:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 8002c90:	bb19      	cbnz	r1, 8002cda <USBD_LL_DataOutStage+0x4e>
 8002c92:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 8002c94:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 8002c98:	2a03      	cmp	r2, #3
 8002c9a:	d127      	bne.n	8002cec <USBD_LL_DataOutStage+0x60>
    {
      if(pep->rem_length > pep->maxpacket)
 8002c9c:	f8d0 110c 	ldr.w	r1, [r0, #268]	; 0x10c
 8002ca0:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
 8002ca4:	4291      	cmp	r1, r2
 8002ca6:	d80b      	bhi.n	8002cc0 <USBD_LL_DataOutStage+0x34>
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
      }
      else
      {
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8002ca8:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002cac:	691b      	ldr	r3, [r3, #16]
 8002cae:	b11b      	cbz	r3, 8002cb8 <USBD_LL_DataOutStage+0x2c>
 8002cb0:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8002cb4:	2a03      	cmp	r2, #3
 8002cb6:	d00e      	beq.n	8002cd6 <USBD_LL_DataOutStage+0x4a>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
        {
          pdev->pClass->EP0_RxReady(pdev); 
        }
        USBD_CtlSendStatus(pdev);
 8002cb8:	4620      	mov	r0, r4
 8002cba:	f000 fb48 	bl	800334e <USBD_CtlSendStatus>
 8002cbe:	e015      	b.n	8002cec <USBD_LL_DataOutStage+0x60>
        pep->rem_length -=  pep->maxpacket;
 8002cc0:	1a89      	subs	r1, r1, r2
 8002cc2:	f8c0 110c 	str.w	r1, [r0, #268]	; 0x10c
                            MIN(pep->rem_length ,pep->maxpacket));
 8002cc6:	428a      	cmp	r2, r1
 8002cc8:	bf28      	it	cs
 8002cca:	460a      	movcs	r2, r1
        USBD_CtlContinueRx (pdev, 
 8002ccc:	b292      	uxth	r2, r2
 8002cce:	4619      	mov	r1, r3
 8002cd0:	f000 fb35 	bl	800333e <USBD_CtlContinueRx>
 8002cd4:	e00a      	b.n	8002cec <USBD_LL_DataOutStage+0x60>
          pdev->pClass->EP0_RxReady(pdev); 
 8002cd6:	4798      	blx	r3
 8002cd8:	e7ee      	b.n	8002cb8 <USBD_LL_DataOutStage+0x2c>
 8002cda:	460a      	mov	r2, r1
      }
    }
  }
  else if((pdev->pClass->DataOut != NULL)&&
 8002cdc:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002ce0:	699b      	ldr	r3, [r3, #24]
 8002ce2:	b11b      	cbz	r3, 8002cec <USBD_LL_DataOutStage+0x60>
 8002ce4:	f890 11fc 	ldrb.w	r1, [r0, #508]	; 0x1fc
 8002ce8:	2903      	cmp	r1, #3
 8002cea:	d001      	beq.n	8002cf0 <USBD_LL_DataOutStage+0x64>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 8002cec:	2000      	movs	r0, #0
 8002cee:	bd10      	pop	{r4, pc}
    pdev->pClass->DataOut(pdev, epnum); 
 8002cf0:	4611      	mov	r1, r2
 8002cf2:	4798      	blx	r3
 8002cf4:	e7fa      	b.n	8002cec <USBD_LL_DataOutStage+0x60>

08002cf6 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 8002cf6:	b510      	push	{r4, lr}
 8002cf8:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 8002cfa:	2900      	cmp	r1, #0
 8002cfc:	d147      	bne.n	8002d8e <USBD_LL_DataInStage+0x98>
 8002cfe:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 8002d00:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 8002d04:	2a02      	cmp	r2, #2
 8002d06:	d005      	beq.n	8002d14 <USBD_LL_DataInStage+0x1e>
          }          
          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 8002d08:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8002d0c:	2b01      	cmp	r3, #1
 8002d0e:	d03a      	beq.n	8002d86 <USBD_LL_DataInStage+0x90>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 8002d10:	2000      	movs	r0, #0
 8002d12:	bd10      	pop	{r4, pc}
      if(pep->rem_length > pep->maxpacket)
 8002d14:	69c1      	ldr	r1, [r0, #28]
 8002d16:	6a02      	ldr	r2, [r0, #32]
 8002d18:	4291      	cmp	r1, r2
 8002d1a:	d817      	bhi.n	8002d4c <USBD_LL_DataInStage+0x56>
        if((pep->total_length % pep->maxpacket == 0) &&
 8002d1c:	6981      	ldr	r1, [r0, #24]
 8002d1e:	fbb1 f3f2 	udiv	r3, r1, r2
 8002d22:	fb02 1313 	mls	r3, r2, r3, r1
 8002d26:	b92b      	cbnz	r3, 8002d34 <USBD_LL_DataInStage+0x3e>
 8002d28:	428a      	cmp	r2, r1
 8002d2a:	d803      	bhi.n	8002d34 <USBD_LL_DataInStage+0x3e>
           (pep->total_length >= pep->maxpacket) &&
 8002d2c:	f8d0 31f8 	ldr.w	r3, [r0, #504]	; 0x1f8
 8002d30:	4299      	cmp	r1, r3
 8002d32:	d318      	bcc.n	8002d66 <USBD_LL_DataInStage+0x70>
          if((pdev->pClass->EP0_TxSent != NULL)&&
 8002d34:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8002d38:	68db      	ldr	r3, [r3, #12]
 8002d3a:	b11b      	cbz	r3, 8002d44 <USBD_LL_DataInStage+0x4e>
 8002d3c:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 8002d40:	2a03      	cmp	r2, #3
 8002d42:	d01d      	beq.n	8002d80 <USBD_LL_DataInStage+0x8a>
          USBD_CtlReceiveStatus(pdev);
 8002d44:	4620      	mov	r0, r4
 8002d46:	f000 fb0d 	bl	8003364 <USBD_CtlReceiveStatus>
 8002d4a:	e7dd      	b.n	8002d08 <USBD_LL_DataInStage+0x12>
        pep->rem_length -=  pep->maxpacket;
 8002d4c:	1a8a      	subs	r2, r1, r2
 8002d4e:	61c2      	str	r2, [r0, #28]
        USBD_CtlContinueSendData (pdev, 
 8002d50:	b292      	uxth	r2, r2
 8002d52:	4619      	mov	r1, r3
 8002d54:	f000 fadc 	bl	8003310 <USBD_CtlContinueSendData>
        USBD_LL_PrepareReceive (pdev,
 8002d58:	2300      	movs	r3, #0
 8002d5a:	461a      	mov	r2, r3
 8002d5c:	4619      	mov	r1, r3
 8002d5e:	4620      	mov	r0, r4
 8002d60:	f000 fef3 	bl	8003b4a <USBD_LL_PrepareReceive>
 8002d64:	e7d0      	b.n	8002d08 <USBD_LL_DataInStage+0x12>
          USBD_CtlContinueSendData(pdev , NULL, 0);
 8002d66:	2200      	movs	r2, #0
 8002d68:	4611      	mov	r1, r2
 8002d6a:	f000 fad1 	bl	8003310 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 8002d6e:	2100      	movs	r1, #0
 8002d70:	f8c4 11f8 	str.w	r1, [r4, #504]	; 0x1f8
        USBD_LL_PrepareReceive (pdev,
 8002d74:	460b      	mov	r3, r1
 8002d76:	460a      	mov	r2, r1
 8002d78:	4620      	mov	r0, r4
 8002d7a:	f000 fee6 	bl	8003b4a <USBD_LL_PrepareReceive>
 8002d7e:	e7c3      	b.n	8002d08 <USBD_LL_DataInStage+0x12>
            pdev->pClass->EP0_TxSent(pdev); 
 8002d80:	4620      	mov	r0, r4
 8002d82:	4798      	blx	r3
 8002d84:	e7de      	b.n	8002d44 <USBD_LL_DataInStage+0x4e>
      pdev->dev_test_mode = 0;
 8002d86:	2300      	movs	r3, #0
 8002d88:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
 8002d8c:	e7c0      	b.n	8002d10 <USBD_LL_DataInStage+0x1a>
 8002d8e:	460a      	mov	r2, r1
  else if((pdev->pClass->DataIn != NULL)&& 
 8002d90:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002d94:	695b      	ldr	r3, [r3, #20]
 8002d96:	2b00      	cmp	r3, #0
 8002d98:	d0ba      	beq.n	8002d10 <USBD_LL_DataInStage+0x1a>
 8002d9a:	f890 11fc 	ldrb.w	r1, [r0, #508]	; 0x1fc
 8002d9e:	2903      	cmp	r1, #3
 8002da0:	d1b6      	bne.n	8002d10 <USBD_LL_DataInStage+0x1a>
    pdev->pClass->DataIn(pdev, epnum); 
 8002da2:	4611      	mov	r1, r2
 8002da4:	4798      	blx	r3
 8002da6:	e7b3      	b.n	8002d10 <USBD_LL_DataInStage+0x1a>

08002da8 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8002da8:	b538      	push	{r3, r4, r5, lr}
 8002daa:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 8002dac:	2340      	movs	r3, #64	; 0x40
 8002dae:	2200      	movs	r2, #0
 8002db0:	4611      	mov	r1, r2
 8002db2:	f000 fe62 	bl	8003a7a <USBD_LL_OpenEP>
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8002db6:	2540      	movs	r5, #64	; 0x40
 8002db8:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 8002dbc:	462b      	mov	r3, r5
 8002dbe:	2200      	movs	r2, #0
 8002dc0:	2180      	movs	r1, #128	; 0x80
 8002dc2:	4620      	mov	r0, r4
 8002dc4:	f000 fe59 	bl	8003a7a <USBD_LL_OpenEP>
              0x80,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8002dc8:	6225      	str	r5, [r4, #32]
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8002dca:	2301      	movs	r3, #1
 8002dcc:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 8002dd0:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 8002dd4:	b12b      	cbz	r3, 8002de2 <USBD_LL_Reset+0x3a>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8002dd6:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8002dda:	685b      	ldr	r3, [r3, #4]
 8002ddc:	7921      	ldrb	r1, [r4, #4]
 8002dde:	4620      	mov	r0, r4
 8002de0:	4798      	blx	r3
 
  
  return USBD_OK;
}
 8002de2:	2000      	movs	r0, #0
 8002de4:	bd38      	pop	{r3, r4, r5, pc}

08002de6 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 8002de6:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 8002de8:	2000      	movs	r0, #0
 8002dea:	4770      	bx	lr

08002dec <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8002dec:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002df0:	f880 31fd 	strb.w	r3, [r0, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8002df4:	2304      	movs	r3, #4
 8002df6:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8002dfa:	2000      	movs	r0, #0
 8002dfc:	4770      	bx	lr

08002dfe <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;  
 8002dfe:	f890 31fd 	ldrb.w	r3, [r0, #509]	; 0x1fd
 8002e02:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8002e06:	2000      	movs	r0, #0
 8002e08:	4770      	bx	lr

08002e0a <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 8002e0a:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8002e0c:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002e10:	2b03      	cmp	r3, #3
 8002e12:	d001      	beq.n	8002e18 <USBD_LL_SOF+0xe>
    {
      pdev->pClass->SOF(pdev);
    }
  }
  return USBD_OK;
}
 8002e14:	2000      	movs	r0, #0
 8002e16:	bd08      	pop	{r3, pc}
    if(pdev->pClass->SOF != NULL)
 8002e18:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002e1c:	69db      	ldr	r3, [r3, #28]
 8002e1e:	2b00      	cmp	r3, #0
 8002e20:	d0f8      	beq.n	8002e14 <USBD_LL_SOF+0xa>
      pdev->pClass->SOF(pdev);
 8002e22:	4798      	blx	r3
 8002e24:	e7f6      	b.n	8002e14 <USBD_LL_SOF+0xa>

08002e26 <USBD_LL_IsoINIncomplete>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 8002e26:	2000      	movs	r0, #0
 8002e28:	4770      	bx	lr

08002e2a <USBD_LL_IsoOUTIncomplete>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 8002e2a:	2000      	movs	r0, #0
 8002e2c:	4770      	bx	lr

08002e2e <USBD_LL_DevConnected>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev)
{
  return USBD_OK;
}
 8002e2e:	2000      	movs	r0, #0
 8002e30:	4770      	bx	lr

08002e32 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
 8002e32:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8002e34:	2201      	movs	r2, #1
 8002e36:	f880 21fc 	strb.w	r2, [r0, #508]	; 0x1fc
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8002e3a:	f8d0 2214 	ldr.w	r2, [r0, #532]	; 0x214
 8002e3e:	6852      	ldr	r2, [r2, #4]
 8002e40:	7901      	ldrb	r1, [r0, #4]
 8002e42:	4790      	blx	r2
   
  return USBD_OK;
}
 8002e44:	2000      	movs	r0, #0
 8002e46:	bd08      	pop	{r3, pc}

08002e48 <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
 8002e48:	780b      	ldrb	r3, [r1, #0]
 8002e4a:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 8002e4c:	784b      	ldrb	r3, [r1, #1]
 8002e4e:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8002e50:	78ca      	ldrb	r2, [r1, #3]
 8002e52:	788b      	ldrb	r3, [r1, #2]
 8002e54:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8002e58:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8002e5a:	794a      	ldrb	r2, [r1, #5]
 8002e5c:	790b      	ldrb	r3, [r1, #4]
 8002e5e:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8002e62:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 8002e64:	79ca      	ldrb	r2, [r1, #7]
 8002e66:	798b      	ldrb	r3, [r1, #6]
 8002e68:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8002e6c:	80c3      	strh	r3, [r0, #6]
 8002e6e:	4770      	bx	lr

08002e70 <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 8002e70:	b510      	push	{r4, lr}
 8002e72:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
 8002e74:	2180      	movs	r1, #128	; 0x80
 8002e76:	f000 fe1d 	bl	8003ab4 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 8002e7a:	2100      	movs	r1, #0
 8002e7c:	4620      	mov	r0, r4
 8002e7e:	f000 fe19 	bl	8003ab4 <USBD_LL_StallEP>
 8002e82:	bd10      	pop	{r4, pc}

08002e84 <USBD_StdDevReq>:
{
 8002e84:	b570      	push	{r4, r5, r6, lr}
 8002e86:	b082      	sub	sp, #8
 8002e88:	4605      	mov	r5, r0
 8002e8a:	460c      	mov	r4, r1
  switch (req->bRequest) 
 8002e8c:	784b      	ldrb	r3, [r1, #1]
 8002e8e:	2b09      	cmp	r3, #9
 8002e90:	f200 8168 	bhi.w	8003164 <USBD_StdDevReq+0x2e0>
 8002e94:	e8df f013 	tbh	[pc, r3, lsl #1]
 8002e98:	0150012d 	.word	0x0150012d
 8002e9c:	01430166 	.word	0x01430166
 8002ea0:	00a00166 	.word	0x00a00166
 8002ea4:	0166000a 	.word	0x0166000a
 8002ea8:	00c40111 	.word	0x00c40111
  switch (req->wValue >> 8)
 8002eac:	884a      	ldrh	r2, [r1, #2]
 8002eae:	0a13      	lsrs	r3, r2, #8
 8002eb0:	3b01      	subs	r3, #1
 8002eb2:	2b06      	cmp	r3, #6
 8002eb4:	f200 808c 	bhi.w	8002fd0 <USBD_StdDevReq+0x14c>
 8002eb8:	e8df f003 	tbb	[pc, r3]
 8002ebc:	8a321e04 	.word	0x8a321e04
 8002ec0:	6e8a      	.short	0x6e8a
 8002ec2:	7b          	.byte	0x7b
 8002ec3:	00          	.byte	0x00
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8002ec4:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002ec8:	681b      	ldr	r3, [r3, #0]
 8002eca:	f10d 0106 	add.w	r1, sp, #6
 8002ece:	7c00      	ldrb	r0, [r0, #16]
 8002ed0:	4798      	blx	r3
  if((len != 0)&& (req->wLength != 0))
 8002ed2:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8002ed6:	2a00      	cmp	r2, #0
 8002ed8:	f000 8146 	beq.w	8003168 <USBD_StdDevReq+0x2e4>
 8002edc:	88e3      	ldrh	r3, [r4, #6]
 8002ede:	2b00      	cmp	r3, #0
 8002ee0:	f000 8142 	beq.w	8003168 <USBD_StdDevReq+0x2e4>
    len = MIN(len , req->wLength);
 8002ee4:	429a      	cmp	r2, r3
 8002ee6:	bf28      	it	cs
 8002ee8:	461a      	movcs	r2, r3
 8002eea:	f8ad 2006 	strh.w	r2, [sp, #6]
    USBD_CtlSendData (pdev, 
 8002eee:	4601      	mov	r1, r0
 8002ef0:	4628      	mov	r0, r5
 8002ef2:	f000 fa00 	bl	80032f6 <USBD_CtlSendData>
 8002ef6:	e137      	b.n	8003168 <USBD_StdDevReq+0x2e4>
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 8002ef8:	7c03      	ldrb	r3, [r0, #16]
 8002efa:	b943      	cbnz	r3, 8002f0e <USBD_StdDevReq+0x8a>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 8002efc:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002f00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002f02:	f10d 0006 	add.w	r0, sp, #6
 8002f06:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8002f08:	2302      	movs	r3, #2
 8002f0a:	7043      	strb	r3, [r0, #1]
 8002f0c:	e7e1      	b.n	8002ed2 <USBD_StdDevReq+0x4e>
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8002f0e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002f12:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002f14:	f10d 0006 	add.w	r0, sp, #6
 8002f18:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8002f1a:	2302      	movs	r3, #2
 8002f1c:	7043      	strb	r3, [r0, #1]
 8002f1e:	e7d8      	b.n	8002ed2 <USBD_StdDevReq+0x4e>
    switch ((uint8_t)(req->wValue))
 8002f20:	b2d2      	uxtb	r2, r2
 8002f22:	2a05      	cmp	r2, #5
 8002f24:	d834      	bhi.n	8002f90 <USBD_StdDevReq+0x10c>
 8002f26:	e8df f002 	tbb	[pc, r2]
 8002f2a:	0b03      	.short	0x0b03
 8002f2c:	2b231b13 	.word	0x2b231b13
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 8002f30:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002f34:	685b      	ldr	r3, [r3, #4]
 8002f36:	f10d 0106 	add.w	r1, sp, #6
 8002f3a:	7c00      	ldrb	r0, [r0, #16]
 8002f3c:	4798      	blx	r3
 8002f3e:	e7c8      	b.n	8002ed2 <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8002f40:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002f44:	689b      	ldr	r3, [r3, #8]
 8002f46:	f10d 0106 	add.w	r1, sp, #6
 8002f4a:	7c00      	ldrb	r0, [r0, #16]
 8002f4c:	4798      	blx	r3
 8002f4e:	e7c0      	b.n	8002ed2 <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8002f50:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002f54:	68db      	ldr	r3, [r3, #12]
 8002f56:	f10d 0106 	add.w	r1, sp, #6
 8002f5a:	7c00      	ldrb	r0, [r0, #16]
 8002f5c:	4798      	blx	r3
 8002f5e:	e7b8      	b.n	8002ed2 <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8002f60:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002f64:	691b      	ldr	r3, [r3, #16]
 8002f66:	f10d 0106 	add.w	r1, sp, #6
 8002f6a:	7c00      	ldrb	r0, [r0, #16]
 8002f6c:	4798      	blx	r3
 8002f6e:	e7b0      	b.n	8002ed2 <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8002f70:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002f74:	695b      	ldr	r3, [r3, #20]
 8002f76:	f10d 0106 	add.w	r1, sp, #6
 8002f7a:	7c00      	ldrb	r0, [r0, #16]
 8002f7c:	4798      	blx	r3
 8002f7e:	e7a8      	b.n	8002ed2 <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8002f80:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002f84:	699b      	ldr	r3, [r3, #24]
 8002f86:	f10d 0106 	add.w	r1, sp, #6
 8002f8a:	7c00      	ldrb	r0, [r0, #16]
 8002f8c:	4798      	blx	r3
 8002f8e:	e7a0      	b.n	8002ed2 <USBD_StdDevReq+0x4e>
       USBD_CtlError(pdev , req);
 8002f90:	4621      	mov	r1, r4
 8002f92:	f7ff ff6d 	bl	8002e70 <USBD_CtlError>
 8002f96:	e0e7      	b.n	8003168 <USBD_StdDevReq+0x2e4>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8002f98:	7c03      	ldrb	r3, [r0, #16]
 8002f9a:	b933      	cbnz	r3, 8002faa <USBD_StdDevReq+0x126>
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8002f9c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002fa0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002fa2:	f10d 0006 	add.w	r0, sp, #6
 8002fa6:	4798      	blx	r3
 8002fa8:	e793      	b.n	8002ed2 <USBD_StdDevReq+0x4e>
      USBD_CtlError(pdev , req);
 8002faa:	4621      	mov	r1, r4
 8002fac:	f7ff ff60 	bl	8002e70 <USBD_CtlError>
 8002fb0:	e0da      	b.n	8003168 <USBD_StdDevReq+0x2e4>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8002fb2:	7c03      	ldrb	r3, [r0, #16]
 8002fb4:	b943      	cbnz	r3, 8002fc8 <USBD_StdDevReq+0x144>
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8002fb6:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002fba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002fbc:	f10d 0006 	add.w	r0, sp, #6
 8002fc0:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8002fc2:	2307      	movs	r3, #7
 8002fc4:	7043      	strb	r3, [r0, #1]
 8002fc6:	e784      	b.n	8002ed2 <USBD_StdDevReq+0x4e>
      USBD_CtlError(pdev , req);
 8002fc8:	4621      	mov	r1, r4
 8002fca:	f7ff ff51 	bl	8002e70 <USBD_CtlError>
 8002fce:	e0cb      	b.n	8003168 <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);
 8002fd0:	4621      	mov	r1, r4
 8002fd2:	f7ff ff4d 	bl	8002e70 <USBD_CtlError>
 8002fd6:	e0c7      	b.n	8003168 <USBD_StdDevReq+0x2e4>
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8002fd8:	888b      	ldrh	r3, [r1, #4]
 8002fda:	b9e3      	cbnz	r3, 8003016 <USBD_StdDevReq+0x192>
 8002fdc:	88cb      	ldrh	r3, [r1, #6]
 8002fde:	b9d3      	cbnz	r3, 8003016 <USBD_StdDevReq+0x192>
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8002fe0:	788e      	ldrb	r6, [r1, #2]
 8002fe2:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8002fe6:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002fea:	2b03      	cmp	r3, #3
 8002fec:	d00c      	beq.n	8003008 <USBD_StdDevReq+0x184>
      pdev->dev_address = dev_addr;
 8002fee:	f880 61fe 	strb.w	r6, [r0, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 8002ff2:	4631      	mov	r1, r6
 8002ff4:	f000 fd8f 	bl	8003b16 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 8002ff8:	4628      	mov	r0, r5
 8002ffa:	f000 f9a8 	bl	800334e <USBD_CtlSendStatus>
      if (dev_addr != 0) 
 8002ffe:	b136      	cbz	r6, 800300e <USBD_StdDevReq+0x18a>
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 8003000:	2302      	movs	r3, #2
 8003002:	f885 31fc 	strb.w	r3, [r5, #508]	; 0x1fc
 8003006:	e0af      	b.n	8003168 <USBD_StdDevReq+0x2e4>
      USBD_CtlError(pdev , req);
 8003008:	f7ff ff32 	bl	8002e70 <USBD_CtlError>
 800300c:	e0ac      	b.n	8003168 <USBD_StdDevReq+0x2e4>
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 800300e:	2301      	movs	r3, #1
 8003010:	f885 31fc 	strb.w	r3, [r5, #508]	; 0x1fc
 8003014:	e0a8      	b.n	8003168 <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);                        
 8003016:	4621      	mov	r1, r4
 8003018:	4628      	mov	r0, r5
 800301a:	f7ff ff29 	bl	8002e70 <USBD_CtlError>
 800301e:	e0a3      	b.n	8003168 <USBD_StdDevReq+0x2e4>
  cfgidx = (uint8_t)(req->wValue);                 
 8003020:	7889      	ldrb	r1, [r1, #2]
 8003022:	4b53      	ldr	r3, [pc, #332]	; (8003170 <USBD_StdDevReq+0x2ec>)
 8003024:	7019      	strb	r1, [r3, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8003026:	2901      	cmp	r1, #1
 8003028:	d809      	bhi.n	800303e <USBD_StdDevReq+0x1ba>
    switch (pdev->dev_state) 
 800302a:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800302e:	2b02      	cmp	r3, #2
 8003030:	d009      	beq.n	8003046 <USBD_StdDevReq+0x1c2>
 8003032:	2b03      	cmp	r3, #3
 8003034:	d01c      	beq.n	8003070 <USBD_StdDevReq+0x1ec>
       USBD_CtlError(pdev , req);                     
 8003036:	4621      	mov	r1, r4
 8003038:	f7ff ff1a 	bl	8002e70 <USBD_CtlError>
 800303c:	e094      	b.n	8003168 <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);                              
 800303e:	4621      	mov	r1, r4
 8003040:	f7ff ff16 	bl	8002e70 <USBD_CtlError>
 8003044:	e090      	b.n	8003168 <USBD_StdDevReq+0x2e4>
      if (cfgidx) 
 8003046:	b181      	cbz	r1, 800306a <USBD_StdDevReq+0x1e6>
        pdev->dev_config = cfgidx;
 8003048:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 800304a:	2303      	movs	r3, #3
 800304c:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8003050:	f7ff fddb 	bl	8002c0a <USBD_SetClassConfig>
 8003054:	2802      	cmp	r0, #2
 8003056:	d003      	beq.n	8003060 <USBD_StdDevReq+0x1dc>
        USBD_CtlSendStatus(pdev);
 8003058:	4628      	mov	r0, r5
 800305a:	f000 f978 	bl	800334e <USBD_CtlSendStatus>
 800305e:	e083      	b.n	8003168 <USBD_StdDevReq+0x2e4>
          USBD_CtlError(pdev , req);  
 8003060:	4621      	mov	r1, r4
 8003062:	4628      	mov	r0, r5
 8003064:	f7ff ff04 	bl	8002e70 <USBD_CtlError>
 8003068:	e07e      	b.n	8003168 <USBD_StdDevReq+0x2e4>
         USBD_CtlSendStatus(pdev);
 800306a:	f000 f970 	bl	800334e <USBD_CtlSendStatus>
 800306e:	e07b      	b.n	8003168 <USBD_StdDevReq+0x2e4>
      if (cfgidx == 0) 
 8003070:	b189      	cbz	r1, 8003096 <USBD_StdDevReq+0x212>
      else  if (cfgidx != pdev->dev_config) 
 8003072:	6843      	ldr	r3, [r0, #4]
 8003074:	4299      	cmp	r1, r3
 8003076:	d01d      	beq.n	80030b4 <USBD_StdDevReq+0x230>
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 8003078:	b2d9      	uxtb	r1, r3
 800307a:	f7ff fdd3 	bl	8002c24 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 800307e:	4b3c      	ldr	r3, [pc, #240]	; (8003170 <USBD_StdDevReq+0x2ec>)
 8003080:	7819      	ldrb	r1, [r3, #0]
 8003082:	6069      	str	r1, [r5, #4]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8003084:	4628      	mov	r0, r5
 8003086:	f7ff fdc0 	bl	8002c0a <USBD_SetClassConfig>
 800308a:	2802      	cmp	r0, #2
 800308c:	d00d      	beq.n	80030aa <USBD_StdDevReq+0x226>
        USBD_CtlSendStatus(pdev);
 800308e:	4628      	mov	r0, r5
 8003090:	f000 f95d 	bl	800334e <USBD_CtlSendStatus>
 8003094:	e068      	b.n	8003168 <USBD_StdDevReq+0x2e4>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8003096:	2302      	movs	r3, #2
 8003098:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
 800309c:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
 800309e:	f7ff fdc1 	bl	8002c24 <USBD_ClrClassConfig>
        USBD_CtlSendStatus(pdev);
 80030a2:	4628      	mov	r0, r5
 80030a4:	f000 f953 	bl	800334e <USBD_CtlSendStatus>
 80030a8:	e05e      	b.n	8003168 <USBD_StdDevReq+0x2e4>
          USBD_CtlError(pdev , req);  
 80030aa:	4621      	mov	r1, r4
 80030ac:	4628      	mov	r0, r5
 80030ae:	f7ff fedf 	bl	8002e70 <USBD_CtlError>
 80030b2:	e059      	b.n	8003168 <USBD_StdDevReq+0x2e4>
        USBD_CtlSendStatus(pdev);
 80030b4:	f000 f94b 	bl	800334e <USBD_CtlSendStatus>
 80030b8:	e056      	b.n	8003168 <USBD_StdDevReq+0x2e4>
  if (req->wLength != 1) 
 80030ba:	88cb      	ldrh	r3, [r1, #6]
 80030bc:	2b01      	cmp	r3, #1
 80030be:	d108      	bne.n	80030d2 <USBD_StdDevReq+0x24e>
    switch (pdev->dev_state )  
 80030c0:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80030c4:	2b02      	cmp	r3, #2
 80030c6:	d007      	beq.n	80030d8 <USBD_StdDevReq+0x254>
 80030c8:	2b03      	cmp	r3, #3
 80030ca:	d00d      	beq.n	80030e8 <USBD_StdDevReq+0x264>
       USBD_CtlError(pdev , req);
 80030cc:	f7ff fed0 	bl	8002e70 <USBD_CtlError>
 80030d0:	e04a      	b.n	8003168 <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);
 80030d2:	f7ff fecd 	bl	8002e70 <USBD_CtlError>
 80030d6:	e047      	b.n	8003168 <USBD_StdDevReq+0x2e4>
      pdev->dev_default_config = 0;
 80030d8:	4601      	mov	r1, r0
 80030da:	2300      	movs	r3, #0
 80030dc:	f841 3f08 	str.w	r3, [r1, #8]!
      USBD_CtlSendData (pdev, 
 80030e0:	2201      	movs	r2, #1
 80030e2:	f000 f908 	bl	80032f6 <USBD_CtlSendData>
 80030e6:	e03f      	b.n	8003168 <USBD_StdDevReq+0x2e4>
      USBD_CtlSendData (pdev, 
 80030e8:	2201      	movs	r2, #1
 80030ea:	1d01      	adds	r1, r0, #4
 80030ec:	f000 f903 	bl	80032f6 <USBD_CtlSendData>
 80030f0:	e03a      	b.n	8003168 <USBD_StdDevReq+0x2e4>
  switch (pdev->dev_state) 
 80030f2:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80030f6:	3b02      	subs	r3, #2
 80030f8:	2b01      	cmp	r3, #1
 80030fa:	d80d      	bhi.n	8003118 <USBD_StdDevReq+0x294>
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 80030fc:	2301      	movs	r3, #1
 80030fe:	60c3      	str	r3, [r0, #12]
    if (pdev->dev_remote_wakeup) 
 8003100:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
 8003104:	b10b      	cbz	r3, 800310a <USBD_StdDevReq+0x286>
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 8003106:	2303      	movs	r3, #3
 8003108:	60c3      	str	r3, [r0, #12]
    USBD_CtlSendData (pdev, 
 800310a:	2202      	movs	r2, #2
 800310c:	f105 010c 	add.w	r1, r5, #12
 8003110:	4628      	mov	r0, r5
 8003112:	f000 f8f0 	bl	80032f6 <USBD_CtlSendData>
 8003116:	e027      	b.n	8003168 <USBD_StdDevReq+0x2e4>
    USBD_CtlError(pdev , req);                        
 8003118:	f7ff feaa 	bl	8002e70 <USBD_CtlError>
 800311c:	e024      	b.n	8003168 <USBD_StdDevReq+0x2e4>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800311e:	884b      	ldrh	r3, [r1, #2]
 8003120:	2b01      	cmp	r3, #1
 8003122:	d121      	bne.n	8003168 <USBD_StdDevReq+0x2e4>
    pdev->dev_remote_wakeup = 1;  
 8003124:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
    pdev->pClass->Setup (pdev, req);   
 8003128:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800312c:	689b      	ldr	r3, [r3, #8]
 800312e:	4798      	blx	r3
    USBD_CtlSendStatus(pdev);
 8003130:	4628      	mov	r0, r5
 8003132:	f000 f90c 	bl	800334e <USBD_CtlSendStatus>
 8003136:	e017      	b.n	8003168 <USBD_StdDevReq+0x2e4>
  switch (pdev->dev_state)
 8003138:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800313c:	3b02      	subs	r3, #2
 800313e:	2b01      	cmp	r3, #1
 8003140:	d80d      	bhi.n	800315e <USBD_StdDevReq+0x2da>
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 8003142:	884b      	ldrh	r3, [r1, #2]
 8003144:	2b01      	cmp	r3, #1
 8003146:	d10f      	bne.n	8003168 <USBD_StdDevReq+0x2e4>
      pdev->dev_remote_wakeup = 0; 
 8003148:	2300      	movs	r3, #0
 800314a:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 800314e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003152:	689b      	ldr	r3, [r3, #8]
 8003154:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 8003156:	4628      	mov	r0, r5
 8003158:	f000 f8f9 	bl	800334e <USBD_CtlSendStatus>
 800315c:	e004      	b.n	8003168 <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);
 800315e:	f7ff fe87 	bl	8002e70 <USBD_CtlError>
 8003162:	e001      	b.n	8003168 <USBD_StdDevReq+0x2e4>
    USBD_CtlError(pdev , req);
 8003164:	f7ff fe84 	bl	8002e70 <USBD_CtlError>
}
 8003168:	2000      	movs	r0, #0
 800316a:	b002      	add	sp, #8
 800316c:	bd70      	pop	{r4, r5, r6, pc}
 800316e:	bf00      	nop
 8003170:	200001d0 	.word	0x200001d0

08003174 <USBD_StdItfReq>:
{
 8003174:	b538      	push	{r3, r4, r5, lr}
 8003176:	4604      	mov	r4, r0
 8003178:	460d      	mov	r5, r1
  switch (pdev->dev_state) 
 800317a:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800317e:	2b03      	cmp	r3, #3
 8003180:	d111      	bne.n	80031a6 <USBD_StdItfReq+0x32>
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 8003182:	790b      	ldrb	r3, [r1, #4]
 8003184:	2b01      	cmp	r3, #1
 8003186:	d903      	bls.n	8003190 <USBD_StdItfReq+0x1c>
       USBD_CtlError(pdev , req);
 8003188:	f7ff fe72 	bl	8002e70 <USBD_CtlError>
}
 800318c:	2000      	movs	r0, #0
 800318e:	bd38      	pop	{r3, r4, r5, pc}
      pdev->pClass->Setup (pdev, req); 
 8003190:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003194:	689b      	ldr	r3, [r3, #8]
 8003196:	4798      	blx	r3
      if((req->wLength == 0)&& (ret == USBD_OK))
 8003198:	88eb      	ldrh	r3, [r5, #6]
 800319a:	2b00      	cmp	r3, #0
 800319c:	d1f6      	bne.n	800318c <USBD_StdItfReq+0x18>
         USBD_CtlSendStatus(pdev);
 800319e:	4620      	mov	r0, r4
 80031a0:	f000 f8d5 	bl	800334e <USBD_CtlSendStatus>
 80031a4:	e7f2      	b.n	800318c <USBD_StdItfReq+0x18>
     USBD_CtlError(pdev , req);
 80031a6:	f7ff fe63 	bl	8002e70 <USBD_CtlError>
    break;
 80031aa:	e7ef      	b.n	800318c <USBD_StdItfReq+0x18>

080031ac <USBD_StdEPReq>:
{
 80031ac:	b538      	push	{r3, r4, r5, lr}
 80031ae:	4605      	mov	r5, r0
 80031b0:	460c      	mov	r4, r1
  ep_addr  = LOBYTE(req->wIndex);   
 80031b2:	888a      	ldrh	r2, [r1, #4]
  if ((req->bmRequest & 0x60) == 0x20)
 80031b4:	780b      	ldrb	r3, [r1, #0]
 80031b6:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80031ba:	2b20      	cmp	r3, #32
 80031bc:	d011      	beq.n	80031e2 <USBD_StdEPReq+0x36>
 80031be:	b2d1      	uxtb	r1, r2
  switch (req->bRequest) 
 80031c0:	7863      	ldrb	r3, [r4, #1]
 80031c2:	2b01      	cmp	r3, #1
 80031c4:	d02a      	beq.n	800321c <USBD_StdEPReq+0x70>
 80031c6:	2b00      	cmp	r3, #0
 80031c8:	d04b      	beq.n	8003262 <USBD_StdEPReq+0xb6>
 80031ca:	2b03      	cmp	r3, #3
 80031cc:	d10d      	bne.n	80031ea <USBD_StdEPReq+0x3e>
    switch (pdev->dev_state) 
 80031ce:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80031d2:	2b02      	cmp	r3, #2
 80031d4:	d00b      	beq.n	80031ee <USBD_StdEPReq+0x42>
 80031d6:	2b03      	cmp	r3, #3
 80031d8:	d00f      	beq.n	80031fa <USBD_StdEPReq+0x4e>
      USBD_CtlError(pdev , req);
 80031da:	4621      	mov	r1, r4
 80031dc:	f7ff fe48 	bl	8002e70 <USBD_CtlError>
      break;    
 80031e0:	e003      	b.n	80031ea <USBD_StdEPReq+0x3e>
    pdev->pClass->Setup (pdev, req);
 80031e2:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80031e6:	689b      	ldr	r3, [r3, #8]
 80031e8:	4798      	blx	r3
}
 80031ea:	2000      	movs	r0, #0
 80031ec:	bd38      	pop	{r3, r4, r5, pc}
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80031ee:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 80031f2:	d0fa      	beq.n	80031ea <USBD_StdEPReq+0x3e>
        USBD_LL_StallEP(pdev , ep_addr);
 80031f4:	f000 fc5e 	bl	8003ab4 <USBD_LL_StallEP>
 80031f8:	e7f7      	b.n	80031ea <USBD_StdEPReq+0x3e>
      if (req->wValue == USB_FEATURE_EP_HALT)
 80031fa:	8863      	ldrh	r3, [r4, #2]
 80031fc:	b923      	cbnz	r3, 8003208 <USBD_StdEPReq+0x5c>
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80031fe:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 8003202:	d001      	beq.n	8003208 <USBD_StdEPReq+0x5c>
          USBD_LL_StallEP(pdev , ep_addr);
 8003204:	f000 fc56 	bl	8003ab4 <USBD_LL_StallEP>
      pdev->pClass->Setup (pdev, req);   
 8003208:	f8d5 3214 	ldr.w	r3, [r5, #532]	; 0x214
 800320c:	689b      	ldr	r3, [r3, #8]
 800320e:	4621      	mov	r1, r4
 8003210:	4628      	mov	r0, r5
 8003212:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 8003214:	4628      	mov	r0, r5
 8003216:	f000 f89a 	bl	800334e <USBD_CtlSendStatus>
      break;
 800321a:	e7e6      	b.n	80031ea <USBD_StdEPReq+0x3e>
    switch (pdev->dev_state) 
 800321c:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003220:	2b02      	cmp	r3, #2
 8003222:	d005      	beq.n	8003230 <USBD_StdEPReq+0x84>
 8003224:	2b03      	cmp	r3, #3
 8003226:	d009      	beq.n	800323c <USBD_StdEPReq+0x90>
      USBD_CtlError(pdev , req);
 8003228:	4621      	mov	r1, r4
 800322a:	f7ff fe21 	bl	8002e70 <USBD_CtlError>
      break;    
 800322e:	e7dc      	b.n	80031ea <USBD_StdEPReq+0x3e>
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8003230:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 8003234:	d0d9      	beq.n	80031ea <USBD_StdEPReq+0x3e>
        USBD_LL_StallEP(pdev , ep_addr);
 8003236:	f000 fc3d 	bl	8003ab4 <USBD_LL_StallEP>
 800323a:	e7d6      	b.n	80031ea <USBD_StdEPReq+0x3e>
      if (req->wValue == USB_FEATURE_EP_HALT)
 800323c:	8863      	ldrh	r3, [r4, #2]
 800323e:	2b00      	cmp	r3, #0
 8003240:	d1d3      	bne.n	80031ea <USBD_StdEPReq+0x3e>
        if ((ep_addr & 0x7F) != 0x00) 
 8003242:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 8003246:	d103      	bne.n	8003250 <USBD_StdEPReq+0xa4>
        USBD_CtlSendStatus(pdev);
 8003248:	4628      	mov	r0, r5
 800324a:	f000 f880 	bl	800334e <USBD_CtlSendStatus>
 800324e:	e7cc      	b.n	80031ea <USBD_StdEPReq+0x3e>
          USBD_LL_ClearStallEP(pdev , ep_addr);
 8003250:	f000 fc3d 	bl	8003ace <USBD_LL_ClearStallEP>
          pdev->pClass->Setup (pdev, req);
 8003254:	f8d5 3214 	ldr.w	r3, [r5, #532]	; 0x214
 8003258:	689b      	ldr	r3, [r3, #8]
 800325a:	4621      	mov	r1, r4
 800325c:	4628      	mov	r0, r5
 800325e:	4798      	blx	r3
 8003260:	e7f2      	b.n	8003248 <USBD_StdEPReq+0x9c>
    switch (pdev->dev_state) 
 8003262:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003266:	2b02      	cmp	r3, #2
 8003268:	d005      	beq.n	8003276 <USBD_StdEPReq+0xca>
 800326a:	2b03      	cmp	r3, #3
 800326c:	d009      	beq.n	8003282 <USBD_StdEPReq+0xd6>
      USBD_CtlError(pdev , req);
 800326e:	4621      	mov	r1, r4
 8003270:	f7ff fdfe 	bl	8002e70 <USBD_CtlError>
      break;
 8003274:	e7b9      	b.n	80031ea <USBD_StdEPReq+0x3e>
      if ((ep_addr & 0x7F) != 0x00) 
 8003276:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 800327a:	d0b6      	beq.n	80031ea <USBD_StdEPReq+0x3e>
        USBD_LL_StallEP(pdev , ep_addr);
 800327c:	f000 fc1a 	bl	8003ab4 <USBD_LL_StallEP>
 8003280:	e7b3      	b.n	80031ea <USBD_StdEPReq+0x3e>
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8003282:	f012 0f80 	tst.w	r2, #128	; 0x80
 8003286:	f001 047f 	and.w	r4, r1, #127	; 0x7f
 800328a:	eb00 1404 	add.w	r4, r0, r4, lsl #4
 800328e:	bf14      	ite	ne
 8003290:	3414      	addne	r4, #20
 8003292:	f504 7482 	addeq.w	r4, r4, #260	; 0x104
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 8003296:	f000 fc27 	bl	8003ae8 <USBD_LL_IsStallEP>
 800329a:	b138      	cbz	r0, 80032ac <USBD_StdEPReq+0x100>
        pep->status = 0x0001;     
 800329c:	2301      	movs	r3, #1
 800329e:	6023      	str	r3, [r4, #0]
      USBD_CtlSendData (pdev,
 80032a0:	2202      	movs	r2, #2
 80032a2:	4621      	mov	r1, r4
 80032a4:	4628      	mov	r0, r5
 80032a6:	f000 f826 	bl	80032f6 <USBD_CtlSendData>
      break;
 80032aa:	e79e      	b.n	80031ea <USBD_StdEPReq+0x3e>
        pep->status = 0x0000;  
 80032ac:	2300      	movs	r3, #0
 80032ae:	6023      	str	r3, [r4, #0]
 80032b0:	e7f6      	b.n	80032a0 <USBD_StdEPReq+0xf4>

080032b2 <USBD_GetString>:
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
 80032b2:	b1f8      	cbz	r0, 80032f4 <USBD_GetString+0x42>
{
 80032b4:	b430      	push	{r4, r5}
 80032b6:	4604      	mov	r4, r0
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 80032b8:	7803      	ldrb	r3, [r0, #0]
 80032ba:	b133      	cbz	r3, 80032ca <USBD_GetString+0x18>
 80032bc:	2300      	movs	r3, #0
    {
        len++;
 80032be:	3301      	adds	r3, #1
 80032c0:	b2db      	uxtb	r3, r3
    while (*buf != '\0') 
 80032c2:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 80032c6:	2d00      	cmp	r5, #0
 80032c8:	d1f9      	bne.n	80032be <USBD_GetString+0xc>
    *len =  USBD_GetLen(desc) * 2 + 2;    
 80032ca:	005b      	lsls	r3, r3, #1
 80032cc:	3302      	adds	r3, #2
 80032ce:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
 80032d0:	700b      	strb	r3, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 80032d2:	2303      	movs	r3, #3
 80032d4:	704b      	strb	r3, [r1, #1]
    while (*desc != '\0') 
 80032d6:	7820      	ldrb	r0, [r4, #0]
 80032d8:	b158      	cbz	r0, 80032f2 <USBD_GetString+0x40>
 80032da:	2302      	movs	r3, #2
      unicode[idx++] =  0x00;
 80032dc:	2500      	movs	r5, #0
      unicode[idx++] = *desc++;
 80032de:	1c5a      	adds	r2, r3, #1
 80032e0:	b2d2      	uxtb	r2, r2
 80032e2:	54c8      	strb	r0, [r1, r3]
      unicode[idx++] =  0x00;
 80032e4:	3302      	adds	r3, #2
 80032e6:	b2db      	uxtb	r3, r3
 80032e8:	548d      	strb	r5, [r1, r2]
    while (*desc != '\0') 
 80032ea:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 80032ee:	2800      	cmp	r0, #0
 80032f0:	d1f5      	bne.n	80032de <USBD_GetString+0x2c>
}
 80032f2:	bc30      	pop	{r4, r5}
 80032f4:	4770      	bx	lr

080032f6 <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 80032f6:	b510      	push	{r4, lr}
 80032f8:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 80032fa:	2202      	movs	r2, #2
 80032fc:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
 8003300:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
 8003302:	61c3      	str	r3, [r0, #28]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8003304:	460a      	mov	r2, r1
 8003306:	2100      	movs	r1, #0
 8003308:	f000 fc12 	bl	8003b30 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 800330c:	2000      	movs	r0, #0
 800330e:	bd10      	pop	{r4, pc}

08003310 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8003310:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 8003312:	4613      	mov	r3, r2
 8003314:	460a      	mov	r2, r1
 8003316:	2100      	movs	r1, #0
 8003318:	f000 fc0a 	bl	8003b30 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 800331c:	2000      	movs	r0, #0
 800331e:	bd08      	pop	{r3, pc}

08003320 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlPrepareRx (USBD_HandleTypeDef  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 8003320:	b510      	push	{r4, lr}
 8003322:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
 8003324:	2203      	movs	r2, #3
 8003326:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_out[0].total_length = len;
 800332a:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  pdev->ep_out[0].rem_length   = len;
 800332e:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev,
 8003332:	460a      	mov	r2, r1
 8003334:	2100      	movs	r1, #0
 8003336:	f000 fc08 	bl	8003b4a <USBD_LL_PrepareReceive>
                          0,
                          pbuf,
                         len);
  
  return USBD_OK;
}
 800333a:	2000      	movs	r0, #0
 800333c:	bd10      	pop	{r4, pc}

0800333e <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 800333e:	b508      	push	{r3, lr}

  USBD_LL_PrepareReceive (pdev,
 8003340:	4613      	mov	r3, r2
 8003342:	460a      	mov	r2, r1
 8003344:	2100      	movs	r1, #0
 8003346:	f000 fc00 	bl	8003b4a <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
 800334a:	2000      	movs	r0, #0
 800334c:	bd08      	pop	{r3, pc}

0800334e <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 800334e:	b508      	push	{r3, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8003350:	2304      	movs	r3, #4
 8003352:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 8003356:	2300      	movs	r3, #0
 8003358:	461a      	mov	r2, r3
 800335a:	4619      	mov	r1, r3
 800335c:	f000 fbe8 	bl	8003b30 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8003360:	2000      	movs	r0, #0
 8003362:	bd08      	pop	{r3, pc}

08003364 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 8003364:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 8003366:	2305      	movs	r3, #5
 8003368:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 800336c:	2300      	movs	r3, #0
 800336e:	461a      	mov	r2, r3
 8003370:	4619      	mov	r1, r3
 8003372:	f000 fbea 	bl	8003b4a <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}
 8003376:	2000      	movs	r0, #0
 8003378:	bd08      	pop	{r3, pc}
	...

0800337c <netif_init_cb>:
{
  return etharp_output(netif, p, ipaddr);
}

err_t netif_init_cb(struct netif *netif)
{
 800337c:	4603      	mov	r3, r0
  LWIP_ASSERT("netif != NULL", (netif != NULL));
  netif->mtu = ETH_MTU;
 800337e:	f240 52dc 	movw	r2, #1500	; 0x5dc
 8003382:	8402      	strh	r2, [r0, #32]
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP | NETIF_FLAG_UP;
 8003384:	2233      	movs	r2, #51	; 0x33
 8003386:	f880 2029 	strb.w	r2, [r0, #41]	; 0x29
  netif->state = NULL;
 800338a:	2000      	movs	r0, #0
 800338c:	61d8      	str	r0, [r3, #28]
  netif->name[0] = 'E';
 800338e:	2245      	movs	r2, #69	; 0x45
 8003390:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
  netif->name[1] = 'X';
 8003394:	2258      	movs	r2, #88	; 0x58
 8003396:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
  netif->linkoutput = linkoutput_fn;
 800339a:	4a02      	ldr	r2, [pc, #8]	; (80033a4 <netif_init_cb+0x28>)
 800339c:	619a      	str	r2, [r3, #24]
  netif->output = output_fn;
 800339e:	4a02      	ldr	r2, [pc, #8]	; (80033a8 <netif_init_cb+0x2c>)
 80033a0:	615a      	str	r2, [r3, #20]
  return ERR_OK;
}
 80033a2:	4770      	bx	lr
 80033a4:	080033ad 	.word	0x080033ad
 80033a8:	08003405 	.word	0x08003405

080033ac <linkoutput_fn>:
{
 80033ac:	b570      	push	{r4, r5, r6, lr}
 80033ae:	460c      	mov	r4, r1
 80033b0:	25c8      	movs	r5, #200	; 0xc8
    msleep(1);
 80033b2:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
    if (!rndis_tx_started()) break;
 80033b6:	f7ff f8fd 	bl	80025b4 <rndis_tx_started>
 80033ba:	b120      	cbz	r0, 80033c6 <linkoutput_fn+0x1a>
    msleep(1);
 80033bc:	4630      	mov	r0, r6
 80033be:	f000 fa26 	bl	800380e <usleep>
  for (i = 0; i < 200; i++)
 80033c2:	3d01      	subs	r5, #1
 80033c4:	d1f7      	bne.n	80033b6 <linkoutput_fn+0xa>
  if (rndis_tx_started())
 80033c6:	f7ff f8f5 	bl	80025b4 <rndis_tx_started>
 80033ca:	b9a8      	cbnz	r0, 80033f8 <linkoutput_fn+0x4c>
  for(q = p; q != NULL; q = q->next)                                            //TODO
 80033cc:	b194      	cbz	r4, 80033f4 <linkoutput_fn+0x48>
 80033ce:	2500      	movs	r5, #0
    memcpy(pbuffer + size, (char *)q->payload, q->len);
 80033d0:	4e0b      	ldr	r6, [pc, #44]	; (8003400 <linkoutput_fn+0x54>)
 80033d2:	8962      	ldrh	r2, [r4, #10]
 80033d4:	6861      	ldr	r1, [r4, #4]
 80033d6:	1970      	adds	r0, r6, r5
 80033d8:	f005 fd59 	bl	8008e8e <memcpy>
    size += q->len;
 80033dc:	8963      	ldrh	r3, [r4, #10]
 80033de:	441d      	add	r5, r3
 80033e0:	b2ad      	uxth	r5, r5
  for(q = p; q != NULL; q = q->next)                                            //TODO
 80033e2:	6824      	ldr	r4, [r4, #0]
 80033e4:	2c00      	cmp	r4, #0
 80033e6:	d1f4      	bne.n	80033d2 <linkoutput_fn+0x26>
  rndis_tx_start(pbuffer, size);
 80033e8:	4629      	mov	r1, r5
 80033ea:	4805      	ldr	r0, [pc, #20]	; (8003400 <linkoutput_fn+0x54>)
 80033ec:	f7ff f886 	bl	80024fc <rndis_tx_start>
  return ERR_OK;
 80033f0:	2000      	movs	r0, #0
 80033f2:	bd70      	pop	{r4, r5, r6, pc}
  for(q = p; q != NULL; q = q->next)                                            //TODO
 80033f4:	2500      	movs	r5, #0
 80033f6:	e7f7      	b.n	80033e8 <linkoutput_fn+0x3c>
    return ERR_USE;
 80033f8:	f06f 0007 	mvn.w	r0, #7
}
 80033fc:	bd70      	pop	{r4, r5, r6, pc}
 80033fe:	bf00      	nop
 8003400:	200001d4 	.word	0x200001d4

08003404 <output_fn>:
{
 8003404:	b508      	push	{r3, lr}
  return etharp_output(netif, p, ipaddr);
 8003406:	f005 fb67 	bl	8008ad8 <etharp_output>
}
 800340a:	bd08      	pop	{r3, pc}

0800340c <tcp_timer_proc>:

TIMER_PROC(tcp_timer, TCP_TMR_INTERVAL * 1000, 1, NULL)
{
 800340c:	b508      	push	{r3, lr}
  tcp_tmr();
 800340e:	f002 feff 	bl	8006210 <tcp_tmr>
 8003412:	bd08      	pop	{r3, pc}

08003414 <dns_query_proc>:
}

bool dns_query_proc(const char *name, ip_addr_t *addr)
{
 8003414:	b538      	push	{r3, r4, r5, lr}
 8003416:	4605      	mov	r5, r0
 8003418:	460c      	mov	r4, r1
  if (strcmp(name, "run.stm") == 0 || strcmp(name, "www.run.stm") == 0)
 800341a:	4908      	ldr	r1, [pc, #32]	; (800343c <dns_query_proc+0x28>)
 800341c:	f7fc fedc 	bl	80001d8 <strcmp>
 8003420:	b120      	cbz	r0, 800342c <dns_query_proc+0x18>
 8003422:	4907      	ldr	r1, [pc, #28]	; (8003440 <dns_query_proc+0x2c>)
 8003424:	4628      	mov	r0, r5
 8003426:	f7fc fed7 	bl	80001d8 <strcmp>
 800342a:	b920      	cbnz	r0, 8003436 <dns_query_proc+0x22>
  {
    addr->addr = *(uint32_t *)ipaddr;
 800342c:	4b05      	ldr	r3, [pc, #20]	; (8003444 <dns_query_proc+0x30>)
 800342e:	681b      	ldr	r3, [r3, #0]
 8003430:	6023      	str	r3, [r4, #0]
    return true;
 8003432:	2001      	movs	r0, #1
 8003434:	bd38      	pop	{r3, r4, r5, pc}
  }
  return false;
 8003436:	2000      	movs	r0, #0
}
 8003438:	bd38      	pop	{r3, r4, r5, pc}
 800343a:	bf00      	nop
 800343c:	08008f48 	.word	0x08008f48
 8003440:	08008f44 	.word	0x08008f44
 8003444:	08008f50 	.word	0x08008f50

08003448 <usb_polling>:
{
 8003448:	b570      	push	{r4, r5, r6, lr}
  if (!rndis_rx_data()) 
 800344a:	f7ff f84b 	bl	80024e4 <rndis_rx_data>
 800344e:	b1f8      	cbz	r0, 8003490 <usb_polling+0x48>
  frame = pbuf_alloc(PBUF_RAW, rndis_rx_size(), PBUF_POOL);
 8003450:	f7ff f83c 	bl	80024cc <rndis_rx_size>
 8003454:	2203      	movs	r2, #3
 8003456:	4601      	mov	r1, r0
 8003458:	4610      	mov	r0, r2
 800345a:	f002 f93b 	bl	80056d4 <pbuf_alloc>
  if (frame == NULL) 
 800345e:	4604      	mov	r4, r0
 8003460:	b1b0      	cbz	r0, 8003490 <usb_polling+0x48>
  memcpy(frame->payload, rndis_rx_data(), rndis_rx_size());
 8003462:	6845      	ldr	r5, [r0, #4]
 8003464:	f7ff f83e 	bl	80024e4 <rndis_rx_data>
 8003468:	4606      	mov	r6, r0
 800346a:	f7ff f82f 	bl	80024cc <rndis_rx_size>
 800346e:	4602      	mov	r2, r0
 8003470:	4631      	mov	r1, r6
 8003472:	4628      	mov	r0, r5
 8003474:	f005 fd0b 	bl	8008e8e <memcpy>
  frame->len = rndis_rx_size();
 8003478:	f7ff f828 	bl	80024cc <rndis_rx_size>
 800347c:	8160      	strh	r0, [r4, #10]
  rndis_rx_start();
 800347e:	f7fe ffed 	bl	800245c <rndis_rx_start>
  ethernet_input(frame, &netif_data);
 8003482:	4904      	ldr	r1, [pc, #16]	; (8003494 <usb_polling+0x4c>)
 8003484:	4620      	mov	r0, r4
 8003486:	f005 fbb9 	bl	8008bfc <ethernet_input>
  pbuf_free(frame);
 800348a:	4620      	mov	r0, r4
 800348c:	f002 f8f3 	bl	8005676 <pbuf_free>
 8003490:	bd70      	pop	{r4, r5, r6, pc}
 8003492:	bf00      	nop
 8003494:	2000793c 	.word	0x2000793c

08003498 <init_lwip>:

void init_lwip()
{
 8003498:	b530      	push	{r4, r5, lr}
 800349a:	b087      	sub	sp, #28
uint8_t hwaddr[6]  = HWADDR;
uint8_t netmask[4] = NETMASK;
 800349c:	23ff      	movs	r3, #255	; 0xff
 800349e:	f88d 3014 	strb.w	r3, [sp, #20]
 80034a2:	f88d 3015 	strb.w	r3, [sp, #21]
 80034a6:	f88d 3016 	strb.w	r3, [sp, #22]
 80034aa:	2500      	movs	r5, #0
 80034ac:	f88d 5017 	strb.w	r5, [sp, #23]
uint8_t gateway[4] = GATEWAY;
 80034b0:	ac06      	add	r4, sp, #24
 80034b2:	f844 5d08 	str.w	r5, [r4, #-8]!

  struct netif  *netif = &netif_data;
  
  lwip_init();
 80034b6:	f000 fe7d 	bl	80041b4 <lwip_init>
  netif->hwaddr_len = 6;
 80034ba:	4813      	ldr	r0, [pc, #76]	; (8003508 <init_lwip+0x70>)
 80034bc:	2306      	movs	r3, #6
 80034be:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
  memcpy(netif->hwaddr, hwaddr, 6);
 80034c2:	2320      	movs	r3, #32
 80034c4:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
 80034c8:	2389      	movs	r3, #137	; 0x89
 80034ca:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
 80034ce:	2384      	movs	r3, #132	; 0x84
 80034d0:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
 80034d4:	236a      	movs	r3, #106	; 0x6a
 80034d6:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
 80034da:	2396      	movs	r3, #150	; 0x96
 80034dc:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
 80034e0:	2334      	movs	r3, #52	; 0x34
 80034e2:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28
  
  netif = netif_add(netif, PADDR(ipaddr), PADDR(netmask), PADDR(gateway), NULL, netif_init_cb, ip_input);
 80034e6:	4b09      	ldr	r3, [pc, #36]	; (800350c <init_lwip+0x74>)
 80034e8:	9302      	str	r3, [sp, #8]
 80034ea:	4b09      	ldr	r3, [pc, #36]	; (8003510 <init_lwip+0x78>)
 80034ec:	9301      	str	r3, [sp, #4]
 80034ee:	9500      	str	r5, [sp, #0]
 80034f0:	4623      	mov	r3, r4
 80034f2:	aa05      	add	r2, sp, #20
 80034f4:	4907      	ldr	r1, [pc, #28]	; (8003514 <init_lwip+0x7c>)
 80034f6:	f002 f827 	bl	8005548 <netif_add>
  netif_set_default(netif);
 80034fa:	f002 f849 	bl	8005590 <netif_set_default>
  
  stmr_add(&tcp_timer);
 80034fe:	4806      	ldr	r0, [pc, #24]	; (8003518 <init_lwip+0x80>)
 8003500:	f000 f9b8 	bl	8003874 <stmr_add>
}
 8003504:	b007      	add	sp, #28
 8003506:	bd30      	pop	{r4, r5, pc}
 8003508:	2000793c 	.word	0x2000793c
 800350c:	080045f5 	.word	0x080045f5
 8003510:	0800337d 	.word	0x0800337d
 8003514:	08008f50 	.word	0x08008f50
 8003518:	200000f4 	.word	0x200000f4

0800351c <init_netif>:

void init_netif(void)
{
  while (!netif_is_up(&netif_data));
 800351c:	4b03      	ldr	r3, [pc, #12]	; (800352c <init_netif+0x10>)
 800351e:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8003522:	f003 0301 	and.w	r3, r3, #1
 8003526:	2b00      	cmp	r3, #0
 8003528:	d0fd      	beq.n	8003526 <init_netif+0xa>
}
 800352a:	4770      	bx	lr
 800352c:	2000793c 	.word	0x2000793c

08003530 <init_dnserv>:

void init_dnserv(void)
{
 8003530:	b570      	push	{r4, r5, r6, lr}
 8003532:	b082      	sub	sp, #8
uint8_t ipaddr[4]  = IPADDR;
 8003534:	4b07      	ldr	r3, [pc, #28]	; (8003554 <init_dnserv+0x24>)
 8003536:	681b      	ldr	r3, [r3, #0]
 8003538:	ac02      	add	r4, sp, #8
 800353a:	f844 3d04 	str.w	r3, [r4, #-4]!
  while (dnserv_init(PADDR(ipaddr), 53, dns_query_proc) != ERR_OK) ;
 800353e:	4e06      	ldr	r6, [pc, #24]	; (8003558 <init_dnserv+0x28>)
 8003540:	2535      	movs	r5, #53	; 0x35
 8003542:	4632      	mov	r2, r6
 8003544:	4629      	mov	r1, r5
 8003546:	4620      	mov	r0, r4
 8003548:	f000 fdf0 	bl	800412c <dnserv_init>
 800354c:	2800      	cmp	r0, #0
 800354e:	d1f8      	bne.n	8003542 <init_dnserv+0x12>
}
 8003550:	b002      	add	sp, #8
 8003552:	bd70      	pop	{r4, r5, r6, pc}
 8003554:	08008ed8 	.word	0x08008ed8
 8003558:	08003415 	.word	0x08003415

0800355c <init_dhserv>:

void init_dhserv(void)
{
 800355c:	b510      	push	{r4, lr}
  while (dhserv_init(&dhcp_config) != ERR_OK) ;
 800355e:	4c03      	ldr	r4, [pc, #12]	; (800356c <init_dhserv+0x10>)
 8003560:	4620      	mov	r0, r4
 8003562:	f000 fcfb 	bl	8003f5c <dhserv_init>
 8003566:	2800      	cmp	r0, #0
 8003568:	d1fa      	bne.n	8003560 <init_dhserv+0x4>
}
 800356a:	bd10      	pop	{r4, pc}
 800356c:	200000a0 	.word	0x200000a0

08003570 <MX_GPIO_Init>:

  //time_init();
}

void MX_GPIO_Init(void)
{
 8003570:	b082      	sub	sp, #8

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8003572:	2100      	movs	r1, #0
 8003574:	9100      	str	r1, [sp, #0]
 8003576:	4b0b      	ldr	r3, [pc, #44]	; (80035a4 <MX_GPIO_Init+0x34>)
 8003578:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800357a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800357e:	631a      	str	r2, [r3, #48]	; 0x30
 8003580:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003582:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8003586:	9200      	str	r2, [sp, #0]
 8003588:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800358a:	9101      	str	r1, [sp, #4]
 800358c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800358e:	f042 0201 	orr.w	r2, r2, #1
 8003592:	631a      	str	r2, [r3, #48]	; 0x30
 8003594:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003596:	f003 0301 	and.w	r3, r3, #1
 800359a:	9301      	str	r3, [sp, #4]
 800359c:	9b01      	ldr	r3, [sp, #4]

}
 800359e:	b002      	add	sp, #8
 80035a0:	4770      	bx	lr
 80035a2:	bf00      	nop
 80035a4:	40023800 	.word	0x40023800

080035a8 <init_periph>:
{
 80035a8:	b508      	push	{r3, lr}
  HAL_Init();
 80035aa:	f7fd f825 	bl	80005f8 <HAL_Init>
  SystemClock_Config();
 80035ae:	f000 f821 	bl	80035f4 <SystemClock_Config>
  MX_GPIO_Init();
 80035b2:	f7ff ffdd 	bl	8003570 <MX_GPIO_Init>
  USB_DEVICE_Init();
 80035b6:	f000 f965 	bl	8003884 <USB_DEVICE_Init>
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 80035ba:	2201      	movs	r2, #1
 80035bc:	4611      	mov	r1, r2
 80035be:	4802      	ldr	r0, [pc, #8]	; (80035c8 <init_periph+0x20>)
 80035c0:	f7fd f99c 	bl	80008fc <HAL_GPIO_WritePin>
 80035c4:	bd08      	pop	{r3, pc}
 80035c6:	bf00      	nop
 80035c8:	40020800 	.word	0x40020800

080035cc <sys_now>:
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
}*/

/* SDIO init function */
uint32_t sys_now()
{
 80035cc:	b508      	push	{r3, lr}
  return (uint32_t)mtime();
 80035ce:	f000 f915 	bl	80037fc <mtime>
}
 80035d2:	bd08      	pop	{r3, pc}

080035d4 <main>:
  * @brief  The application entry point.
  *
  * @retval None
  */
int main(void)
{
 80035d4:	b508      	push	{r3, lr}
  init_periph();
 80035d6:	f7ff ffe7 	bl	80035a8 <init_periph>
  init_lwip();
 80035da:	f7ff ff5d 	bl	8003498 <init_lwip>

  //MX_FATFS_Init();
  //f_mount(&fs, SD_Path, 1);

  init_netif();
 80035de:	f7ff ff9d 	bl	800351c <init_netif>
  init_dhserv();
 80035e2:	f7ff ffbb 	bl	800355c <init_dhserv>
  init_dnserv();
 80035e6:	f7ff ffa3 	bl	8003530 <init_dnserv>

  //init_htserv();

  while (1)
  {
    usb_polling();     // usb device polling
 80035ea:	f7ff ff2d 	bl	8003448 <usb_polling>
    stmr();            // call software timers
 80035ee:	f000 f923 	bl	8003838 <stmr>
 80035f2:	e7fa      	b.n	80035ea <main+0x16>

080035f4 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80035f4:	b500      	push	{lr}
 80035f6:	b09b      	sub	sp, #108	; 0x6c
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;

    /**Configure the main internal regulator output voltage
    */
  __HAL_RCC_PWR_CLK_ENABLE();
 80035f8:	2100      	movs	r1, #0
 80035fa:	9101      	str	r1, [sp, #4]
 80035fc:	4b2c      	ldr	r3, [pc, #176]	; (80036b0 <SystemClock_Config+0xbc>)
 80035fe:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8003600:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003604:	641a      	str	r2, [r3, #64]	; 0x40
 8003606:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003608:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800360c:	9301      	str	r3, [sp, #4]
 800360e:	9b01      	ldr	r3, [sp, #4]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8003610:	9102      	str	r1, [sp, #8]
 8003612:	4b28      	ldr	r3, [pc, #160]	; (80036b4 <SystemClock_Config+0xc0>)
 8003614:	681a      	ldr	r2, [r3, #0]
 8003616:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 800361a:	601a      	str	r2, [r3, #0]
 800361c:	681b      	ldr	r3, [r3, #0]
 800361e:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8003622:	9302      	str	r3, [sp, #8]
 8003624:	9b02      	ldr	r3, [sp, #8]

    /**Initializes the CPU, AHB and APB busses clocks
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 8003626:	2309      	movs	r3, #9
 8003628:	930e      	str	r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800362a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800362e:	920f      	str	r2, [sp, #60]	; 0x3c
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8003630:	2201      	movs	r2, #1
 8003632:	9213      	str	r2, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8003634:	2202      	movs	r2, #2
 8003636:	9214      	str	r2, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8003638:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 800363c:	9215      	str	r2, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLM = 4;
 800363e:	2204      	movs	r2, #4
 8003640:	9216      	str	r2, [sp, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLN = 216;
 8003642:	22d8      	movs	r2, #216	; 0xd8
 8003644:	9217      	str	r2, [sp, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV6;
 8003646:	2206      	movs	r2, #6
 8003648:	9218      	str	r2, [sp, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLQ = 9;
 800364a:	9319      	str	r3, [sp, #100]	; 0x64
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800364c:	a80e      	add	r0, sp, #56	; 0x38
 800364e:	f7fd fe47 	bl	80012e0 <HAL_RCC_OscConfig>
 8003652:	bb50      	cbnz	r0, 80036aa <SystemClock_Config+0xb6>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Initializes the CPU, AHB and APB busses clocks
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8003654:	230f      	movs	r3, #15
 8003656:	9309      	str	r3, [sp, #36]	; 0x24
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8003658:	2102      	movs	r1, #2
 800365a:	910a      	str	r1, [sp, #40]	; 0x28
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800365c:	2300      	movs	r3, #0
 800365e:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8003660:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8003664:	920c      	str	r2, [sp, #48]	; 0x30
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8003666:	930d      	str	r3, [sp, #52]	; 0x34

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8003668:	a809      	add	r0, sp, #36	; 0x24
 800366a:	f7fe f871 	bl	8001750 <HAL_RCC_ClockConfig>
 800366e:	b9e8      	cbnz	r0, 80036ac <SystemClock_Config+0xb8>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 8003670:	2302      	movs	r3, #2
 8003672:	9303      	str	r3, [sp, #12]
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 8003674:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003678:	9307      	str	r3, [sp, #28]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800367a:	a803      	add	r0, sp, #12
 800367c:	f7fe f924 	bl	80018c8 <HAL_RCCEx_PeriphCLKConfig>
 8003680:	b9a8      	cbnz	r0, 80036ae <SystemClock_Config+0xba>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure the Systick interrupt time
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8003682:	f7fe f91b 	bl	80018bc <HAL_RCC_GetHCLKFreq>
 8003686:	4b0c      	ldr	r3, [pc, #48]	; (80036b8 <SystemClock_Config+0xc4>)
 8003688:	fba3 3000 	umull	r3, r0, r3, r0
 800368c:	0980      	lsrs	r0, r0, #6
 800368e:	f7fd f841 	bl	8000714 <HAL_SYSTICK_Config>

    /**Configure the Systick
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8003692:	2004      	movs	r0, #4
 8003694:	f7fd f854 	bl	8000740 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8003698:	2200      	movs	r2, #0
 800369a:	4611      	mov	r1, r2
 800369c:	f04f 30ff 	mov.w	r0, #4294967295
 80036a0:	f7fc fffc 	bl	800069c <HAL_NVIC_SetPriority>
}
 80036a4:	b01b      	add	sp, #108	; 0x6c
 80036a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80036aa:	e7fe      	b.n	80036aa <SystemClock_Config+0xb6>
 80036ac:	e7fe      	b.n	80036ac <SystemClock_Config+0xb8>
 80036ae:	e7fe      	b.n	80036ae <SystemClock_Config+0xba>
 80036b0:	40023800 	.word	0x40023800
 80036b4:	40007000 	.word	0x40007000
 80036b8:	10624dd3 	.word	0x10624dd3

080036bc <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80036bc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80036be:	2003      	movs	r0, #3
 80036c0:	f7fc ffda 	bl	8000678 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 80036c4:	2200      	movs	r2, #0
 80036c6:	4611      	mov	r1, r2
 80036c8:	f06f 000b 	mvn.w	r0, #11
 80036cc:	f7fc ffe6 	bl	800069c <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 80036d0:	2200      	movs	r2, #0
 80036d2:	4611      	mov	r1, r2
 80036d4:	f06f 000a 	mvn.w	r0, #10
 80036d8:	f7fc ffe0 	bl	800069c <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 80036dc:	2200      	movs	r2, #0
 80036de:	4611      	mov	r1, r2
 80036e0:	f06f 0009 	mvn.w	r0, #9
 80036e4:	f7fc ffda 	bl	800069c <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 80036e8:	2200      	movs	r2, #0
 80036ea:	4611      	mov	r1, r2
 80036ec:	f06f 0004 	mvn.w	r0, #4
 80036f0:	f7fc ffd4 	bl	800069c <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 80036f4:	2200      	movs	r2, #0
 80036f6:	4611      	mov	r1, r2
 80036f8:	f06f 0003 	mvn.w	r0, #3
 80036fc:	f7fc ffce 	bl	800069c <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 8003700:	2200      	movs	r2, #0
 8003702:	4611      	mov	r1, r2
 8003704:	f06f 0001 	mvn.w	r0, #1
 8003708:	f7fc ffc8 	bl	800069c <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 800370c:	2200      	movs	r2, #0
 800370e:	4611      	mov	r1, r2
 8003710:	f04f 30ff 	mov.w	r0, #4294967295
 8003714:	f7fc ffc2 	bl	800069c <HAL_NVIC_SetPriority>
 8003718:	bd08      	pop	{r3, pc}

0800371a <NMI_Handler>:

/**
* @brief This function handles Non maskable interrupt.
*/
void NMI_Handler(void)
{
 800371a:	4770      	bx	lr

0800371c <HardFault_Handler>:

/**
* @brief This function handles Hard fault interrupt.
*/
void HardFault_Handler(void)
{
 800371c:	e7fe      	b.n	800371c <HardFault_Handler>

0800371e <MemManage_Handler>:

/**
* @brief This function handles Memory management fault.
*/
void MemManage_Handler(void)
{
 800371e:	e7fe      	b.n	800371e <MemManage_Handler>

08003720 <BusFault_Handler>:

/**
* @brief This function handles Pre-fetch fault, memory access fault.
*/
void BusFault_Handler(void)
{
 8003720:	e7fe      	b.n	8003720 <BusFault_Handler>

08003722 <UsageFault_Handler>:

/**
* @brief This function handles Undefined instruction or illegal state.
*/
void UsageFault_Handler(void)
{
 8003722:	e7fe      	b.n	8003722 <UsageFault_Handler>

08003724 <SVC_Handler>:

/**
* @brief This function handles System service call via SWI instruction.
*/
void SVC_Handler(void)
{
 8003724:	4770      	bx	lr

08003726 <DebugMon_Handler>:

/**
* @brief This function handles Debug monitor.
*/
void DebugMon_Handler(void)
{
 8003726:	4770      	bx	lr

08003728 <PendSV_Handler>:

/**
* @brief This function handles Pendable request for system service.
*/
void PendSV_Handler(void)
{
 8003728:	4770      	bx	lr

0800372a <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 800372a:	b508      	push	{r3, lr}
  //USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800372c:	f7fc ff7e 	bl	800062c <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
 8003730:	f7fd f812 	bl	8000758 <HAL_SYSTICK_IRQHandler>
 8003734:	bd08      	pop	{r3, pc}
	...

08003738 <OTG_FS_IRQHandler>:

/**
* @brief This function handles USB On The Go FS global interrupt.
*/
void OTG_FS_IRQHandler(void)
{
 8003738:	b508      	push	{r3, lr}
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 800373a:	4802      	ldr	r0, [pc, #8]	; (8003744 <OTG_FS_IRQHandler+0xc>)
 800373c:	f7fd f964 	bl	8000a08 <HAL_PCD_IRQHandler>
 8003740:	bd08      	pop	{r3, pc}
 8003742:	bf00      	nop
 8003744:	20007b90 	.word	0x20007b90

08003748 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8003748:	490f      	ldr	r1, [pc, #60]	; (8003788 <SystemInit+0x40>)
 800374a:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 800374e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8003752:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8003756:	4b0d      	ldr	r3, [pc, #52]	; (800378c <SystemInit+0x44>)
 8003758:	681a      	ldr	r2, [r3, #0]
 800375a:	f042 0201 	orr.w	r2, r2, #1
 800375e:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8003760:	2000      	movs	r0, #0
 8003762:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8003764:	681a      	ldr	r2, [r3, #0]
 8003766:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800376a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800376e:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8003770:	4a07      	ldr	r2, [pc, #28]	; (8003790 <SystemInit+0x48>)
 8003772:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003774:	681a      	ldr	r2, [r3, #0]
 8003776:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800377a:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800377c:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800377e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003782:	608b      	str	r3, [r1, #8]
 8003784:	4770      	bx	lr
 8003786:	bf00      	nop
 8003788:	e000ed00 	.word	0xe000ed00
 800378c:	40023800 	.word	0x40023800
 8003790:	24003010 	.word	0x24003010

08003794 <HAL_SYSTICK_Callback>:

volatile int64_t usAddition = 0;

void HAL_SYSTICK_Callback(void)
{
  usAddition += 1000;
 8003794:	4b05      	ldr	r3, [pc, #20]	; (80037ac <HAL_SYSTICK_Callback+0x18>)
 8003796:	e9d3 0100 	ldrd	r0, r1, [r3]
 800379a:	f510 707a 	adds.w	r0, r0, #1000	; 0x3e8
 800379e:	f141 0100 	adc.w	r1, r1, #0
 80037a2:	e9c3 0100 	strd	r0, r1, [r3]
  if ((usAddition & 0x03FF) == 0)
 80037a6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80037aa:	4770      	bx	lr
 80037ac:	200007f0 	.word	0x200007f0

080037b0 <utime>:
    //cpuLoad.cnt = 0;
  }
}

int64_t utime(void)
{
 80037b0:	b430      	push	{r4, r5}
	uint32_t ctrl;
	static int64_t res;
	uint32_t ticks;

	ctrl = SysTick->CTRL;
 80037b2:	4b0e      	ldr	r3, [pc, #56]	; (80037ec <utime+0x3c>)
 80037b4:	681b      	ldr	r3, [r3, #0]

read:
	ticks = SysTick->VAL;
 80037b6:	4b0d      	ldr	r3, [pc, #52]	; (80037ec <utime+0x3c>)
	res = usAddition;
 80037b8:	480d      	ldr	r0, [pc, #52]	; (80037f0 <utime+0x40>)
	ticks = SysTick->VAL;
 80037ba:	6899      	ldr	r1, [r3, #8]
	res = usAddition;
 80037bc:	e9d0 4500 	ldrd	r4, r5, [r0]
	ctrl = SysTick->CTRL;
 80037c0:	681a      	ldr	r2, [r3, #0]
	if (ctrl & SysTick_CTRL_COUNTFLAG_Msk)
 80037c2:	f412 3f80 	tst.w	r2, #65536	; 0x10000
 80037c6:	d1f8      	bne.n	80037ba <utime+0xa>
		goto read;

	#define ticksPerUs (SystemCoreClock / 1000000)
	res += 1000 - ticks / ticksPerUs;
 80037c8:	4b0a      	ldr	r3, [pc, #40]	; (80037f4 <utime+0x44>)
 80037ca:	6818      	ldr	r0, [r3, #0]
 80037cc:	4b0a      	ldr	r3, [pc, #40]	; (80037f8 <utime+0x48>)
 80037ce:	fba3 3000 	umull	r3, r0, r3, r0
 80037d2:	0c80      	lsrs	r0, r0, #18
 80037d4:	fbb1 f1f0 	udiv	r1, r1, r0
 80037d8:	f5c1 717a 	rsb	r1, r1, #1000	; 0x3e8
	#undef usecPerTick

	return res;
}
 80037dc:	1862      	adds	r2, r4, r1
 80037de:	f145 0300 	adc.w	r3, r5, #0
 80037e2:	4610      	mov	r0, r2
 80037e4:	4619      	mov	r1, r3
 80037e6:	bc30      	pop	{r4, r5}
 80037e8:	4770      	bx	lr
 80037ea:	bf00      	nop
 80037ec:	e000e010 	.word	0xe000e010
 80037f0:	200007f0 	.word	0x200007f0
 80037f4:	2000010c 	.word	0x2000010c
 80037f8:	431bde83 	.word	0x431bde83

080037fc <mtime>:

int64_t mtime(void)
{
 80037fc:	b508      	push	{r3, lr}
  //return HAL_GetTick();
  return utime() / 1000;
 80037fe:	f7ff ffd7 	bl	80037b0 <utime>
 8003802:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8003806:	2300      	movs	r3, #0
 8003808:	f7fc fcf8 	bl	80001fc <__aeabi_ldivmod>
}
 800380c:	bd08      	pop	{r3, pc}

0800380e <usleep>:

void usleep(int us)
{
 800380e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003810:	4606      	mov	r6, r0
  uint64_t t = utime();
 8003812:	f7ff ffcd 	bl	80037b0 <utime>
 8003816:	4604      	mov	r4, r0
 8003818:	460d      	mov	r5, r1
  while (true)
  {
    uint64_t t1 = utime();
    if (t1 - t >= us) break;
 800381a:	17f7      	asrs	r7, r6, #31
    uint64_t t1 = utime();
 800381c:	f7ff ffc8 	bl	80037b0 <utime>
    if (t1 - t >= us) break;
 8003820:	1b02      	subs	r2, r0, r4
 8003822:	eb61 0305 	sbc.w	r3, r1, r5
 8003826:	42bb      	cmp	r3, r7
 8003828:	bf08      	it	eq
 800382a:	42b2      	cmpeq	r2, r6
 800382c:	d203      	bcs.n	8003836 <usleep+0x28>
    if (t1 < t) break; // overflow
 800382e:	42a9      	cmp	r1, r5
 8003830:	bf08      	it	eq
 8003832:	42a0      	cmpeq	r0, r4
 8003834:	d2f2      	bcs.n	800381c <usleep+0xe>
 8003836:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08003838 <stmr>:
}

static stmr_t *stmrs = NULL;

void stmr(void)
{
 8003838:	b570      	push	{r4, r5, r6, lr}
  stmr_t *tmr;
  uint32_t time;
  time = utime();
 800383a:	f7ff ffb9 	bl	80037b0 <utime>
 800383e:	4606      	mov	r6, r0
  tmr = stmrs;
 8003840:	4b0b      	ldr	r3, [pc, #44]	; (8003870 <stmr+0x38>)
 8003842:	681c      	ldr	r4, [r3, #0]
  while (tmr != NULL)
 8003844:	b91c      	cbnz	r4, 800384e <stmr+0x16>
 8003846:	bd70      	pop	{r4, r5, r6, pc}
 8003848:	462c      	mov	r4, r5
 800384a:	2d00      	cmp	r5, #0
 800384c:	d0fb      	beq.n	8003846 <stmr+0xe>
  {
    stmr_t *t;
    uint32_t elapsed;
    t = tmr;
    tmr = tmr->next;
 800384e:	6965      	ldr	r5, [r4, #20]
    if ((t->flags & STMR_ACTIVE) == 0)
 8003850:	68a3      	ldr	r3, [r4, #8]
 8003852:	f013 0f01 	tst.w	r3, #1
 8003856:	d0f7      	beq.n	8003848 <stmr+0x10>
      continue;
    elapsed = time;
    elapsed -= t->event;
 8003858:	6863      	ldr	r3, [r4, #4]
 800385a:	1af3      	subs	r3, r6, r3
    if (elapsed < t->period)
 800385c:	6822      	ldr	r2, [r4, #0]
 800385e:	4293      	cmp	r3, r2
 8003860:	d3f2      	bcc.n	8003848 <stmr+0x10>
      continue;
    t->proc(t);
 8003862:	6923      	ldr	r3, [r4, #16]
 8003864:	4620      	mov	r0, r4
 8003866:	4798      	blx	r3
    t->event = utime();
 8003868:	f7ff ffa2 	bl	80037b0 <utime>
 800386c:	6060      	str	r0, [r4, #4]
 800386e:	e7eb      	b.n	8003848 <stmr+0x10>
 8003870:	200007ec 	.word	0x200007ec

08003874 <stmr_add>:
  stmrs = tmr;
}*/

void stmr_add(stmr_t *tmr)
{
  tmr->next = stmrs;
 8003874:	4b02      	ldr	r3, [pc, #8]	; (8003880 <stmr_add+0xc>)
 8003876:	681a      	ldr	r2, [r3, #0]
 8003878:	6142      	str	r2, [r0, #20]
  stmrs = tmr;
 800387a:	6018      	str	r0, [r3, #0]
 800387c:	4770      	bx	lr
 800387e:	bf00      	nop
 8003880:	200007ec 	.word	0x200007ec

08003884 <USB_DEVICE_Init>:
/* USB Device Core handle declaration */
USBD_HandleTypeDef hUsbDeviceFS;

/* init function */
void USB_DEVICE_Init(void)
{
 8003884:	b510      	push	{r4, lr}
  /* Init Device Library, Add Supported Class and Start the library */
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 8003886:	4c07      	ldr	r4, [pc, #28]	; (80038a4 <USB_DEVICE_Init+0x20>)
 8003888:	2200      	movs	r2, #0
 800388a:	4907      	ldr	r1, [pc, #28]	; (80038a8 <USB_DEVICE_Init+0x24>)
 800388c:	4620      	mov	r0, r4
 800388e:	f7ff f999 	bl	8002bc4 <USBD_Init>

  USBD_RegisterClass(&hUsbDeviceFS, &usbd_rndis);
 8003892:	4906      	ldr	r1, [pc, #24]	; (80038ac <USB_DEVICE_Init+0x28>)
 8003894:	4620      	mov	r0, r4
 8003896:	f7ff f9ac 	bl	8002bf2 <USBD_RegisterClass>

  USBD_Start(&hUsbDeviceFS);
 800389a:	4620      	mov	r0, r4
 800389c:	f7ff f9b0 	bl	8002c00 <USBD_Start>
 80038a0:	bd10      	pop	{r4, pc}
 80038a2:	bf00      	nop
 80038a4:	2000796c 	.word	0x2000796c
 80038a8:	20000110 	.word	0x20000110
 80038ac:	20000024 	.word	0x20000024

080038b0 <HAL_PCD_MspInit>:
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 80038b0:	6803      	ldr	r3, [r0, #0]
 80038b2:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80038b6:	d000      	beq.n	80038ba <HAL_PCD_MspInit+0xa>
 80038b8:	4770      	bx	lr
{
 80038ba:	b530      	push	{r4, r5, lr}
 80038bc:	b087      	sub	sp, #28
    PA8     ------> USB_OTG_FS_SOF
    PA9     ------> USB_OTG_FS_VBUS
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12;
 80038be:	f44f 53c8 	mov.w	r3, #6400	; 0x1900
 80038c2:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80038c4:	2302      	movs	r3, #2
 80038c6:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80038c8:	2400      	movs	r4, #0
 80038ca:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80038cc:	2303      	movs	r3, #3
 80038ce:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80038d0:	230a      	movs	r3, #10
 80038d2:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80038d4:	4d13      	ldr	r5, [pc, #76]	; (8003924 <HAL_PCD_MspInit+0x74>)
 80038d6:	a901      	add	r1, sp, #4
 80038d8:	4628      	mov	r0, r5
 80038da:	f7fc ff41 	bl	8000760 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9;
 80038de:	f44f 7300 	mov.w	r3, #512	; 0x200
 80038e2:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80038e4:	9402      	str	r4, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80038e6:	9403      	str	r4, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80038e8:	a901      	add	r1, sp, #4
 80038ea:	4628      	mov	r0, r5
 80038ec:	f7fc ff38 	bl	8000760 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 80038f0:	4b0d      	ldr	r3, [pc, #52]	; (8003928 <HAL_PCD_MspInit+0x78>)
 80038f2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80038f4:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80038f8:	635a      	str	r2, [r3, #52]	; 0x34
 80038fa:	9400      	str	r4, [sp, #0]
 80038fc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80038fe:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8003902:	645a      	str	r2, [r3, #68]	; 0x44
 8003904:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003906:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800390a:	9300      	str	r3, [sp, #0]
 800390c:	9b00      	ldr	r3, [sp, #0]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 800390e:	4622      	mov	r2, r4
 8003910:	4621      	mov	r1, r4
 8003912:	2043      	movs	r0, #67	; 0x43
 8003914:	f7fc fec2 	bl	800069c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8003918:	2043      	movs	r0, #67	; 0x43
 800391a:	f7fc feef 	bl	80006fc <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 800391e:	b007      	add	sp, #28
 8003920:	bd30      	pop	{r4, r5, pc}
 8003922:	bf00      	nop
 8003924:	40020000 	.word	0x40020000
 8003928:	40023800 	.word	0x40023800

0800392c <HAL_PCD_SetupStageCallback>:
  * @brief  Setup stage callback
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
 800392c:	b508      	push	{r3, lr}
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 800392e:	f500 716f 	add.w	r1, r0, #956	; 0x3bc
 8003932:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003936:	f7ff f97c 	bl	8002c32 <USBD_LL_SetupStage>
 800393a:	bd08      	pop	{r3, pc}

0800393c <HAL_PCD_DataOutStageCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 800393c:	b508      	push	{r3, lr}
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 800393e:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8003942:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8003946:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 800394a:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 800394e:	f7ff f99d 	bl	8002c8c <USBD_LL_DataOutStage>
 8003952:	bd08      	pop	{r3, pc}

08003954 <HAL_PCD_DataInStageCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8003954:	b508      	push	{r3, lr}
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8003956:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 800395a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800395e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003960:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003964:	f7ff f9c7 	bl	8002cf6 <USBD_LL_DataInStage>
 8003968:	bd08      	pop	{r3, pc}

0800396a <HAL_PCD_SOFCallback>:
  * @brief  SOF callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
 800396a:	b508      	push	{r3, lr}
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 800396c:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003970:	f7ff fa4b 	bl	8002e0a <USBD_LL_SOF>
 8003974:	bd08      	pop	{r3, pc}

08003976 <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 8003976:	b510      	push	{r4, lr}
 8003978:	4604      	mov	r4, r0
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  /* Set USB current speed. */
  switch (hpcd->Init.speed)
 800397a:	68c1      	ldr	r1, [r0, #12]
	
  default:
    speed = USBD_SPEED_FULL;
    break;    
  }
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 800397c:	3100      	adds	r1, #0
 800397e:	bf18      	it	ne
 8003980:	2101      	movne	r1, #1
 8003982:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003986:	f7ff fa2e 	bl	8002de6 <USBD_LL_SetSpeed>
  
  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 800398a:	f8d4 03ec 	ldr.w	r0, [r4, #1004]	; 0x3ec
 800398e:	f7ff fa0b 	bl	8002da8 <USBD_LL_Reset>
 8003992:	bd10      	pop	{r4, pc}

08003994 <HAL_PCD_SuspendCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
 8003994:	b510      	push	{r4, lr}
 8003996:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8003998:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 800399c:	f7ff fa26 	bl	8002dec <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 80039a0:	6822      	ldr	r2, [r4, #0]
 80039a2:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 80039a6:	f043 0301 	orr.w	r3, r3, #1
 80039aa:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 80039ae:	6a23      	ldr	r3, [r4, #32]
 80039b0:	b123      	cbz	r3, 80039bc <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 80039b2:	4a03      	ldr	r2, [pc, #12]	; (80039c0 <HAL_PCD_SuspendCallback+0x2c>)
 80039b4:	6913      	ldr	r3, [r2, #16]
 80039b6:	f043 0306 	orr.w	r3, r3, #6
 80039ba:	6113      	str	r3, [r2, #16]
 80039bc:	bd10      	pop	{r4, pc}
 80039be:	bf00      	nop
 80039c0:	e000ed00 	.word	0xe000ed00

080039c4 <HAL_PCD_ResumeCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
 80039c4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 80039c6:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 80039ca:	f7ff fa18 	bl	8002dfe <USBD_LL_Resume>
 80039ce:	bd08      	pop	{r3, pc}

080039d0 <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 80039d0:	b508      	push	{r3, lr}
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 80039d2:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 80039d6:	f7ff fa28 	bl	8002e2a <USBD_LL_IsoOUTIncomplete>
 80039da:	bd08      	pop	{r3, pc}

080039dc <HAL_PCD_ISOINIncompleteCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 80039dc:	b508      	push	{r3, lr}
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 80039de:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 80039e2:	f7ff fa20 	bl	8002e26 <USBD_LL_IsoINIncomplete>
 80039e6:	bd08      	pop	{r3, pc}

080039e8 <HAL_PCD_ConnectCallback>:
  * @brief  Connect callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
 80039e8:	b508      	push	{r3, lr}
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 80039ea:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 80039ee:	f7ff fa1e 	bl	8002e2e <USBD_LL_DevConnected>
 80039f2:	bd08      	pop	{r3, pc}

080039f4 <HAL_PCD_DisconnectCallback>:
  * @brief  Disconnect callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
 80039f4:	b508      	push	{r3, lr}
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 80039f6:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 80039fa:	f7ff fa1a 	bl	8002e32 <USBD_LL_DevDisconnected>
 80039fe:	bd08      	pop	{r3, pc}

08003a00 <USBD_LL_Init>:
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 8003a00:	7803      	ldrb	r3, [r0, #0]
 8003a02:	b10b      	cbz	r3, 8003a08 <USBD_LL_Init+0x8>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
  }
  return USBD_OK;
}
 8003a04:	2000      	movs	r0, #0
 8003a06:	4770      	bx	lr
{
 8003a08:	b570      	push	{r4, r5, r6, lr}
  hpcd_USB_OTG_FS.pData = pdev;
 8003a0a:	4c14      	ldr	r4, [pc, #80]	; (8003a5c <USBD_LL_Init+0x5c>)
 8003a0c:	f8c4 03ec 	str.w	r0, [r4, #1004]	; 0x3ec
  pdev->pData = &hpcd_USB_OTG_FS;
 8003a10:	f8c0 4220 	str.w	r4, [r0, #544]	; 0x220
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8003a14:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8003a18:	6023      	str	r3, [r4, #0]
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 8003a1a:	2304      	movs	r3, #4
 8003a1c:	6063      	str	r3, [r4, #4]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8003a1e:	2302      	movs	r3, #2
 8003a20:	60e3      	str	r3, [r4, #12]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 8003a22:	2500      	movs	r5, #0
 8003a24:	6125      	str	r5, [r4, #16]
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 8003a26:	6165      	str	r5, [r4, #20]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8003a28:	61a3      	str	r3, [r4, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = ENABLE;
 8003a2a:	2601      	movs	r6, #1
 8003a2c:	61e6      	str	r6, [r4, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8003a2e:	6225      	str	r5, [r4, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8003a30:	6265      	str	r5, [r4, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 8003a32:	62e6      	str	r6, [r4, #44]	; 0x2c
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 8003a34:	6325      	str	r5, [r4, #48]	; 0x30
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8003a36:	4620      	mov	r0, r4
 8003a38:	f7fc ff66 	bl	8000908 <HAL_PCD_Init>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 8003a3c:	2180      	movs	r1, #128	; 0x80
 8003a3e:	4620      	mov	r0, r4
 8003a40:	f7fd fc4a 	bl	80012d8 <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8003a44:	2240      	movs	r2, #64	; 0x40
 8003a46:	4629      	mov	r1, r5
 8003a48:	4620      	mov	r0, r4
 8003a4a:	f7fd fc20 	bl	800128e <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 8003a4e:	2280      	movs	r2, #128	; 0x80
 8003a50:	4631      	mov	r1, r6
 8003a52:	4620      	mov	r0, r4
 8003a54:	f7fd fc1b 	bl	800128e <HAL_PCDEx_SetTxFiFo>
}
 8003a58:	2000      	movs	r0, #0
 8003a5a:	bd70      	pop	{r4, r5, r6, pc}
 8003a5c:	20007b90 	.word	0x20007b90

08003a60 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8003a60:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_Start(pdev->pData);
 8003a62:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003a66:	f7fc ffb9 	bl	80009dc <HAL_PCD_Start>

  switch (hal_status) {
 8003a6a:	b120      	cbz	r0, 8003a76 <USBD_LL_Start+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003a6c:	2802      	cmp	r0, #2
 8003a6e:	bf0c      	ite	eq
 8003a70:	2001      	moveq	r0, #1
 8003a72:	2002      	movne	r0, #2
 8003a74:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003a76:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003a78:	bd08      	pop	{r3, pc}

08003a7a <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8003a7a:	b510      	push	{r4, lr}
 8003a7c:	461c      	mov	r4, r3
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8003a7e:	4613      	mov	r3, r2
 8003a80:	4622      	mov	r2, r4
 8003a82:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003a86:	f7fd fae9 	bl	800105c <HAL_PCD_EP_Open>

  switch (hal_status) {
 8003a8a:	b120      	cbz	r0, 8003a96 <USBD_LL_OpenEP+0x1c>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003a8c:	2802      	cmp	r0, #2
 8003a8e:	bf0c      	ite	eq
 8003a90:	2001      	moveq	r0, #1
 8003a92:	2002      	movne	r0, #2
 8003a94:	bd10      	pop	{r4, pc}
      usb_status = USBD_OK;
 8003a96:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003a98:	bd10      	pop	{r4, pc}

08003a9a <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003a9a:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8003a9c:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003aa0:	f7fd fb1d 	bl	80010de <HAL_PCD_EP_Close>

  switch (hal_status) {
 8003aa4:	b120      	cbz	r0, 8003ab0 <USBD_LL_CloseEP+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003aa6:	2802      	cmp	r0, #2
 8003aa8:	bf0c      	ite	eq
 8003aaa:	2001      	moveq	r0, #1
 8003aac:	2002      	movne	r0, #2
 8003aae:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003ab0:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003ab2:	bd08      	pop	{r3, pc}

08003ab4 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003ab4:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8003ab6:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003aba:	f7fd fb8a 	bl	80011d2 <HAL_PCD_EP_SetStall>

  switch (hal_status) {
 8003abe:	b120      	cbz	r0, 8003aca <USBD_LL_StallEP+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003ac0:	2802      	cmp	r0, #2
 8003ac2:	bf0c      	ite	eq
 8003ac4:	2001      	moveq	r0, #1
 8003ac6:	2002      	movne	r0, #2
 8003ac8:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003aca:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003acc:	bd08      	pop	{r3, pc}

08003ace <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003ace:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8003ad0:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003ad4:	f7fd fbb0 	bl	8001238 <HAL_PCD_EP_ClrStall>

  switch (hal_status) {
 8003ad8:	b120      	cbz	r0, 8003ae4 <USBD_LL_ClearStallEP+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003ada:	2802      	cmp	r0, #2
 8003adc:	bf0c      	ite	eq
 8003ade:	2001      	moveq	r0, #1
 8003ae0:	2002      	movne	r0, #2
 8003ae2:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003ae4:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003ae6:	bd08      	pop	{r3, pc}

08003ae8 <USBD_LL_IsStallEP>:
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8003ae8:	f8d0 2220 	ldr.w	r2, [r0, #544]	; 0x220
  
  if((ep_addr & 0x80) == 0x80)
 8003aec:	f011 0f80 	tst.w	r1, #128	; 0x80
 8003af0:	d108      	bne.n	8003b04 <USBD_LL_IsStallEP+0x1c>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8003af2:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8003af6:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8003afa:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8003afe:	f891 01fa 	ldrb.w	r0, [r1, #506]	; 0x1fa
  }
}
 8003b02:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8003b04:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8003b08:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8003b0c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8003b10:	f893 003a 	ldrb.w	r0, [r3, #58]	; 0x3a
 8003b14:	4770      	bx	lr

08003b16 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8003b16:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8003b18:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003b1c:	f7fd fa8c 	bl	8001038 <HAL_PCD_SetAddress>

  switch (hal_status) {
 8003b20:	b120      	cbz	r0, 8003b2c <USBD_LL_SetUSBAddress+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003b22:	2802      	cmp	r0, #2
 8003b24:	bf0c      	ite	eq
 8003b26:	2001      	moveq	r0, #1
 8003b28:	2002      	movne	r0, #2
 8003b2a:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003b2c:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003b2e:	bd08      	pop	{r3, pc}

08003b30 <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size    
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8003b30:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8003b32:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003b36:	f7fd fb23 	bl	8001180 <HAL_PCD_EP_Transmit>

  switch (hal_status) {
 8003b3a:	b120      	cbz	r0, 8003b46 <USBD_LL_Transmit+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003b3c:	2802      	cmp	r0, #2
 8003b3e:	bf0c      	ite	eq
 8003b40:	2001      	moveq	r0, #1
 8003b42:	2002      	movne	r0, #2
 8003b44:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003b46:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003b48:	bd08      	pop	{r3, pc}

08003b4a <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8003b4a:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8003b4c:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003b50:	f7fd fae9 	bl	8001126 <HAL_PCD_EP_Receive>

  switch (hal_status) {
 8003b54:	b120      	cbz	r0, 8003b60 <USBD_LL_PrepareReceive+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003b56:	2802      	cmp	r0, #2
 8003b58:	bf0c      	ite	eq
 8003b5a:	2001      	moveq	r0, #1
 8003b5c:	2002      	movne	r0, #2
 8003b5e:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003b60:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003b62:	bd08      	pop	{r3, pc}

08003b64 <USBD_FS_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_DeviceDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length = sizeof(USBD_FS_DeviceDesc);
 8003b64:	2312      	movs	r3, #18
 8003b66:	800b      	strh	r3, [r1, #0]
  return USBD_FS_DeviceDesc;
}
 8003b68:	4800      	ldr	r0, [pc, #0]	; (8003b6c <USBD_FS_DeviceDescriptor+0x8>)
 8003b6a:	4770      	bx	lr
 8003b6c:	2000012c 	.word	0x2000012c

08003b70 <USBD_FS_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_LangIDStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);
 8003b70:	2304      	movs	r3, #4
 8003b72:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 8003b74:	4800      	ldr	r0, [pc, #0]	; (8003b78 <USBD_FS_LangIDStrDescriptor+0x8>)
 8003b76:	4770      	bx	lr
 8003b78:	20000140 	.word	0x20000140

08003b7c <USBD_FS_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ProductStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8003b7c:	b508      	push	{r3, lr}
 8003b7e:	460a      	mov	r2, r1
  {
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
  }
  else
  {
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8003b80:	4902      	ldr	r1, [pc, #8]	; (8003b8c <USBD_FS_ProductStrDescriptor+0x10>)
 8003b82:	4803      	ldr	r0, [pc, #12]	; (8003b90 <USBD_FS_ProductStrDescriptor+0x14>)
 8003b84:	f7ff fb95 	bl	80032b2 <USBD_GetString>
  }
  return USBD_StrDesc;
}
 8003b88:	4800      	ldr	r0, [pc, #0]	; (8003b8c <USBD_FS_ProductStrDescriptor+0x10>)
 8003b8a:	bd08      	pop	{r3, pc}
 8003b8c:	20007f80 	.word	0x20007f80
 8003b90:	08008fbc 	.word	0x08008fbc

08003b94 <USBD_FS_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ManufacturerStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8003b94:	b510      	push	{r4, lr}
  USBD_GetString (USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8003b96:	4c04      	ldr	r4, [pc, #16]	; (8003ba8 <USBD_FS_ManufacturerStrDescriptor+0x14>)
 8003b98:	460a      	mov	r2, r1
 8003b9a:	4621      	mov	r1, r4
 8003b9c:	4803      	ldr	r0, [pc, #12]	; (8003bac <USBD_FS_ManufacturerStrDescriptor+0x18>)
 8003b9e:	f7ff fb88 	bl	80032b2 <USBD_GetString>
  return USBD_StrDesc;
}
 8003ba2:	4620      	mov	r0, r4
 8003ba4:	bd10      	pop	{r4, pc}
 8003ba6:	bf00      	nop
 8003ba8:	20007f80 	.word	0x20007f80
 8003bac:	08008fac 	.word	0x08008fac

08003bb0 <USBD_FS_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_SerialStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8003bb0:	b508      	push	{r3, lr}
 8003bb2:	460a      	mov	r2, r1
  {
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
  }
  else
  {
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
 8003bb4:	4902      	ldr	r1, [pc, #8]	; (8003bc0 <USBD_FS_SerialStrDescriptor+0x10>)
 8003bb6:	4803      	ldr	r0, [pc, #12]	; (8003bc4 <USBD_FS_SerialStrDescriptor+0x14>)
 8003bb8:	f7ff fb7b 	bl	80032b2 <USBD_GetString>
  }
  return USBD_StrDesc;
}
 8003bbc:	4800      	ldr	r0, [pc, #0]	; (8003bc0 <USBD_FS_SerialStrDescriptor+0x10>)
 8003bbe:	bd08      	pop	{r3, pc}
 8003bc0:	20007f80 	.word	0x20007f80
 8003bc4:	08008fcc 	.word	0x08008fcc

08003bc8 <USBD_FS_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ConfigStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8003bc8:	b508      	push	{r3, lr}
 8003bca:	460a      	mov	r2, r1
  {
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
  }
  else
  {
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8003bcc:	4902      	ldr	r1, [pc, #8]	; (8003bd8 <USBD_FS_ConfigStrDescriptor+0x10>)
 8003bce:	4803      	ldr	r0, [pc, #12]	; (8003bdc <USBD_FS_ConfigStrDescriptor+0x14>)
 8003bd0:	f7ff fb6f 	bl	80032b2 <USBD_GetString>
  }
  return USBD_StrDesc;
}
 8003bd4:	4800      	ldr	r0, [pc, #0]	; (8003bd8 <USBD_FS_ConfigStrDescriptor+0x10>)
 8003bd6:	bd08      	pop	{r3, pc}
 8003bd8:	20007f80 	.word	0x20007f80
 8003bdc:	08008f8c 	.word	0x08008f8c

08003be0 <USBD_FS_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_InterfaceStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8003be0:	b508      	push	{r3, lr}
 8003be2:	460a      	mov	r2, r1
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
  }
  else
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8003be4:	4902      	ldr	r1, [pc, #8]	; (8003bf0 <USBD_FS_InterfaceStrDescriptor+0x10>)
 8003be6:	4803      	ldr	r0, [pc, #12]	; (8003bf4 <USBD_FS_InterfaceStrDescriptor+0x14>)
 8003be8:	f7ff fb63 	bl	80032b2 <USBD_GetString>
  }
  return USBD_StrDesc;
}
 8003bec:	4800      	ldr	r0, [pc, #0]	; (8003bf0 <USBD_FS_InterfaceStrDescriptor+0x10>)
 8003bee:	bd08      	pop	{r3, pc}
 8003bf0:	20007f80 	.word	0x20007f80
 8003bf4:	08008f9c 	.word	0x08008f9c

08003bf8 <entry_by_mac>:
			return &config->entries[i];
	return NULL;
}

static dhcp_entry_t *entry_by_mac(uint8_t *mac)
{
 8003bf8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int i;
	for (i = 0; i < config->num_entry; i++)
 8003bfc:	4b0e      	ldr	r3, [pc, #56]	; (8003c38 <entry_by_mac+0x40>)
 8003bfe:	681b      	ldr	r3, [r3, #0]
 8003c00:	f8d3 8010 	ldr.w	r8, [r3, #16]
 8003c04:	f1b8 0f00 	cmp.w	r8, #0
 8003c08:	dd13      	ble.n	8003c32 <entry_by_mac+0x3a>
 8003c0a:	4606      	mov	r6, r0
 8003c0c:	695c      	ldr	r4, [r3, #20]
		if (memcmp(config->entries[i].mac, mac, 6) == 0)
 8003c0e:	2500      	movs	r5, #0
 8003c10:	f04f 0906 	mov.w	r9, #6
 8003c14:	4627      	mov	r7, r4
 8003c16:	464a      	mov	r2, r9
 8003c18:	4631      	mov	r1, r6
 8003c1a:	4620      	mov	r0, r4
 8003c1c:	f005 f928 	bl	8008e70 <memcmp>
 8003c20:	b120      	cbz	r0, 8003c2c <entry_by_mac+0x34>
	for (i = 0; i < config->num_entry; i++)
 8003c22:	3501      	adds	r5, #1
 8003c24:	3414      	adds	r4, #20
 8003c26:	4545      	cmp	r5, r8
 8003c28:	d1f4      	bne.n	8003c14 <entry_by_mac+0x1c>
			return &config->entries[i];
	return NULL;
 8003c2a:	2700      	movs	r7, #0
}
 8003c2c:	4638      	mov	r0, r7
 8003c2e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return NULL;
 8003c32:	2700      	movs	r7, #0
 8003c34:	e7fa      	b.n	8003c2c <entry_by_mac+0x34>
 8003c36:	bf00      	nop
 8003c38:	200007f8 	.word	0x200007f8

08003c3c <find_dhcp_option>:
{
	memset(entry->mac, 0, 6);
}

uint8_t *find_dhcp_option(uint8_t *attrs, int size, uint8_t attr)
{
 8003c3c:	b430      	push	{r4, r5}
	int i = 0;
 8003c3e:	2300      	movs	r3, #0
	while ((i + 1) < size)
 8003c40:	1c5c      	adds	r4, r3, #1
 8003c42:	428c      	cmp	r4, r1
 8003c44:	da0b      	bge.n	8003c5e <find_dhcp_option+0x22>
	{
		int next = i + attrs[i + 1] + 2;
 8003c46:	461c      	mov	r4, r3
 8003c48:	18c5      	adds	r5, r0, r3
 8003c4a:	786d      	ldrb	r5, [r5, #1]
 8003c4c:	442b      	add	r3, r5
 8003c4e:	3302      	adds	r3, #2
		if (next > size) return NULL;
 8003c50:	4299      	cmp	r1, r3
 8003c52:	db08      	blt.n	8003c66 <find_dhcp_option+0x2a>
		if (attrs[i] == attr)
 8003c54:	1905      	adds	r5, r0, r4
 8003c56:	5d04      	ldrb	r4, [r0, r4]
 8003c58:	4294      	cmp	r4, r2
 8003c5a:	d1f1      	bne.n	8003c40 <find_dhcp_option+0x4>
 8003c5c:	e000      	b.n	8003c60 <find_dhcp_option+0x24>
			return attrs + i;
		i = next;
	}
	return NULL;
 8003c5e:	2500      	movs	r5, #0
}
 8003c60:	4628      	mov	r0, r5
 8003c62:	bc30      	pop	{r4, r5}
 8003c64:	4770      	bx	lr
		if (next > size) return NULL;
 8003c66:	2500      	movs	r5, #0
 8003c68:	e7fa      	b.n	8003c60 <find_dhcp_option+0x24>

08003c6a <fill_options>:
	uint32_t dns,
	int lease_time,
	uint32_t serverid,
	uint32_t router,
	uint32_t subnet)
{
 8003c6a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003c6e:	4604      	mov	r4, r0
 8003c70:	4617      	mov	r7, r2
 8003c72:	4698      	mov	r8, r3
 8003c74:	9b08      	ldr	r3, [sp, #32]
 8003c76:	9d0a      	ldr	r5, [sp, #40]	; 0x28
	uint8_t *ptr = (uint8_t *)dest;
	/* ACK message type */
	*ptr++ = 53;
 8003c78:	2235      	movs	r2, #53	; 0x35
 8003c7a:	7002      	strb	r2, [r0, #0]
	*ptr++ = 1;
 8003c7c:	2001      	movs	r0, #1
 8003c7e:	7060      	strb	r0, [r4, #1]
	*ptr++ = msg_type;
 8003c80:	70a1      	strb	r1, [r4, #2]

	/* dhcp server identifier */
	*ptr++ = DHCP_SERVERID;
 8003c82:	2236      	movs	r2, #54	; 0x36
 8003c84:	70e2      	strb	r2, [r4, #3]
	*ptr++ = 4;
 8003c86:	2204      	movs	r2, #4
 8003c88:	7122      	strb	r2, [r4, #4]
	*(uint32_t *)ptr = serverid;
 8003c8a:	9909      	ldr	r1, [sp, #36]	; 0x24
 8003c8c:	f8c4 1005 	str.w	r1, [r4, #5]
	ptr += 4;

	/* lease time */
	*ptr++ = DHCP_LEASETIME;
 8003c90:	2133      	movs	r1, #51	; 0x33
 8003c92:	7261      	strb	r1, [r4, #9]
	*ptr++ = 4;
 8003c94:	72a2      	strb	r2, [r4, #10]
	*ptr++ = (lease_time >> 24) & 0xFF;
 8003c96:	0e19      	lsrs	r1, r3, #24
 8003c98:	72e1      	strb	r1, [r4, #11]
	*ptr++ = (lease_time >> 16) & 0xFF;
 8003c9a:	1419      	asrs	r1, r3, #16
 8003c9c:	7321      	strb	r1, [r4, #12]
	*ptr++ = (lease_time >> 8) & 0xFF;
 8003c9e:	1219      	asrs	r1, r3, #8
 8003ca0:	7361      	strb	r1, [r4, #13]
	*ptr++ = (lease_time >> 0) & 0xFF;
 8003ca2:	73a3      	strb	r3, [r4, #14]

	/* subnet mask */
	*ptr++ = DHCP_SUBNETMASK;
 8003ca4:	73e0      	strb	r0, [r4, #15]
	*ptr++ = 4;
 8003ca6:	7422      	strb	r2, [r4, #16]
	*(uint32_t *)ptr = subnet;
 8003ca8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8003caa:	f8c4 3011 	str.w	r3, [r4, #17]
	ptr += 4;

	/* router */
	if (router != 0)
 8003cae:	bb15      	cbnz	r5, 8003cf6 <fill_options+0x8c>
	ptr += 4;
 8003cb0:	f104 0515 	add.w	r5, r4, #21
		*(uint32_t *)ptr = router;
		ptr += 4;
	}

	/* domain name */
	if (domain != NULL)
 8003cb4:	b17f      	cbz	r7, 8003cd6 <fill_options+0x6c>
	{
		int len = strlen(domain);
 8003cb6:	4638      	mov	r0, r7
 8003cb8:	f7fc fa98 	bl	80001ec <strlen>
 8003cbc:	4681      	mov	r9, r0
		*ptr++ = DHCP_DNSDOMAIN;
 8003cbe:	462e      	mov	r6, r5
 8003cc0:	230f      	movs	r3, #15
 8003cc2:	f806 3b02 	strb.w	r3, [r6], #2
		*ptr++ = len;
 8003cc6:	7068      	strb	r0, [r5, #1]
		memcpy(ptr, domain, len);
 8003cc8:	4602      	mov	r2, r0
 8003cca:	4639      	mov	r1, r7
 8003ccc:	4630      	mov	r0, r6
 8003cce:	f005 f8de 	bl	8008e8e <memcpy>
		ptr += len;
 8003cd2:	eb06 0509 	add.w	r5, r6, r9
	}

	/* domain name server (DNS) */
	if (dns != 0)
 8003cd6:	f1b8 0f00 	cmp.w	r8, #0
 8003cda:	d006      	beq.n	8003cea <fill_options+0x80>
	{
		*ptr++ = DHCP_DNSSERVER;
 8003cdc:	2306      	movs	r3, #6
 8003cde:	702b      	strb	r3, [r5, #0]
		*ptr++ = 4;
 8003ce0:	2304      	movs	r3, #4
 8003ce2:	706b      	strb	r3, [r5, #1]
		*(uint32_t *)ptr = dns;
 8003ce4:	f8c5 8002 	str.w	r8, [r5, #2]
		ptr += 4;
 8003ce8:	3506      	adds	r5, #6
	}

	/* end */
	*ptr++ = DHCP_END;
 8003cea:	23ff      	movs	r3, #255	; 0xff
 8003cec:	f805 3b01 	strb.w	r3, [r5], #1
	return ptr - (uint8_t *)dest;
}
 8003cf0:	1b28      	subs	r0, r5, r4
 8003cf2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		*ptr++ = DHCP_ROUTER;
 8003cf6:	2303      	movs	r3, #3
 8003cf8:	7563      	strb	r3, [r4, #21]
		*ptr++ = 4;
 8003cfa:	2304      	movs	r3, #4
 8003cfc:	75a3      	strb	r3, [r4, #22]
		*(uint32_t *)ptr = router;
 8003cfe:	f8c4 5017 	str.w	r5, [r4, #23]
		ptr += 4;
 8003d02:	f104 051b 	add.w	r5, r4, #27
 8003d06:	e7d5      	b.n	8003cb4 <fill_options+0x4a>

08003d08 <udp_recv_proc>:

static void udp_recv_proc(void *arg, struct udp_pcb *upcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
 8003d08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003d0c:	b087      	sub	sp, #28
 8003d0e:	460d      	mov	r5, r1
 8003d10:	4614      	mov	r4, r2
 8003d12:	f8bd 6040 	ldrh.w	r6, [sp, #64]	; 0x40
	dhcp_entry_t *entry;
	struct pbuf *pp;

	int n = p->len;
	if (n > sizeof(dhcp_data)) n = sizeof(dhcp_data);
	memcpy(&dhcp_data, p->payload, n);
 8003d16:	4f84      	ldr	r7, [pc, #528]	; (8003f28 <udp_recv_proc+0x220>)
 8003d18:	8952      	ldrh	r2, [r2, #10]
 8003d1a:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
 8003d1e:	bf28      	it	cs
 8003d20:	f44f 7201 	movcs.w	r2, #516	; 0x204
 8003d24:	6861      	ldr	r1, [r4, #4]
 8003d26:	4638      	mov	r0, r7
 8003d28:	f005 f8b1 	bl	8008e8e <memcpy>
	switch (dhcp_data.dp_options[2])
 8003d2c:	f897 30f2 	ldrb.w	r3, [r7, #242]	; 0xf2
 8003d30:	2b01      	cmp	r3, #1
 8003d32:	d007      	beq.n	8003d44 <udp_recv_proc+0x3c>
 8003d34:	2b03      	cmp	r3, #3
 8003d36:	d070      	beq.n	8003e1a <udp_recv_proc+0x112>
			break;

		default:
				break;
	}
	pbuf_free(p);
 8003d38:	4620      	mov	r0, r4
 8003d3a:	f001 fc9c 	bl	8005676 <pbuf_free>
}
 8003d3e:	b007      	add	sp, #28
 8003d40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			entry = entry_by_mac(dhcp_data.dp_chaddr);
 8003d44:	4879      	ldr	r0, [pc, #484]	; (8003f2c <udp_recv_proc+0x224>)
 8003d46:	f7ff ff57 	bl	8003bf8 <entry_by_mac>
			if (entry == NULL) entry = vacant_address();
 8003d4a:	4681      	mov	r9, r0
 8003d4c:	2800      	cmp	r0, #0
 8003d4e:	d043      	beq.n	8003dd8 <udp_recv_proc+0xd0>
			dhcp_data.dp_op = 2; /* reply */
 8003d50:	4f75      	ldr	r7, [pc, #468]	; (8003f28 <udp_recv_proc+0x220>)
 8003d52:	f04f 0a02 	mov.w	sl, #2
 8003d56:	f887 a000 	strb.w	sl, [r7]
			dhcp_data.dp_secs = 0;
 8003d5a:	f04f 0800 	mov.w	r8, #0
 8003d5e:	f8a7 8008 	strh.w	r8, [r7, #8]
			dhcp_data.dp_flags = 0;
 8003d62:	f8a7 800a 	strh.w	r8, [r7, #10]
			*(uint32_t *)dhcp_data.dp_yiaddr = *(uint32_t *)entry->addr;
 8003d66:	f8d9 3006 	ldr.w	r3, [r9, #6]
 8003d6a:	613b      	str	r3, [r7, #16]
			memcpy(dhcp_data.dp_magic, magic_cookie, 4);
 8003d6c:	4b70      	ldr	r3, [pc, #448]	; (8003f30 <udp_recv_proc+0x228>)
 8003d6e:	681b      	ldr	r3, [r3, #0]
 8003d70:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
			memset(dhcp_data.dp_options, 0, sizeof(dhcp_data.dp_options));
 8003d74:	37f0      	adds	r7, #240	; 0xf0
 8003d76:	f240 1213 	movw	r2, #275	; 0x113
 8003d7a:	4641      	mov	r1, r8
 8003d7c:	4638      	mov	r0, r7
 8003d7e:	f005 f891 	bl	8008ea4 <memset>
				config->domain,
 8003d82:	4b6c      	ldr	r3, [pc, #432]	; (8003f34 <udp_recv_proc+0x22c>)
 8003d84:	681a      	ldr	r2, [r3, #0]
			fill_options(dhcp_data.dp_options,
 8003d86:	6811      	ldr	r1, [r2, #0]
 8003d88:	f8d2 3006 	ldr.w	r3, [r2, #6]
 8003d8c:	68d2      	ldr	r2, [r2, #12]
 8003d8e:	f8d9 000a 	ldr.w	r0, [r9, #10]
 8003d92:	9003      	str	r0, [sp, #12]
 8003d94:	9102      	str	r1, [sp, #8]
 8003d96:	9101      	str	r1, [sp, #4]
 8003d98:	f8d9 1010 	ldr.w	r1, [r9, #16]
 8003d9c:	9100      	str	r1, [sp, #0]
 8003d9e:	4651      	mov	r1, sl
 8003da0:	4638      	mov	r0, r7
 8003da2:	f7ff ff62 	bl	8003c6a <fill_options>
			pp = pbuf_alloc(PBUF_TRANSPORT, sizeof(dhcp_data), PBUF_POOL);
 8003da6:	2203      	movs	r2, #3
 8003da8:	f44f 7101 	mov.w	r1, #516	; 0x204
 8003dac:	4640      	mov	r0, r8
 8003dae:	f001 fc91 	bl	80056d4 <pbuf_alloc>
			if (pp == NULL) break;
 8003db2:	4607      	mov	r7, r0
 8003db4:	2800      	cmp	r0, #0
 8003db6:	d0bf      	beq.n	8003d38 <udp_recv_proc+0x30>
			memcpy(pp->payload, &dhcp_data, sizeof(dhcp_data));
 8003db8:	f44f 7201 	mov.w	r2, #516	; 0x204
 8003dbc:	495a      	ldr	r1, [pc, #360]	; (8003f28 <udp_recv_proc+0x220>)
 8003dbe:	6840      	ldr	r0, [r0, #4]
 8003dc0:	f005 f865 	bl	8008e8e <memcpy>
			udp_sendto(upcb, pp, IP_ADDR_BROADCAST, port);
 8003dc4:	4633      	mov	r3, r6
 8003dc6:	4a5c      	ldr	r2, [pc, #368]	; (8003f38 <udp_recv_proc+0x230>)
 8003dc8:	4639      	mov	r1, r7
 8003dca:	4628      	mov	r0, r5
 8003dcc:	f004 fbd4 	bl	8008578 <udp_sendto>
			pbuf_free(pp);
 8003dd0:	4638      	mov	r0, r7
 8003dd2:	f001 fc50 	bl	8005676 <pbuf_free>
			break;
 8003dd6:	e7af      	b.n	8003d38 <udp_recv_proc+0x30>
	for (i = 0; i < config->num_entry; i++)
 8003dd8:	4b56      	ldr	r3, [pc, #344]	; (8003f34 <udp_recv_proc+0x22c>)
 8003dda:	681b      	ldr	r3, [r3, #0]
 8003ddc:	f8d3 9010 	ldr.w	r9, [r3, #16]
 8003de0:	f1b9 0f00 	cmp.w	r9, #0
 8003de4:	dda8      	ble.n	8003d38 <udp_recv_proc+0x30>
		if (is_vacant(config->entries + i))
 8003de6:	695b      	ldr	r3, [r3, #20]
 8003de8:	9305      	str	r3, [sp, #20]
 8003dea:	461f      	mov	r7, r3
 8003dec:	f04f 0800 	mov.w	r8, #0
	return memcmp("\0\0\0\0\0", entry->mac, 6) == 0;
 8003df0:	f8df b14c 	ldr.w	fp, [pc, #332]	; 8003f40 <udp_recv_proc+0x238>
 8003df4:	f04f 0a06 	mov.w	sl, #6
 8003df8:	4652      	mov	r2, sl
 8003dfa:	4639      	mov	r1, r7
 8003dfc:	4658      	mov	r0, fp
 8003dfe:	f005 f837 	bl	8008e70 <memcmp>
		if (is_vacant(config->entries + i))
 8003e02:	b128      	cbz	r0, 8003e10 <udp_recv_proc+0x108>
	for (i = 0; i < config->num_entry; i++)
 8003e04:	f108 0801 	add.w	r8, r8, #1
 8003e08:	3714      	adds	r7, #20
 8003e0a:	45c1      	cmp	r9, r8
 8003e0c:	d1f4      	bne.n	8003df8 <udp_recv_proc+0xf0>
 8003e0e:	e793      	b.n	8003d38 <udp_recv_proc+0x30>
			if (entry == NULL) break;
 8003e10:	9b05      	ldr	r3, [sp, #20]
 8003e12:	f113 0914 	adds.w	r9, r3, #20
 8003e16:	d08f      	beq.n	8003d38 <udp_recv_proc+0x30>
 8003e18:	e79a      	b.n	8003d50 <udp_recv_proc+0x48>
			ptr = find_dhcp_option(dhcp_data.dp_options, sizeof(dhcp_data.dp_options), DHCP_IPADDRESS);
 8003e1a:	2232      	movs	r2, #50	; 0x32
 8003e1c:	f240 1113 	movw	r1, #275	; 0x113
 8003e20:	4846      	ldr	r0, [pc, #280]	; (8003f3c <udp_recv_proc+0x234>)
 8003e22:	f7ff ff0b 	bl	8003c3c <find_dhcp_option>
			if (ptr == NULL) break;
 8003e26:	4607      	mov	r7, r0
 8003e28:	2800      	cmp	r0, #0
 8003e2a:	d085      	beq.n	8003d38 <udp_recv_proc+0x30>
			if (ptr[1] != 4) break;
 8003e2c:	7843      	ldrb	r3, [r0, #1]
 8003e2e:	2b04      	cmp	r3, #4
 8003e30:	d182      	bne.n	8003d38 <udp_recv_proc+0x30>
			entry = entry_by_mac(dhcp_data.dp_chaddr);
 8003e32:	483e      	ldr	r0, [pc, #248]	; (8003f2c <udp_recv_proc+0x224>)
 8003e34:	f7ff fee0 	bl	8003bf8 <entry_by_mac>
			if (entry != NULL) free_entry(entry);
 8003e38:	b110      	cbz	r0, 8003e40 <udp_recv_proc+0x138>
	memset(entry->mac, 0, 6);
 8003e3a:	2200      	movs	r2, #0
 8003e3c:	6002      	str	r2, [r0, #0]
 8003e3e:	8082      	strh	r2, [r0, #4]
			entry = entry_by_ip(*(uint32_t *)ptr);
 8003e40:	f8d7 8002 	ldr.w	r8, [r7, #2]
	for (i = 0; i < config->num_entry; i++)
 8003e44:	4b3b      	ldr	r3, [pc, #236]	; (8003f34 <udp_recv_proc+0x22c>)
 8003e46:	f8d3 9000 	ldr.w	r9, [r3]
 8003e4a:	f8d9 0010 	ldr.w	r0, [r9, #16]
 8003e4e:	2800      	cmp	r0, #0
 8003e50:	f77f af72 	ble.w	8003d38 <udp_recv_proc+0x30>
		if (*(uint32_t *)config->entries[i].addr == ip)
 8003e54:	f8d9 7014 	ldr.w	r7, [r9, #20]
 8003e58:	f8d7 3006 	ldr.w	r3, [r7, #6]
 8003e5c:	4598      	cmp	r8, r3
 8003e5e:	d00c      	beq.n	8003e7a <udp_recv_proc+0x172>
 8003e60:	f107 0314 	add.w	r3, r7, #20
 8003e64:	2200      	movs	r2, #0
	for (i = 0; i < config->num_entry; i++)
 8003e66:	3201      	adds	r2, #1
 8003e68:	4282      	cmp	r2, r0
 8003e6a:	f43f af65 	beq.w	8003d38 <udp_recv_proc+0x30>
		if (*(uint32_t *)config->entries[i].addr == ip)
 8003e6e:	461f      	mov	r7, r3
 8003e70:	3314      	adds	r3, #20
 8003e72:	f853 1c0e 	ldr.w	r1, [r3, #-14]
 8003e76:	4588      	cmp	r8, r1
 8003e78:	d1f5      	bne.n	8003e66 <udp_recv_proc+0x15e>
			if (entry == NULL) break;
 8003e7a:	2f00      	cmp	r7, #0
 8003e7c:	f43f af5c 	beq.w	8003d38 <udp_recv_proc+0x30>
	return memcmp("\0\0\0\0\0", entry->mac, 6) == 0;
 8003e80:	46ba      	mov	sl, r7
 8003e82:	2206      	movs	r2, #6
 8003e84:	4639      	mov	r1, r7
 8003e86:	482e      	ldr	r0, [pc, #184]	; (8003f40 <udp_recv_proc+0x238>)
 8003e88:	f004 fff2 	bl	8008e70 <memcmp>
			if (!is_vacant(entry)) break;
 8003e8c:	2800      	cmp	r0, #0
 8003e8e:	f47f af53 	bne.w	8003d38 <udp_recv_proc+0x30>
			memcpy(dhcp_data.dp_yiaddr, ptr, 4);
 8003e92:	4825      	ldr	r0, [pc, #148]	; (8003f28 <udp_recv_proc+0x220>)
 8003e94:	f8c0 8010 	str.w	r8, [r0, #16]
			dhcp_data.dp_op = 2; /* reply */
 8003e98:	2302      	movs	r3, #2
 8003e9a:	7003      	strb	r3, [r0, #0]
			dhcp_data.dp_secs = 0;
 8003e9c:	f04f 0800 	mov.w	r8, #0
 8003ea0:	f8a0 8008 	strh.w	r8, [r0, #8]
			dhcp_data.dp_flags = 0;
 8003ea4:	f8a0 800a 	strh.w	r8, [r0, #10]
			memcpy(dhcp_data.dp_magic, magic_cookie, 4);
 8003ea8:	4b21      	ldr	r3, [pc, #132]	; (8003f30 <udp_recv_proc+0x228>)
 8003eaa:	681b      	ldr	r3, [r3, #0]
 8003eac:	f8c0 30ec 	str.w	r3, [r0, #236]	; 0xec
			memset(dhcp_data.dp_options, 0, sizeof(dhcp_data.dp_options));
 8003eb0:	f100 0bf0 	add.w	fp, r0, #240	; 0xf0
 8003eb4:	f240 1213 	movw	r2, #275	; 0x113
 8003eb8:	4641      	mov	r1, r8
 8003eba:	4658      	mov	r0, fp
 8003ebc:	f004 fff2 	bl	8008ea4 <memset>
			fill_options(dhcp_data.dp_options,
 8003ec0:	f8d9 1000 	ldr.w	r1, [r9]
 8003ec4:	f8d9 3006 	ldr.w	r3, [r9, #6]
 8003ec8:	f8d9 200c 	ldr.w	r2, [r9, #12]
 8003ecc:	f8d7 000a 	ldr.w	r0, [r7, #10]
 8003ed0:	9003      	str	r0, [sp, #12]
 8003ed2:	9102      	str	r1, [sp, #8]
 8003ed4:	9101      	str	r1, [sp, #4]
 8003ed6:	6939      	ldr	r1, [r7, #16]
 8003ed8:	9100      	str	r1, [sp, #0]
 8003eda:	2105      	movs	r1, #5
 8003edc:	4658      	mov	r0, fp
 8003ede:	f7ff fec4 	bl	8003c6a <fill_options>
			pp = pbuf_alloc(PBUF_TRANSPORT, sizeof(dhcp_data), PBUF_POOL);
 8003ee2:	2203      	movs	r2, #3
 8003ee4:	f44f 7101 	mov.w	r1, #516	; 0x204
 8003ee8:	4640      	mov	r0, r8
 8003eea:	f001 fbf3 	bl	80056d4 <pbuf_alloc>
			if (pp == NULL) break;
 8003eee:	4607      	mov	r7, r0
 8003ef0:	2800      	cmp	r0, #0
 8003ef2:	f43f af21 	beq.w	8003d38 <udp_recv_proc+0x30>
			memcpy(entry->mac, dhcp_data.dp_chaddr, 6);
 8003ef6:	f1ab 01d4 	sub.w	r1, fp, #212	; 0xd4
 8003efa:	6808      	ldr	r0, [r1, #0]
 8003efc:	f8ca 0000 	str.w	r0, [sl]
 8003f00:	888b      	ldrh	r3, [r1, #4]
 8003f02:	f8aa 3004 	strh.w	r3, [sl, #4]
			memcpy(pp->payload, &dhcp_data, sizeof(dhcp_data));
 8003f06:	f44f 7201 	mov.w	r2, #516	; 0x204
 8003f0a:	391c      	subs	r1, #28
 8003f0c:	6878      	ldr	r0, [r7, #4]
 8003f0e:	f004 ffbe 	bl	8008e8e <memcpy>
			udp_sendto(upcb, pp, IP_ADDR_BROADCAST, port);
 8003f12:	4633      	mov	r3, r6
 8003f14:	4a08      	ldr	r2, [pc, #32]	; (8003f38 <udp_recv_proc+0x230>)
 8003f16:	4639      	mov	r1, r7
 8003f18:	4628      	mov	r0, r5
 8003f1a:	f004 fb2d 	bl	8008578 <udp_sendto>
			pbuf_free(pp);
 8003f1e:	4638      	mov	r0, r7
 8003f20:	f001 fba9 	bl	8005676 <pbuf_free>
			break;
 8003f24:	e708      	b.n	8003d38 <udp_recv_proc+0x30>
 8003f26:	bf00      	nop
 8003f28:	20008180 	.word	0x20008180
 8003f2c:	2000819c 	.word	0x2000819c
 8003f30:	20000144 	.word	0x20000144
 8003f34:	200007f8 	.word	0x200007f8
 8003f38:	08008fe0 	.word	0x08008fe0
 8003f3c:	20008270 	.word	0x20008270
 8003f40:	08008edc 	.word	0x08008edc

08003f44 <dhserv_free>:
	config = c;
	return ERR_OK;
}

void dhserv_free(void)
{
 8003f44:	b508      	push	{r3, lr}
	if (pcb == NULL) return;
 8003f46:	4b04      	ldr	r3, [pc, #16]	; (8003f58 <dhserv_free+0x14>)
 8003f48:	6818      	ldr	r0, [r3, #0]
 8003f4a:	b120      	cbz	r0, 8003f56 <dhserv_free+0x12>
	udp_remove(pcb);
 8003f4c:	f004 fb36 	bl	80085bc <udp_remove>
	pcb = NULL;
 8003f50:	2200      	movs	r2, #0
 8003f52:	4b01      	ldr	r3, [pc, #4]	; (8003f58 <dhserv_free+0x14>)
 8003f54:	601a      	str	r2, [r3, #0]
 8003f56:	bd08      	pop	{r3, pc}
 8003f58:	200007fc 	.word	0x200007fc

08003f5c <dhserv_init>:
{
 8003f5c:	b538      	push	{r3, r4, r5, lr}
 8003f5e:	4604      	mov	r4, r0
	udp_init();
 8003f60:	f004 f914 	bl	800818c <udp_init>
	dhserv_free();
 8003f64:	f7ff ffee 	bl	8003f44 <dhserv_free>
	pcb = udp_new();
 8003f68:	f004 fb44 	bl	80085f4 <udp_new>
 8003f6c:	4b0c      	ldr	r3, [pc, #48]	; (8003fa0 <dhserv_init+0x44>)
 8003f6e:	6018      	str	r0, [r3, #0]
	if (pcb == NULL)
 8003f70:	b190      	cbz	r0, 8003f98 <dhserv_init+0x3c>
	err = udp_bind(pcb, IP_ADDR_ANY, c->port);
 8003f72:	88a2      	ldrh	r2, [r4, #4]
 8003f74:	490b      	ldr	r1, [pc, #44]	; (8003fa4 <dhserv_init+0x48>)
 8003f76:	f004 fa11 	bl	800839c <udp_bind>
	if (err != ERR_OK)
 8003f7a:	4605      	mov	r5, r0
 8003f7c:	b948      	cbnz	r0, 8003f92 <dhserv_init+0x36>
	udp_recv(pcb, udp_recv_proc, NULL);
 8003f7e:	2200      	movs	r2, #0
 8003f80:	4909      	ldr	r1, [pc, #36]	; (8003fa8 <dhserv_init+0x4c>)
 8003f82:	4b07      	ldr	r3, [pc, #28]	; (8003fa0 <dhserv_init+0x44>)
 8003f84:	6818      	ldr	r0, [r3, #0]
 8003f86:	f004 fb15 	bl	80085b4 <udp_recv>
	config = c;
 8003f8a:	4b08      	ldr	r3, [pc, #32]	; (8003fac <dhserv_init+0x50>)
 8003f8c:	601c      	str	r4, [r3, #0]
}
 8003f8e:	4628      	mov	r0, r5
 8003f90:	bd38      	pop	{r3, r4, r5, pc}
		dhserv_free();
 8003f92:	f7ff ffd7 	bl	8003f44 <dhserv_free>
		return err;
 8003f96:	e7fa      	b.n	8003f8e <dhserv_init+0x32>
		return ERR_MEM;
 8003f98:	f04f 35ff 	mov.w	r5, #4294967295
 8003f9c:	e7f7      	b.n	8003f8e <dhserv_init+0x32>
 8003f9e:	bf00      	nop
 8003fa0:	200007fc 	.word	0x200007fc
 8003fa4:	08008fdc 	.word	0x08008fdc
 8003fa8:	08003d09 	.word	0x08003d09
 8003fac:	200007f8 	.word	0x200007f8

08003fb0 <udp_recv_proc>:
	ptr += 2;
	return ptr - (uint8_t *)data;
}

static void udp_recv_proc(void *arg, struct udp_pcb *upcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
 8003fb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003fb4:	b087      	sub	sp, #28
 8003fb6:	9101      	str	r1, [sp, #4]
 8003fb8:	4617      	mov	r7, r2
 8003fba:	9302      	str	r3, [sp, #8]
	static dns_query_t query;
	struct pbuf *out;
	ip_addr_t host_addr;
	dns_answer_t *answer;

	if (p->len <= sizeof(dns_header_t)) goto error;
 8003fbc:	8953      	ldrh	r3, [r2, #10]
 8003fbe:	2b0c      	cmp	r3, #12
 8003fc0:	d909      	bls.n	8003fd6 <udp_recv_proc+0x26>
	header = (dns_header_t *)p->payload;
 8003fc2:	6855      	ldr	r5, [r2, #4]
	if (header->flags.qr != 0) goto error;
 8003fc4:	f995 3002 	ldrsb.w	r3, [r5, #2]
 8003fc8:	2b00      	cmp	r3, #0
 8003fca:	db04      	blt.n	8003fd6 <udp_recv_proc+0x26>
	if (ntohs(header->n_record[0]) != 1) goto error;
 8003fcc:	88a8      	ldrh	r0, [r5, #4]
 8003fce:	f000 f8dc 	bl	800418a <lwip_ntohs>
 8003fd2:	2801      	cmp	r0, #1
 8003fd4:	d005      	beq.n	8003fe2 <udp_recv_proc+0x32>
	
	udp_sendto(upcb, out, addr, port);
	pbuf_free(out);

error:
	pbuf_free(p);
 8003fd6:	4638      	mov	r0, r7
 8003fd8:	f001 fb4d 	bl	8005676 <pbuf_free>
}
 8003fdc:	b007      	add	sp, #28
 8003fde:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	len = parse_next_query(header + 1, p->len - sizeof(dns_header_t), &query);
 8003fe2:	f105 030c 	add.w	r3, r5, #12
 8003fe6:	9303      	str	r3, [sp, #12]
 8003fe8:	897c      	ldrh	r4, [r7, #10]
 8003fea:	3c0c      	subs	r4, #12
		if (size <= 0) return -1;
 8003fec:	2c00      	cmp	r4, #0
 8003fee:	ddf2      	ble.n	8003fd6 <udp_recv_proc+0x26>
		lable_len = *ptr++;
 8003ff0:	f105 0a0d 	add.w	sl, r5, #13
 8003ff4:	7b2e      	ldrb	r6, [r5, #12]
		size--;
 8003ff6:	3c01      	subs	r4, #1
		if (lable_len == 0) break;
 8003ff8:	b35e      	cbz	r6, 8004052 <udp_recv_proc+0xa2>
 8003ffa:	f04f 0900 	mov.w	r9, #0
 8003ffe:	4648      	mov	r0, r9
		memcpy(&query->name[len], ptr, lable_len);
 8004000:	f8df b108 	ldr.w	fp, [pc, #264]	; 800410c <udp_recv_proc+0x15c>
 8004004:	e000      	b.n	8004008 <udp_recv_proc+0x58>
		if (len + lable_len >= DNS_MAX_HOST_NAME_LEN) return -2;
 8004006:	4640      	mov	r0, r8
		if (lable_len > size) return -1;
 8004008:	42a6      	cmp	r6, r4
 800400a:	dce4      	bgt.n	8003fd6 <udp_recv_proc+0x26>
		if (len + lable_len >= DNS_MAX_HOST_NAME_LEN) return -2;
 800400c:	eb06 0800 	add.w	r8, r6, r0
 8004010:	f1b8 0f7f 	cmp.w	r8, #127	; 0x7f
 8004014:	dcdf      	bgt.n	8003fd6 <udp_recv_proc+0x26>
		memcpy(&query->name[len], ptr, lable_len);
 8004016:	4632      	mov	r2, r6
 8004018:	4651      	mov	r1, sl
 800401a:	4458      	add	r0, fp
 800401c:	f004 ff37 	bl	8008e8e <memcpy>
		ptr += lable_len;
 8004020:	eb0a 0306 	add.w	r3, sl, r6
		size -= lable_len;
 8004024:	1ba4      	subs	r4, r4, r6
		lables++;
 8004026:	f109 0901 	add.w	r9, r9, #1
		if (size <= 0) return -1;
 800402a:	2c00      	cmp	r4, #0
 800402c:	ddd3      	ble.n	8003fd6 <udp_recv_proc+0x26>
		lable_len = *ptr++;
 800402e:	f103 0a01 	add.w	sl, r3, #1
 8004032:	781e      	ldrb	r6, [r3, #0]
		size--;
 8004034:	3c01      	subs	r4, #1
		if (lable_len == 0) break;
 8004036:	b17e      	cbz	r6, 8004058 <udp_recv_proc+0xa8>
		if (lables > 0)
 8004038:	f1b9 0f00 	cmp.w	r9, #0
 800403c:	dde3      	ble.n	8004006 <udp_recv_proc+0x56>
			if (len == DNS_MAX_HOST_NAME_LEN) return -2;
 800403e:	f1b8 0f80 	cmp.w	r8, #128	; 0x80
 8004042:	d0c8      	beq.n	8003fd6 <udp_recv_proc+0x26>
			query->name[len++] = '.';
 8004044:	f108 0001 	add.w	r0, r8, #1
 8004048:	f04f 032e 	mov.w	r3, #46	; 0x2e
 800404c:	f80b 3008 	strb.w	r3, [fp, r8]
 8004050:	e7da      	b.n	8004008 <udp_recv_proc+0x58>
	ptr = (uint8_t *)data;
 8004052:	9b03      	ldr	r3, [sp, #12]
	len = 0;
 8004054:	f04f 0800 	mov.w	r8, #0
	if (size < 4) return -1;
 8004058:	2c03      	cmp	r4, #3
 800405a:	ddbc      	ble.n	8003fd6 <udp_recv_proc+0x26>
	query->name[len] = 0;
 800405c:	4a2b      	ldr	r2, [pc, #172]	; (800410c <udp_recv_proc+0x15c>)
 800405e:	2100      	movs	r1, #0
 8004060:	f802 1008 	strb.w	r1, [r2, r8]
	query->type = *(uint16_t *)ptr;
 8004064:	f8b3 1001 	ldrh.w	r1, [r3, #1]
 8004068:	f8a2 1080 	strh.w	r1, [r2, #128]	; 0x80
	query->Class = *(uint16_t *)ptr;
 800406c:	f8b3 1003 	ldrh.w	r1, [r3, #3]
 8004070:	f8a2 1082 	strh.w	r1, [r2, #130]	; 0x82
	ptr += 2;
 8004074:	3305      	adds	r3, #5
	if (len < 0) goto error;
 8004076:	9a03      	ldr	r2, [sp, #12]
 8004078:	1a9c      	subs	r4, r3, r2
 800407a:	d4ac      	bmi.n	8003fd6 <udp_recv_proc+0x26>
	if (!query_proc(query.name, &host_addr)) goto error;
 800407c:	4b24      	ldr	r3, [pc, #144]	; (8004110 <udp_recv_proc+0x160>)
 800407e:	681b      	ldr	r3, [r3, #0]
 8004080:	a905      	add	r1, sp, #20
 8004082:	4822      	ldr	r0, [pc, #136]	; (800410c <udp_recv_proc+0x15c>)
 8004084:	4798      	blx	r3
 8004086:	2800      	cmp	r0, #0
 8004088:	d0a5      	beq.n	8003fd6 <udp_recv_proc+0x26>
	out = pbuf_alloc(PBUF_TRANSPORT, len + 16, PBUF_POOL);
 800408a:	f104 011c 	add.w	r1, r4, #28
	len += sizeof(dns_header_t);
 800408e:	340c      	adds	r4, #12
	out = pbuf_alloc(PBUF_TRANSPORT, len + 16, PBUF_POOL);
 8004090:	2203      	movs	r2, #3
 8004092:	b289      	uxth	r1, r1
 8004094:	2000      	movs	r0, #0
 8004096:	f001 fb1d 	bl	80056d4 <pbuf_alloc>
	if (out == NULL) goto error;
 800409a:	4605      	mov	r5, r0
 800409c:	2800      	cmp	r0, #0
 800409e:	d09a      	beq.n	8003fd6 <udp_recv_proc+0x26>
	memcpy(out->payload, p->payload, len);
 80040a0:	4622      	mov	r2, r4
 80040a2:	6879      	ldr	r1, [r7, #4]
 80040a4:	6840      	ldr	r0, [r0, #4]
 80040a6:	f004 fef2 	bl	8008e8e <memcpy>
	header = (dns_header_t *)out->payload;
 80040aa:	686e      	ldr	r6, [r5, #4]
	header->flags.qr = 1;
 80040ac:	78b3      	ldrb	r3, [r6, #2]
 80040ae:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80040b2:	70b3      	strb	r3, [r6, #2]
	header->n_record[1] = htons(1);
 80040b4:	2001      	movs	r0, #1
 80040b6:	f000 f863 	bl	8004180 <lwip_htons>
 80040ba:	80f0      	strh	r0, [r6, #6]
	answer = (struct dns_answer *)((uint8_t *)out->payload + len);
 80040bc:	f8d5 8004 	ldr.w	r8, [r5, #4]
 80040c0:	eb08 0604 	add.w	r6, r8, r4
	answer->name = htons(0xC00C);
 80040c4:	f24c 000c 	movw	r0, #49164	; 0xc00c
 80040c8:	f000 f85a 	bl	8004180 <lwip_htons>
 80040cc:	f828 0004 	strh.w	r0, [r8, r4]
	answer->type = htons(1);
 80040d0:	2001      	movs	r0, #1
 80040d2:	f000 f855 	bl	8004180 <lwip_htons>
 80040d6:	8070      	strh	r0, [r6, #2]
	answer->Class = htons(1);
 80040d8:	2001      	movs	r0, #1
 80040da:	f000 f851 	bl	8004180 <lwip_htons>
 80040de:	80b0      	strh	r0, [r6, #4]
	answer->ttl = htonl(32);
 80040e0:	2020      	movs	r0, #32
 80040e2:	f000 f857 	bl	8004194 <lwip_htonl>
 80040e6:	f8c6 0006 	str.w	r0, [r6, #6]
	answer->len = htons(4);
 80040ea:	2004      	movs	r0, #4
 80040ec:	f000 f848 	bl	8004180 <lwip_htons>
 80040f0:	8170      	strh	r0, [r6, #10]
	answer->addr = host_addr.addr;
 80040f2:	9b05      	ldr	r3, [sp, #20]
 80040f4:	60f3      	str	r3, [r6, #12]
	udp_sendto(upcb, out, addr, port);
 80040f6:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
 80040fa:	9a02      	ldr	r2, [sp, #8]
 80040fc:	4629      	mov	r1, r5
 80040fe:	9801      	ldr	r0, [sp, #4]
 8004100:	f004 fa3a 	bl	8008578 <udp_sendto>
	pbuf_free(out);
 8004104:	4628      	mov	r0, r5
 8004106:	f001 fab6 	bl	8005676 <pbuf_free>
 800410a:	e764      	b.n	8003fd6 <udp_recv_proc+0x26>
 800410c:	20000804 	.word	0x20000804
 8004110:	20000888 	.word	0x20000888

08004114 <dnserv_free>:
	query_proc = qp;
	return ERR_OK;
}

void dnserv_free()
{
 8004114:	b508      	push	{r3, lr}
	if (pcb == NULL) return;
 8004116:	4b04      	ldr	r3, [pc, #16]	; (8004128 <dnserv_free+0x14>)
 8004118:	6818      	ldr	r0, [r3, #0]
 800411a:	b120      	cbz	r0, 8004126 <dnserv_free+0x12>
	udp_remove(pcb);
 800411c:	f004 fa4e 	bl	80085bc <udp_remove>
	pcb = NULL;
 8004120:	2200      	movs	r2, #0
 8004122:	4b01      	ldr	r3, [pc, #4]	; (8004128 <dnserv_free+0x14>)
 8004124:	601a      	str	r2, [r3, #0]
 8004126:	bd08      	pop	{r3, pc}
 8004128:	20000800 	.word	0x20000800

0800412c <dnserv_init>:
{
 800412c:	b570      	push	{r4, r5, r6, lr}
 800412e:	4604      	mov	r4, r0
 8004130:	460d      	mov	r5, r1
 8004132:	4616      	mov	r6, r2
	udp_init();
 8004134:	f004 f82a 	bl	800818c <udp_init>
	dnserv_free();
 8004138:	f7ff ffec 	bl	8004114 <dnserv_free>
	pcb = udp_new();
 800413c:	f004 fa5a 	bl	80085f4 <udp_new>
 8004140:	4b0c      	ldr	r3, [pc, #48]	; (8004174 <dnserv_init+0x48>)
 8004142:	6018      	str	r0, [r3, #0]
	if (pcb == NULL)
 8004144:	b190      	cbz	r0, 800416c <dnserv_init+0x40>
	err = udp_bind(pcb, bind, port);
 8004146:	462a      	mov	r2, r5
 8004148:	4621      	mov	r1, r4
 800414a:	f004 f927 	bl	800839c <udp_bind>
	if (err != ERR_OK)
 800414e:	4604      	mov	r4, r0
 8004150:	b948      	cbnz	r0, 8004166 <dnserv_init+0x3a>
	udp_recv(pcb, udp_recv_proc, NULL);
 8004152:	2200      	movs	r2, #0
 8004154:	4908      	ldr	r1, [pc, #32]	; (8004178 <dnserv_init+0x4c>)
 8004156:	4b07      	ldr	r3, [pc, #28]	; (8004174 <dnserv_init+0x48>)
 8004158:	6818      	ldr	r0, [r3, #0]
 800415a:	f004 fa2b 	bl	80085b4 <udp_recv>
	query_proc = qp;
 800415e:	4b07      	ldr	r3, [pc, #28]	; (800417c <dnserv_init+0x50>)
 8004160:	601e      	str	r6, [r3, #0]
}
 8004162:	4620      	mov	r0, r4
 8004164:	bd70      	pop	{r4, r5, r6, pc}
		dnserv_free();
 8004166:	f7ff ffd5 	bl	8004114 <dnserv_free>
		return err;
 800416a:	e7fa      	b.n	8004162 <dnserv_init+0x36>
		return ERR_MEM;
 800416c:	f04f 34ff 	mov.w	r4, #4294967295
 8004170:	e7f7      	b.n	8004162 <dnserv_init+0x36>
 8004172:	bf00      	nop
 8004174:	20000800 	.word	0x20000800
 8004178:	08003fb1 	.word	0x08003fb1
 800417c:	20000888 	.word	0x20000888

08004180 <lwip_htons>:
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
 8004180:	0a03      	lsrs	r3, r0, #8
 8004182:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
}
 8004186:	b280      	uxth	r0, r0
 8004188:	4770      	bx	lr

0800418a <lwip_ntohs>:
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
 800418a:	0a03      	lsrs	r3, r0, #8
 800418c:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 */
u16_t
lwip_ntohs(u16_t n)
{
  return lwip_htons(n);
}
 8004190:	b280      	uxth	r0, r0
 8004192:	4770      	bx	lr

08004194 <lwip_htonl>:
lwip_htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
 8004194:	0e03      	lsrs	r3, r0, #24
    ((n & 0xff0000UL) >> 8) |
 8004196:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
    ((n & 0xff00) << 8) |
 800419a:	0202      	lsls	r2, r0, #8
 800419c:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    ((n & 0xff0000UL) >> 8) |
 80041a0:	4313      	orrs	r3, r2
 80041a2:	0a00      	lsrs	r0, r0, #8
 80041a4:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
}
 80041a8:	4318      	orrs	r0, r3
 80041aa:	4770      	bx	lr

080041ac <lwip_ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
lwip_ntohl(u32_t n)
{
 80041ac:	b508      	push	{r3, lr}
  return lwip_htonl(n);
 80041ae:	f7ff fff1 	bl	8004194 <lwip_htonl>
}
 80041b2:	bd08      	pop	{r3, pc}

080041b4 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
 80041b4:	b508      	push	{r3, lr}
  /* Modules initialization */
  stats_init();
 80041b6:	f001 fc61 	bl	8005a7c <stats_init>
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
 80041ba:	f000 ff3d 	bl	8005038 <mem_init>
  memp_init();
 80041be:	f001 f8dd 	bl	800537c <memp_init>
  pbuf_init();
  netif_init();
 80041c2:	f001 f97b 	bl	80054bc <netif_init>
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 80041c6:	f003 ffe1 	bl	800818c <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 80041ca:	f001 fc58 	bl	8005a7e <tcp_init>
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
 80041ce:	f003 ffad 	bl	800812c <sys_timeouts_init>
 80041d2:	bd08      	pop	{r3, pc}

080041d4 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 80041d4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80041d8:	b085      	sub	sp, #20
 80041da:	4680      	mov	r8, r0
 80041dc:	4689      	mov	r9, r1
 80041de:	4615      	mov	r5, r2
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 80041e0:	2200      	movs	r2, #0
 80041e2:	2124      	movs	r1, #36	; 0x24
 80041e4:	2001      	movs	r0, #1
 80041e6:	f001 fa75 	bl	80056d4 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 80041ea:	2800      	cmp	r0, #0
 80041ec:	d043      	beq.n	8004276 <icmp_send_response+0xa2>
 80041ee:	4606      	mov	r6, r0
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 80041f0:	f8d8 7004 	ldr.w	r7, [r8, #4]
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 80041f4:	6844      	ldr	r4, [r0, #4]
  icmphdr->type = type;
 80041f6:	f884 9000 	strb.w	r9, [r4]
  icmphdr->code = code;
 80041fa:	7065      	strb	r5, [r4, #1]
  icmphdr->id = 0;
 80041fc:	2500      	movs	r5, #0
 80041fe:	7125      	strb	r5, [r4, #4]
 8004200:	7165      	strb	r5, [r4, #5]
  icmphdr->seqno = 0;
 8004202:	71a5      	strb	r5, [r4, #6]
 8004204:	71e5      	strb	r5, [r4, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8004206:	f8d0 c004 	ldr.w	ip, [r0, #4]
 800420a:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800420e:	f8d3 e000 	ldr.w	lr, [r3]
 8004212:	6858      	ldr	r0, [r3, #4]
 8004214:	6899      	ldr	r1, [r3, #8]
 8004216:	f8d3 800c 	ldr.w	r8, [r3, #12]
 800421a:	f8cc e008 	str.w	lr, [ip, #8]
 800421e:	f8cc 000c 	str.w	r0, [ip, #12]
 8004222:	f8cc 1010 	str.w	r1, [ip, #16]
 8004226:	f8cc 8014 	str.w	r8, [ip, #20]
 800422a:	f8d3 e010 	ldr.w	lr, [r3, #16]
 800422e:	6958      	ldr	r0, [r3, #20]
 8004230:	6999      	ldr	r1, [r3, #24]
 8004232:	f8cc e018 	str.w	lr, [ip, #24]
 8004236:	f8cc 001c 	str.w	r0, [ip, #28]
 800423a:	f8cc 1020 	str.w	r1, [ip, #32]
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
 800423e:	70a5      	strb	r5, [r4, #2]
 8004240:	70e5      	strb	r5, [r4, #3]
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8004242:	8971      	ldrh	r1, [r6, #10]
 8004244:	4620      	mov	r0, r4
 8004246:	f000 f97c 	bl	8004542 <inet_chksum>
 800424a:	8060      	strh	r0, [r4, #2]
  ICMP_STATS_INC(icmp.xmit);
 800424c:	4a0b      	ldr	r2, [pc, #44]	; (800427c <icmp_send_response+0xa8>)
 800424e:	f8b2 3060 	ldrh.w	r3, [r2, #96]	; 0x60
 8004252:	3301      	adds	r3, #1
 8004254:	f8a2 3060 	strh.w	r3, [r2, #96]	; 0x60
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 8004258:	68fb      	ldr	r3, [r7, #12]
 800425a:	aa04      	add	r2, sp, #16
 800425c:	f842 3d04 	str.w	r3, [r2, #-4]!
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
 8004260:	2301      	movs	r3, #1
 8004262:	9301      	str	r3, [sp, #4]
 8004264:	9500      	str	r5, [sp, #0]
 8004266:	23ff      	movs	r3, #255	; 0xff
 8004268:	4629      	mov	r1, r5
 800426a:	4630      	mov	r0, r6
 800426c:	f000 fb60 	bl	8004930 <ip_output>
  pbuf_free(q);
 8004270:	4630      	mov	r0, r6
 8004272:	f001 fa00 	bl	8005676 <pbuf_free>
}
 8004276:	b005      	add	sp, #20
 8004278:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800427c:	2000aac4 	.word	0x2000aac4

08004280 <icmp_input>:
{
 8004280:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004284:	b085      	sub	sp, #20
 8004286:	4606      	mov	r6, r0
 8004288:	4688      	mov	r8, r1
  ICMP_STATS_INC(icmp.recv);
 800428a:	4a62      	ldr	r2, [pc, #392]	; (8004414 <icmp_input+0x194>)
 800428c:	f8b2 3062 	ldrh.w	r3, [r2, #98]	; 0x62
 8004290:	3301      	adds	r3, #1
 8004292:	f8a2 3062 	strh.w	r3, [r2, #98]	; 0x62
  iphdr = (struct ip_hdr *)p->payload;
 8004296:	6847      	ldr	r7, [r0, #4]
  hlen = IPH_HL(iphdr) * 4;
 8004298:	783c      	ldrb	r4, [r7, #0]
 800429a:	f004 040f 	and.w	r4, r4, #15
 800429e:	00a4      	lsls	r4, r4, #2
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 80042a0:	4265      	negs	r5, r4
 80042a2:	b22d      	sxth	r5, r5
 80042a4:	4629      	mov	r1, r5
 80042a6:	f001 f9a8 	bl	80055fa <pbuf_header>
 80042aa:	b9c0      	cbnz	r0, 80042de <icmp_input+0x5e>
 80042ac:	8933      	ldrh	r3, [r6, #8]
 80042ae:	2b03      	cmp	r3, #3
 80042b0:	d915      	bls.n	80042de <icmp_input+0x5e>
  type = *((u8_t *)p->payload);
 80042b2:	6873      	ldr	r3, [r6, #4]
  switch (type) {
 80042b4:	781b      	ldrb	r3, [r3, #0]
 80042b6:	2b00      	cmp	r3, #0
 80042b8:	f000 80a8 	beq.w	800440c <icmp_input+0x18c>
 80042bc:	2b08      	cmp	r3, #8
 80042be:	f040 809a 	bne.w	80043f6 <icmp_input+0x176>
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
 80042c2:	4b55      	ldr	r3, [pc, #340]	; (8004418 <icmp_input+0x198>)
 80042c4:	6818      	ldr	r0, [r3, #0]
 80042c6:	f000 09f0 	and.w	r9, r0, #240	; 0xf0
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
 80042ca:	4641      	mov	r1, r8
 80042cc:	f000 fb54 	bl	8004978 <ip4_addr_isbroadcast>
 80042d0:	b988      	cbnz	r0, 80042f6 <icmp_input+0x76>
      if (!accepted) {
 80042d2:	f1b9 0fe0 	cmp.w	r9, #224	; 0xe0
 80042d6:	d00e      	beq.n	80042f6 <icmp_input+0x76>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 80042d8:	8933      	ldrh	r3, [r6, #8]
 80042da:	2b07      	cmp	r3, #7
 80042dc:	d815      	bhi.n	800430a <icmp_input+0x8a>
  pbuf_free(p);
 80042de:	4630      	mov	r0, r6
 80042e0:	f001 f9c9 	bl	8005676 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
 80042e4:	4a4b      	ldr	r2, [pc, #300]	; (8004414 <icmp_input+0x194>)
 80042e6:	f8b2 306a 	ldrh.w	r3, [r2, #106]	; 0x6a
 80042ea:	3301      	adds	r3, #1
 80042ec:	f8a2 306a 	strh.w	r3, [r2, #106]	; 0x6a
}
 80042f0:	b005      	add	sp, #20
 80042f2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ICMP_STATS_INC(icmp.err);
 80042f6:	4a47      	ldr	r2, [pc, #284]	; (8004414 <icmp_input+0x194>)
 80042f8:	f8b2 3074 	ldrh.w	r3, [r2, #116]	; 0x74
 80042fc:	3301      	adds	r3, #1
 80042fe:	f8a2 3074 	strh.w	r3, [r2, #116]	; 0x74
        pbuf_free(p);
 8004302:	4630      	mov	r0, r6
 8004304:	f001 f9b7 	bl	8005676 <pbuf_free>
        return;
 8004308:	e7f2      	b.n	80042f0 <icmp_input+0x70>
    if (inet_chksum_pbuf(p) != 0) {
 800430a:	4630      	mov	r0, r6
 800430c:	f000 f91f 	bl	800454e <inet_chksum_pbuf>
 8004310:	b9a0      	cbnz	r0, 800433c <icmp_input+0xbc>
  hlen = IPH_HL(iphdr) * 4;
 8004312:	b224      	sxth	r4, r4
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 8004314:	2122      	movs	r1, #34	; 0x22
 8004316:	4630      	mov	r0, r6
 8004318:	f001 f96f 	bl	80055fa <pbuf_header>
 800431c:	b390      	cbz	r0, 8004384 <icmp_input+0x104>
      if (pbuf_header(p, hlen)) {
 800431e:	4621      	mov	r1, r4
 8004320:	4630      	mov	r0, r6
 8004322:	f001 f96a 	bl	80055fa <pbuf_header>
 8004326:	b198      	cbz	r0, 8004350 <icmp_input+0xd0>
  pbuf_free(p);
 8004328:	4630      	mov	r0, r6
 800432a:	f001 f9a4 	bl	8005676 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
 800432e:	4a39      	ldr	r2, [pc, #228]	; (8004414 <icmp_input+0x194>)
 8004330:	f8b2 3074 	ldrh.w	r3, [r2, #116]	; 0x74
 8004334:	3301      	adds	r3, #1
 8004336:	f8a2 3074 	strh.w	r3, [r2, #116]	; 0x74
  return;
 800433a:	e7d9      	b.n	80042f0 <icmp_input+0x70>
      pbuf_free(p);
 800433c:	4630      	mov	r0, r6
 800433e:	f001 f99a 	bl	8005676 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
 8004342:	4a34      	ldr	r2, [pc, #208]	; (8004414 <icmp_input+0x194>)
 8004344:	f8b2 3068 	ldrh.w	r3, [r2, #104]	; 0x68
 8004348:	3301      	adds	r3, #1
 800434a:	f8a2 3068 	strh.w	r3, [r2, #104]	; 0x68
      return;
 800434e:	e7cf      	b.n	80042f0 <icmp_input+0x70>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 8004350:	2200      	movs	r2, #0
 8004352:	8931      	ldrh	r1, [r6, #8]
 8004354:	2002      	movs	r0, #2
 8004356:	f001 f9bd 	bl	80056d4 <pbuf_alloc>
      if (r == NULL) {
 800435a:	4681      	mov	r9, r0
 800435c:	2800      	cmp	r0, #0
 800435e:	d0e3      	beq.n	8004328 <icmp_input+0xa8>
      if (pbuf_copy(r, p) != ERR_OK) {
 8004360:	4631      	mov	r1, r6
 8004362:	f001 faab 	bl	80058bc <pbuf_copy>
 8004366:	2800      	cmp	r0, #0
 8004368:	d1de      	bne.n	8004328 <icmp_input+0xa8>
      iphdr = (struct ip_hdr *)r->payload;
 800436a:	f8d9 7004 	ldr.w	r7, [r9, #4]
      if (pbuf_header(r, -hlen)) {
 800436e:	4629      	mov	r1, r5
 8004370:	4648      	mov	r0, r9
 8004372:	f001 f942 	bl	80055fa <pbuf_header>
 8004376:	2800      	cmp	r0, #0
 8004378:	d1d6      	bne.n	8004328 <icmp_input+0xa8>
      pbuf_free(p);
 800437a:	4630      	mov	r0, r6
 800437c:	f001 f97b 	bl	8005676 <pbuf_free>
      p = r;
 8004380:	464e      	mov	r6, r9
 8004382:	e006      	b.n	8004392 <icmp_input+0x112>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 8004384:	f06f 0121 	mvn.w	r1, #33	; 0x21
 8004388:	4630      	mov	r0, r6
 800438a:	f001 f936 	bl	80055fa <pbuf_header>
 800438e:	2800      	cmp	r0, #0
 8004390:	d1ca      	bne.n	8004328 <icmp_input+0xa8>
    iecho = (struct icmp_echo_hdr *)p->payload;
 8004392:	6872      	ldr	r2, [r6, #4]
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
 8004394:	4b20      	ldr	r3, [pc, #128]	; (8004418 <icmp_input+0x198>)
 8004396:	681b      	ldr	r3, [r3, #0]
 8004398:	60fb      	str	r3, [r7, #12]
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 800439a:	4b20      	ldr	r3, [pc, #128]	; (800441c <icmp_input+0x19c>)
 800439c:	681b      	ldr	r3, [r3, #0]
 800439e:	613b      	str	r3, [r7, #16]
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 80043a0:	2300      	movs	r3, #0
 80043a2:	7013      	strb	r3, [r2, #0]
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 80043a4:	8853      	ldrh	r3, [r2, #2]
 80043a6:	f64f 71f6 	movw	r1, #65526	; 0xfff6
 80043aa:	428b      	cmp	r3, r1
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
 80043ac:	bf8c      	ite	hi
 80043ae:	3309      	addhi	r3, #9
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
 80043b0:	3308      	addls	r3, #8
 80043b2:	8053      	strh	r3, [r2, #2]
    IPH_TTL_SET(iphdr, ICMP_TTL);
 80043b4:	23ff      	movs	r3, #255	; 0xff
 80043b6:	723b      	strb	r3, [r7, #8]
    IPH_CHKSUM_SET(iphdr, 0);
 80043b8:	2300      	movs	r3, #0
 80043ba:	72bb      	strb	r3, [r7, #10]
 80043bc:	72fb      	strb	r3, [r7, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 80043be:	2114      	movs	r1, #20
 80043c0:	4638      	mov	r0, r7
 80043c2:	f000 f8be 	bl	8004542 <inet_chksum>
 80043c6:	8178      	strh	r0, [r7, #10]
    ICMP_STATS_INC(icmp.xmit);
 80043c8:	4a12      	ldr	r2, [pc, #72]	; (8004414 <icmp_input+0x194>)
 80043ca:	f8b2 3060 	ldrh.w	r3, [r2, #96]	; 0x60
 80043ce:	3301      	adds	r3, #1
 80043d0:	f8a2 3060 	strh.w	r3, [r2, #96]	; 0x60
    if(pbuf_header(p, hlen)) {
 80043d4:	4621      	mov	r1, r4
 80043d6:	4630      	mov	r0, r6
 80043d8:	f001 f90f 	bl	80055fa <pbuf_header>
 80043dc:	b9b0      	cbnz	r0, 800440c <icmp_input+0x18c>
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
 80043de:	f8cd 8008 	str.w	r8, [sp, #8]
 80043e2:	2301      	movs	r3, #1
 80043e4:	9301      	str	r3, [sp, #4]
 80043e6:	2200      	movs	r2, #0
 80043e8:	9200      	str	r2, [sp, #0]
 80043ea:	23ff      	movs	r3, #255	; 0xff
 80043ec:	490a      	ldr	r1, [pc, #40]	; (8004418 <icmp_input+0x198>)
 80043ee:	4630      	mov	r0, r6
 80043f0:	f000 fa1c 	bl	800482c <ip_output_if>
 80043f4:	e00a      	b.n	800440c <icmp_input+0x18c>
    ICMP_STATS_INC(icmp.proterr);
 80043f6:	4b07      	ldr	r3, [pc, #28]	; (8004414 <icmp_input+0x194>)
 80043f8:	f8b3 2070 	ldrh.w	r2, [r3, #112]	; 0x70
 80043fc:	3201      	adds	r2, #1
 80043fe:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
    ICMP_STATS_INC(icmp.drop);
 8004402:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
 8004406:	3201      	adds	r2, #1
 8004408:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
  pbuf_free(p);
 800440c:	4630      	mov	r0, r6
 800440e:	f001 f932 	bl	8005676 <pbuf_free>
  return;
 8004412:	e76d      	b.n	80042f0 <icmp_input+0x70>
 8004414:	2000aac4 	.word	0x2000aac4
 8004418:	2000838c 	.word	0x2000838c
 800441c:	20008384 	.word	0x20008384

08004420 <icmp_dest_unreach>:
{
 8004420:	b508      	push	{r3, lr}
  icmp_send_response(p, ICMP_DUR, t);
 8004422:	460a      	mov	r2, r1
 8004424:	2103      	movs	r1, #3
 8004426:	f7ff fed5 	bl	80041d4 <icmp_send_response>
 800442a:	bd08      	pop	{r3, pc}

0800442c <icmp_time_exceeded>:
{
 800442c:	b508      	push	{r3, lr}
  icmp_send_response(p, ICMP_TE, t);
 800442e:	460a      	mov	r2, r1
 8004430:	210b      	movs	r1, #11
 8004432:	f7ff fecf 	bl	80041d4 <icmp_send_response>
 8004436:	bd08      	pop	{r3, pc}

08004438 <lwip_standard_chksum>:
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
 8004438:	b410      	push	{r4}
 800443a:	b083      	sub	sp, #12
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
 800443c:	2300      	movs	r3, #0
 800443e:	f8ad 3006 	strh.w	r3, [sp, #6]
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 8004442:	f010 0401 	ands.w	r4, r0, #1
 8004446:	d007      	beq.n	8004458 <lwip_standard_chksum+0x20>
 8004448:	4299      	cmp	r1, r3
 800444a:	dd2a      	ble.n	80044a2 <lwip_standard_chksum+0x6a>
    ((u8_t *)&t)[1] = *pb++;
 800444c:	1c43      	adds	r3, r0, #1
 800444e:	7802      	ldrb	r2, [r0, #0]
 8004450:	f88d 2007 	strb.w	r2, [sp, #7]
    len--;
 8004454:	3901      	subs	r1, #1
 8004456:	e000      	b.n	800445a <lwip_standard_chksum+0x22>
  u8_t *pb = (u8_t *)dataptr;
 8004458:	4603      	mov	r3, r0
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 800445a:	2901      	cmp	r1, #1
 800445c:	dd1f      	ble.n	800449e <lwip_standard_chksum+0x66>
  u8_t *pb = (u8_t *)dataptr;
 800445e:	2200      	movs	r2, #0
    sum += *ps++;
 8004460:	f833 0b02 	ldrh.w	r0, [r3], #2
 8004464:	4402      	add	r2, r0
    len -= 2;
 8004466:	3902      	subs	r1, #2
  while (len > 1) {
 8004468:	2901      	cmp	r1, #1
 800446a:	dcf9      	bgt.n	8004460 <lwip_standard_chksum+0x28>
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 800446c:	2900      	cmp	r1, #0
    ((u8_t *)&t)[0] = *(u8_t *)ps;
 800446e:	bfc4      	itt	gt
 8004470:	781b      	ldrbgt	r3, [r3, #0]
 8004472:	f88d 3006 	strbgt.w	r3, [sp, #6]
  }

  /* Add end bytes */
  sum += t;
 8004476:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 800447a:	4402      	add	r2, r0

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
 800447c:	b290      	uxth	r0, r2
 800447e:	eb00 4212 	add.w	r2, r0, r2, lsr #16
  sum = FOLD_U32T(sum);
 8004482:	b290      	uxth	r0, r2
 8004484:	eb00 4012 	add.w	r0, r0, r2, lsr #16

  /* Swap if alignment was odd */
  if (odd) {
 8004488:	b124      	cbz	r4, 8004494 <lwip_standard_chksum+0x5c>
    sum = SWAP_BYTES_IN_WORD(sum);
 800448a:	0203      	lsls	r3, r0, #8
 800448c:	b29b      	uxth	r3, r3
 800448e:	f3c0 2007 	ubfx	r0, r0, #8, #8
 8004492:	4318      	orrs	r0, r3
  }

  return (u16_t)sum;
 8004494:	b280      	uxth	r0, r0
}
 8004496:	b003      	add	sp, #12
 8004498:	f85d 4b04 	ldr.w	r4, [sp], #4
 800449c:	4770      	bx	lr
  u32_t sum = 0;
 800449e:	2200      	movs	r2, #0
 80044a0:	e7e4      	b.n	800446c <lwip_standard_chksum+0x34>
  while (len > 1) {
 80044a2:	2901      	cmp	r1, #1
  u8_t *pb = (u8_t *)dataptr;
 80044a4:	bfc8      	it	gt
 80044a6:	4603      	movgt	r3, r0
  while (len > 1) {
 80044a8:	dcd9      	bgt.n	800445e <lwip_standard_chksum+0x26>
  sum = FOLD_U32T(sum);
 80044aa:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 80044ae:	e7ec      	b.n	800448a <lwip_standard_chksum+0x52>

080044b0 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len)
{
 80044b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80044b4:	4689      	mov	r9, r1
 80044b6:	4690      	mov	r8, r2
 80044b8:	461f      	mov	r7, r3
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 80044ba:	2800      	cmp	r0, #0
 80044bc:	d03f      	beq.n	800453e <inet_chksum_pseudo+0x8e>
 80044be:	4605      	mov	r5, r0
 80044c0:	2600      	movs	r6, #0
 80044c2:	4634      	mov	r4, r6
 80044c4:	e001      	b.n	80044ca <inet_chksum_pseudo+0x1a>
 80044c6:	682d      	ldr	r5, [r5, #0]
 80044c8:	b1a5      	cbz	r5, 80044f4 <inet_chksum_pseudo+0x44>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 80044ca:	8969      	ldrh	r1, [r5, #10]
 80044cc:	6868      	ldr	r0, [r5, #4]
 80044ce:	f7ff ffb3 	bl	8004438 <lwip_standard_chksum>
 80044d2:	4404      	add	r4, r0
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 80044d4:	b2a0      	uxth	r0, r4
 80044d6:	eb00 4414 	add.w	r4, r0, r4, lsr #16
    if (q->len % 2 != 0) {
 80044da:	896b      	ldrh	r3, [r5, #10]
 80044dc:	f013 0f01 	tst.w	r3, #1
 80044e0:	d0f1      	beq.n	80044c6 <inet_chksum_pseudo+0x16>
      swapped = 1 - swapped;
 80044e2:	f1c6 0601 	rsb	r6, r6, #1
 80044e6:	b2f6      	uxtb	r6, r6
      acc = SWAP_BYTES_IN_WORD(acc);
 80044e8:	0223      	lsls	r3, r4, #8
 80044ea:	b29b      	uxth	r3, r3
 80044ec:	f3c4 2407 	ubfx	r4, r4, #8, #8
 80044f0:	431c      	orrs	r4, r3
 80044f2:	e7e8      	b.n	80044c6 <inet_chksum_pseudo+0x16>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 80044f4:	b126      	cbz	r6, 8004500 <inet_chksum_pseudo+0x50>
    acc = SWAP_BYTES_IN_WORD(acc);
 80044f6:	0223      	lsls	r3, r4, #8
 80044f8:	b29b      	uxth	r3, r3
 80044fa:	f3c4 2407 	ubfx	r4, r4, #8, #8
 80044fe:	431c      	orrs	r4, r3
  }
  addr = ip4_addr_get_u32(src);
 8004500:	f8d9 2000 	ldr.w	r2, [r9]
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
 8004504:	f8d8 3000 	ldr.w	r3, [r8]
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
 8004508:	0c18      	lsrs	r0, r3, #16
 800450a:	fa10 f083 	uxtah	r0, r0, r3
 800450e:	fa10 f082 	uxtah	r0, r0, r2
 8004512:	eb00 4012 	add.w	r0, r0, r2, lsr #16
 8004516:	4404      	add	r4, r0
  acc += (u32_t)htons((u16_t)proto);
 8004518:	4638      	mov	r0, r7
 800451a:	f7ff fe31 	bl	8004180 <lwip_htons>
 800451e:	4404      	add	r4, r0
  acc += (u32_t)htons(proto_len);
 8004520:	f8bd 0020 	ldrh.w	r0, [sp, #32]
 8004524:	f7ff fe2c 	bl	8004180 <lwip_htons>
 8004528:	4420      	add	r0, r4

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 800452a:	b284      	uxth	r4, r0
 800452c:	eb04 4410 	add.w	r4, r4, r0, lsr #16
  acc = FOLD_U32T(acc);
 8004530:	b2a0      	uxth	r0, r4
 8004532:	eb00 4014 	add.w	r0, r0, r4, lsr #16
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 8004536:	43c0      	mvns	r0, r0
}
 8004538:	b280      	uxth	r0, r0
 800453a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  acc = 0;
 800453e:	2400      	movs	r4, #0
 8004540:	e7de      	b.n	8004500 <inet_chksum_pseudo+0x50>

08004542 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
 8004542:	b508      	push	{r3, lr}
  return ~LWIP_CHKSUM(dataptr, len);
 8004544:	f7ff ff78 	bl	8004438 <lwip_standard_chksum>
 8004548:	43c0      	mvns	r0, r0
}
 800454a:	b280      	uxth	r0, r0
 800454c:	bd08      	pop	{r3, pc}

0800454e <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 800454e:	b570      	push	{r4, r5, r6, lr}
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 8004550:	b318      	cbz	r0, 800459a <inet_chksum_pbuf+0x4c>
 8004552:	4605      	mov	r5, r0
 8004554:	2600      	movs	r6, #0
 8004556:	4634      	mov	r4, r6
 8004558:	e001      	b.n	800455e <inet_chksum_pbuf+0x10>
 800455a:	682d      	ldr	r5, [r5, #0]
 800455c:	b1a5      	cbz	r5, 8004588 <inet_chksum_pbuf+0x3a>
    acc += LWIP_CHKSUM(q->payload, q->len);
 800455e:	8969      	ldrh	r1, [r5, #10]
 8004560:	6868      	ldr	r0, [r5, #4]
 8004562:	f7ff ff69 	bl	8004438 <lwip_standard_chksum>
 8004566:	4420      	add	r0, r4
    acc = FOLD_U32T(acc);
 8004568:	b284      	uxth	r4, r0
 800456a:	eb04 4410 	add.w	r4, r4, r0, lsr #16
    if (q->len % 2 != 0) {
 800456e:	896b      	ldrh	r3, [r5, #10]
 8004570:	f013 0f01 	tst.w	r3, #1
 8004574:	d0f1      	beq.n	800455a <inet_chksum_pbuf+0xc>
      swapped = 1 - swapped;
 8004576:	f1c6 0601 	rsb	r6, r6, #1
 800457a:	b2f6      	uxtb	r6, r6
      acc = SWAP_BYTES_IN_WORD(acc);
 800457c:	0223      	lsls	r3, r4, #8
 800457e:	b29b      	uxth	r3, r3
 8004580:	f3c4 2407 	ubfx	r4, r4, #8, #8
 8004584:	431c      	orrs	r4, r3
 8004586:	e7e8      	b.n	800455a <inet_chksum_pbuf+0xc>
    }
  }

  if (swapped) {
 8004588:	b126      	cbz	r6, 8004594 <inet_chksum_pbuf+0x46>
    acc = SWAP_BYTES_IN_WORD(acc);
 800458a:	0223      	lsls	r3, r4, #8
 800458c:	b29b      	uxth	r3, r3
 800458e:	f3c4 2407 	ubfx	r4, r4, #8, #8
 8004592:	431c      	orrs	r4, r3
  }
  return (u16_t)~(acc & 0xffffUL);
 8004594:	43e0      	mvns	r0, r4
}
 8004596:	b280      	uxth	r0, r0
 8004598:	bd70      	pop	{r4, r5, r6, pc}
  acc = 0;
 800459a:	2400      	movs	r4, #0
 800459c:	e7fa      	b.n	8004594 <inet_chksum_pbuf+0x46>
	...

080045a0 <ip_route>:
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 80045a0:	4b11      	ldr	r3, [pc, #68]	; (80045e8 <ip_route+0x48>)
 80045a2:	681b      	ldr	r3, [r3, #0]
 80045a4:	b963      	cbnz	r3, 80045c0 <ip_route+0x20>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
 80045a6:	4b11      	ldr	r3, [pc, #68]	; (80045ec <ip_route+0x4c>)
 80045a8:	681b      	ldr	r3, [r3, #0]
 80045aa:	b1ab      	cbz	r3, 80045d8 <ip_route+0x38>
 80045ac:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 80045b0:	f012 0f01 	tst.w	r2, #1
 80045b4:	d010      	beq.n	80045d8 <ip_route+0x38>
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
 80045b6:	4618      	mov	r0, r3
 80045b8:	4770      	bx	lr
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 80045ba:	681b      	ldr	r3, [r3, #0]
 80045bc:	2b00      	cmp	r3, #0
 80045be:	d0f2      	beq.n	80045a6 <ip_route+0x6>
    if (netif_is_up(netif)) {
 80045c0:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 80045c4:	f012 0f01 	tst.w	r2, #1
 80045c8:	d0f7      	beq.n	80045ba <ip_route+0x1a>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
 80045ca:	6802      	ldr	r2, [r0, #0]
 80045cc:	6859      	ldr	r1, [r3, #4]
 80045ce:	404a      	eors	r2, r1
 80045d0:	6899      	ldr	r1, [r3, #8]
 80045d2:	420a      	tst	r2, r1
 80045d4:	d1f1      	bne.n	80045ba <ip_route+0x1a>
 80045d6:	e7ee      	b.n	80045b6 <ip_route+0x16>
    IP_STATS_INC(ip.rterr);
 80045d8:	4a05      	ldr	r2, [pc, #20]	; (80045f0 <ip_route+0x50>)
 80045da:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
 80045de:	3301      	adds	r3, #1
 80045e0:	f8a2 3056 	strh.w	r3, [r2, #86]	; 0x56
    return NULL;
 80045e4:	2300      	movs	r3, #0
 80045e6:	e7e6      	b.n	80045b6 <ip_route+0x16>
 80045e8:	2000aab8 	.word	0x2000aab8
 80045ec:	2000aabc 	.word	0x2000aabc
 80045f0:	2000aac4 	.word	0x2000aac4

080045f4 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 80045f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80045f8:	4606      	mov	r6, r0
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
 80045fa:	4a86      	ldr	r2, [pc, #536]	; (8004814 <ip_input+0x220>)
 80045fc:	f8b2 304a 	ldrh.w	r3, [r2, #74]	; 0x4a
 8004600:	3301      	adds	r3, #1
 8004602:	f8a2 304a 	strh.w	r3, [r2, #74]	; 0x4a
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 8004606:	f8d0 9004 	ldr.w	r9, [r0, #4]
  if (IPH_V(iphdr) != 4) {
 800460a:	f899 5000 	ldrb.w	r5, [r9]
 800460e:	092b      	lsrs	r3, r5, #4
 8004610:	2b04      	cmp	r3, #4
 8004612:	d00f      	beq.n	8004634 <ip_input+0x40>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
 8004614:	f001 f82f 	bl	8005676 <pbuf_free>
    IP_STATS_INC(ip.err);
 8004618:	4b7e      	ldr	r3, [pc, #504]	; (8004814 <ip_input+0x220>)
 800461a:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 800461e:	3201      	adds	r2, #1
 8004620:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
    IP_STATS_INC(ip.drop);
 8004624:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 8004628:	3201      	adds	r2, #1
 800462a:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
  current_header = NULL;
  ip_addr_set_any(&current_iphdr_src);
  ip_addr_set_any(&current_iphdr_dest);

  return ERR_OK;
}
 800462e:	2000      	movs	r0, #0
 8004630:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004634:	4688      	mov	r8, r1
  iphdr_hlen = IPH_HL(iphdr);
 8004636:	f005 050f 	and.w	r5, r5, #15
  iphdr_hlen *= 4;
 800463a:	00ad      	lsls	r5, r5, #2
  iphdr_len = ntohs(IPH_LEN(iphdr));
 800463c:	f8b9 0002 	ldrh.w	r0, [r9, #2]
 8004640:	f7ff fda3 	bl	800418a <lwip_ntohs>
 8004644:	4604      	mov	r4, r0
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 8004646:	8973      	ldrh	r3, [r6, #10]
 8004648:	42ab      	cmp	r3, r5
 800464a:	d302      	bcc.n	8004652 <ip_input+0x5e>
 800464c:	8933      	ldrh	r3, [r6, #8]
 800464e:	4283      	cmp	r3, r0
 8004650:	d20e      	bcs.n	8004670 <ip_input+0x7c>
    pbuf_free(p);
 8004652:	4630      	mov	r0, r6
 8004654:	f001 f80f 	bl	8005676 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
 8004658:	4b6e      	ldr	r3, [pc, #440]	; (8004814 <ip_input+0x220>)
 800465a:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 800465e:	3201      	adds	r2, #1
 8004660:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    IP_STATS_INC(ip.drop);
 8004664:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 8004668:	3201      	adds	r2, #1
 800466a:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    return ERR_OK;
 800466e:	e7de      	b.n	800462e <ip_input+0x3a>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
 8004670:	4629      	mov	r1, r5
 8004672:	4648      	mov	r0, r9
 8004674:	f7ff ff65 	bl	8004542 <inet_chksum>
 8004678:	b990      	cbnz	r0, 80046a0 <ip_input+0xac>
  pbuf_realloc(p, iphdr_len);
 800467a:	4621      	mov	r1, r4
 800467c:	4630      	mov	r0, r6
 800467e:	f001 f8c1 	bl	8005804 <pbuf_realloc>
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
 8004682:	f8d9 2010 	ldr.w	r2, [r9, #16]
 8004686:	4b64      	ldr	r3, [pc, #400]	; (8004818 <ip_input+0x224>)
 8004688:	601a      	str	r2, [r3, #0]
  ip_addr_copy(current_iphdr_src, iphdr->src);
 800468a:	f8d9 200c 	ldr.w	r2, [r9, #12]
 800468e:	4b63      	ldr	r3, [pc, #396]	; (800481c <ip_input+0x228>)
 8004690:	601a      	str	r2, [r3, #0]
    netif = inp;
 8004692:	4644      	mov	r4, r8
    int first = 1;
 8004694:	2701      	movs	r7, #1
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 8004696:	f8df b180 	ldr.w	fp, [pc, #384]	; 8004818 <ip_input+0x224>
        netif = netif_list;
 800469a:	f8df a18c 	ldr.w	sl, [pc, #396]	; 8004828 <ip_input+0x234>
 800469e:	e016      	b.n	80046ce <ip_input+0xda>
    pbuf_free(p);
 80046a0:	4630      	mov	r0, r6
 80046a2:	f000 ffe8 	bl	8005676 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
 80046a6:	4b5b      	ldr	r3, [pc, #364]	; (8004814 <ip_input+0x220>)
 80046a8:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
 80046ac:	3201      	adds	r2, #1
 80046ae:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
    IP_STATS_INC(ip.drop);
 80046b2:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 80046b6:	3201      	adds	r2, #1
 80046b8:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    return ERR_OK;
 80046bc:	e7b7      	b.n	800462e <ip_input+0x3a>
      if (first) {
 80046be:	b1ff      	cbz	r7, 8004700 <ip_input+0x10c>
        netif = netif_list;
 80046c0:	f8da 4000 	ldr.w	r4, [sl]
      if (netif == inp) {
 80046c4:	4544      	cmp	r4, r8
        netif = netif->next;
 80046c6:	bf08      	it	eq
 80046c8:	6824      	ldreq	r4, [r4, #0]
 80046ca:	2700      	movs	r7, #0
    } while(netif != NULL);
 80046cc:	b1d4      	cbz	r4, 8004704 <ip_input+0x110>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
 80046ce:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 80046d2:	f013 0f01 	tst.w	r3, #1
 80046d6:	d0f2      	beq.n	80046be <ip_input+0xca>
 80046d8:	f114 0f04 	cmn.w	r4, #4
 80046dc:	d0ef      	beq.n	80046be <ip_input+0xca>
 80046de:	6863      	ldr	r3, [r4, #4]
 80046e0:	2b00      	cmp	r3, #0
 80046e2:	d0ec      	beq.n	80046be <ip_input+0xca>
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 80046e4:	f8db 0000 	ldr.w	r0, [fp]
 80046e8:	4283      	cmp	r3, r0
 80046ea:	d004      	beq.n	80046f6 <ip_input+0x102>
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
 80046ec:	4621      	mov	r1, r4
 80046ee:	f000 f943 	bl	8004978 <ip4_addr_isbroadcast>
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 80046f2:	2800      	cmp	r0, #0
 80046f4:	d0e3      	beq.n	80046be <ip_input+0xca>
  if (netif == NULL) {
 80046f6:	b12c      	cbz	r4, 8004704 <ip_input+0x110>
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
 80046f8:	4b48      	ldr	r3, [pc, #288]	; (800481c <ip_input+0x228>)
 80046fa:	6818      	ldr	r0, [r3, #0]
 80046fc:	b1c0      	cbz	r0, 8004730 <ip_input+0x13c>
 80046fe:	e00a      	b.n	8004716 <ip_input+0x122>
        netif = netif->next;
 8004700:	6824      	ldr	r4, [r4, #0]
 8004702:	e7df      	b.n	80046c4 <ip_input+0xd0>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
 8004704:	f899 3009 	ldrb.w	r3, [r9, #9]
 8004708:	2b11      	cmp	r3, #17
 800470a:	d055      	beq.n	80047b8 <ip_input+0x1c4>
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
 800470c:	4b43      	ldr	r3, [pc, #268]	; (800481c <ip_input+0x228>)
 800470e:	6818      	ldr	r0, [r3, #0]
 8004710:	2800      	cmp	r0, #0
 8004712:	d062      	beq.n	80047da <ip_input+0x1e6>
 8004714:	2400      	movs	r4, #0
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 8004716:	4641      	mov	r1, r8
 8004718:	f000 f92e 	bl	8004978 <ip4_addr_isbroadcast>
 800471c:	2800      	cmp	r0, #0
 800471e:	d152      	bne.n	80047c6 <ip_input+0x1d2>
         (ip_addr_ismulticast(&current_iphdr_src))) {
 8004720:	4b3e      	ldr	r3, [pc, #248]	; (800481c <ip_input+0x228>)
 8004722:	681b      	ldr	r3, [r3, #0]
 8004724:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 8004728:	2be0      	cmp	r3, #224	; 0xe0
 800472a:	d04c      	beq.n	80047c6 <ip_input+0x1d2>
  if (netif == NULL) {
 800472c:	2c00      	cmp	r4, #0
 800472e:	d054      	beq.n	80047da <ip_input+0x1e6>
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 8004730:	f8b9 3006 	ldrh.w	r3, [r9, #6]
 8004734:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8004738:	b29b      	uxth	r3, r3
 800473a:	b143      	cbz	r3, 800474e <ip_input+0x15a>
    p = ip_reass(p);
 800473c:	4630      	mov	r0, r6
 800473e:	f000 f9e5 	bl	8004b0c <ip_reass>
    if (p == NULL) {
 8004742:	4606      	mov	r6, r0
 8004744:	2800      	cmp	r0, #0
 8004746:	f43f af72 	beq.w	800462e <ip_input+0x3a>
    iphdr = (struct ip_hdr *)p->payload;
 800474a:	f8d0 9004 	ldr.w	r9, [r0, #4]
  current_netif = inp;
 800474e:	4b34      	ldr	r3, [pc, #208]	; (8004820 <ip_input+0x22c>)
 8004750:	f8c3 8000 	str.w	r8, [r3]
  current_header = iphdr;
 8004754:	4b33      	ldr	r3, [pc, #204]	; (8004824 <ip_input+0x230>)
 8004756:	f8c3 9000 	str.w	r9, [r3]
  if (raw_input(p, inp) == 0)
 800475a:	4641      	mov	r1, r8
 800475c:	4630      	mov	r0, r6
 800475e:	f001 f951 	bl	8005a04 <raw_input>
 8004762:	2800      	cmp	r0, #0
 8004764:	d141      	bne.n	80047ea <ip_input+0x1f6>
    switch (IPH_PROTO(iphdr)) {
 8004766:	f899 3009 	ldrb.w	r3, [r9, #9]
 800476a:	2b06      	cmp	r3, #6
 800476c:	d047      	beq.n	80047fe <ip_input+0x20a>
 800476e:	2b11      	cmp	r3, #17
 8004770:	d037      	beq.n	80047e2 <ip_input+0x1ee>
 8004772:	2b01      	cmp	r3, #1
 8004774:	d048      	beq.n	8004808 <ip_input+0x214>
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 8004776:	4641      	mov	r1, r8
 8004778:	4b27      	ldr	r3, [pc, #156]	; (8004818 <ip_input+0x224>)
 800477a:	6818      	ldr	r0, [r3, #0]
 800477c:	f000 f8fc 	bl	8004978 <ip4_addr_isbroadcast>
 8004780:	b958      	cbnz	r0, 800479a <ip_input+0x1a6>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 8004782:	4b25      	ldr	r3, [pc, #148]	; (8004818 <ip_input+0x224>)
 8004784:	681b      	ldr	r3, [r3, #0]
 8004786:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 800478a:	2be0      	cmp	r3, #224	; 0xe0
 800478c:	d005      	beq.n	800479a <ip_input+0x1a6>
        p->payload = iphdr;
 800478e:	f8c6 9004 	str.w	r9, [r6, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 8004792:	2102      	movs	r1, #2
 8004794:	4630      	mov	r0, r6
 8004796:	f7ff fe43 	bl	8004420 <icmp_dest_unreach>
      pbuf_free(p);
 800479a:	4630      	mov	r0, r6
 800479c:	f000 ff6b 	bl	8005676 <pbuf_free>
      IP_STATS_INC(ip.proterr);
 80047a0:	4b1c      	ldr	r3, [pc, #112]	; (8004814 <ip_input+0x220>)
 80047a2:	f8b3 2058 	ldrh.w	r2, [r3, #88]	; 0x58
 80047a6:	3201      	adds	r2, #1
 80047a8:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
      IP_STATS_INC(ip.drop);
 80047ac:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 80047b0:	3201      	adds	r2, #1
 80047b2:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
 80047b6:	e018      	b.n	80047ea <ip_input+0x1f6>
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
 80047b8:	444d      	add	r5, r9
 80047ba:	886b      	ldrh	r3, [r5, #2]
 80047bc:	f5b3 4f86 	cmp.w	r3, #17152	; 0x4300
 80047c0:	d1a4      	bne.n	800470c <ip_input+0x118>
        netif = inp;
 80047c2:	4644      	mov	r4, r8
 80047c4:	e7b2      	b.n	800472c <ip_input+0x138>
      pbuf_free(p);
 80047c6:	4630      	mov	r0, r6
 80047c8:	f000 ff55 	bl	8005676 <pbuf_free>
      IP_STATS_INC(ip.drop);
 80047cc:	4a11      	ldr	r2, [pc, #68]	; (8004814 <ip_input+0x220>)
 80047ce:	f8b2 304e 	ldrh.w	r3, [r2, #78]	; 0x4e
 80047d2:	3301      	adds	r3, #1
 80047d4:	f8a2 304e 	strh.w	r3, [r2, #78]	; 0x4e
      return ERR_OK;
 80047d8:	e729      	b.n	800462e <ip_input+0x3a>
    pbuf_free(p);
 80047da:	4630      	mov	r0, r6
 80047dc:	f000 ff4b 	bl	8005676 <pbuf_free>
    return ERR_OK;
 80047e0:	e725      	b.n	800462e <ip_input+0x3a>
      udp_input(p, inp);
 80047e2:	4641      	mov	r1, r8
 80047e4:	4630      	mov	r0, r6
 80047e6:	f003 fcd3 	bl	8008190 <udp_input>
  current_netif = NULL;
 80047ea:	2300      	movs	r3, #0
 80047ec:	4a0c      	ldr	r2, [pc, #48]	; (8004820 <ip_input+0x22c>)
 80047ee:	6013      	str	r3, [r2, #0]
  current_header = NULL;
 80047f0:	4a0c      	ldr	r2, [pc, #48]	; (8004824 <ip_input+0x230>)
 80047f2:	6013      	str	r3, [r2, #0]
  ip_addr_set_any(&current_iphdr_src);
 80047f4:	4a09      	ldr	r2, [pc, #36]	; (800481c <ip_input+0x228>)
 80047f6:	6013      	str	r3, [r2, #0]
  ip_addr_set_any(&current_iphdr_dest);
 80047f8:	4a07      	ldr	r2, [pc, #28]	; (8004818 <ip_input+0x224>)
 80047fa:	6013      	str	r3, [r2, #0]
  return ERR_OK;
 80047fc:	e717      	b.n	800462e <ip_input+0x3a>
      tcp_input(p, inp);
 80047fe:	4641      	mov	r1, r8
 8004800:	4630      	mov	r0, r6
 8004802:	f002 fb0f 	bl	8006e24 <tcp_input>
      break;
 8004806:	e7f0      	b.n	80047ea <ip_input+0x1f6>
      icmp_input(p, inp);
 8004808:	4641      	mov	r1, r8
 800480a:	4630      	mov	r0, r6
 800480c:	f7ff fd38 	bl	8004280 <icmp_input>
      break;
 8004810:	e7eb      	b.n	80047ea <ip_input+0x1f6>
 8004812:	bf00      	nop
 8004814:	2000aac4 	.word	0x2000aac4
 8004818:	2000838c 	.word	0x2000838c
 800481c:	20008384 	.word	0x20008384
 8004820:	20008388 	.word	0x20008388
 8004824:	20008390 	.word	0x20008390
 8004828:	2000aab8 	.word	0x2000aab8

0800482c <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 800482c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004830:	b083      	sub	sp, #12
 8004832:	4605      	mov	r5, r0
 8004834:	f89d 9030 	ldrb.w	r9, [sp, #48]	; 0x30
 8004838:	f89d b034 	ldrb.w	fp, [sp, #52]	; 0x34
 800483c:	9e0e      	ldr	r6, [sp, #56]	; 0x38
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
 800483e:	2a00      	cmp	r2, #0
 8004840:	d065      	beq.n	800490e <ip_output_if+0xe2>
 8004842:	468a      	mov	sl, r1
 8004844:	4698      	mov	r8, r3
 8004846:	4617      	mov	r7, r2
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 8004848:	2114      	movs	r1, #20
 800484a:	f000 fed6 	bl	80055fa <pbuf_header>
 800484e:	2800      	cmp	r0, #0
 8004850:	d152      	bne.n	80048f8 <ip_output_if+0xcc>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
 8004852:	686c      	ldr	r4, [r5, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 8004854:	f884 8008 	strb.w	r8, [r4, #8]
    IPH_PROTO_SET(iphdr, proto);
 8004858:	f884 b009 	strb.w	fp, [r4, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
 800485c:	6838      	ldr	r0, [r7, #0]
 800485e:	6120      	str	r0, [r4, #16]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 8004860:	2345      	movs	r3, #69	; 0x45
 8004862:	7023      	strb	r3, [r4, #0]
    IPH_TOS_SET(iphdr, tos);
 8004864:	f884 9001 	strb.w	r9, [r4, #1]
    chk_sum += LWIP_MAKE_U16(proto, ttl);
 8004868:	ea48 280b 	orr.w	r8, r8, fp, lsl #8
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
 800486c:	fa18 f880 	uxtah	r8, r8, r0
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
 8004870:	ea4f 2309 	mov.w	r3, r9, lsl #8
 8004874:	f043 0345 	orr.w	r3, r3, #69	; 0x45
 8004878:	4443      	add	r3, r8
 800487a:	eb03 4810 	add.w	r8, r3, r0, lsr #16
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 800487e:	8928      	ldrh	r0, [r5, #8]
 8004880:	f7ff fc7e 	bl	8004180 <lwip_htons>
 8004884:	4681      	mov	r9, r0
 8004886:	8060      	strh	r0, [r4, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 8004888:	2300      	movs	r3, #0
 800488a:	71a3      	strb	r3, [r4, #6]
 800488c:	71e3      	strb	r3, [r4, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
 800488e:	f8df b09c 	ldr.w	fp, [pc, #156]	; 800492c <ip_output_if+0x100>
 8004892:	f8bb 0000 	ldrh.w	r0, [fp]
 8004896:	f7ff fc73 	bl	8004180 <lwip_htons>
 800489a:	80a0      	strh	r0, [r4, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 800489c:	f8bb 3000 	ldrh.w	r3, [fp]
 80048a0:	3301      	adds	r3, #1
 80048a2:	f8ab 3000 	strh.w	r3, [fp]

    if (ip_addr_isany(src)) {
 80048a6:	f1ba 0f00 	cmp.w	sl, #0
 80048aa:	d002      	beq.n	80048b2 <ip_output_if+0x86>
 80048ac:	f8da 3000 	ldr.w	r3, [sl]
 80048b0:	bb5b      	cbnz	r3, 800490a <ip_output_if+0xde>
      ip_addr_copy(iphdr->src, netif->ip_addr);
 80048b2:	6873      	ldr	r3, [r6, #4]
 80048b4:	60e3      	str	r3, [r4, #12]
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
 80048b6:	68e2      	ldr	r2, [r4, #12]
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
 80048b8:	fa18 f382 	uxtah	r3, r8, r2
 80048bc:	eb03 4312 	add.w	r3, r3, r2, lsr #16
 80048c0:	444b      	add	r3, r9
 80048c2:	4418      	add	r0, r3
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
 80048c4:	b283      	uxth	r3, r0
 80048c6:	eb03 4010 	add.w	r0, r3, r0, lsr #16
    chk_sum = (chk_sum >> 16) + chk_sum;
 80048ca:	eb00 4010 	add.w	r0, r0, r0, lsr #16
    chk_sum = ~chk_sum;
    iphdr->_chksum = chk_sum; /* network order */
 80048ce:	43c0      	mvns	r0, r0
 80048d0:	8160      	strh	r0, [r4, #10]
    iphdr = (struct ip_hdr *)p->payload;
    ip_addr_copy(dest_addr, iphdr->dest);
    dest = &dest_addr;
  }

  IP_STATS_INC(ip.xmit);
 80048d2:	4a15      	ldr	r2, [pc, #84]	; (8004928 <ip_output_if+0xfc>)
 80048d4:	f8b2 3048 	ldrh.w	r3, [r2, #72]	; 0x48
 80048d8:	3301      	adds	r3, #1
 80048da:	f8a2 3048 	strh.w	r3, [r2, #72]	; 0x48
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 80048de:	8c33      	ldrh	r3, [r6, #32]
 80048e0:	b113      	cbz	r3, 80048e8 <ip_output_if+0xbc>
 80048e2:	892a      	ldrh	r2, [r5, #8]
 80048e4:	429a      	cmp	r2, r3
 80048e6:	d818      	bhi.n	800491a <ip_output_if+0xee>
    return ip_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
 80048e8:	6973      	ldr	r3, [r6, #20]
 80048ea:	463a      	mov	r2, r7
 80048ec:	4629      	mov	r1, r5
 80048ee:	4630      	mov	r0, r6
 80048f0:	4798      	blx	r3
}
 80048f2:	b003      	add	sp, #12
 80048f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      IP_STATS_INC(ip.err);
 80048f8:	4a0b      	ldr	r2, [pc, #44]	; (8004928 <ip_output_if+0xfc>)
 80048fa:	f8b2 305c 	ldrh.w	r3, [r2, #92]	; 0x5c
 80048fe:	3301      	adds	r3, #1
 8004900:	f8a2 305c 	strh.w	r3, [r2, #92]	; 0x5c
      return ERR_BUF;
 8004904:	f06f 0001 	mvn.w	r0, #1
 8004908:	e7f3      	b.n	80048f2 <ip_output_if+0xc6>
      ip_addr_copy(iphdr->src, *src);
 800490a:	60e3      	str	r3, [r4, #12]
 800490c:	e7d3      	b.n	80048b6 <ip_output_if+0x8a>
    ip_addr_copy(dest_addr, iphdr->dest);
 800490e:	6843      	ldr	r3, [r0, #4]
 8004910:	691b      	ldr	r3, [r3, #16]
 8004912:	af02      	add	r7, sp, #8
 8004914:	f847 3d04 	str.w	r3, [r7, #-4]!
 8004918:	e7db      	b.n	80048d2 <ip_output_if+0xa6>
    return ip_frag(p, netif, dest);
 800491a:	463a      	mov	r2, r7
 800491c:	4631      	mov	r1, r6
 800491e:	4628      	mov	r0, r5
 8004920:	f000 faac 	bl	8004e7c <ip_frag>
 8004924:	e7e5      	b.n	80048f2 <ip_output_if+0xc6>
 8004926:	bf00      	nop
 8004928:	2000aac4 	.word	0x2000aac4
 800492c:	2000088c 	.word	0x2000088c

08004930 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 8004930:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004932:	b085      	sub	sp, #20
 8004934:	4605      	mov	r5, r0
 8004936:	460e      	mov	r6, r1
 8004938:	4614      	mov	r4, r2
 800493a:	461f      	mov	r7, r3

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(dest)) == NULL) {
 800493c:	4610      	mov	r0, r2
 800493e:	f7ff fe2f 	bl	80045a0 <ip_route>
 8004942:	b170      	cbz	r0, 8004962 <ip_output+0x32>
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
 8004944:	9002      	str	r0, [sp, #8]
 8004946:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 800494a:	9301      	str	r3, [sp, #4]
 800494c:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 8004950:	9300      	str	r3, [sp, #0]
 8004952:	463b      	mov	r3, r7
 8004954:	4622      	mov	r2, r4
 8004956:	4631      	mov	r1, r6
 8004958:	4628      	mov	r0, r5
 800495a:	f7ff ff67 	bl	800482c <ip_output_if>
}
 800495e:	b005      	add	sp, #20
 8004960:	bdf0      	pop	{r4, r5, r6, r7, pc}
    IP_STATS_INC(ip.rterr);
 8004962:	4a04      	ldr	r2, [pc, #16]	; (8004974 <ip_output+0x44>)
 8004964:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
 8004968:	3301      	adds	r3, #1
 800496a:	f8a2 3056 	strh.w	r3, [r2, #86]	; 0x56
    return ERR_RTE;
 800496e:	f06f 0003 	mvn.w	r0, #3
 8004972:	e7f4      	b.n	800495e <ip_output+0x2e>
 8004974:	2000aac4 	.word	0x2000aac4

08004978 <ip4_addr_isbroadcast>:
{
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 8004978:	1e43      	subs	r3, r0, #1
 800497a:	f113 0f03 	cmn.w	r3, #3
 800497e:	d812      	bhi.n	80049a6 <ip4_addr_isbroadcast+0x2e>
      (addr == IPADDR_ANY)) {
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 8004980:	f891 3029 	ldrb.w	r3, [r1, #41]	; 0x29
 8004984:	f013 0f02 	tst.w	r3, #2
 8004988:	d00f      	beq.n	80049aa <ip4_addr_isbroadcast+0x32>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
 800498a:	684b      	ldr	r3, [r1, #4]
 800498c:	4298      	cmp	r0, r3
 800498e:	d00e      	beq.n	80049ae <ip4_addr_isbroadcast+0x36>
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
 8004990:	688a      	ldr	r2, [r1, #8]
 8004992:	4043      	eors	r3, r0
 8004994:	4213      	tst	r3, r2
 8004996:	d10c      	bne.n	80049b2 <ip4_addr_isbroadcast+0x3a>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
 8004998:	43d2      	mvns	r2, r2
 800499a:	ea32 0300 	bics.w	r3, r2, r0
    return 1;
 800499e:	bf0c      	ite	eq
 80049a0:	2001      	moveq	r0, #1
 80049a2:	2000      	movne	r0, #0
 80049a4:	4770      	bx	lr
 80049a6:	2001      	movs	r0, #1
 80049a8:	4770      	bx	lr
    return 0;
 80049aa:	2000      	movs	r0, #0
 80049ac:	4770      	bx	lr
    return 0;
 80049ae:	2000      	movs	r0, #0
 80049b0:	4770      	bx	lr
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
 80049b2:	2000      	movs	r0, #0
  }
}
 80049b4:	4770      	bx	lr
	...

080049b8 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 80049b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80049bc:	4607      	mov	r7, r0
 80049be:	4688      	mov	r8, r1
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 80049c0:	6845      	ldr	r5, [r0, #4]
 80049c2:	686b      	ldr	r3, [r5, #4]
  if (iprh->start == 0) {
 80049c4:	889a      	ldrh	r2, [r3, #4]
 80049c6:	b30a      	cbz	r2, 8004a0c <ip_reass_free_complete_datagram+0x54>
  u16_t pbufs_freed = 0;
 80049c8:	2400      	movs	r4, #0
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
 80049ca:	687d      	ldr	r5, [r7, #4]
  while (p != NULL) {
 80049cc:	b165      	cbz	r5, 80049e8 <ip_reass_free_complete_datagram+0x30>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
 80049ce:	686b      	ldr	r3, [r5, #4]
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
 80049d0:	681e      	ldr	r6, [r3, #0]
    clen = pbuf_clen(pcur);
 80049d2:	4628      	mov	r0, r5
 80049d4:	f000 ff41 	bl	800585a <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 80049d8:	4404      	add	r4, r0
 80049da:	b2a4      	uxth	r4, r4
    pbuf_free(pcur);
 80049dc:	4628      	mov	r0, r5
 80049de:	f000 fe4a 	bl	8005676 <pbuf_free>
    p = iprh->next_pbuf;
 80049e2:	4635      	mov	r5, r6
  while (p != NULL) {
 80049e4:	2e00      	cmp	r6, #0
 80049e6:	d1f2      	bne.n	80049ce <ip_reass_free_complete_datagram+0x16>
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 80049e8:	4b18      	ldr	r3, [pc, #96]	; (8004a4c <ip_reass_free_complete_datagram+0x94>)
 80049ea:	681b      	ldr	r3, [r3, #0]
 80049ec:	429f      	cmp	r7, r3
 80049ee:	d028      	beq.n	8004a42 <ip_reass_free_complete_datagram+0x8a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
 80049f0:	683b      	ldr	r3, [r7, #0]
 80049f2:	f8c8 3000 	str.w	r3, [r8]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 80049f6:	4639      	mov	r1, r7
 80049f8:	2005      	movs	r0, #5
 80049fa:	f000 fd45 	bl	8005488 <memp_free>
  ip_reass_pbufcount -= pbufs_freed;
 80049fe:	4a14      	ldr	r2, [pc, #80]	; (8004a50 <ip_reass_free_complete_datagram+0x98>)
 8004a00:	8813      	ldrh	r3, [r2, #0]
 8004a02:	1b1b      	subs	r3, r3, r4
 8004a04:	8013      	strh	r3, [r2, #0]
}
 8004a06:	4620      	mov	r0, r4
 8004a08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ipr->p = iprh->next_pbuf;
 8004a0c:	681b      	ldr	r3, [r3, #0]
 8004a0e:	6043      	str	r3, [r0, #4]
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 8004a10:	686a      	ldr	r2, [r5, #4]
 8004a12:	4603      	mov	r3, r0
 8004a14:	f853 1f08 	ldr.w	r1, [r3, #8]!
 8004a18:	685e      	ldr	r6, [r3, #4]
 8004a1a:	689c      	ldr	r4, [r3, #8]
 8004a1c:	68d8      	ldr	r0, [r3, #12]
 8004a1e:	6011      	str	r1, [r2, #0]
 8004a20:	6056      	str	r6, [r2, #4]
 8004a22:	6094      	str	r4, [r2, #8]
 8004a24:	60d0      	str	r0, [r2, #12]
 8004a26:	6919      	ldr	r1, [r3, #16]
 8004a28:	6111      	str	r1, [r2, #16]
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 8004a2a:	2101      	movs	r1, #1
 8004a2c:	4628      	mov	r0, r5
 8004a2e:	f7ff fcfd 	bl	800442c <icmp_time_exceeded>
    clen = pbuf_clen(p);
 8004a32:	4628      	mov	r0, r5
 8004a34:	f000 ff11 	bl	800585a <pbuf_clen>
    pbufs_freed += clen;
 8004a38:	b284      	uxth	r4, r0
    pbuf_free(p);
 8004a3a:	4628      	mov	r0, r5
 8004a3c:	f000 fe1b 	bl	8005676 <pbuf_free>
 8004a40:	e7c3      	b.n	80049ca <ip_reass_free_complete_datagram+0x12>
    reassdatagrams = ipr->next;
 8004a42:	683a      	ldr	r2, [r7, #0]
 8004a44:	4b01      	ldr	r3, [pc, #4]	; (8004a4c <ip_reass_free_complete_datagram+0x94>)
 8004a46:	601a      	str	r2, [r3, #0]
 8004a48:	e7d5      	b.n	80049f6 <ip_reass_free_complete_datagram+0x3e>
 8004a4a:	bf00      	nop
 8004a4c:	20000890 	.word	0x20000890
 8004a50:	2000088e 	.word	0x2000088e

08004a54 <ip_reass_remove_oldest_datagram>:
{
 8004a54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004a58:	4605      	mov	r5, r0
 8004a5a:	4688      	mov	r8, r1
  int pbufs_freed = 0, pbufs_freed_current;
 8004a5c:	2600      	movs	r6, #0
    r = reassdatagrams;
 8004a5e:	4f18      	ldr	r7, [pc, #96]	; (8004ac0 <ip_reass_remove_oldest_datagram+0x6c>)
 8004a60:	e023      	b.n	8004aaa <ip_reass_remove_oldest_datagram+0x56>
        other_datagrams++;
 8004a62:	3401      	adds	r4, #1
        if (oldest == NULL) {
 8004a64:	b1b8      	cbz	r0, 8004a96 <ip_reass_remove_oldest_datagram+0x42>
        } else if (r->timer <= oldest->timer) {
 8004a66:	f893 e01f 	ldrb.w	lr, [r3, #31]
 8004a6a:	7fc2      	ldrb	r2, [r0, #31]
 8004a6c:	4596      	cmp	lr, r2
 8004a6e:	bf98      	it	ls
 8004a70:	4618      	movls	r0, r3
      if (r->next != NULL) {
 8004a72:	681a      	ldr	r2, [r3, #0]
 8004a74:	b18a      	cbz	r2, 8004a9a <ip_reass_remove_oldest_datagram+0x46>
 8004a76:	4619      	mov	r1, r3
 8004a78:	4613      	mov	r3, r2
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 8004a7a:	695a      	ldr	r2, [r3, #20]
 8004a7c:	4562      	cmp	r2, ip
 8004a7e:	d1f0      	bne.n	8004a62 <ip_reass_remove_oldest_datagram+0xe>
 8004a80:	f8d5 e010 	ldr.w	lr, [r5, #16]
 8004a84:	699a      	ldr	r2, [r3, #24]
 8004a86:	4572      	cmp	r2, lr
 8004a88:	d1eb      	bne.n	8004a62 <ip_reass_remove_oldest_datagram+0xe>
 8004a8a:	f8b3 e00c 	ldrh.w	lr, [r3, #12]
 8004a8e:	88aa      	ldrh	r2, [r5, #4]
 8004a90:	4596      	cmp	lr, r2
 8004a92:	d1e6      	bne.n	8004a62 <ip_reass_remove_oldest_datagram+0xe>
 8004a94:	e7ed      	b.n	8004a72 <ip_reass_remove_oldest_datagram+0x1e>
 8004a96:	4618      	mov	r0, r3
 8004a98:	e7eb      	b.n	8004a72 <ip_reass_remove_oldest_datagram+0x1e>
    if (oldest != NULL) {
 8004a9a:	b110      	cbz	r0, 8004aa2 <ip_reass_remove_oldest_datagram+0x4e>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
 8004a9c:	f7ff ff8c 	bl	80049b8 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
 8004aa0:	4406      	add	r6, r0
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 8004aa2:	4546      	cmp	r6, r8
 8004aa4:	da09      	bge.n	8004aba <ip_reass_remove_oldest_datagram+0x66>
 8004aa6:	2c01      	cmp	r4, #1
 8004aa8:	dd07      	ble.n	8004aba <ip_reass_remove_oldest_datagram+0x66>
    r = reassdatagrams;
 8004aaa:	683b      	ldr	r3, [r7, #0]
    while (r != NULL) {
 8004aac:	b12b      	cbz	r3, 8004aba <ip_reass_remove_oldest_datagram+0x66>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 8004aae:	f8d5 c00c 	ldr.w	ip, [r5, #12]
 8004ab2:	2400      	movs	r4, #0
 8004ab4:	4621      	mov	r1, r4
 8004ab6:	4620      	mov	r0, r4
 8004ab8:	e7df      	b.n	8004a7a <ip_reass_remove_oldest_datagram+0x26>
}
 8004aba:	4630      	mov	r0, r6
 8004abc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004ac0:	20000890 	.word	0x20000890

08004ac4 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 8004ac4:	b510      	push	{r4, lr}
 8004ac6:	4604      	mov	r4, r0
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
 8004ac8:	6940      	ldr	r0, [r0, #20]
 8004aca:	b108      	cbz	r0, 8004ad0 <ipfrag_free_pbuf_custom+0xc>
    pbuf_free(pcr->original);
 8004acc:	f000 fdd3 	bl	8005676 <pbuf_free>
  memp_free(MEMP_FRAG_PBUF, p);
 8004ad0:	4621      	mov	r1, r4
 8004ad2:	2006      	movs	r0, #6
 8004ad4:	f000 fcd8 	bl	8005488 <memp_free>
 8004ad8:	bd10      	pop	{r4, pc}
	...

08004adc <ip_reass_tmr>:
{
 8004adc:	b538      	push	{r3, r4, r5, lr}
  r = reassdatagrams;
 8004ade:	4b0a      	ldr	r3, [pc, #40]	; (8004b08 <ip_reass_tmr+0x2c>)
 8004ae0:	6818      	ldr	r0, [r3, #0]
  while (r != NULL) {
 8004ae2:	b178      	cbz	r0, 8004b04 <ip_reass_tmr+0x28>
 8004ae4:	2400      	movs	r4, #0
 8004ae6:	e005      	b.n	8004af4 <ip_reass_tmr+0x18>
      r = r->next;
 8004ae8:	6805      	ldr	r5, [r0, #0]
      ip_reass_free_complete_datagram(tmp, prev);
 8004aea:	4621      	mov	r1, r4
 8004aec:	f7ff ff64 	bl	80049b8 <ip_reass_free_complete_datagram>
      r = r->next;
 8004af0:	4628      	mov	r0, r5
  while (r != NULL) {
 8004af2:	b138      	cbz	r0, 8004b04 <ip_reass_tmr+0x28>
    if (r->timer > 0) {
 8004af4:	7fc3      	ldrb	r3, [r0, #31]
 8004af6:	2b00      	cmp	r3, #0
 8004af8:	d0f6      	beq.n	8004ae8 <ip_reass_tmr+0xc>
      r->timer--;
 8004afa:	3b01      	subs	r3, #1
 8004afc:	77c3      	strb	r3, [r0, #31]
 8004afe:	4604      	mov	r4, r0
      r = r->next;
 8004b00:	6800      	ldr	r0, [r0, #0]
 8004b02:	e7f6      	b.n	8004af2 <ip_reass_tmr+0x16>
 8004b04:	bd38      	pop	{r3, r4, r5, pc}
 8004b06:	bf00      	nop
 8004b08:	20000890 	.word	0x20000890

08004b0c <ip_reass>:
{
 8004b0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004b10:	b083      	sub	sp, #12
 8004b12:	4607      	mov	r7, r0
  IPFRAG_STATS_INC(ip_frag.recv);
 8004b14:	4ab2      	ldr	r2, [pc, #712]	; (8004de0 <ip_reass+0x2d4>)
 8004b16:	8e53      	ldrh	r3, [r2, #50]	; 0x32
 8004b18:	3301      	adds	r3, #1
 8004b1a:	8653      	strh	r3, [r2, #50]	; 0x32
  fraghdr = (struct ip_hdr*)p->payload;
 8004b1c:	6846      	ldr	r6, [r0, #4]
  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 8004b1e:	7833      	ldrb	r3, [r6, #0]
 8004b20:	f003 030f 	and.w	r3, r3, #15
 8004b24:	2b05      	cmp	r3, #5
 8004b26:	d11a      	bne.n	8004b5e <ip_reass+0x52>
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 8004b28:	88f0      	ldrh	r0, [r6, #6]
 8004b2a:	f7ff fb2e 	bl	800418a <lwip_ntohs>
 8004b2e:	9001      	str	r0, [sp, #4]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8004b30:	8870      	ldrh	r0, [r6, #2]
 8004b32:	f7ff fb2a 	bl	800418a <lwip_ntohs>
 8004b36:	4683      	mov	fp, r0
 8004b38:	f896 8000 	ldrb.w	r8, [r6]
  clen = pbuf_clen(p);
 8004b3c:	4638      	mov	r0, r7
 8004b3e:	f000 fe8c 	bl	800585a <pbuf_clen>
 8004b42:	4681      	mov	r9, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 8004b44:	4ba7      	ldr	r3, [pc, #668]	; (8004de4 <ip_reass+0x2d8>)
 8004b46:	881b      	ldrh	r3, [r3, #0]
 8004b48:	4403      	add	r3, r0
 8004b4a:	2b0a      	cmp	r3, #10
 8004b4c:	dc16      	bgt.n	8004b7c <ip_reass+0x70>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 8004b4e:	4ba6      	ldr	r3, [pc, #664]	; (8004de8 <ip_reass+0x2dc>)
 8004b50:	681c      	ldr	r4, [r3, #0]
 8004b52:	2c00      	cmp	r4, #0
 8004b54:	f000 8091 	beq.w	8004c7a <ip_reass+0x16e>
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 8004b58:	68f2      	ldr	r2, [r6, #12]
 8004b5a:	2500      	movs	r5, #0
 8004b5c:	e022      	b.n	8004ba4 <ip_reass+0x98>
    IPFRAG_STATS_INC(ip_frag.err);
 8004b5e:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8004b62:	3301      	adds	r3, #1
 8004b64:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
  IPFRAG_STATS_INC(ip_frag.drop);
 8004b68:	4a9d      	ldr	r2, [pc, #628]	; (8004de0 <ip_reass+0x2d4>)
 8004b6a:	8ed3      	ldrh	r3, [r2, #54]	; 0x36
 8004b6c:	3301      	adds	r3, #1
 8004b6e:	86d3      	strh	r3, [r2, #54]	; 0x36
  pbuf_free(p);
 8004b70:	4638      	mov	r0, r7
 8004b72:	f000 fd80 	bl	8005676 <pbuf_free>
  return NULL;
 8004b76:	f04f 0800 	mov.w	r8, #0
 8004b7a:	e119      	b.n	8004db0 <ip_reass+0x2a4>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8004b7c:	4601      	mov	r1, r0
 8004b7e:	4630      	mov	r0, r6
 8004b80:	f7ff ff68 	bl	8004a54 <ip_reass_remove_oldest_datagram>
 8004b84:	b120      	cbz	r0, 8004b90 <ip_reass+0x84>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 8004b86:	4b97      	ldr	r3, [pc, #604]	; (8004de4 <ip_reass+0x2d8>)
 8004b88:	881b      	ldrh	r3, [r3, #0]
 8004b8a:	444b      	add	r3, r9
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8004b8c:	2b0a      	cmp	r3, #10
 8004b8e:	ddde      	ble.n	8004b4e <ip_reass+0x42>
      IPFRAG_STATS_INC(ip_frag.memerr);
 8004b90:	4a93      	ldr	r2, [pc, #588]	; (8004de0 <ip_reass+0x2d4>)
 8004b92:	8f93      	ldrh	r3, [r2, #60]	; 0x3c
 8004b94:	3301      	adds	r3, #1
 8004b96:	8793      	strh	r3, [r2, #60]	; 0x3c
      goto nullreturn;
 8004b98:	e7e6      	b.n	8004b68 <ip_reass+0x5c>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 8004b9a:	6823      	ldr	r3, [r4, #0]
 8004b9c:	4625      	mov	r5, r4
 8004b9e:	2b00      	cmp	r3, #0
 8004ba0:	d06b      	beq.n	8004c7a <ip_reass+0x16e>
 8004ba2:	461c      	mov	r4, r3
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 8004ba4:	6963      	ldr	r3, [r4, #20]
 8004ba6:	4293      	cmp	r3, r2
 8004ba8:	d1f7      	bne.n	8004b9a <ip_reass+0x8e>
 8004baa:	6933      	ldr	r3, [r6, #16]
 8004bac:	69a1      	ldr	r1, [r4, #24]
 8004bae:	4299      	cmp	r1, r3
 8004bb0:	d1f3      	bne.n	8004b9a <ip_reass+0x8e>
 8004bb2:	89a1      	ldrh	r1, [r4, #12]
 8004bb4:	88b3      	ldrh	r3, [r6, #4]
 8004bb6:	4299      	cmp	r1, r3
 8004bb8:	d1ef      	bne.n	8004b9a <ip_reass+0x8e>
      IPFRAG_STATS_INC(ip_frag.cachehit);
 8004bba:	4a89      	ldr	r2, [pc, #548]	; (8004de0 <ip_reass+0x2d4>)
 8004bbc:	f8b2 3046 	ldrh.w	r3, [r2, #70]	; 0x46
 8004bc0:	3301      	adds	r3, #1
 8004bc2:	f8a2 3046 	strh.w	r3, [r2, #70]	; 0x46
  if (ipr == NULL) {
 8004bc6:	2c00      	cmp	r4, #0
 8004bc8:	d056      	beq.n	8004c78 <ip_reass+0x16c>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 8004bca:	88f0      	ldrh	r0, [r6, #6]
 8004bcc:	f7ff fadd 	bl	800418a <lwip_ntohs>
 8004bd0:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8004bd4:	2800      	cmp	r0, #0
 8004bd6:	f000 8087 	beq.w	8004ce8 <ip_reass+0x1dc>
  ip_reass_pbufcount += clen;
 8004bda:	4a82      	ldr	r2, [pc, #520]	; (8004de4 <ip_reass+0x2d8>)
 8004bdc:	8813      	ldrh	r3, [r2, #0]
 8004bde:	4499      	add	r9, r3
 8004be0:	f8a2 9000 	strh.w	r9, [r2]
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
 8004be4:	88f3      	ldrh	r3, [r6, #6]
 8004be6:	f013 0f20 	tst.w	r3, #32
 8004bea:	d10c      	bne.n	8004c06 <ip_reass+0xfa>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 8004bec:	7fa3      	ldrb	r3, [r4, #30]
 8004bee:	f043 0301 	orr.w	r3, r3, #1
 8004bf2:	77a3      	strb	r3, [r4, #30]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8004bf4:	f008 080f 	and.w	r8, r8, #15
 8004bf8:	ebab 0b88 	sub.w	fp, fp, r8, lsl #2
    ipr->datagram_len = offset + len;
 8004bfc:	9b01      	ldr	r3, [sp, #4]
 8004bfe:	eb0b 0ac3 	add.w	sl, fp, r3, lsl #3
 8004c02:	f8a4 a01c 	strh.w	sl, [r4, #28]
  fraghdr = (struct ip_hdr*)new_p->payload; 
 8004c06:	f8d7 8004 	ldr.w	r8, [r7, #4]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8004c0a:	f8b8 0002 	ldrh.w	r0, [r8, #2]
 8004c0e:	f7ff fabc 	bl	800418a <lwip_ntohs>
 8004c12:	f898 6000 	ldrb.w	r6, [r8]
 8004c16:	f006 060f 	and.w	r6, r6, #15
 8004c1a:	eba0 0686 	sub.w	r6, r0, r6, lsl #2
 8004c1e:	b2b6      	uxth	r6, r6
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 8004c20:	f8b8 0006 	ldrh.w	r0, [r8, #6]
 8004c24:	f7ff fab1 	bl	800418a <lwip_ntohs>
 8004c28:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8004c2c:	00c0      	lsls	r0, r0, #3
  iprh = (struct ip_reass_helper*)new_p->payload;
 8004c2e:	f8d7 8004 	ldr.w	r8, [r7, #4]
  iprh->next_pbuf = NULL;
 8004c32:	2300      	movs	r3, #0
 8004c34:	f888 3000 	strb.w	r3, [r8]
 8004c38:	f888 3001 	strb.w	r3, [r8, #1]
 8004c3c:	f888 3002 	strb.w	r3, [r8, #2]
 8004c40:	f888 3003 	strb.w	r3, [r8, #3]
  iprh->start = offset;
 8004c44:	f8a8 0004 	strh.w	r0, [r8, #4]
  iprh->end = offset + len;
 8004c48:	eb06 0c00 	add.w	ip, r6, r0
 8004c4c:	fa1f fc8c 	uxth.w	ip, ip
 8004c50:	f8a8 c006 	strh.w	ip, [r8, #6]
  for (q = ipr->p; q != NULL;) {
 8004c54:	6862      	ldr	r2, [r4, #4]
 8004c56:	2a00      	cmp	r2, #0
 8004c58:	f000 809a 	beq.w	8004d90 <ip_reass+0x284>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 8004c5c:	6853      	ldr	r3, [r2, #4]
    if (iprh->start < iprh_tmp->start) {
 8004c5e:	8899      	ldrh	r1, [r3, #4]
 8004c60:	4288      	cmp	r0, r1
 8004c62:	f0c0 80ad 	bcc.w	8004dc0 <ip_reass+0x2b4>
    } else if(iprh->start == iprh_tmp->start) {
 8004c66:	f000 8097 	beq.w	8004d98 <ip_reass+0x28c>
    } else if(iprh->start < iprh_tmp->end) {
 8004c6a:	88da      	ldrh	r2, [r3, #6]
 8004c6c:	4282      	cmp	r2, r0
 8004c6e:	f200 8093 	bhi.w	8004d98 <ip_reass+0x28c>
 8004c72:	f04f 0e01 	mov.w	lr, #1
 8004c76:	e078      	b.n	8004d6a <ip_reass+0x25e>
 8004c78:	462c      	mov	r4, r5
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 8004c7a:	2005      	movs	r0, #5
 8004c7c:	f000 fbce 	bl	800541c <memp_malloc>
  if (ipr == NULL) {
 8004c80:	4682      	mov	sl, r0
 8004c82:	b1f8      	cbz	r0, 8004cc4 <ip_reass+0x1b8>
  memset(ipr, 0, sizeof(struct ip_reassdata));
 8004c84:	2220      	movs	r2, #32
 8004c86:	2100      	movs	r1, #0
 8004c88:	4650      	mov	r0, sl
 8004c8a:	f004 f90b 	bl	8008ea4 <memset>
  ipr->timer = IP_REASS_MAXAGE;
 8004c8e:	2303      	movs	r3, #3
 8004c90:	f88a 301f 	strb.w	r3, [sl, #31]
  ipr->next = reassdatagrams;
 8004c94:	4b54      	ldr	r3, [pc, #336]	; (8004de8 <ip_reass+0x2dc>)
 8004c96:	681a      	ldr	r2, [r3, #0]
 8004c98:	f8ca 2000 	str.w	r2, [sl]
  reassdatagrams = ipr;
 8004c9c:	f8c3 a000 	str.w	sl, [r3]
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 8004ca0:	6832      	ldr	r2, [r6, #0]
 8004ca2:	6875      	ldr	r5, [r6, #4]
 8004ca4:	68b0      	ldr	r0, [r6, #8]
 8004ca6:	68f1      	ldr	r1, [r6, #12]
 8004ca8:	f8ca 2008 	str.w	r2, [sl, #8]
 8004cac:	f8ca 500c 	str.w	r5, [sl, #12]
 8004cb0:	f8ca 0010 	str.w	r0, [sl, #16]
 8004cb4:	f8ca 1014 	str.w	r1, [sl, #20]
 8004cb8:	6932      	ldr	r2, [r6, #16]
 8004cba:	f8ca 2018 	str.w	r2, [sl, #24]
 8004cbe:	4625      	mov	r5, r4
 8004cc0:	4654      	mov	r4, sl
 8004cc2:	e78a      	b.n	8004bda <ip_reass+0xce>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 8004cc4:	4649      	mov	r1, r9
 8004cc6:	4630      	mov	r0, r6
 8004cc8:	f7ff fec4 	bl	8004a54 <ip_reass_remove_oldest_datagram>
 8004ccc:	4581      	cmp	r9, r0
 8004cce:	dd04      	ble.n	8004cda <ip_reass+0x1ce>
      IPFRAG_STATS_INC(ip_frag.memerr);
 8004cd0:	4a43      	ldr	r2, [pc, #268]	; (8004de0 <ip_reass+0x2d4>)
 8004cd2:	8f93      	ldrh	r3, [r2, #60]	; 0x3c
 8004cd4:	3301      	adds	r3, #1
 8004cd6:	8793      	strh	r3, [r2, #60]	; 0x3c
 8004cd8:	e746      	b.n	8004b68 <ip_reass+0x5c>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 8004cda:	2005      	movs	r0, #5
 8004cdc:	f000 fb9e 	bl	800541c <memp_malloc>
    if (ipr == NULL)
 8004ce0:	4682      	mov	sl, r0
 8004ce2:	2800      	cmp	r0, #0
 8004ce4:	d1ce      	bne.n	8004c84 <ip_reass+0x178>
 8004ce6:	e7f3      	b.n	8004cd0 <ip_reass+0x1c4>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 8004ce8:	89e0      	ldrh	r0, [r4, #14]
 8004cea:	f7ff fa4e 	bl	800418a <lwip_ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 8004cee:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8004cf2:	2800      	cmp	r0, #0
 8004cf4:	f43f af71 	beq.w	8004bda <ip_reass+0xce>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 8004cf8:	6832      	ldr	r2, [r6, #0]
 8004cfa:	f8d6 e004 	ldr.w	lr, [r6, #4]
 8004cfe:	68b0      	ldr	r0, [r6, #8]
 8004d00:	68f1      	ldr	r1, [r6, #12]
 8004d02:	60a2      	str	r2, [r4, #8]
 8004d04:	f8c4 e00c 	str.w	lr, [r4, #12]
 8004d08:	6120      	str	r0, [r4, #16]
 8004d0a:	6161      	str	r1, [r4, #20]
 8004d0c:	6932      	ldr	r2, [r6, #16]
 8004d0e:	61a2      	str	r2, [r4, #24]
 8004d10:	e763      	b.n	8004bda <ip_reass+0xce>
      iprh->next_pbuf = q;
 8004d12:	f8c8 6000 	str.w	r6, [r8]
      if (iprh_prev != NULL) {
 8004d16:	2b00      	cmp	r3, #0
 8004d18:	d056      	beq.n	8004dc8 <ip_reass+0x2bc>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 8004d1a:	88d9      	ldrh	r1, [r3, #6]
 8004d1c:	4281      	cmp	r1, r0
 8004d1e:	d83b      	bhi.n	8004d98 <ip_reass+0x28c>
 8004d20:	8892      	ldrh	r2, [r2, #4]
 8004d22:	4562      	cmp	r2, ip
 8004d24:	d338      	bcc.n	8004d98 <ip_reass+0x28c>
        iprh_prev->next_pbuf = new_p;
 8004d26:	601f      	str	r7, [r3, #0]
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 8004d28:	7fa3      	ldrb	r3, [r4, #30]
 8004d2a:	f013 0f01 	tst.w	r3, #1
 8004d2e:	d03d      	beq.n	8004dac <ip_reass+0x2a0>
    if (valid) {
 8004d30:	f1be 0f00 	cmp.w	lr, #0
 8004d34:	d03a      	beq.n	8004dac <ip_reass+0x2a0>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
 8004d36:	6860      	ldr	r0, [r4, #4]
 8004d38:	6843      	ldr	r3, [r0, #4]
 8004d3a:	889b      	ldrh	r3, [r3, #4]
 8004d3c:	2b00      	cmp	r3, #0
 8004d3e:	d135      	bne.n	8004dac <ip_reass+0x2a0>
        q = iprh->next_pbuf;
 8004d40:	f8d8 3000 	ldr.w	r3, [r8]
        while (q != NULL) {
 8004d44:	2b00      	cmp	r3, #0
 8004d46:	d051      	beq.n	8004dec <ip_reass+0x2e0>
          iprh = (struct ip_reass_helper*)q->payload;
 8004d48:	685b      	ldr	r3, [r3, #4]
          if (iprh_prev->end != iprh->start) {
 8004d4a:	8899      	ldrh	r1, [r3, #4]
 8004d4c:	f8b8 2006 	ldrh.w	r2, [r8, #6]
 8004d50:	4291      	cmp	r1, r2
 8004d52:	d12b      	bne.n	8004dac <ip_reass+0x2a0>
          q = iprh->next_pbuf;
 8004d54:	681a      	ldr	r2, [r3, #0]
        while (q != NULL) {
 8004d56:	2a00      	cmp	r2, #0
 8004d58:	d048      	beq.n	8004dec <ip_reass+0x2e0>
          iprh = (struct ip_reass_helper*)q->payload;
 8004d5a:	6852      	ldr	r2, [r2, #4]
          if (iprh_prev->end != iprh->start) {
 8004d5c:	88d9      	ldrh	r1, [r3, #6]
 8004d5e:	8893      	ldrh	r3, [r2, #4]
 8004d60:	4299      	cmp	r1, r3
 8004d62:	d123      	bne.n	8004dac <ip_reass+0x2a0>
          iprh = (struct ip_reass_helper*)q->payload;
 8004d64:	4613      	mov	r3, r2
 8004d66:	e7f5      	b.n	8004d54 <ip_reass+0x248>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 8004d68:	4613      	mov	r3, r2
    q = iprh_tmp->next_pbuf;
 8004d6a:	681e      	ldr	r6, [r3, #0]
  for (q = ipr->p; q != NULL;) {
 8004d6c:	b376      	cbz	r6, 8004dcc <ip_reass+0x2c0>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 8004d6e:	6872      	ldr	r2, [r6, #4]
    if (iprh->start < iprh_tmp->start) {
 8004d70:	8891      	ldrh	r1, [r2, #4]
 8004d72:	4288      	cmp	r0, r1
 8004d74:	d3cd      	bcc.n	8004d12 <ip_reass+0x206>
    } else if(iprh->start == iprh_tmp->start) {
 8004d76:	4288      	cmp	r0, r1
 8004d78:	d00e      	beq.n	8004d98 <ip_reass+0x28c>
    } else if(iprh->start < iprh_tmp->end) {
 8004d7a:	88d6      	ldrh	r6, [r2, #6]
 8004d7c:	4286      	cmp	r6, r0
 8004d7e:	d80b      	bhi.n	8004d98 <ip_reass+0x28c>
      if (iprh_prev != NULL) {
 8004d80:	2b00      	cmp	r3, #0
 8004d82:	d0f1      	beq.n	8004d68 <ip_reass+0x25c>
        if (iprh_prev->end != iprh_tmp->start) {
 8004d84:	88db      	ldrh	r3, [r3, #6]
          valid = 0;
 8004d86:	428b      	cmp	r3, r1
 8004d88:	bf18      	it	ne
 8004d8a:	f04f 0e00 	movne.w	lr, #0
 8004d8e:	e7eb      	b.n	8004d68 <ip_reass+0x25c>
  int valid = 1;
 8004d90:	f04f 0e01 	mov.w	lr, #1
      ipr->p = new_p;
 8004d94:	6067      	str	r7, [r4, #4]
 8004d96:	e7c7      	b.n	8004d28 <ip_reass+0x21c>
  ip_reass_pbufcount -= pbuf_clen(new_p);
 8004d98:	4638      	mov	r0, r7
 8004d9a:	f000 fd5e 	bl	800585a <pbuf_clen>
 8004d9e:	4a11      	ldr	r2, [pc, #68]	; (8004de4 <ip_reass+0x2d8>)
 8004da0:	8813      	ldrh	r3, [r2, #0]
 8004da2:	1a18      	subs	r0, r3, r0
 8004da4:	8010      	strh	r0, [r2, #0]
  pbuf_free(new_p);
 8004da6:	4638      	mov	r0, r7
 8004da8:	f000 fc65 	bl	8005676 <pbuf_free>
  return NULL;
 8004dac:	f04f 0800 	mov.w	r8, #0
}
 8004db0:	4640      	mov	r0, r8
 8004db2:	b003      	add	sp, #12
 8004db4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    reassdatagrams = ipr->next;
 8004db8:	6822      	ldr	r2, [r4, #0]
 8004dba:	4b0b      	ldr	r3, [pc, #44]	; (8004de8 <ip_reass+0x2dc>)
 8004dbc:	601a      	str	r2, [r3, #0]
 8004dbe:	e04d      	b.n	8004e5c <ip_reass+0x350>
      iprh->next_pbuf = q;
 8004dc0:	f8c8 2000 	str.w	r2, [r8]
  int valid = 1;
 8004dc4:	f04f 0e01 	mov.w	lr, #1
        ipr->p = new_p;
 8004dc8:	6067      	str	r7, [r4, #4]
 8004dca:	e7ad      	b.n	8004d28 <ip_reass+0x21c>
    if (iprh_prev != NULL) {
 8004dcc:	2b00      	cmp	r3, #0
 8004dce:	d0e1      	beq.n	8004d94 <ip_reass+0x288>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 8004dd0:	88da      	ldrh	r2, [r3, #6]
      iprh_prev->next_pbuf = new_p;
 8004dd2:	601f      	str	r7, [r3, #0]
      if (iprh_prev->end != iprh->start) {
 8004dd4:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8004dd8:	4293      	cmp	r3, r2
 8004dda:	d1e7      	bne.n	8004dac <ip_reass+0x2a0>
 8004ddc:	e7a4      	b.n	8004d28 <ip_reass+0x21c>
 8004dde:	bf00      	nop
 8004de0:	2000aac4 	.word	0x2000aac4
 8004de4:	2000088e 	.word	0x2000088e
 8004de8:	20000890 	.word	0x20000890
    ipr->datagram_len += IP_HLEN;
 8004dec:	8ba3      	ldrh	r3, [r4, #28]
 8004dee:	3314      	adds	r3, #20
 8004df0:	83a3      	strh	r3, [r4, #28]
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 8004df2:	6847      	ldr	r7, [r0, #4]
 8004df4:	683e      	ldr	r6, [r7, #0]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 8004df6:	4623      	mov	r3, r4
 8004df8:	f853 2f08 	ldr.w	r2, [r3, #8]!
 8004dfc:	f8d3 e004 	ldr.w	lr, [r3, #4]
 8004e00:	6898      	ldr	r0, [r3, #8]
 8004e02:	68d9      	ldr	r1, [r3, #12]
 8004e04:	603a      	str	r2, [r7, #0]
 8004e06:	f8c7 e004 	str.w	lr, [r7, #4]
 8004e0a:	60b8      	str	r0, [r7, #8]
 8004e0c:	60f9      	str	r1, [r7, #12]
 8004e0e:	691a      	ldr	r2, [r3, #16]
 8004e10:	613a      	str	r2, [r7, #16]
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 8004e12:	8ba0      	ldrh	r0, [r4, #28]
 8004e14:	f7ff f9b4 	bl	8004180 <lwip_htons>
 8004e18:	8078      	strh	r0, [r7, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 8004e1a:	2300      	movs	r3, #0
 8004e1c:	71bb      	strb	r3, [r7, #6]
 8004e1e:	71fb      	strb	r3, [r7, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 8004e20:	72bb      	strb	r3, [r7, #10]
 8004e22:	72fb      	strb	r3, [r7, #11]
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 8004e24:	2114      	movs	r1, #20
 8004e26:	4638      	mov	r0, r7
 8004e28:	f7ff fb8b 	bl	8004542 <inet_chksum>
 8004e2c:	8178      	strh	r0, [r7, #10]
    p = ipr->p;
 8004e2e:	f8d4 8004 	ldr.w	r8, [r4, #4]
      pbuf_header(r, -IP_HLEN);
 8004e32:	f06f 0913 	mvn.w	r9, #19
    while(r != NULL) {
 8004e36:	b15e      	cbz	r6, 8004e50 <ip_reass+0x344>
      iprh = (struct ip_reass_helper*)r->payload;
 8004e38:	6877      	ldr	r7, [r6, #4]
      pbuf_header(r, -IP_HLEN);
 8004e3a:	4649      	mov	r1, r9
 8004e3c:	4630      	mov	r0, r6
 8004e3e:	f000 fbdc 	bl	80055fa <pbuf_header>
      pbuf_cat(p, r);
 8004e42:	4631      	mov	r1, r6
 8004e44:	4640      	mov	r0, r8
 8004e46:	f000 fd18 	bl	800587a <pbuf_cat>
      r = iprh->next_pbuf;
 8004e4a:	683e      	ldr	r6, [r7, #0]
    while(r != NULL) {
 8004e4c:	2e00      	cmp	r6, #0
 8004e4e:	d1f3      	bne.n	8004e38 <ip_reass+0x32c>
  if (reassdatagrams == ipr) {
 8004e50:	4b08      	ldr	r3, [pc, #32]	; (8004e74 <ip_reass+0x368>)
 8004e52:	681b      	ldr	r3, [r3, #0]
 8004e54:	429c      	cmp	r4, r3
 8004e56:	d0af      	beq.n	8004db8 <ip_reass+0x2ac>
    prev->next = ipr->next;
 8004e58:	6823      	ldr	r3, [r4, #0]
 8004e5a:	602b      	str	r3, [r5, #0]
  memp_free(MEMP_REASSDATA, ipr);
 8004e5c:	4621      	mov	r1, r4
 8004e5e:	2005      	movs	r0, #5
 8004e60:	f000 fb12 	bl	8005488 <memp_free>
    ip_reass_pbufcount -= pbuf_clen(p);
 8004e64:	4640      	mov	r0, r8
 8004e66:	f000 fcf8 	bl	800585a <pbuf_clen>
 8004e6a:	4a03      	ldr	r2, [pc, #12]	; (8004e78 <ip_reass+0x36c>)
 8004e6c:	8813      	ldrh	r3, [r2, #0]
 8004e6e:	1a18      	subs	r0, r3, r0
 8004e70:	8010      	strh	r0, [r2, #0]
    return p;
 8004e72:	e79d      	b.n	8004db0 <ip_reass+0x2a4>
 8004e74:	20000890 	.word	0x20000890
 8004e78:	2000088e 	.word	0x2000088e

08004e7c <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 8004e7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004e80:	b08d      	sub	sp, #52	; 0x34
 8004e82:	4604      	mov	r4, r0
 8004e84:	9109      	str	r1, [sp, #36]	; 0x24
 8004e86:	920a      	str	r2, [sp, #40]	; 0x28
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
 8004e88:	8c0d      	ldrh	r5, [r1, #32]

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
#else /* IP_FRAG_USES_STATIC_BUF */
  original_iphdr = (struct ip_hdr *)p->payload;
 8004e8a:	f8d0 8004 	ldr.w	r8, [r0, #4]
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 8004e8e:	f8b8 0006 	ldrh.w	r0, [r8, #6]
 8004e92:	f7ff f97a 	bl	800418a <lwip_ntohs>
  ofo = tmp & IP_OFFMASK;
 8004e96:	f3c0 030c 	ubfx	r3, r0, #0, #13
 8004e9a:	9303      	str	r3, [sp, #12]
  omf = tmp & IP_MF;
 8004e9c:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
 8004ea0:	9307      	str	r3, [sp, #28]

  left = p->tot_len - IP_HLEN;
 8004ea2:	f8b4 9008 	ldrh.w	r9, [r4, #8]
 8004ea6:	f1a9 0914 	sub.w	r9, r9, #20
 8004eaa:	fa1f f989 	uxth.w	r9, r9

  nfb = (mtu - IP_HLEN) / 8;
 8004eae:	f1a5 0314 	sub.w	r3, r5, #20
 8004eb2:	9306      	str	r3, [sp, #24]
 8004eb4:	2b00      	cmp	r3, #0
 8004eb6:	bfb8      	it	lt
 8004eb8:	3307      	addlt	r3, #7
 8004eba:	f3c3 03cf 	ubfx	r3, r3, #3, #16
 8004ebe:	9308      	str	r3, [sp, #32]

  while (left) {
 8004ec0:	f1b9 0f00 	cmp.w	r9, #0
 8004ec4:	f000 80af 	beq.w	8005026 <ip_frag+0x1aa>
    if (!last) {
      tmp = tmp | IP_MF;
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 8004ec8:	00db      	lsls	r3, r3, #3
 8004eca:	b29b      	uxth	r3, r3
 8004ecc:	930b      	str	r3, [sp, #44]	; 0x2c
 8004ece:	2600      	movs	r6, #0
 8004ed0:	2514      	movs	r5, #20
 8004ed2:	e084      	b.n	8004fde <ip_frag+0x162>
 8004ed4:	f8cd 9010 	str.w	r9, [sp, #16]
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 8004ed8:	2200      	movs	r2, #0
 8004eda:	2114      	movs	r1, #20
 8004edc:	2002      	movs	r0, #2
 8004ede:	f000 fbf9 	bl	80056d4 <pbuf_alloc>
    if (rambuf == NULL) {
 8004ee2:	4682      	mov	sl, r0
 8004ee4:	2800      	cmp	r0, #0
 8004ee6:	f000 80a0 	beq.w	800502a <ip_frag+0x1ae>
      return ERR_MEM;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 8004eea:	6843      	ldr	r3, [r0, #4]
 8004eec:	f8d8 2000 	ldr.w	r2, [r8]
 8004ef0:	f8d8 7004 	ldr.w	r7, [r8, #4]
 8004ef4:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8004ef8:	f8d8 100c 	ldr.w	r1, [r8, #12]
 8004efc:	601a      	str	r2, [r3, #0]
 8004efe:	605f      	str	r7, [r3, #4]
 8004f00:	6098      	str	r0, [r3, #8]
 8004f02:	60d9      	str	r1, [r3, #12]
 8004f04:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8004f08:	611a      	str	r2, [r3, #16]
    iphdr = (struct ip_hdr *)rambuf->payload;
 8004f0a:	f8da b004 	ldr.w	fp, [sl, #4]

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
 8004f0e:	6863      	ldr	r3, [r4, #4]
 8004f10:	442b      	add	r3, r5
 8004f12:	6063      	str	r3, [r4, #4]
    p->len -= poff;
 8004f14:	8963      	ldrh	r3, [r4, #10]
 8004f16:	1b5d      	subs	r5, r3, r5
 8004f18:	8165      	strh	r5, [r4, #10]

    left_to_copy = cop;
    while (left_to_copy) {
 8004f1a:	9b04      	ldr	r3, [sp, #16]
 8004f1c:	2b00      	cmp	r3, #0
 8004f1e:	d02c      	beq.n	8004f7a <ip_frag+0xfe>
 8004f20:	461d      	mov	r5, r3
 8004f22:	e01f      	b.n	8004f64 <ip_frag+0xe8>
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 8004f24:	2006      	movs	r0, #6
 8004f26:	f000 fa79 	bl	800541c <memp_malloc>
      if (!newpbuflen) {
        p = p->next;
        continue;
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
      if (pcr == NULL) {
 8004f2a:	4607      	mov	r7, r0
 8004f2c:	2800      	cmp	r0, #0
 8004f2e:	d066      	beq.n	8004ffe <ip_frag+0x182>
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
 8004f30:	9601      	str	r6, [sp, #4]
 8004f32:	6863      	ldr	r3, [r4, #4]
 8004f34:	9300      	str	r3, [sp, #0]
 8004f36:	4603      	mov	r3, r0
 8004f38:	2202      	movs	r2, #2
 8004f3a:	4631      	mov	r1, r6
 8004f3c:	2003      	movs	r0, #3
 8004f3e:	f000 fb2d 	bl	800559c <pbuf_alloced_custom>
      if (newpbuf == NULL) {
 8004f42:	9002      	str	r0, [sp, #8]
 8004f44:	2800      	cmp	r0, #0
 8004f46:	d062      	beq.n	800500e <ip_frag+0x192>
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      pbuf_ref(p);
 8004f48:	4620      	mov	r0, r4
 8004f4a:	f000 fc91 	bl	8005870 <pbuf_ref>
      pcr->original = p;
 8004f4e:	617c      	str	r4, [r7, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 8004f50:	4b37      	ldr	r3, [pc, #220]	; (8005030 <ip_frag+0x1b4>)
 8004f52:	613b      	str	r3, [r7, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 8004f54:	9902      	ldr	r1, [sp, #8]
 8004f56:	4650      	mov	r0, sl
 8004f58:	f000 fc8f 	bl	800587a <pbuf_cat>
      left_to_copy -= newpbuflen;
 8004f5c:	1bad      	subs	r5, r5, r6
 8004f5e:	b2ad      	uxth	r5, r5
      if (left_to_copy) {
 8004f60:	b15d      	cbz	r5, 8004f7a <ip_frag+0xfe>
        p = p->next;
 8004f62:	6824      	ldr	r4, [r4, #0]
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
 8004f64:	8966      	ldrh	r6, [r4, #10]
 8004f66:	42ae      	cmp	r6, r5
 8004f68:	bf28      	it	cs
 8004f6a:	462e      	movcs	r6, r5
 8004f6c:	b2b6      	uxth	r6, r6
      if (!newpbuflen) {
 8004f6e:	2e00      	cmp	r6, #0
 8004f70:	d1d8      	bne.n	8004f24 <ip_frag+0xa8>
        p = p->next;
 8004f72:	6824      	ldr	r4, [r4, #0]
    while (left_to_copy) {
 8004f74:	2d00      	cmp	r5, #0
 8004f76:	d1f5      	bne.n	8004f64 <ip_frag+0xe8>
 8004f78:	462e      	mov	r6, r5
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 8004f7a:	9805      	ldr	r0, [sp, #20]
 8004f7c:	f7ff f900 	bl	8004180 <lwip_htons>
 8004f80:	f8ab 0006 	strh.w	r0, [fp, #6]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 8004f84:	9d04      	ldr	r5, [sp, #16]
 8004f86:	f105 0014 	add.w	r0, r5, #20
 8004f8a:	b280      	uxth	r0, r0
 8004f8c:	f7ff f8f8 	bl	8004180 <lwip_htons>
 8004f90:	f8ab 0002 	strh.w	r0, [fp, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 8004f94:	2300      	movs	r3, #0
 8004f96:	f88b 300a 	strb.w	r3, [fp, #10]
 8004f9a:	f88b 300b 	strb.w	r3, [fp, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 8004f9e:	2114      	movs	r1, #20
 8004fa0:	4658      	mov	r0, fp
 8004fa2:	f7ff face 	bl	8004542 <inet_chksum>
 8004fa6:	f8ab 000a 	strh.w	r0, [fp, #10]
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
 8004faa:	9809      	ldr	r0, [sp, #36]	; 0x24
 8004fac:	6943      	ldr	r3, [r0, #20]
 8004fae:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8004fb0:	4651      	mov	r1, sl
 8004fb2:	4798      	blx	r3
    IPFRAG_STATS_INC(ip_frag.xmit);
 8004fb4:	4b1f      	ldr	r3, [pc, #124]	; (8005034 <ip_frag+0x1b8>)
 8004fb6:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8004fb8:	3301      	adds	r3, #1
 8004fba:	4a1e      	ldr	r2, [pc, #120]	; (8005034 <ip_frag+0x1b8>)
 8004fbc:	8613      	strh	r3, [r2, #48]	; 0x30
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
 8004fbe:	4650      	mov	r0, sl
 8004fc0:	f000 fb59 	bl	8005676 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 8004fc4:	eba9 0305 	sub.w	r3, r9, r5
 8004fc8:	fa1f f983 	uxth.w	r9, r3
    ofo += nfb;
 8004fcc:	9b03      	ldr	r3, [sp, #12]
 8004fce:	9a08      	ldr	r2, [sp, #32]
 8004fd0:	4413      	add	r3, r2
 8004fd2:	b29b      	uxth	r3, r3
 8004fd4:	9303      	str	r3, [sp, #12]
 8004fd6:	4635      	mov	r5, r6
  while (left) {
 8004fd8:	f1b9 0f00 	cmp.w	r9, #0
 8004fdc:	d021      	beq.n	8005022 <ip_frag+0x1a6>
    tmp = omf | (IP_OFFMASK & (ofo));
 8004fde:	9b03      	ldr	r3, [sp, #12]
 8004fe0:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8004fe4:	9a07      	ldr	r2, [sp, #28]
 8004fe6:	4313      	orrs	r3, r2
 8004fe8:	9305      	str	r3, [sp, #20]
    if (!last) {
 8004fea:	9a06      	ldr	r2, [sp, #24]
 8004fec:	454a      	cmp	r2, r9
 8004fee:	f6bf af71 	bge.w	8004ed4 <ip_frag+0x58>
      tmp = tmp | IP_MF;
 8004ff2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8004ff6:	9305      	str	r3, [sp, #20]
    cop = last ? left : nfb * 8;
 8004ff8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8004ffa:	9304      	str	r3, [sp, #16]
 8004ffc:	e76c      	b.n	8004ed8 <ip_frag+0x5c>
 8004ffe:	4650      	mov	r0, sl
        pbuf_free(rambuf);
 8005000:	f000 fb39 	bl	8005676 <pbuf_free>
        return ERR_MEM;
 8005004:	f04f 30ff 	mov.w	r0, #4294967295
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
 8005008:	b00d      	add	sp, #52	; 0x34
 800500a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  memp_free(MEMP_FRAG_PBUF, p);
 800500e:	4639      	mov	r1, r7
 8005010:	2006      	movs	r0, #6
 8005012:	f000 fa39 	bl	8005488 <memp_free>
        pbuf_free(rambuf);
 8005016:	4650      	mov	r0, sl
 8005018:	f000 fb2d 	bl	8005676 <pbuf_free>
        return ERR_MEM;
 800501c:	f04f 30ff 	mov.w	r0, #4294967295
 8005020:	e7f2      	b.n	8005008 <ip_frag+0x18c>
  return ERR_OK;
 8005022:	2000      	movs	r0, #0
 8005024:	e7f0      	b.n	8005008 <ip_frag+0x18c>
 8005026:	2000      	movs	r0, #0
 8005028:	e7ee      	b.n	8005008 <ip_frag+0x18c>
      return ERR_MEM;
 800502a:	f04f 30ff 	mov.w	r0, #4294967295
 800502e:	e7eb      	b.n	8005008 <ip_frag+0x18c>
 8005030:	08004ac5 	.word	0x08004ac5
 8005034:	2000aac4 	.word	0x2000aac4

08005038 <mem_init>:

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8005038:	4b0b      	ldr	r3, [pc, #44]	; (8005068 <mem_init+0x30>)
 800503a:	f023 0303 	bic.w	r3, r3, #3
 800503e:	4a0b      	ldr	r2, [pc, #44]	; (800506c <mem_init+0x34>)
 8005040:	6013      	str	r3, [r2, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 8005042:	f242 7210 	movw	r2, #10000	; 0x2710
 8005046:	801a      	strh	r2, [r3, #0]
  mem->prev = 0;
 8005048:	2100      	movs	r1, #0
 800504a:	8059      	strh	r1, [r3, #2]
  mem->used = 0;
 800504c:	7119      	strb	r1, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 800504e:	1899      	adds	r1, r3, r2
 8005050:	4807      	ldr	r0, [pc, #28]	; (8005070 <mem_init+0x38>)
 8005052:	6001      	str	r1, [r0, #0]
  ram_end->used = 1;
 8005054:	2001      	movs	r0, #1
 8005056:	7108      	strb	r0, [r1, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 8005058:	529a      	strh	r2, [r3, r2]
  ram_end->prev = MEM_SIZE_ALIGNED;
 800505a:	804a      	strh	r2, [r1, #2]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 800505c:	4905      	ldr	r1, [pc, #20]	; (8005074 <mem_init+0x3c>)
 800505e:	600b      	str	r3, [r1, #0]

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
 8005060:	4b05      	ldr	r3, [pc, #20]	; (8005078 <mem_init+0x40>)
 8005062:	f8a3 20a8 	strh.w	r2, [r3, #168]	; 0xa8
 8005066:	4770      	bx	lr
 8005068:	20008397 	.word	0x20008397
 800506c:	20000898 	.word	0x20000898
 8005070:	2000089c 	.word	0x2000089c
 8005074:	20000894 	.word	0x20000894
 8005078:	2000aac4 	.word	0x2000aac4

0800507c <mem_free>:
mem_free(void *rmem)
{
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 800507c:	2800      	cmp	r0, #0
 800507e:	d050      	beq.n	8005122 <mem_free+0xa6>
{
 8005080:	b4f0      	push	{r4, r5, r6, r7}
 8005082:	4603      	mov	r3, r0
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8005084:	4a27      	ldr	r2, [pc, #156]	; (8005124 <mem_free+0xa8>)
 8005086:	6812      	ldr	r2, [r2, #0]
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8005088:	4290      	cmp	r0, r2
 800508a:	d343      	bcc.n	8005114 <mem_free+0x98>
 800508c:	4926      	ldr	r1, [pc, #152]	; (8005128 <mem_free+0xac>)
 800508e:	680f      	ldr	r7, [r1, #0]
 8005090:	42b8      	cmp	r0, r7
 8005092:	d23f      	bcs.n	8005114 <mem_free+0x98>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8005094:	f1a0 0108 	sub.w	r1, r0, #8
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 8005098:	2000      	movs	r0, #0
 800509a:	f803 0c04 	strb.w	r0, [r3, #-4]

  if (mem < lfree) {
 800509e:	4823      	ldr	r0, [pc, #140]	; (800512c <mem_free+0xb0>)
 80050a0:	6800      	ldr	r0, [r0, #0]
 80050a2:	4281      	cmp	r1, r0
    /* the newly freed struct is now the lowest */
    lfree = mem;
 80050a4:	bf3c      	itt	cc
 80050a6:	4821      	ldrcc	r0, [pc, #132]	; (800512c <mem_free+0xb0>)
 80050a8:	6001      	strcc	r1, [r0, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
 80050aa:	1a8c      	subs	r4, r1, r2
 80050ac:	b2a4      	uxth	r4, r4
 80050ae:	4d20      	ldr	r5, [pc, #128]	; (8005130 <mem_free+0xb4>)
 80050b0:	f8b5 00aa 	ldrh.w	r0, [r5, #170]	; 0xaa
 80050b4:	f833 6c08 	ldrh.w	r6, [r3, #-8]
 80050b8:	1b80      	subs	r0, r0, r6
 80050ba:	4420      	add	r0, r4
 80050bc:	f8a5 00aa 	strh.w	r0, [r5, #170]	; 0xaa
  nmem = (struct mem *)(void *)&ram[mem->next];
 80050c0:	f833 5c08 	ldrh.w	r5, [r3, #-8]
 80050c4:	1950      	adds	r0, r2, r5
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 80050c6:	4281      	cmp	r1, r0
 80050c8:	d00f      	beq.n	80050ea <mem_free+0x6e>
 80050ca:	7906      	ldrb	r6, [r0, #4]
 80050cc:	b96e      	cbnz	r6, 80050ea <mem_free+0x6e>
 80050ce:	4287      	cmp	r7, r0
 80050d0:	d00b      	beq.n	80050ea <mem_free+0x6e>
    if (lfree == nmem) {
 80050d2:	4e16      	ldr	r6, [pc, #88]	; (800512c <mem_free+0xb0>)
 80050d4:	6836      	ldr	r6, [r6, #0]
 80050d6:	42b0      	cmp	r0, r6
      lfree = mem;
 80050d8:	bf04      	itt	eq
 80050da:	4814      	ldreq	r0, [pc, #80]	; (800512c <mem_free+0xb0>)
 80050dc:	6001      	streq	r1, [r0, #0]
    mem->next = nmem->next;
 80050de:	5b50      	ldrh	r0, [r2, r5]
 80050e0:	f823 0c08 	strh.w	r0, [r3, #-8]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 80050e4:	5b50      	ldrh	r0, [r2, r5]
 80050e6:	4410      	add	r0, r2
 80050e8:	8044      	strh	r4, [r0, #2]
  pmem = (struct mem *)(void *)&ram[mem->prev];
 80050ea:	f833 0c06 	ldrh.w	r0, [r3, #-6]
 80050ee:	1814      	adds	r4, r2, r0
  if (pmem != mem && pmem->used == 0) {
 80050f0:	42a1      	cmp	r1, r4
 80050f2:	d015      	beq.n	8005120 <mem_free+0xa4>
 80050f4:	7925      	ldrb	r5, [r4, #4]
 80050f6:	b99d      	cbnz	r5, 8005120 <mem_free+0xa4>
    if (lfree == mem) {
 80050f8:	4d0c      	ldr	r5, [pc, #48]	; (800512c <mem_free+0xb0>)
 80050fa:	682d      	ldr	r5, [r5, #0]
 80050fc:	42a9      	cmp	r1, r5
      lfree = pmem;
 80050fe:	bf04      	itt	eq
 8005100:	490a      	ldreq	r1, [pc, #40]	; (800512c <mem_free+0xb0>)
 8005102:	600c      	streq	r4, [r1, #0]
    pmem->next = mem->next;
 8005104:	f833 1c08 	ldrh.w	r1, [r3, #-8]
 8005108:	5211      	strh	r1, [r2, r0]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 800510a:	f833 3c08 	ldrh.w	r3, [r3, #-8]
 800510e:	441a      	add	r2, r3
 8005110:	8050      	strh	r0, [r2, #2]
 8005112:	e005      	b.n	8005120 <mem_free+0xa4>
    MEM_STATS_INC(illegal);
 8005114:	4a06      	ldr	r2, [pc, #24]	; (8005130 <mem_free+0xb4>)
 8005116:	f8b2 30b0 	ldrh.w	r3, [r2, #176]	; 0xb0
 800511a:	3301      	adds	r3, #1
 800511c:	f8a2 30b0 	strh.w	r3, [r2, #176]	; 0xb0
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 8005120:	bcf0      	pop	{r4, r5, r6, r7}
 8005122:	4770      	bx	lr
 8005124:	20000898 	.word	0x20000898
 8005128:	2000089c 	.word	0x2000089c
 800512c:	20000894 	.word	0x20000894
 8005130:	2000aac4 	.word	0x2000aac4

08005134 <mem_trim>:
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 8005134:	3103      	adds	r1, #3
 8005136:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 800513a:	400b      	ands	r3, r1
 800513c:	2b0c      	cmp	r3, #12
 800513e:	bf38      	it	cc
 8005140:	230c      	movcc	r3, #12
  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 8005142:	f242 7210 	movw	r2, #10000	; 0x2710
 8005146:	4293      	cmp	r3, r2
 8005148:	d86e      	bhi.n	8005228 <mem_trim+0xf4>
    return NULL;
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 800514a:	4a39      	ldr	r2, [pc, #228]	; (8005230 <mem_trim+0xfc>)
 800514c:	6812      	ldr	r2, [r2, #0]
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 800514e:	4282      	cmp	r2, r0
 8005150:	d837      	bhi.n	80051c2 <mem_trim+0x8e>
 8005152:	4938      	ldr	r1, [pc, #224]	; (8005234 <mem_trim+0x100>)
 8005154:	6809      	ldr	r1, [r1, #0]
 8005156:	4288      	cmp	r0, r1
 8005158:	d233      	bcs.n	80051c2 <mem_trim+0x8e>
{
 800515a:	b5f0      	push	{r4, r5, r6, r7, lr}
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 800515c:	f1a0 0408 	sub.w	r4, r0, #8
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
 8005160:	1aa4      	subs	r4, r4, r2
 8005162:	b2a4      	uxth	r4, r4

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 8005164:	f830 5c08 	ldrh.w	r5, [r0, #-8]
 8005168:	f1a5 0108 	sub.w	r1, r5, #8
 800516c:	1b09      	subs	r1, r1, r4
 800516e:	b289      	uxth	r1, r1
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
  if (newsize > size) {
 8005170:	4299      	cmp	r1, r3
 8005172:	d35b      	bcc.n	800522c <mem_trim+0xf8>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
 8005174:	d05b      	beq.n	800522e <mem_trim+0xfa>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = (struct mem *)(void *)&ram[mem->next];
 8005176:	1956      	adds	r6, r2, r5
  if(mem2->used == 0) {
 8005178:	7937      	ldrb	r7, [r6, #4]
 800517a:	bb7f      	cbnz	r7, 80051dc <mem_trim+0xa8>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
 800517c:	5b57      	ldrh	r7, [r2, r5]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 800517e:	f104 0508 	add.w	r5, r4, #8
 8005182:	441d      	add	r5, r3
 8005184:	b2ad      	uxth	r5, r5
    if (lfree == mem2) {
 8005186:	f8df e0b4 	ldr.w	lr, [pc, #180]	; 800523c <mem_trim+0x108>
 800518a:	f8de e000 	ldr.w	lr, [lr]
 800518e:	4576      	cmp	r6, lr
 8005190:	d01e      	beq.n	80051d0 <mem_trim+0x9c>
      lfree = (struct mem *)(void *)&ram[ptr2];
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
 8005192:	1956      	adds	r6, r2, r5
    mem2->used = 0;
 8005194:	f04f 0e00 	mov.w	lr, #0
 8005198:	f886 e004 	strb.w	lr, [r6, #4]
    /* restore the next pointer */
    mem2->next = next;
 800519c:	5357      	strh	r7, [r2, r5]
    /* link it back to mem */
    mem2->prev = ptr;
 800519e:	8074      	strh	r4, [r6, #2]
    /* link mem to it */
    mem->next = ptr2;
 80051a0:	f820 5c08 	strh.w	r5, [r0, #-8]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 80051a4:	5b54      	ldrh	r4, [r2, r5]
 80051a6:	f242 7610 	movw	r6, #10000	; 0x2710
 80051aa:	42b4      	cmp	r4, r6
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 80051ac:	bf1c      	itt	ne
 80051ae:	1912      	addne	r2, r2, r4
 80051b0:	8055      	strhne	r5, [r2, #2]
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 80051b2:	4c21      	ldr	r4, [pc, #132]	; (8005238 <mem_trim+0x104>)
 80051b4:	f8b4 20aa 	ldrh.w	r2, [r4, #170]	; 0xaa
 80051b8:	4413      	add	r3, r2
 80051ba:	1a5b      	subs	r3, r3, r1
 80051bc:	f8a4 30aa 	strh.w	r3, [r4, #170]	; 0xaa
 80051c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    MEM_STATS_INC(illegal);
 80051c2:	4a1d      	ldr	r2, [pc, #116]	; (8005238 <mem_trim+0x104>)
 80051c4:	f8b2 30b0 	ldrh.w	r3, [r2, #176]	; 0xb0
 80051c8:	3301      	adds	r3, #1
 80051ca:	f8a2 30b0 	strh.w	r3, [r2, #176]	; 0xb0
    return rmem;
 80051ce:	4770      	bx	lr
      lfree = (struct mem *)(void *)&ram[ptr2];
 80051d0:	1956      	adds	r6, r2, r5
 80051d2:	f8df e068 	ldr.w	lr, [pc, #104]	; 800523c <mem_trim+0x108>
 80051d6:	f8ce 6000 	str.w	r6, [lr]
 80051da:	e7da      	b.n	8005192 <mem_trim+0x5e>
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 80051dc:	f103 0514 	add.w	r5, r3, #20
 80051e0:	428d      	cmp	r5, r1
 80051e2:	d824      	bhi.n	800522e <mem_trim+0xfa>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 80051e4:	f104 0508 	add.w	r5, r4, #8
 80051e8:	441d      	add	r5, r3
 80051ea:	b2ad      	uxth	r5, r5
    mem2 = (struct mem *)(void *)&ram[ptr2];
 80051ec:	1956      	adds	r6, r2, r5
    if (mem2 < lfree) {
 80051ee:	4f13      	ldr	r7, [pc, #76]	; (800523c <mem_trim+0x108>)
 80051f0:	683f      	ldr	r7, [r7, #0]
 80051f2:	42be      	cmp	r6, r7
      lfree = mem2;
 80051f4:	bf3c      	itt	cc
 80051f6:	4f11      	ldrcc	r7, [pc, #68]	; (800523c <mem_trim+0x108>)
 80051f8:	603e      	strcc	r6, [r7, #0]
    }
    mem2->used = 0;
 80051fa:	2700      	movs	r7, #0
 80051fc:	7137      	strb	r7, [r6, #4]
    mem2->next = mem->next;
 80051fe:	f830 7c08 	ldrh.w	r7, [r0, #-8]
 8005202:	5357      	strh	r7, [r2, r5]
    mem2->prev = ptr;
 8005204:	8074      	strh	r4, [r6, #2]
    mem->next = ptr2;
 8005206:	f820 5c08 	strh.w	r5, [r0, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 800520a:	5b54      	ldrh	r4, [r2, r5]
 800520c:	f242 7610 	movw	r6, #10000	; 0x2710
 8005210:	42b4      	cmp	r4, r6
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8005212:	bf1c      	itt	ne
 8005214:	1912      	addne	r2, r2, r4
 8005216:	8055      	strhne	r5, [r2, #2]
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 8005218:	4a07      	ldr	r2, [pc, #28]	; (8005238 <mem_trim+0x104>)
 800521a:	f8b2 40aa 	ldrh.w	r4, [r2, #170]	; 0xaa
 800521e:	4423      	add	r3, r4
 8005220:	1a5b      	subs	r3, r3, r1
 8005222:	f8a2 30aa 	strh.w	r3, [r2, #170]	; 0xaa
 8005226:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NULL;
 8005228:	2000      	movs	r0, #0
 800522a:	4770      	bx	lr
    return NULL;
 800522c:	2000      	movs	r0, #0
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
 800522e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005230:	20000898 	.word	0x20000898
 8005234:	2000089c 	.word	0x2000089c
 8005238:	2000aac4 	.word	0x2000aac4
 800523c:	20000894 	.word	0x20000894

08005240 <mem_malloc>:
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 8005240:	2800      	cmp	r0, #0
 8005242:	f000 808f 	beq.w	8005364 <mem_malloc+0x124>
{
 8005246:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005248:	4602      	mov	r2, r0
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 800524a:	3203      	adds	r2, #3
 800524c:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 8005250:	4013      	ands	r3, r2
 8005252:	2b0c      	cmp	r3, #12
 8005254:	bf38      	it	cc
 8005256:	230c      	movcc	r3, #12
 8005258:	469e      	mov	lr, r3
  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
 800525a:	f242 7310 	movw	r3, #10000	; 0x2710
 800525e:	459e      	cmp	lr, r3
 8005260:	f200 8082 	bhi.w	8005368 <mem_malloc+0x128>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8005264:	4b41      	ldr	r3, [pc, #260]	; (800536c <mem_malloc+0x12c>)
 8005266:	f8d3 c000 	ldr.w	ip, [r3]
 800526a:	4b41      	ldr	r3, [pc, #260]	; (8005370 <mem_malloc+0x130>)
 800526c:	681a      	ldr	r2, [r3, #0]
 800526e:	eba2 020c 	sub.w	r2, r2, ip
 8005272:	b293      	uxth	r3, r2
 8005274:	f5ce 511c 	rsb	r1, lr, #9984	; 0x2700
 8005278:	3110      	adds	r1, #16
 800527a:	428b      	cmp	r3, r1
 800527c:	da6a      	bge.n	8005354 <mem_malloc+0x114>
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 800527e:	f06f 0607 	mvn.w	r6, #7
 8005282:	4675      	mov	r5, lr
 8005284:	e030      	b.n	80052e8 <mem_malloc+0xa8>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 8005286:	2201      	movs	r2, #1
 8005288:	7102      	strb	r2, [r0, #4]
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
 800528a:	4a3a      	ldr	r2, [pc, #232]	; (8005374 <mem_malloc+0x134>)
 800528c:	f8b2 10aa 	ldrh.w	r1, [r2, #170]	; 0xaa
 8005290:	440c      	add	r4, r1
 8005292:	1ae3      	subs	r3, r4, r3
 8005294:	b29b      	uxth	r3, r3
 8005296:	f8a2 30aa 	strh.w	r3, [r2, #170]	; 0xaa
 800529a:	f8b2 20ac 	ldrh.w	r2, [r2, #172]	; 0xac
 800529e:	429a      	cmp	r2, r3
 80052a0:	bf3c      	itt	cc
 80052a2:	4a34      	ldrcc	r2, [pc, #208]	; (8005374 <mem_malloc+0x134>)
 80052a4:	f8a2 30ac 	strhcc.w	r3, [r2, #172]	; 0xac
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 80052a8:	4b31      	ldr	r3, [pc, #196]	; (8005370 <mem_malloc+0x130>)
 80052aa:	681b      	ldr	r3, [r3, #0]
 80052ac:	4298      	cmp	r0, r3
 80052ae:	d001      	beq.n	80052b4 <mem_malloc+0x74>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 80052b0:	3008      	adds	r0, #8
 80052b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
          while (cur->used && cur != ram_end) {
 80052b4:	7903      	ldrb	r3, [r0, #4]
 80052b6:	b183      	cbz	r3, 80052da <mem_malloc+0x9a>
 80052b8:	4b2f      	ldr	r3, [pc, #188]	; (8005378 <mem_malloc+0x138>)
 80052ba:	6819      	ldr	r1, [r3, #0]
 80052bc:	4288      	cmp	r0, r1
 80052be:	d00e      	beq.n	80052de <mem_malloc+0x9e>
            cur = (struct mem *)(void *)&ram[cur->next];
 80052c0:	4b2a      	ldr	r3, [pc, #168]	; (800536c <mem_malloc+0x12c>)
 80052c2:	681c      	ldr	r4, [r3, #0]
 80052c4:	4603      	mov	r3, r0
 80052c6:	881b      	ldrh	r3, [r3, #0]
 80052c8:	4423      	add	r3, r4
          while (cur->used && cur != ram_end) {
 80052ca:	791a      	ldrb	r2, [r3, #4]
 80052cc:	b112      	cbz	r2, 80052d4 <mem_malloc+0x94>
 80052ce:	428b      	cmp	r3, r1
 80052d0:	d1f9      	bne.n	80052c6 <mem_malloc+0x86>
            cur = (struct mem *)(void *)&ram[cur->next];
 80052d2:	460b      	mov	r3, r1
          lfree = cur;
 80052d4:	4a26      	ldr	r2, [pc, #152]	; (8005370 <mem_malloc+0x130>)
 80052d6:	6013      	str	r3, [r2, #0]
 80052d8:	e7ea      	b.n	80052b0 <mem_malloc+0x70>
      mem = (struct mem *)(void *)&ram[ptr];
 80052da:	4603      	mov	r3, r0
 80052dc:	e7fa      	b.n	80052d4 <mem_malloc+0x94>
 80052de:	4603      	mov	r3, r0
 80052e0:	e7f8      	b.n	80052d4 <mem_malloc+0x94>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 80052e2:	8803      	ldrh	r3, [r0, #0]
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 80052e4:	428b      	cmp	r3, r1
 80052e6:	da35      	bge.n	8005354 <mem_malloc+0x114>
      mem = (struct mem *)(void *)&ram[ptr];
 80052e8:	eb0c 0003 	add.w	r0, ip, r3
      if ((!mem->used) &&
 80052ec:	7902      	ldrb	r2, [r0, #4]
 80052ee:	2a00      	cmp	r2, #0
 80052f0:	d1f7      	bne.n	80052e2 <mem_malloc+0xa2>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 80052f2:	f83c 4003 	ldrh.w	r4, [ip, r3]
 80052f6:	1af2      	subs	r2, r6, r3
 80052f8:	4422      	add	r2, r4
 80052fa:	462f      	mov	r7, r5
      if ((!mem->used) &&
 80052fc:	4572      	cmp	r2, lr
 80052fe:	d3f0      	bcc.n	80052e2 <mem_malloc+0xa2>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 8005300:	3714      	adds	r7, #20
 8005302:	42ba      	cmp	r2, r7
 8005304:	d3bf      	bcc.n	8005286 <mem_malloc+0x46>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 8005306:	f10e 0208 	add.w	r2, lr, #8
 800530a:	441a      	add	r2, r3
 800530c:	b292      	uxth	r2, r2
          mem2 = (struct mem *)(void *)&ram[ptr2];
 800530e:	eb0c 0102 	add.w	r1, ip, r2
          mem2->used = 0;
 8005312:	2400      	movs	r4, #0
 8005314:	710c      	strb	r4, [r1, #4]
          mem2->next = mem->next;
 8005316:	8804      	ldrh	r4, [r0, #0]
 8005318:	f82c 4002 	strh.w	r4, [ip, r2]
          mem2->prev = ptr;
 800531c:	804b      	strh	r3, [r1, #2]
          mem->next = ptr2;
 800531e:	8002      	strh	r2, [r0, #0]
          mem->used = 1;
 8005320:	2301      	movs	r3, #1
 8005322:	7103      	strb	r3, [r0, #4]
          if (mem2->next != MEM_SIZE_ALIGNED) {
 8005324:	f83c 3002 	ldrh.w	r3, [ip, r2]
 8005328:	f242 7110 	movw	r1, #10000	; 0x2710
 800532c:	428b      	cmp	r3, r1
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 800532e:	bf1c      	itt	ne
 8005330:	4463      	addne	r3, ip
 8005332:	805a      	strhne	r2, [r3, #2]
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
 8005334:	4a0f      	ldr	r2, [pc, #60]	; (8005374 <mem_malloc+0x134>)
 8005336:	f8b2 30aa 	ldrh.w	r3, [r2, #170]	; 0xaa
 800533a:	3308      	adds	r3, #8
 800533c:	4473      	add	r3, lr
 800533e:	b29b      	uxth	r3, r3
 8005340:	f8a2 30aa 	strh.w	r3, [r2, #170]	; 0xaa
 8005344:	f8b2 20ac 	ldrh.w	r2, [r2, #172]	; 0xac
 8005348:	429a      	cmp	r2, r3
 800534a:	d2ad      	bcs.n	80052a8 <mem_malloc+0x68>
 800534c:	4a09      	ldr	r2, [pc, #36]	; (8005374 <mem_malloc+0x134>)
 800534e:	f8a2 30ac 	strh.w	r3, [r2, #172]	; 0xac
 8005352:	e7a9      	b.n	80052a8 <mem_malloc+0x68>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
 8005354:	4a07      	ldr	r2, [pc, #28]	; (8005374 <mem_malloc+0x134>)
 8005356:	f8b2 30ae 	ldrh.w	r3, [r2, #174]	; 0xae
 800535a:	3301      	adds	r3, #1
 800535c:	f8a2 30ae 	strh.w	r3, [r2, #174]	; 0xae
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
 8005360:	2000      	movs	r0, #0
 8005362:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NULL;
 8005364:	2000      	movs	r0, #0
 8005366:	4770      	bx	lr
    return NULL;
 8005368:	2000      	movs	r0, #0
}
 800536a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800536c:	20000898 	.word	0x20000898
 8005370:	20000894 	.word	0x20000894
 8005374:	2000aac4 	.word	0x2000aac4
 8005378:	2000089c 	.word	0x2000089c

0800537c <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 800537c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005380:	4b21      	ldr	r3, [pc, #132]	; (8005408 <memp_init+0x8c>)
 8005382:	f8df c090 	ldr.w	ip, [pc, #144]	; 8005414 <memp_init+0x98>
 8005386:	f103 0464 	add.w	r4, r3, #100	; 0x64
 800538a:	4661      	mov	r1, ip
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    MEMP_STATS_AVAIL(used, i, 0);
 800538c:	2200      	movs	r2, #0
 800538e:	f8a3 20b4 	strh.w	r2, [r3, #180]	; 0xb4
    MEMP_STATS_AVAIL(max, i, 0);
 8005392:	f8a3 20b6 	strh.w	r2, [r3, #182]	; 0xb6
    MEMP_STATS_AVAIL(err, i, 0);
 8005396:	f8a3 20b8 	strh.w	r2, [r3, #184]	; 0xb8
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
 800539a:	f831 0b02 	ldrh.w	r0, [r1], #2
 800539e:	f8a3 00b2 	strh.w	r0, [r3, #178]	; 0xb2
 80053a2:	330a      	adds	r3, #10
  for (i = 0; i < MEMP_MAX; ++i) {
 80053a4:	42a3      	cmp	r3, r4
 80053a6:	d1f2      	bne.n	800538e <memp_init+0x12>
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
 80053a8:	4f18      	ldr	r7, [pc, #96]	; (800540c <memp_init+0x90>)
 80053aa:	f027 0703 	bic.w	r7, r7, #3
 80053ae:	4e18      	ldr	r6, [pc, #96]	; (8005410 <memp_init+0x94>)
 80053b0:	f8df e064 	ldr.w	lr, [pc, #100]	; 8005418 <memp_init+0x9c>
 80053b4:	f106 0a28 	add.w	sl, r6, #40	; 0x28
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
 80053b8:	f04f 0900 	mov.w	r9, #0
 80053bc:	e015      	b.n	80053ea <memp_init+0x6e>
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 80053be:	4603      	mov	r3, r0
      memp->next = memp_tab[i];
 80053c0:	6019      	str	r1, [r3, #0]
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 80053c2:	1958      	adds	r0, r3, r5
 80053c4:	3201      	adds	r2, #1
      memp_tab[i] = memp;
 80053c6:	4619      	mov	r1, r3
    for (j = 0; j < memp_num[i]; ++j) {
 80053c8:	b293      	uxth	r3, r2
 80053ca:	42a3      	cmp	r3, r4
 80053cc:	d3f7      	bcc.n	80053be <memp_init+0x42>
 80053ce:	3c01      	subs	r4, #1
 80053d0:	b2a4      	uxth	r4, r4
 80053d2:	fb04 5305 	mla	r3, r4, r5, r5
 80053d6:	fb04 7405 	mla	r4, r4, r5, r7
 80053da:	f8c8 4000 	str.w	r4, [r8]
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 80053de:	441f      	add	r7, r3
 80053e0:	3604      	adds	r6, #4
 80053e2:	f10e 0e02 	add.w	lr, lr, #2
  for (i = 0; i < MEMP_MAX; ++i) {
 80053e6:	4556      	cmp	r6, sl
 80053e8:	d00c      	beq.n	8005404 <memp_init+0x88>
 80053ea:	46b0      	mov	r8, r6
    memp_tab[i] = NULL;
 80053ec:	f8c6 9000 	str.w	r9, [r6]
    for (j = 0; j < memp_num[i]; ++j) {
 80053f0:	f83c 4b02 	ldrh.w	r4, [ip], #2
 80053f4:	2c00      	cmp	r4, #0
 80053f6:	d0f3      	beq.n	80053e0 <memp_init+0x64>
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 80053f8:	f8be 5000 	ldrh.w	r5, [lr]
 80053fc:	463b      	mov	r3, r7
 80053fe:	2200      	movs	r2, #0
 8005400:	4611      	mov	r1, r2
 8005402:	e7dd      	b.n	80053c0 <memp_init+0x44>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
 8005404:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005408:	2000aac4 	.word	0x2000aac4
 800540c:	200008a3 	.word	0x200008a3
 8005410:	20007164 	.word	0x20007164
 8005414:	08008fe4 	.word	0x08008fe4
 8005418:	08008ff8 	.word	0x08008ff8

0800541c <memp_malloc>:
#endif
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 800541c:	2809      	cmp	r0, #9
 800541e:	d82a      	bhi.n	8005476 <memp_malloc+0x5a>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
 8005420:	4b17      	ldr	r3, [pc, #92]	; (8005480 <memp_malloc+0x64>)
 8005422:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
  
  if (memp != NULL) {
 8005426:	b1d2      	cbz	r2, 800545e <memp_malloc+0x42>
    memp_tab[type] = memp->next;
 8005428:	6811      	ldr	r1, [r2, #0]
 800542a:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
 800542e:	eb00 0180 	add.w	r1, r0, r0, lsl #2
 8005432:	4b14      	ldr	r3, [pc, #80]	; (8005484 <memp_malloc+0x68>)
 8005434:	eb03 0141 	add.w	r1, r3, r1, lsl #1
 8005438:	f8b1 30b4 	ldrh.w	r3, [r1, #180]	; 0xb4
 800543c:	3301      	adds	r3, #1
 800543e:	b29b      	uxth	r3, r3
 8005440:	f8a1 30b4 	strh.w	r3, [r1, #180]	; 0xb4
 8005444:	f8b1 10b6 	ldrh.w	r1, [r1, #182]	; 0xb6
 8005448:	4299      	cmp	r1, r3
 800544a:	d216      	bcs.n	800547a <memp_malloc+0x5e>
 800544c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8005450:	490c      	ldr	r1, [pc, #48]	; (8005484 <memp_malloc+0x68>)
 8005452:	eb01 0040 	add.w	r0, r1, r0, lsl #1
 8005456:	f8a0 30b6 	strh.w	r3, [r0, #182]	; 0xb6
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
 800545a:	4610      	mov	r0, r2
 800545c:	4770      	bx	lr
    MEMP_STATS_INC(err, type);
 800545e:	4b09      	ldr	r3, [pc, #36]	; (8005484 <memp_malloc+0x68>)
 8005460:	0082      	lsls	r2, r0, #2
 8005462:	1811      	adds	r1, r2, r0
 8005464:	eb03 0141 	add.w	r1, r3, r1, lsl #1
 8005468:	f8b1 30b8 	ldrh.w	r3, [r1, #184]	; 0xb8
 800546c:	3301      	adds	r3, #1
 800546e:	f8a1 30b8 	strh.w	r3, [r1, #184]	; 0xb8
  return memp;
 8005472:	2000      	movs	r0, #0
 8005474:	4770      	bx	lr
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 8005476:	2000      	movs	r0, #0
 8005478:	4770      	bx	lr
  return memp;
 800547a:	4610      	mov	r0, r2
}
 800547c:	4770      	bx	lr
 800547e:	bf00      	nop
 8005480:	20007164 	.word	0x20007164
 8005484:	2000aac4 	.word	0x2000aac4

08005488 <memp_free>:
memp_free(memp_t type, void *mem)
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
 8005488:	b191      	cbz	r1, 80054b0 <memp_free+0x28>
{
 800548a:	b410      	push	{r4}
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
 800548c:	eb00 0280 	add.w	r2, r0, r0, lsl #2
 8005490:	4b08      	ldr	r3, [pc, #32]	; (80054b4 <memp_free+0x2c>)
 8005492:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 8005496:	f8b3 20b4 	ldrh.w	r2, [r3, #180]	; 0xb4
 800549a:	3a01      	subs	r2, #1
 800549c:	f8a3 20b4 	strh.w	r2, [r3, #180]	; 0xb4
  
  memp->next = memp_tab[type]; 
 80054a0:	4b05      	ldr	r3, [pc, #20]	; (80054b8 <memp_free+0x30>)
 80054a2:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 80054a6:	600a      	str	r2, [r1, #0]
  memp_tab[type] = memp;
 80054a8:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
 80054ac:	f85d 4b04 	ldr.w	r4, [sp], #4
 80054b0:	4770      	bx	lr
 80054b2:	bf00      	nop
 80054b4:	2000aac4 	.word	0x2000aac4
 80054b8:	20007164 	.word	0x20007164

080054bc <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
 80054bc:	4770      	bx	lr
	...

080054c0 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
 80054c0:	b570      	push	{r4, r5, r6, lr}
 80054c2:	4604      	mov	r4, r0
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
 80054c4:	2900      	cmp	r1, #0
 80054c6:	d027      	beq.n	8005518 <netif_set_ipaddr+0x58>
 80054c8:	460d      	mov	r5, r1
 80054ca:	680a      	ldr	r2, [r1, #0]
 80054cc:	6843      	ldr	r3, [r0, #4]
 80054ce:	429a      	cmp	r2, r3
 80054d0:	d005      	beq.n	80054de <netif_set_ipaddr+0x1e>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 80054d2:	4b12      	ldr	r3, [pc, #72]	; (800551c <netif_set_ipaddr+0x5c>)
 80054d4:	6818      	ldr	r0, [r3, #0]
    while (pcb != NULL) {
 80054d6:	b958      	cbnz	r0, 80054f0 <netif_set_ipaddr+0x30>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80054d8:	4b11      	ldr	r3, [pc, #68]	; (8005520 <netif_set_ipaddr+0x60>)
 80054da:	681b      	ldr	r3, [r3, #0]
 80054dc:	b98b      	cbnz	r3, 8005502 <netif_set_ipaddr+0x42>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 80054de:	682b      	ldr	r3, [r5, #0]
 80054e0:	6063      	str	r3, [r4, #4]
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->ip_addr),
    ip4_addr2_16(&netif->ip_addr),
    ip4_addr3_16(&netif->ip_addr),
    ip4_addr4_16(&netif->ip_addr)));
}
 80054e2:	bd70      	pop	{r4, r5, r6, pc}
        struct tcp_pcb *next = pcb->next;
 80054e4:	68c6      	ldr	r6, [r0, #12]
        tcp_abort(pcb);
 80054e6:	f000 feef 	bl	80062c8 <tcp_abort>
        pcb = next;
 80054ea:	4630      	mov	r0, r6
    while (pcb != NULL) {
 80054ec:	2800      	cmp	r0, #0
 80054ee:	d0f3      	beq.n	80054d8 <netif_set_ipaddr+0x18>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 80054f0:	6802      	ldr	r2, [r0, #0]
 80054f2:	6863      	ldr	r3, [r4, #4]
 80054f4:	429a      	cmp	r2, r3
 80054f6:	d0f5      	beq.n	80054e4 <netif_set_ipaddr+0x24>
        pcb = pcb->next;
 80054f8:	68c0      	ldr	r0, [r0, #12]
 80054fa:	e7f7      	b.n	80054ec <netif_set_ipaddr+0x2c>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80054fc:	68db      	ldr	r3, [r3, #12]
 80054fe:	2b00      	cmp	r3, #0
 8005500:	d0ed      	beq.n	80054de <netif_set_ipaddr+0x1e>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 8005502:	2b00      	cmp	r3, #0
 8005504:	d0fa      	beq.n	80054fc <netif_set_ipaddr+0x3c>
 8005506:	681a      	ldr	r2, [r3, #0]
 8005508:	2a00      	cmp	r2, #0
 800550a:	d0f7      	beq.n	80054fc <netif_set_ipaddr+0x3c>
 800550c:	6861      	ldr	r1, [r4, #4]
 800550e:	428a      	cmp	r2, r1
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 8005510:	bf04      	itt	eq
 8005512:	682a      	ldreq	r2, [r5, #0]
 8005514:	601a      	streq	r2, [r3, #0]
 8005516:	e7f1      	b.n	80054fc <netif_set_ipaddr+0x3c>
  ip_addr_set(&(netif->ip_addr), ipaddr);
 8005518:	2300      	movs	r3, #0
 800551a:	e7e1      	b.n	80054e0 <netif_set_ipaddr+0x20>
 800551c:	2000abe0 	.word	0x2000abe0
 8005520:	2000abe8 	.word	0x2000abe8

08005524 <netif_set_addr>:
{
 8005524:	b570      	push	{r4, r5, r6, lr}
 8005526:	4604      	mov	r4, r0
 8005528:	4616      	mov	r6, r2
 800552a:	461d      	mov	r5, r3
  netif_set_ipaddr(netif, ipaddr);
 800552c:	f7ff ffc8 	bl	80054c0 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 8005530:	b12e      	cbz	r6, 800553e <netif_set_addr+0x1a>
 8005532:	6833      	ldr	r3, [r6, #0]
 8005534:	60a3      	str	r3, [r4, #8]
  ip_addr_set(&(netif->gw), gw);
 8005536:	b125      	cbz	r5, 8005542 <netif_set_addr+0x1e>
 8005538:	682b      	ldr	r3, [r5, #0]
 800553a:	60e3      	str	r3, [r4, #12]
 800553c:	bd70      	pop	{r4, r5, r6, pc}
  ip_addr_set(&(netif->netmask), netmask);
 800553e:	2300      	movs	r3, #0
 8005540:	e7f8      	b.n	8005534 <netif_set_addr+0x10>
  ip_addr_set(&(netif->gw), gw);
 8005542:	2300      	movs	r3, #0
 8005544:	e7f9      	b.n	800553a <netif_set_addr+0x16>
	...

08005548 <netif_add>:
{
 8005548:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800554a:	4604      	mov	r4, r0
  ip_addr_set_zero(&netif->ip_addr);
 800554c:	2500      	movs	r5, #0
 800554e:	6045      	str	r5, [r0, #4]
  ip_addr_set_zero(&netif->netmask);
 8005550:	6085      	str	r5, [r0, #8]
  ip_addr_set_zero(&netif->gw);
 8005552:	60c5      	str	r5, [r0, #12]
  netif->flags = 0;
 8005554:	f880 5029 	strb.w	r5, [r0, #41]	; 0x29
  netif->state = state;
 8005558:	9d06      	ldr	r5, [sp, #24]
 800555a:	61c5      	str	r5, [r0, #28]
  netif->num = netif_num++;
 800555c:	4e0a      	ldr	r6, [pc, #40]	; (8005588 <netif_add+0x40>)
 800555e:	7835      	ldrb	r5, [r6, #0]
 8005560:	1c6f      	adds	r7, r5, #1
 8005562:	7037      	strb	r7, [r6, #0]
 8005564:	f880 502c 	strb.w	r5, [r0, #44]	; 0x2c
  netif->input = input;
 8005568:	9d08      	ldr	r5, [sp, #32]
 800556a:	6105      	str	r5, [r0, #16]
  netif_set_addr(netif, ipaddr, netmask, gw);
 800556c:	f7ff ffda 	bl	8005524 <netif_set_addr>
  if (init(netif) != ERR_OK) {
 8005570:	4620      	mov	r0, r4
 8005572:	9b07      	ldr	r3, [sp, #28]
 8005574:	4798      	blx	r3
 8005576:	b928      	cbnz	r0, 8005584 <netif_add+0x3c>
  netif->next = netif_list;
 8005578:	4b04      	ldr	r3, [pc, #16]	; (800558c <netif_add+0x44>)
 800557a:	681a      	ldr	r2, [r3, #0]
 800557c:	6022      	str	r2, [r4, #0]
  netif_list = netif;
 800557e:	601c      	str	r4, [r3, #0]
  return netif;
 8005580:	4620      	mov	r0, r4
 8005582:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return NULL;
 8005584:	2000      	movs	r0, #0
}
 8005586:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005588:	2000718c 	.word	0x2000718c
 800558c:	2000aab8 	.word	0x2000aab8

08005590 <netif_set_default>:
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
 8005590:	4b01      	ldr	r3, [pc, #4]	; (8005598 <netif_set_default+0x8>)
 8005592:	6018      	str	r0, [r3, #0]
 8005594:	4770      	bx	lr
 8005596:	bf00      	nop
 8005598:	2000aabc 	.word	0x2000aabc

0800559c <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf*
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
 800559c:	b470      	push	{r4, r5, r6}
 800559e:	9c03      	ldr	r4, [sp, #12]
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (l) {
 80055a0:	2803      	cmp	r0, #3
 80055a2:	d826      	bhi.n	80055f2 <pbuf_alloced_custom+0x56>
 80055a4:	e8df f000 	tbb	[pc, r0]
 80055a8:	06040208 	.word	0x06040208
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    break;
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 80055ac:	2022      	movs	r0, #34	; 0x22
 80055ae:	e004      	b.n	80055ba <pbuf_alloced_custom+0x1e>
    break;
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
 80055b0:	200e      	movs	r0, #14
    break;
 80055b2:	e002      	b.n	80055ba <pbuf_alloced_custom+0x1e>
  case PBUF_RAW:
    offset = 0;
 80055b4:	2000      	movs	r0, #0
    break;
 80055b6:	e000      	b.n	80055ba <pbuf_alloced_custom+0x1e>
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 80055b8:	2036      	movs	r0, #54	; 0x36
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 80055ba:	3003      	adds	r0, #3
 80055bc:	f020 0503 	bic.w	r5, r0, #3
 80055c0:	440d      	add	r5, r1
 80055c2:	f8bd 6010 	ldrh.w	r6, [sp, #16]
 80055c6:	42b5      	cmp	r5, r6
 80055c8:	dc15      	bgt.n	80055f6 <pbuf_alloced_custom+0x5a>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
  }

  p->pbuf.next = NULL;
 80055ca:	2500      	movs	r5, #0
 80055cc:	601d      	str	r5, [r3, #0]
  if (payload_mem != NULL) {
 80055ce:	b16c      	cbz	r4, 80055ec <pbuf_alloced_custom+0x50>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 80055d0:	f020 0003 	bic.w	r0, r0, #3
 80055d4:	4420      	add	r0, r4
 80055d6:	6058      	str	r0, [r3, #4]
  } else {
    p->pbuf.payload = NULL;
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 80055d8:	2002      	movs	r0, #2
 80055da:	7358      	strb	r0, [r3, #13]
  p->pbuf.len = p->pbuf.tot_len = length;
 80055dc:	8119      	strh	r1, [r3, #8]
 80055de:	8159      	strh	r1, [r3, #10]
  p->pbuf.type = type;
 80055e0:	731a      	strb	r2, [r3, #12]
  p->pbuf.ref = 1;
 80055e2:	2201      	movs	r2, #1
 80055e4:	81da      	strh	r2, [r3, #14]
  return &p->pbuf;
 80055e6:	4618      	mov	r0, r3
}
 80055e8:	bc70      	pop	{r4, r5, r6}
 80055ea:	4770      	bx	lr
    p->pbuf.payload = NULL;
 80055ec:	2000      	movs	r0, #0
 80055ee:	6058      	str	r0, [r3, #4]
 80055f0:	e7f2      	b.n	80055d8 <pbuf_alloced_custom+0x3c>
    return NULL;
 80055f2:	2000      	movs	r0, #0
 80055f4:	e7f8      	b.n	80055e8 <pbuf_alloced_custom+0x4c>
    return NULL;
 80055f6:	2000      	movs	r0, #0
 80055f8:	e7f6      	b.n	80055e8 <pbuf_alloced_custom+0x4c>

080055fa <pbuf_header>:
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
 80055fa:	2900      	cmp	r1, #0
 80055fc:	d033      	beq.n	8005666 <pbuf_header+0x6c>
 80055fe:	460b      	mov	r3, r1
 8005600:	2800      	cmp	r0, #0
 8005602:	d032      	beq.n	800566a <pbuf_header+0x70>
{
 8005604:	b410      	push	{r4}
    return 0;
  }
 
  if (header_size_increment < 0){
 8005606:	2900      	cmp	r1, #0
 8005608:	db0b      	blt.n	8005622 <pbuf_header+0x28>
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
 800560a:	b28c      	uxth	r4, r1
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 800560c:	7b02      	ldrb	r2, [r0, #12]
  /* remember current payload pointer */
  payload = p->payload;
 800560e:	6841      	ldr	r1, [r0, #4]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 8005610:	b172      	cbz	r2, 8005630 <pbuf_header+0x36>
 8005612:	2a03      	cmp	r2, #3
 8005614:	d00c      	beq.n	8005630 <pbuf_header+0x36>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 8005616:	3a01      	subs	r2, #1
 8005618:	b292      	uxth	r2, r2
 800561a:	2a01      	cmp	r2, #1
 800561c:	d919      	bls.n	8005652 <pbuf_header+0x58>
      return 1;
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
 800561e:	2001      	movs	r0, #1
 8005620:	e014      	b.n	800564c <pbuf_header+0x52>
    increment_magnitude = -header_size_increment;
 8005622:	424c      	negs	r4, r1
 8005624:	b2a4      	uxth	r4, r4
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8005626:	8942      	ldrh	r2, [r0, #10]
 8005628:	42a2      	cmp	r2, r4
 800562a:	d2ef      	bcs.n	800560c <pbuf_header+0x12>
 800562c:	2001      	movs	r0, #1
 800562e:	e00d      	b.n	800564c <pbuf_header+0x52>
    p->payload = (u8_t *)p->payload - header_size_increment;
 8005630:	1ac9      	subs	r1, r1, r3
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 8005632:	f100 0210 	add.w	r2, r0, #16
 8005636:	4291      	cmp	r1, r2
 8005638:	d319      	bcc.n	800566e <pbuf_header+0x74>
    p->payload = (u8_t *)p->payload - header_size_increment;
 800563a:	6041      	str	r1, [r0, #4]
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 800563c:	b29b      	uxth	r3, r3
 800563e:	8942      	ldrh	r2, [r0, #10]
 8005640:	441a      	add	r2, r3
 8005642:	8142      	strh	r2, [r0, #10]
  p->tot_len += header_size_increment;
 8005644:	8902      	ldrh	r2, [r0, #8]
 8005646:	4413      	add	r3, r2
 8005648:	8103      	strh	r3, [r0, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 800564a:	2000      	movs	r0, #0
}
 800564c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005650:	4770      	bx	lr
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8005652:	2b00      	cmp	r3, #0
 8005654:	db01      	blt.n	800565a <pbuf_header+0x60>
      return 1;
 8005656:	2001      	movs	r0, #1
 8005658:	e7f8      	b.n	800564c <pbuf_header+0x52>
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 800565a:	8942      	ldrh	r2, [r0, #10]
 800565c:	42a2      	cmp	r2, r4
 800565e:	d308      	bcc.n	8005672 <pbuf_header+0x78>
      p->payload = (u8_t *)p->payload - header_size_increment;
 8005660:	1ac9      	subs	r1, r1, r3
 8005662:	6041      	str	r1, [r0, #4]
 8005664:	e7ea      	b.n	800563c <pbuf_header+0x42>
    return 0;
 8005666:	2000      	movs	r0, #0
 8005668:	4770      	bx	lr
 800566a:	2000      	movs	r0, #0
 800566c:	4770      	bx	lr
      return 1;
 800566e:	2001      	movs	r0, #1
 8005670:	e7ec      	b.n	800564c <pbuf_header+0x52>
      return 1;
 8005672:	2001      	movs	r0, #1
 8005674:	e7ea      	b.n	800564c <pbuf_header+0x52>

08005676 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 8005676:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 8005678:	b340      	cbz	r0, 80056cc <pbuf_free+0x56>
 800567a:	4601      	mov	r1, r0
 800567c:	2400      	movs	r4, #0
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
 800567e:	2508      	movs	r5, #8
          memp_free(MEMP_PBUF_POOL, p);
 8005680:	2609      	movs	r6, #9
 8005682:	e006      	b.n	8005692 <pbuf_free+0x1c>
        pc->custom_free_function(p);
 8005684:	690b      	ldr	r3, [r1, #16]
 8005686:	4608      	mov	r0, r1
 8005688:	4798      	blx	r3
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
        }
      }
      count++;
 800568a:	3401      	adds	r4, #1
 800568c:	b2e4      	uxtb	r4, r4
      /* proceed to next pbuf */
      p = q;
 800568e:	4639      	mov	r1, r7
  while (p != NULL) {
 8005690:	b1ef      	cbz	r7, 80056ce <pbuf_free+0x58>
    ref = --(p->ref);
 8005692:	89cb      	ldrh	r3, [r1, #14]
 8005694:	3b01      	subs	r3, #1
 8005696:	b29b      	uxth	r3, r3
 8005698:	81cb      	strh	r3, [r1, #14]
    if (ref == 0) {
 800569a:	b9c3      	cbnz	r3, 80056ce <pbuf_free+0x58>
      q = p->next;
 800569c:	680f      	ldr	r7, [r1, #0]
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 800569e:	7b4b      	ldrb	r3, [r1, #13]
 80056a0:	f013 0f02 	tst.w	r3, #2
 80056a4:	d1ee      	bne.n	8005684 <pbuf_free+0xe>
      type = p->type;
 80056a6:	7b0b      	ldrb	r3, [r1, #12]
        if (type == PBUF_POOL) {
 80056a8:	2b03      	cmp	r3, #3
 80056aa:	d007      	beq.n	80056bc <pbuf_free+0x46>
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 80056ac:	3b01      	subs	r3, #1
 80056ae:	b29b      	uxth	r3, r3
 80056b0:	2b01      	cmp	r3, #1
 80056b2:	d907      	bls.n	80056c4 <pbuf_free+0x4e>
          mem_free(p);
 80056b4:	4608      	mov	r0, r1
 80056b6:	f7ff fce1 	bl	800507c <mem_free>
 80056ba:	e7e6      	b.n	800568a <pbuf_free+0x14>
          memp_free(MEMP_PBUF_POOL, p);
 80056bc:	4630      	mov	r0, r6
 80056be:	f7ff fee3 	bl	8005488 <memp_free>
 80056c2:	e7e2      	b.n	800568a <pbuf_free+0x14>
          memp_free(MEMP_PBUF, p);
 80056c4:	4628      	mov	r0, r5
 80056c6:	f7ff fedf 	bl	8005488 <memp_free>
 80056ca:	e7de      	b.n	800568a <pbuf_free+0x14>
    return 0;
 80056cc:	2400      	movs	r4, #0
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
 80056ce:	4620      	mov	r0, r4
 80056d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080056d4 <pbuf_alloc>:
{
 80056d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  switch (layer) {
 80056d8:	2803      	cmp	r0, #3
 80056da:	f200 808d 	bhi.w	80057f8 <pbuf_alloc+0x124>
 80056de:	e8df f000 	tbb	[pc, r0]
 80056e2:	0208      	.short	0x0208
 80056e4:	0604      	.short	0x0604
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 80056e6:	2422      	movs	r4, #34	; 0x22
 80056e8:	e004      	b.n	80056f4 <pbuf_alloc+0x20>
    offset = PBUF_LINK_HLEN;
 80056ea:	240e      	movs	r4, #14
    break;
 80056ec:	e002      	b.n	80056f4 <pbuf_alloc+0x20>
    offset = 0;
 80056ee:	2400      	movs	r4, #0
    break;
 80056f0:	e000      	b.n	80056f4 <pbuf_alloc+0x20>
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 80056f2:	2436      	movs	r4, #54	; 0x36
 80056f4:	4617      	mov	r7, r2
 80056f6:	460d      	mov	r5, r1
  switch (type) {
 80056f8:	2a03      	cmp	r2, #3
 80056fa:	d87f      	bhi.n	80057fc <pbuf_alloc+0x128>
 80056fc:	e8df f002 	tbb	[pc, r2]
 8005700:	026f6f51 	.word	0x026f6f51
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8005704:	2009      	movs	r0, #9
 8005706:	f7ff fe89 	bl	800541c <memp_malloc>
    if (p == NULL) {
 800570a:	4606      	mov	r6, r0
 800570c:	2800      	cmp	r0, #0
 800570e:	d03c      	beq.n	800578a <pbuf_alloc+0xb6>
    p->type = type;
 8005710:	2303      	movs	r3, #3
 8005712:	7303      	strb	r3, [r0, #12]
    p->next = NULL;
 8005714:	2300      	movs	r3, #0
 8005716:	6003      	str	r3, [r0, #0]
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8005718:	1903      	adds	r3, r0, r4
 800571a:	3313      	adds	r3, #19
 800571c:	f023 0303 	bic.w	r3, r3, #3
 8005720:	6043      	str	r3, [r0, #4]
    p->tot_len = length;
 8005722:	8105      	strh	r5, [r0, #8]
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8005724:	3403      	adds	r4, #3
 8005726:	f024 0403 	bic.w	r4, r4, #3
 800572a:	f5c4 64bd 	rsb	r4, r4, #1512	; 0x5e8
 800572e:	3404      	adds	r4, #4
 8005730:	42ac      	cmp	r4, r5
 8005732:	bfa8      	it	ge
 8005734:	462c      	movge	r4, r5
 8005736:	8144      	strh	r4, [r0, #10]
    p->ref = 1;
 8005738:	2301      	movs	r3, #1
 800573a:	81c3      	strh	r3, [r0, #14]
    rem_len = length - p->len;
 800573c:	b2a4      	uxth	r4, r4
 800573e:	1b2d      	subs	r5, r5, r4
    while (rem_len > 0) {
 8005740:	2d00      	cmp	r5, #0
 8005742:	dd45      	ble.n	80057d0 <pbuf_alloc+0xfc>
 8005744:	4682      	mov	sl, r0
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8005746:	f04f 0809 	mov.w	r8, #9
      q->type = type;
 800574a:	f04f 0903 	mov.w	r9, #3
      q->flags = 0;
 800574e:	2700      	movs	r7, #0
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8005750:	4640      	mov	r0, r8
 8005752:	f7ff fe63 	bl	800541c <memp_malloc>
      if (q == NULL) {
 8005756:	4604      	mov	r4, r0
 8005758:	b1d8      	cbz	r0, 8005792 <pbuf_alloc+0xbe>
      q->type = type;
 800575a:	f880 900c 	strb.w	r9, [r0, #12]
      q->flags = 0;
 800575e:	7347      	strb	r7, [r0, #13]
      q->next = NULL;
 8005760:	6007      	str	r7, [r0, #0]
      r->next = q;
 8005762:	f8ca 0000 	str.w	r0, [sl]
      q->tot_len = (u16_t)rem_len;
 8005766:	b2ab      	uxth	r3, r5
 8005768:	8103      	strh	r3, [r0, #8]
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 800576a:	f240 52ec 	movw	r2, #1516	; 0x5ec
 800576e:	4293      	cmp	r3, r2
 8005770:	bf28      	it	cs
 8005772:	4613      	movcs	r3, r2
 8005774:	8143      	strh	r3, [r0, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 8005776:	f100 0210 	add.w	r2, r0, #16
 800577a:	6042      	str	r2, [r0, #4]
      q->ref = 1;
 800577c:	2201      	movs	r2, #1
 800577e:	81c2      	strh	r2, [r0, #14]
      rem_len -= q->len;
 8005780:	1aed      	subs	r5, r5, r3
      r = q;
 8005782:	4682      	mov	sl, r0
    while (rem_len > 0) {
 8005784:	2d00      	cmp	r5, #0
 8005786:	dce3      	bgt.n	8005750 <pbuf_alloc+0x7c>
 8005788:	e022      	b.n	80057d0 <pbuf_alloc+0xfc>
  pbuf_free_ooseq_pending = 1;
 800578a:	2201      	movs	r2, #1
 800578c:	4b1c      	ldr	r3, [pc, #112]	; (8005800 <pbuf_alloc+0x12c>)
 800578e:	701a      	strb	r2, [r3, #0]
 8005790:	e022      	b.n	80057d8 <pbuf_alloc+0x104>
 8005792:	2201      	movs	r2, #1
 8005794:	4b1a      	ldr	r3, [pc, #104]	; (8005800 <pbuf_alloc+0x12c>)
 8005796:	701a      	strb	r2, [r3, #0]
        pbuf_free(p);
 8005798:	4630      	mov	r0, r6
 800579a:	f7ff ff6c 	bl	8005676 <pbuf_free>
        return NULL;
 800579e:	4626      	mov	r6, r4
 80057a0:	e01a      	b.n	80057d8 <pbuf_alloc+0x104>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
 80057a2:	f104 0013 	add.w	r0, r4, #19
 80057a6:	f020 0003 	bic.w	r0, r0, #3
 80057aa:	1ccb      	adds	r3, r1, #3
 80057ac:	f023 0303 	bic.w	r3, r3, #3
 80057b0:	4418      	add	r0, r3
 80057b2:	b280      	uxth	r0, r0
 80057b4:	f7ff fd44 	bl	8005240 <mem_malloc>
    if (p == NULL) {
 80057b8:	4606      	mov	r6, r0
 80057ba:	b168      	cbz	r0, 80057d8 <pbuf_alloc+0x104>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 80057bc:	4404      	add	r4, r0
 80057be:	3413      	adds	r4, #19
 80057c0:	f024 0403 	bic.w	r4, r4, #3
 80057c4:	6044      	str	r4, [r0, #4]
    p->len = p->tot_len = length;
 80057c6:	8105      	strh	r5, [r0, #8]
 80057c8:	8145      	strh	r5, [r0, #10]
    p->next = NULL;
 80057ca:	2300      	movs	r3, #0
 80057cc:	6003      	str	r3, [r0, #0]
    p->type = type;
 80057ce:	7303      	strb	r3, [r0, #12]
  p->ref = 1;
 80057d0:	2301      	movs	r3, #1
 80057d2:	81f3      	strh	r3, [r6, #14]
  p->flags = 0;
 80057d4:	2300      	movs	r3, #0
 80057d6:	7373      	strb	r3, [r6, #13]
}
 80057d8:	4630      	mov	r0, r6
 80057da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 80057de:	2008      	movs	r0, #8
 80057e0:	f7ff fe1c 	bl	800541c <memp_malloc>
    if (p == NULL) {
 80057e4:	4606      	mov	r6, r0
 80057e6:	2800      	cmp	r0, #0
 80057e8:	d0f6      	beq.n	80057d8 <pbuf_alloc+0x104>
    p->payload = NULL;
 80057ea:	2300      	movs	r3, #0
 80057ec:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
 80057ee:	8105      	strh	r5, [r0, #8]
 80057f0:	8145      	strh	r5, [r0, #10]
    p->next = NULL;
 80057f2:	6003      	str	r3, [r0, #0]
    p->type = type;
 80057f4:	7307      	strb	r7, [r0, #12]
    break;
 80057f6:	e7eb      	b.n	80057d0 <pbuf_alloc+0xfc>
    return NULL;
 80057f8:	2600      	movs	r6, #0
 80057fa:	e7ed      	b.n	80057d8 <pbuf_alloc+0x104>
    return NULL;
 80057fc:	2600      	movs	r6, #0
 80057fe:	e7eb      	b.n	80057d8 <pbuf_alloc+0x104>
 8005800:	2000aac0 	.word	0x2000aac0

08005804 <pbuf_realloc>:
  if (new_len >= p->tot_len) {
 8005804:	8902      	ldrh	r2, [r0, #8]
 8005806:	428a      	cmp	r2, r1
 8005808:	d926      	bls.n	8005858 <pbuf_realloc+0x54>
{
 800580a:	b538      	push	{r3, r4, r5, lr}
 800580c:	4604      	mov	r4, r0
  while (rem_len > q->len) {
 800580e:	8943      	ldrh	r3, [r0, #10]
 8005810:	4299      	cmp	r1, r3
 8005812:	d91f      	bls.n	8005854 <pbuf_realloc+0x50>
 8005814:	460d      	mov	r5, r1
    q->tot_len += (u16_t)grow;
 8005816:	1a89      	subs	r1, r1, r2
    rem_len -= q->len;
 8005818:	1aeb      	subs	r3, r5, r3
 800581a:	b29d      	uxth	r5, r3
    q->tot_len += (u16_t)grow;
 800581c:	8923      	ldrh	r3, [r4, #8]
 800581e:	440b      	add	r3, r1
 8005820:	8123      	strh	r3, [r4, #8]
    q = q->next;
 8005822:	6824      	ldr	r4, [r4, #0]
  while (rem_len > q->len) {
 8005824:	8963      	ldrh	r3, [r4, #10]
 8005826:	42ab      	cmp	r3, r5
 8005828:	d3f6      	bcc.n	8005818 <pbuf_realloc+0x14>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 800582a:	7b22      	ldrb	r2, [r4, #12]
 800582c:	b94a      	cbnz	r2, 8005842 <pbuf_realloc+0x3e>
 800582e:	429d      	cmp	r5, r3
 8005830:	d007      	beq.n	8005842 <pbuf_realloc+0x3e>
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 8005832:	6863      	ldr	r3, [r4, #4]
 8005834:	1b1b      	subs	r3, r3, r4
 8005836:	18e9      	adds	r1, r5, r3
 8005838:	b289      	uxth	r1, r1
 800583a:	4620      	mov	r0, r4
 800583c:	f7ff fc7a 	bl	8005134 <mem_trim>
 8005840:	4604      	mov	r4, r0
  q->len = rem_len;
 8005842:	8165      	strh	r5, [r4, #10]
  q->tot_len = q->len;
 8005844:	8125      	strh	r5, [r4, #8]
  if (q->next != NULL) {
 8005846:	6820      	ldr	r0, [r4, #0]
 8005848:	b108      	cbz	r0, 800584e <pbuf_realloc+0x4a>
    pbuf_free(q->next);
 800584a:	f7ff ff14 	bl	8005676 <pbuf_free>
  q->next = NULL;
 800584e:	2300      	movs	r3, #0
 8005850:	6023      	str	r3, [r4, #0]
 8005852:	bd38      	pop	{r3, r4, r5, pc}
  while (rem_len > q->len) {
 8005854:	460d      	mov	r5, r1
 8005856:	e7e8      	b.n	800582a <pbuf_realloc+0x26>
 8005858:	4770      	bx	lr

0800585a <pbuf_clen>:
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 800585a:	4603      	mov	r3, r0
 800585c:	b130      	cbz	r0, 800586c <pbuf_clen+0x12>
 800585e:	2000      	movs	r0, #0
    ++len;
 8005860:	3001      	adds	r0, #1
 8005862:	b2c0      	uxtb	r0, r0
    p = p->next;
 8005864:	681b      	ldr	r3, [r3, #0]
  while (p != NULL) {
 8005866:	2b00      	cmp	r3, #0
 8005868:	d1fa      	bne.n	8005860 <pbuf_clen+0x6>
 800586a:	4770      	bx	lr
  len = 0;
 800586c:	2000      	movs	r0, #0
  }
  return len;
}
 800586e:	4770      	bx	lr

08005870 <pbuf_ref>:
void
pbuf_ref(struct pbuf *p)
{
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 8005870:	b110      	cbz	r0, 8005878 <pbuf_ref+0x8>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
 8005872:	89c3      	ldrh	r3, [r0, #14]
 8005874:	3301      	adds	r3, #1
 8005876:	81c3      	strh	r3, [r0, #14]
 8005878:	4770      	bx	lr

0800587a <pbuf_cat>:
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 800587a:	b1b0      	cbz	r0, 80058aa <pbuf_cat+0x30>
{
 800587c:	b410      	push	{r4}
 800587e:	4604      	mov	r4, r0
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 8005880:	b189      	cbz	r1, 80058a6 <pbuf_cat+0x2c>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8005882:	6802      	ldr	r2, [r0, #0]
 8005884:	b912      	cbnz	r2, 800588c <pbuf_cat+0x12>
 8005886:	4602      	mov	r2, r0
 8005888:	e008      	b.n	800589c <pbuf_cat+0x22>
 800588a:	461a      	mov	r2, r3
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 800588c:	8923      	ldrh	r3, [r4, #8]
 800588e:	8908      	ldrh	r0, [r1, #8]
 8005890:	4403      	add	r3, r0
 8005892:	8123      	strh	r3, [r4, #8]
  for (p = h; p->next != NULL; p = p->next) {
 8005894:	6813      	ldr	r3, [r2, #0]
 8005896:	4614      	mov	r4, r2
 8005898:	2b00      	cmp	r3, #0
 800589a:	d1f6      	bne.n	800588a <pbuf_cat+0x10>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 800589c:	8913      	ldrh	r3, [r2, #8]
 800589e:	8908      	ldrh	r0, [r1, #8]
 80058a0:	4403      	add	r3, r0
 80058a2:	8113      	strh	r3, [r2, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 80058a4:	6011      	str	r1, [r2, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 80058a6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80058aa:	4770      	bx	lr

080058ac <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 80058ac:	b510      	push	{r4, lr}
 80058ae:	460c      	mov	r4, r1
  pbuf_cat(h, t);
 80058b0:	f7ff ffe3 	bl	800587a <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 80058b4:	4620      	mov	r0, r4
 80058b6:	f7ff ffdb 	bl	8005870 <pbuf_ref>
 80058ba:	bd10      	pop	{r4, pc}

080058bc <pbuf_copy>:

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 80058bc:	b310      	cbz	r0, 8005904 <pbuf_copy+0x48>
{
 80058be:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80058c2:	460e      	mov	r6, r1
 80058c4:	4607      	mov	r7, r0
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 80058c6:	b301      	cbz	r1, 800590a <pbuf_copy+0x4e>
 80058c8:	8902      	ldrh	r2, [r0, #8]
 80058ca:	890b      	ldrh	r3, [r1, #8]
 80058cc:	429a      	cmp	r2, r3
 80058ce:	d320      	bcc.n	8005912 <pbuf_copy+0x56>
 80058d0:	f04f 0900 	mov.w	r9, #0
 80058d4:	464d      	mov	r5, r9
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
 80058d6:	46c8      	mov	r8, r9
 80058d8:	e02e      	b.n	8005938 <pbuf_copy+0x7c>
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
 80058da:	683f      	ldr	r7, [r7, #0]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 80058dc:	b10f      	cbz	r7, 80058e2 <pbuf_copy+0x26>
      offset_to = 0;
 80058de:	4645      	mov	r5, r8
 80058e0:	e049      	b.n	8005976 <pbuf_copy+0xba>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 80058e2:	2e00      	cmp	r6, #0
 80058e4:	bf14      	ite	ne
 80058e6:	f06f 000d 	mvnne.w	r0, #13
 80058ea:	2000      	moveq	r0, #0
 80058ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 80058f0:	6833      	ldr	r3, [r6, #0]
 80058f2:	2b00      	cmp	r3, #0
 80058f4:	d045      	beq.n	8005982 <pbuf_copy+0xc6>
 80058f6:	f06f 0005 	mvn.w	r0, #5
 80058fa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  return ERR_OK;
 80058fe:	2000      	movs	r0, #0
 8005900:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8005904:	f06f 000d 	mvn.w	r0, #13
 8005908:	4770      	bx	lr
 800590a:	f06f 000d 	mvn.w	r0, #13
 800590e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005912:	f06f 000d 	mvn.w	r0, #13
 8005916:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 800591a:	f06f 0005 	mvn.w	r0, #5
 800591e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 8005922:	2f00      	cmp	r7, #0
 8005924:	d034      	beq.n	8005990 <pbuf_copy+0xd4>
 8005926:	897a      	ldrh	r2, [r7, #10]
 8005928:	893b      	ldrh	r3, [r7, #8]
 800592a:	429a      	cmp	r2, r3
 800592c:	d133      	bne.n	8005996 <pbuf_copy+0xda>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 800592e:	683b      	ldr	r3, [r7, #0]
 8005930:	2b00      	cmp	r3, #0
 8005932:	d1f2      	bne.n	800591a <pbuf_copy+0x5e>
  } while (p_from);
 8005934:	2e00      	cmp	r6, #0
 8005936:	d0e2      	beq.n	80058fe <pbuf_copy+0x42>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 8005938:	897b      	ldrh	r3, [r7, #10]
 800593a:	8974      	ldrh	r4, [r6, #10]
 800593c:	1b59      	subs	r1, r3, r5
 800593e:	eba4 0209 	sub.w	r2, r4, r9
 8005942:	4291      	cmp	r1, r2
      len = p_from->len - offset_from;
 8005944:	bfa7      	ittee	ge
 8005946:	4614      	movge	r4, r2
 8005948:	b2a4      	uxthge	r4, r4
      len = p_to->len - offset_to;
 800594a:	1b5b      	sublt	r3, r3, r5
 800594c:	b29c      	uxthlt	r4, r3
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 800594e:	6878      	ldr	r0, [r7, #4]
 8005950:	6871      	ldr	r1, [r6, #4]
 8005952:	4622      	mov	r2, r4
 8005954:	4449      	add	r1, r9
 8005956:	4428      	add	r0, r5
 8005958:	f003 fa99 	bl	8008e8e <memcpy>
    offset_to += len;
 800595c:	4425      	add	r5, r4
 800595e:	b2ad      	uxth	r5, r5
    offset_from += len;
 8005960:	444c      	add	r4, r9
 8005962:	fa1f f984 	uxth.w	r9, r4
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 8005966:	897b      	ldrh	r3, [r7, #10]
    if (offset_from >= p_from->len) {
 8005968:	8972      	ldrh	r2, [r6, #10]
 800596a:	454a      	cmp	r2, r9
      p_from = p_from->next;
 800596c:	bf9c      	itt	ls
 800596e:	6836      	ldrls	r6, [r6, #0]
      offset_from = 0;
 8005970:	46c1      	movls	r9, r8
    if (offset_to == p_to->len) {
 8005972:	429d      	cmp	r5, r3
 8005974:	d0b1      	beq.n	80058da <pbuf_copy+0x1e>
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 8005976:	2e00      	cmp	r6, #0
 8005978:	d0d3      	beq.n	8005922 <pbuf_copy+0x66>
 800597a:	8972      	ldrh	r2, [r6, #10]
 800597c:	8933      	ldrh	r3, [r6, #8]
 800597e:	429a      	cmp	r2, r3
 8005980:	d0b6      	beq.n	80058f0 <pbuf_copy+0x34>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 8005982:	2f00      	cmp	r7, #0
 8005984:	d0d8      	beq.n	8005938 <pbuf_copy+0x7c>
 8005986:	897a      	ldrh	r2, [r7, #10]
 8005988:	893b      	ldrh	r3, [r7, #8]
 800598a:	429a      	cmp	r2, r3
 800598c:	d1d4      	bne.n	8005938 <pbuf_copy+0x7c>
 800598e:	e7ce      	b.n	800592e <pbuf_copy+0x72>
  return ERR_OK;
 8005990:	2000      	movs	r0, #0
 8005992:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005996:	2000      	movs	r0, #0
}
 8005998:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0800599c <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 800599c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 80059a0:	b338      	cbz	r0, 80059f2 <pbuf_copy_partial+0x56>
 80059a2:	460f      	mov	r7, r1
 80059a4:	4691      	mov	r9, r2
 80059a6:	4605      	mov	r5, r0
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 80059a8:	b339      	cbz	r1, 80059fa <pbuf_copy_partial+0x5e>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 80059aa:	b342      	cbz	r2, 80059fe <pbuf_copy_partial+0x62>
 80059ac:	2600      	movs	r6, #0
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
      copied_total += buf_copy_len;
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
 80059ae:	46b0      	mov	r8, r6
 80059b0:	e017      	b.n	80059e2 <pbuf_copy_partial+0x46>
      buf_copy_len = p->len - offset;
 80059b2:	896c      	ldrh	r4, [r5, #10]
 80059b4:	1ae4      	subs	r4, r4, r3
 80059b6:	b2a4      	uxth	r4, r4
 80059b8:	454c      	cmp	r4, r9
 80059ba:	bf28      	it	cs
 80059bc:	464c      	movcs	r4, r9
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 80059be:	6869      	ldr	r1, [r5, #4]
 80059c0:	4622      	mov	r2, r4
 80059c2:	4419      	add	r1, r3
 80059c4:	19b8      	adds	r0, r7, r6
 80059c6:	f003 fa62 	bl	8008e8e <memcpy>
      copied_total += buf_copy_len;
 80059ca:	4426      	add	r6, r4
 80059cc:	b2b6      	uxth	r6, r6
      len -= buf_copy_len;
 80059ce:	eba9 0404 	sub.w	r4, r9, r4
 80059d2:	fa1f f984 	uxth.w	r9, r4
      offset = 0;
 80059d6:	4643      	mov	r3, r8
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 80059d8:	682d      	ldr	r5, [r5, #0]
 80059da:	f1b9 0f00 	cmp.w	r9, #0
 80059de:	d009      	beq.n	80059f4 <pbuf_copy_partial+0x58>
 80059e0:	b145      	cbz	r5, 80059f4 <pbuf_copy_partial+0x58>
    if ((offset != 0) && (offset >= p->len)) {
 80059e2:	2b00      	cmp	r3, #0
 80059e4:	d0e5      	beq.n	80059b2 <pbuf_copy_partial+0x16>
 80059e6:	8969      	ldrh	r1, [r5, #10]
 80059e8:	4299      	cmp	r1, r3
 80059ea:	d8e2      	bhi.n	80059b2 <pbuf_copy_partial+0x16>
      offset -= p->len;
 80059ec:	1a5b      	subs	r3, r3, r1
 80059ee:	b29b      	uxth	r3, r3
 80059f0:	e7f2      	b.n	80059d8 <pbuf_copy_partial+0x3c>
  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 80059f2:	2600      	movs	r6, #0
    }
  }
  return copied_total;
}
 80059f4:	4630      	mov	r0, r6
 80059f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 80059fa:	2600      	movs	r6, #0
 80059fc:	e7fa      	b.n	80059f4 <pbuf_copy_partial+0x58>
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 80059fe:	4616      	mov	r6, r2
 8005a00:	e7f8      	b.n	80059f4 <pbuf_copy_partial+0x58>
	...

08005a04 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
 8005a04:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);
 8005a08:	6843      	ldr	r3, [r0, #4]
 8005a0a:	7a5e      	ldrb	r6, [r3, #9]

  prev = NULL;
  pcb = raw_pcbs;
 8005a0c:	4b18      	ldr	r3, [pc, #96]	; (8005a70 <raw_input+0x6c>)
 8005a0e:	681c      	ldr	r4, [r3, #0]
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 8005a10:	b35c      	cbz	r4, 8005a6a <raw_input+0x66>
 8005a12:	4682      	mov	sl, r0
 8005a14:	2500      	movs	r5, #0
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 8005a16:	f8df 805c 	ldr.w	r8, [pc, #92]	; 8005a74 <raw_input+0x70>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
 8005a1a:	f8df 905c 	ldr.w	r9, [pc, #92]	; 8005a78 <raw_input+0x74>
 8005a1e:	e003      	b.n	8005a28 <raw_input+0x24>
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
 8005a20:	68e3      	ldr	r3, [r4, #12]
 8005a22:	4625      	mov	r5, r4
  while ((eaten == 0) && (pcb != NULL)) {
 8005a24:	b1f3      	cbz	r3, 8005a64 <raw_input+0x60>
    pcb = pcb->next;
 8005a26:	461c      	mov	r4, r3
    if ((pcb->protocol == proto) &&
 8005a28:	7c23      	ldrb	r3, [r4, #16]
 8005a2a:	42b3      	cmp	r3, r6
 8005a2c:	d1f8      	bne.n	8005a20 <raw_input+0x1c>
 8005a2e:	b12c      	cbz	r4, 8005a3c <raw_input+0x38>
        (ip_addr_isany(&pcb->local_ip) ||
 8005a30:	6823      	ldr	r3, [r4, #0]
 8005a32:	b11b      	cbz	r3, 8005a3c <raw_input+0x38>
 8005a34:	f8d9 2000 	ldr.w	r2, [r9]
 8005a38:	4293      	cmp	r3, r2
 8005a3a:	d1f1      	bne.n	8005a20 <raw_input+0x1c>
        if (pcb->recv != NULL) {
 8005a3c:	6967      	ldr	r7, [r4, #20]
 8005a3e:	2f00      	cmp	r7, #0
 8005a40:	d0ee      	beq.n	8005a20 <raw_input+0x1c>
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 8005a42:	4643      	mov	r3, r8
 8005a44:	4652      	mov	r2, sl
 8005a46:	4621      	mov	r1, r4
 8005a48:	69a0      	ldr	r0, [r4, #24]
 8005a4a:	47b8      	blx	r7
 8005a4c:	2800      	cmp	r0, #0
 8005a4e:	d0e7      	beq.n	8005a20 <raw_input+0x1c>
            if (prev != NULL) {
 8005a50:	b12d      	cbz	r5, 8005a5e <raw_input+0x5a>
              prev->next = pcb->next;
 8005a52:	68e3      	ldr	r3, [r4, #12]
 8005a54:	60eb      	str	r3, [r5, #12]
              pcb->next = raw_pcbs;
 8005a56:	4b06      	ldr	r3, [pc, #24]	; (8005a70 <raw_input+0x6c>)
 8005a58:	681a      	ldr	r2, [r3, #0]
 8005a5a:	60e2      	str	r2, [r4, #12]
              raw_pcbs = pcb;
 8005a5c:	601c      	str	r4, [r3, #0]
    pcb = pcb->next;
 8005a5e:	2001      	movs	r0, #1
  }
  return eaten;
}
 8005a60:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005a64:	2000      	movs	r0, #0
 8005a66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  u8_t eaten = 0;
 8005a6a:	2000      	movs	r0, #0
 8005a6c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005a70:	20007190 	.word	0x20007190
 8005a74:	20008384 	.word	0x20008384
 8005a78:	2000838c 	.word	0x2000838c

08005a7c <stats_init>:
#include <string.h>

struct stats_ lwip_stats;

void stats_init(void)
{
 8005a7c:	4770      	bx	lr

08005a7e <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
 8005a7e:	4770      	bx	lr

08005a80 <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 8005a80:	b470      	push	{r4, r5, r6}
 8005a82:	4602      	mov	r2, r0
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8005a84:	6a85      	ldr	r5, [r0, #40]	; 0x28
 8005a86:	8d84      	ldrh	r4, [r0, #44]	; 0x2c

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8005a88:	6b01      	ldr	r1, [r0, #48]	; 0x30
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8005a8a:	1963      	adds	r3, r4, r5
 8005a8c:	1a58      	subs	r0, r3, r1
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8005a8e:	8ed3      	ldrh	r3, [r2, #54]	; 0x36
 8005a90:	f640 3668 	movw	r6, #2920	; 0xb68
 8005a94:	42b3      	cmp	r3, r6
 8005a96:	bf94      	ite	ls
 8005a98:	1ac3      	subls	r3, r0, r3
 8005a9a:	1b83      	subhi	r3, r0, r6
 8005a9c:	2b00      	cmp	r3, #0
 8005a9e:	db02      	blt.n	8005aa6 <tcp_update_rcv_ann_wnd+0x26>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 8005aa0:	85d4      	strh	r4, [r2, #46]	; 0x2e
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
  }
}
 8005aa2:	bc70      	pop	{r4, r5, r6}
 8005aa4:	4770      	bx	lr
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 8005aa6:	1a6b      	subs	r3, r5, r1
 8005aa8:	2b00      	cmp	r3, #0
 8005aaa:	dd03      	ble.n	8005ab4 <tcp_update_rcv_ann_wnd+0x34>
      pcb->rcv_ann_wnd = 0;
 8005aac:	2300      	movs	r3, #0
 8005aae:	85d3      	strh	r3, [r2, #46]	; 0x2e
    return 0;
 8005ab0:	4618      	mov	r0, r3
 8005ab2:	e7f6      	b.n	8005aa2 <tcp_update_rcv_ann_wnd+0x22>
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 8005ab4:	1b49      	subs	r1, r1, r5
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
 8005ab6:	85d1      	strh	r1, [r2, #46]	; 0x2e
    return 0;
 8005ab8:	2000      	movs	r0, #0
 8005aba:	e7f2      	b.n	8005aa2 <tcp_update_rcv_ann_wnd+0x22>

08005abc <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 8005abc:	b510      	push	{r4, lr}
 8005abe:	4604      	mov	r4, r0
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8005ac0:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 8005ac2:	4419      	add	r1, r3
 8005ac4:	b289      	uxth	r1, r1
  if (pcb->rcv_wnd > TCP_WND) {
 8005ac6:	f241 63d0 	movw	r3, #5840	; 0x16d0
 8005aca:	4299      	cmp	r1, r3
  pcb->rcv_wnd += len;
 8005acc:	bf92      	itee	ls
 8005ace:	8581      	strhls	r1, [r0, #44]	; 0x2c
    pcb->rcv_wnd = TCP_WND;
 8005ad0:	f241 63d0 	movwhi	r3, #5840	; 0x16d0
 8005ad4:	8583      	strhhi	r3, [r0, #44]	; 0x2c
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 8005ad6:	f7ff ffd3 	bl	8005a80 <tcp_update_rcv_ann_wnd>

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8005ada:	f240 53b3 	movw	r3, #1459	; 0x5b3
 8005ade:	4298      	cmp	r0, r3
 8005ae0:	dc00      	bgt.n	8005ae4 <tcp_recved+0x28>
 8005ae2:	bd10      	pop	{r4, pc}
    tcp_ack_now(pcb);
 8005ae4:	7fa3      	ldrb	r3, [r4, #30]
 8005ae6:	f043 0302 	orr.w	r3, r3, #2
 8005aea:	77a3      	strb	r3, [r4, #30]
    tcp_output(pcb);
 8005aec:	4620      	mov	r0, r4
 8005aee:	f002 f801 	bl	8007af4 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
 8005af2:	e7f6      	b.n	8005ae2 <tcp_recved+0x26>

08005af4 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
 8005af4:	b150      	cbz	r0, 8005b0c <tcp_seg_free+0x18>
{
 8005af6:	b510      	push	{r4, lr}
 8005af8:	4604      	mov	r4, r0
    if (seg->p != NULL) {
 8005afa:	6840      	ldr	r0, [r0, #4]
 8005afc:	b108      	cbz	r0, 8005b02 <tcp_seg_free+0xe>
      pbuf_free(seg->p);
 8005afe:	f7ff fdba 	bl	8005676 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8005b02:	4621      	mov	r1, r4
 8005b04:	2004      	movs	r0, #4
 8005b06:	f7ff fcbf 	bl	8005488 <memp_free>
 8005b0a:	bd10      	pop	{r4, pc}
 8005b0c:	4770      	bx	lr

08005b0e <tcp_segs_free>:
  while (seg != NULL) {
 8005b0e:	4603      	mov	r3, r0
 8005b10:	b140      	cbz	r0, 8005b24 <tcp_segs_free+0x16>
{
 8005b12:	b510      	push	{r4, lr}
    struct tcp_seg *next = seg->next;
 8005b14:	681c      	ldr	r4, [r3, #0]
    tcp_seg_free(seg);
 8005b16:	4618      	mov	r0, r3
 8005b18:	f7ff ffec 	bl	8005af4 <tcp_seg_free>
    seg = next;
 8005b1c:	4623      	mov	r3, r4
  while (seg != NULL) {
 8005b1e:	2c00      	cmp	r4, #0
 8005b20:	d1f8      	bne.n	8005b14 <tcp_segs_free+0x6>
 8005b22:	bd10      	pop	{r4, pc}
 8005b24:	4770      	bx	lr

08005b26 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 8005b26:	b538      	push	{r3, r4, r5, lr}
 8005b28:	4605      	mov	r5, r0
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 8005b2a:	2004      	movs	r0, #4
 8005b2c:	f7ff fc76 	bl	800541c <memp_malloc>
  if (cseg == NULL) {
 8005b30:	4604      	mov	r4, r0
 8005b32:	b150      	cbz	r0, 8005b4a <tcp_seg_copy+0x24>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
 8005b34:	6828      	ldr	r0, [r5, #0]
 8005b36:	6869      	ldr	r1, [r5, #4]
 8005b38:	68aa      	ldr	r2, [r5, #8]
 8005b3a:	68eb      	ldr	r3, [r5, #12]
 8005b3c:	6020      	str	r0, [r4, #0]
 8005b3e:	6061      	str	r1, [r4, #4]
 8005b40:	60a2      	str	r2, [r4, #8]
 8005b42:	60e3      	str	r3, [r4, #12]
  pbuf_ref(cseg->p);
 8005b44:	6860      	ldr	r0, [r4, #4]
 8005b46:	f7ff fe93 	bl	8005870 <pbuf_ref>
  return cseg;
}
 8005b4a:	4620      	mov	r0, r4
 8005b4c:	bd38      	pop	{r3, r4, r5, pc}

08005b4e <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 8005b4e:	b538      	push	{r3, r4, r5, lr}
  if (pcb->state != CLOSED &&
 8005b50:	7e03      	ldrb	r3, [r0, #24]
 8005b52:	2b01      	cmp	r3, #1
 8005b54:	d91a      	bls.n	8005b8c <tcp_pcb_purge+0x3e>
 8005b56:	2b0a      	cmp	r3, #10
 8005b58:	d018      	beq.n	8005b8c <tcp_pcb_purge+0x3e>
 8005b5a:	4604      	mov	r4, r0
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 8005b5c:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8005b5e:	b118      	cbz	r0, 8005b68 <tcp_pcb_purge+0x1a>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 8005b60:	f7ff fd89 	bl	8005676 <pbuf_free>
      pcb->refused_data = NULL;
 8005b64:	2300      	movs	r3, #0
 8005b66:	67a3      	str	r3, [r4, #120]	; 0x78
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
 8005b68:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8005b6a:	f7ff ffd0 	bl	8005b0e <tcp_segs_free>
    pcb->ooseq = NULL;
 8005b6e:	2500      	movs	r5, #0
 8005b70:	6765      	str	r5, [r4, #116]	; 0x74
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 8005b72:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005b76:	86a3      	strh	r3, [r4, #52]	; 0x34

    tcp_segs_free(pcb->unsent);
 8005b78:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8005b7a:	f7ff ffc8 	bl	8005b0e <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 8005b7e:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8005b80:	f7ff ffc5 	bl	8005b0e <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 8005b84:	66e5      	str	r5, [r4, #108]	; 0x6c
 8005b86:	6725      	str	r5, [r4, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 8005b88:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
 8005b8c:	bd38      	pop	{r3, r4, r5, pc}
	...

08005b90 <tcp_slowtmr>:
{
 8005b90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005b94:	b083      	sub	sp, #12
  ++tcp_ticks;
 8005b96:	4ab6      	ldr	r2, [pc, #728]	; (8005e70 <tcp_slowtmr+0x2e0>)
 8005b98:	6813      	ldr	r3, [r2, #0]
 8005b9a:	3301      	adds	r3, #1
 8005b9c:	6013      	str	r3, [r2, #0]
  ++tcp_timer_ctr;
 8005b9e:	4ab5      	ldr	r2, [pc, #724]	; (8005e74 <tcp_slowtmr+0x2e4>)
 8005ba0:	7813      	ldrb	r3, [r2, #0]
 8005ba2:	3301      	adds	r3, #1
 8005ba4:	7013      	strb	r3, [r2, #0]
    if (pcb->last_timer == tcp_timer_ctr) {
 8005ba6:	4615      	mov	r5, r2
        tcp_active_pcbs_changed = 0;
 8005ba8:	4fb3      	ldr	r7, [pc, #716]	; (8005e78 <tcp_slowtmr+0x2e8>)
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 8005baa:	f8df b2e0 	ldr.w	fp, [pc, #736]	; 8005e8c <tcp_slowtmr+0x2fc>
  pcb = tcp_active_pcbs;
 8005bae:	4bb3      	ldr	r3, [pc, #716]	; (8005e7c <tcp_slowtmr+0x2ec>)
 8005bb0:	681c      	ldr	r4, [r3, #0]
  while (pcb != NULL) {
 8005bb2:	2c00      	cmp	r4, #0
 8005bb4:	f000 816c 	beq.w	8005e90 <tcp_slowtmr+0x300>
 8005bb8:	2600      	movs	r6, #0
 8005bba:	e003      	b.n	8005bc4 <tcp_slowtmr+0x34>
      pcb = pcb->next;
 8005bbc:	68e4      	ldr	r4, [r4, #12]
  while (pcb != NULL) {
 8005bbe:	2c00      	cmp	r4, #0
 8005bc0:	f000 8166 	beq.w	8005e90 <tcp_slowtmr+0x300>
    if (pcb->last_timer == tcp_timer_ctr) {
 8005bc4:	782b      	ldrb	r3, [r5, #0]
 8005bc6:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 8005bca:	429a      	cmp	r2, r3
 8005bcc:	d0f6      	beq.n	8005bbc <tcp_slowtmr+0x2c>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 8005bce:	7e22      	ldrb	r2, [r4, #24]
    pcb->last_timer = tcp_timer_ctr;
 8005bd0:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 8005bd4:	2a02      	cmp	r2, #2
 8005bd6:	d024      	beq.n	8005c22 <tcp_slowtmr+0x92>
    else if (pcb->nrtx == TCP_MAXRTX) {
 8005bd8:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8005bdc:	2b0c      	cmp	r3, #12
 8005bde:	d061      	beq.n	8005ca4 <tcp_slowtmr+0x114>
      if (pcb->persist_backoff > 0) {
 8005be0:	f894 8095 	ldrb.w	r8, [r4, #149]	; 0x95
 8005be4:	f1b8 0f00 	cmp.w	r8, #0
 8005be8:	d027      	beq.n	8005c3a <tcp_slowtmr+0xaa>
        pcb->persist_cnt++;
 8005bea:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
 8005bee:	3301      	adds	r3, #1
 8005bf0:	b2db      	uxtb	r3, r3
 8005bf2:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 8005bf6:	4aa2      	ldr	r2, [pc, #648]	; (8005e80 <tcp_slowtmr+0x2f0>)
 8005bf8:	4442      	add	r2, r8
 8005bfa:	f812 2c01 	ldrb.w	r2, [r2, #-1]
 8005bfe:	429a      	cmp	r2, r3
 8005c00:	d873      	bhi.n	8005cea <tcp_slowtmr+0x15a>
          pcb->persist_cnt = 0;
 8005c02:	2300      	movs	r3, #0
 8005c04:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 8005c08:	f1b8 0f06 	cmp.w	r8, #6
            pcb->persist_backoff++;
 8005c0c:	bf9c      	itt	ls
 8005c0e:	f108 0801 	addls.w	r8, r8, #1
 8005c12:	f884 8095 	strbls.w	r8, [r4, #149]	; 0x95
          tcp_zero_window_probe(pcb);
 8005c16:	4620      	mov	r0, r4
 8005c18:	f002 f9b4 	bl	8007f84 <tcp_zero_window_probe>
    pcb_remove = 0;
 8005c1c:	f04f 0800 	mov.w	r8, #0
 8005c20:	e042      	b.n	8005ca8 <tcp_slowtmr+0x118>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 8005c22:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8005c26:	2b06      	cmp	r3, #6
 8005c28:	f000 808f 	beq.w	8005d4a <tcp_slowtmr+0x1ba>
    else if (pcb->nrtx == TCP_MAXRTX) {
 8005c2c:	2b0c      	cmp	r3, #12
 8005c2e:	d1d7      	bne.n	8005be0 <tcp_slowtmr+0x50>
    pcb_reset = 0;
 8005c30:	f04f 0900 	mov.w	r9, #0
    else if (pcb->nrtx == TCP_MAXRTX) {
 8005c34:	f04f 0801 	mov.w	r8, #1
 8005c38:	e08e      	b.n	8005d58 <tcp_slowtmr+0x1c8>
        if(pcb->rtime >= 0) {
 8005c3a:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
 8005c3e:	2900      	cmp	r1, #0
          ++pcb->rtime;
 8005c40:	bfa4      	itt	ge
 8005c42:	3101      	addge	r1, #1
 8005c44:	86a1      	strhge	r1, [r4, #52]	; 0x34
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 8005c46:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8005c48:	b371      	cbz	r1, 8005ca8 <tcp_slowtmr+0x118>
 8005c4a:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
 8005c4e:	f9b4 1044 	ldrsh.w	r1, [r4, #68]	; 0x44
 8005c52:	4288      	cmp	r0, r1
 8005c54:	db28      	blt.n	8005ca8 <tcp_slowtmr+0x118>
          if (pcb->state != SYN_SENT) {
 8005c56:	2a02      	cmp	r2, #2
 8005c58:	d00b      	beq.n	8005c72 <tcp_slowtmr+0xe2>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 8005c5a:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
 8005c5e:	f9b4 2042 	ldrsh.w	r2, [r4, #66]	; 0x42
 8005c62:	eb02 02e1 	add.w	r2, r2, r1, asr #3
 8005c66:	4987      	ldr	r1, [pc, #540]	; (8005e84 <tcp_slowtmr+0x2f4>)
 8005c68:	5ccb      	ldrb	r3, [r1, r3]
 8005c6a:	fa02 f303 	lsl.w	r3, r2, r3
 8005c6e:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
          pcb->rtime = 0;
 8005c72:	2300      	movs	r3, #0
 8005c74:	86a3      	strh	r3, [r4, #52]	; 0x34
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 8005c76:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 8005c7a:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
          pcb->ssthresh = eff_wnd >> 1;
 8005c7e:	4293      	cmp	r3, r2
 8005c80:	bf28      	it	cs
 8005c82:	4613      	movcs	r3, r2
 8005c84:	085b      	lsrs	r3, r3, #1
 8005c86:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
          if (pcb->ssthresh < (pcb->mss << 1)) {
 8005c8a:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8005c8c:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
            pcb->ssthresh = (pcb->mss << 1);
 8005c90:	bfbc      	itt	lt
 8005c92:	0053      	lsllt	r3, r2, #1
 8005c94:	f8a4 304e 	strhlt.w	r3, [r4, #78]	; 0x4e
          pcb->cwnd = pcb->mss;
 8005c98:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
          tcp_rexmit_rto(pcb);
 8005c9c:	4620      	mov	r0, r4
 8005c9e:	f002 f8d3 	bl	8007e48 <tcp_rexmit_rto>
 8005ca2:	e001      	b.n	8005ca8 <tcp_slowtmr+0x118>
      ++pcb_remove;
 8005ca4:	f04f 0801 	mov.w	r8, #1
    if (pcb->state == FIN_WAIT_2) {
 8005ca8:	7e23      	ldrb	r3, [r4, #24]
 8005caa:	2b06      	cmp	r3, #6
 8005cac:	d020      	beq.n	8005cf0 <tcp_slowtmr+0x160>
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
 8005cae:	7a22      	ldrb	r2, [r4, #8]
 8005cb0:	f012 0f08 	tst.w	r2, #8
 8005cb4:	d04e      	beq.n	8005d54 <tcp_slowtmr+0x1c4>
 8005cb6:	2b04      	cmp	r3, #4
 8005cb8:	d001      	beq.n	8005cbe <tcp_slowtmr+0x12e>
       ((pcb->state == ESTABLISHED) ||
 8005cba:	2b07      	cmp	r3, #7
 8005cbc:	d17e      	bne.n	8005dbc <tcp_slowtmr+0x22c>
      if((u32_t)(tcp_ticks - pcb->tmr) >
 8005cbe:	4b6c      	ldr	r3, [pc, #432]	; (8005e70 <tcp_slowtmr+0x2e0>)
 8005cc0:	681a      	ldr	r2, [r3, #0]
 8005cc2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005cc4:	1ad2      	subs	r2, r2, r3
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 8005cc6:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 8005cca:	f501 2324 	add.w	r3, r1, #671744	; 0xa4000
 8005cce:	f603 43b8 	addw	r3, r3, #3256	; 0xcb8
 8005cd2:	fbab 0303 	umull	r0, r3, fp, r3
      if((u32_t)(tcp_ticks - pcb->tmr) >
 8005cd6:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 8005cda:	d91e      	bls.n	8005d1a <tcp_slowtmr+0x18a>
        ++pcb_remove;
 8005cdc:	f108 0801 	add.w	r8, r8, #1
 8005ce0:	fa5f f888 	uxtb.w	r8, r8
        ++pcb_reset;
 8005ce4:	f04f 0901 	mov.w	r9, #1
 8005ce8:	e036      	b.n	8005d58 <tcp_slowtmr+0x1c8>
    pcb_remove = 0;
 8005cea:	f04f 0800 	mov.w	r8, #0
 8005cee:	e7db      	b.n	8005ca8 <tcp_slowtmr+0x118>
      if (pcb->flags & TF_RXCLOSED) {
 8005cf0:	7fa3      	ldrb	r3, [r4, #30]
 8005cf2:	f013 0f10 	tst.w	r3, #16
 8005cf6:	d009      	beq.n	8005d0c <tcp_slowtmr+0x17c>
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 8005cf8:	4b5d      	ldr	r3, [pc, #372]	; (8005e70 <tcp_slowtmr+0x2e0>)
 8005cfa:	681b      	ldr	r3, [r3, #0]
 8005cfc:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8005cfe:	1a9b      	subs	r3, r3, r2
 8005d00:	2b28      	cmp	r3, #40	; 0x28
 8005d02:	d903      	bls.n	8005d0c <tcp_slowtmr+0x17c>
          ++pcb_remove;
 8005d04:	f108 0801 	add.w	r8, r8, #1
 8005d08:	fa5f f888 	uxtb.w	r8, r8
    if (pcb->ooseq != NULL &&
 8005d0c:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8005d0e:	2800      	cmp	r0, #0
 8005d10:	f000 80e1 	beq.w	8005ed6 <tcp_slowtmr+0x346>
    pcb_reset = 0;
 8005d14:	f04f 0900 	mov.w	r9, #0
 8005d18:	e020      	b.n	8005d5c <tcp_slowtmr+0x1cc>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 8005d1a:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
 8005d1e:	485a      	ldr	r0, [pc, #360]	; (8005e88 <tcp_slowtmr+0x2f8>)
 8005d20:	fb00 1303 	mla	r3, r0, r3, r1
              / TCP_SLOW_INTERVAL)
 8005d24:	fbab 1303 	umull	r1, r3, fp, r3
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 8005d28:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 8005d2c:	d802      	bhi.n	8005d34 <tcp_slowtmr+0x1a4>
    pcb_reset = 0;
 8005d2e:	f04f 0900 	mov.w	r9, #0
 8005d32:	e011      	b.n	8005d58 <tcp_slowtmr+0x1c8>
        tcp_keepalive(pcb);
 8005d34:	4620      	mov	r0, r4
 8005d36:	f002 f8f5 	bl	8007f24 <tcp_keepalive>
        pcb->keep_cnt_sent++;
 8005d3a:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
 8005d3e:	3301      	adds	r3, #1
 8005d40:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
    pcb_reset = 0;
 8005d44:	f04f 0900 	mov.w	r9, #0
 8005d48:	e006      	b.n	8005d58 <tcp_slowtmr+0x1c8>
 8005d4a:	f04f 0900 	mov.w	r9, #0
 8005d4e:	f04f 0801 	mov.w	r8, #1
 8005d52:	e001      	b.n	8005d58 <tcp_slowtmr+0x1c8>
 8005d54:	f04f 0900 	mov.w	r9, #0
    if (pcb->ooseq != NULL &&
 8005d58:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8005d5a:	b150      	cbz	r0, 8005d72 <tcp_slowtmr+0x1e2>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
 8005d5c:	4b44      	ldr	r3, [pc, #272]	; (8005e70 <tcp_slowtmr+0x2e0>)
 8005d5e:	681a      	ldr	r2, [r3, #0]
 8005d60:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005d62:	1ad2      	subs	r2, r2, r3
 8005d64:	f9b4 3044 	ldrsh.w	r3, [r4, #68]	; 0x44
 8005d68:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    if (pcb->ooseq != NULL &&
 8005d6c:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
 8005d70:	d227      	bcs.n	8005dc2 <tcp_slowtmr+0x232>
    if (pcb->state == SYN_RCVD) {
 8005d72:	7e23      	ldrb	r3, [r4, #24]
 8005d74:	2b03      	cmp	r3, #3
 8005d76:	d029      	beq.n	8005dcc <tcp_slowtmr+0x23c>
    if (pcb->state == LAST_ACK) {
 8005d78:	2b09      	cmp	r3, #9
 8005d7a:	d032      	beq.n	8005de2 <tcp_slowtmr+0x252>
    if (pcb_remove) {
 8005d7c:	f1b8 0f00 	cmp.w	r8, #0
 8005d80:	d13a      	bne.n	8005df8 <tcp_slowtmr+0x268>
      pcb = pcb->next;
 8005d82:	f8d4 800c 	ldr.w	r8, [r4, #12]
      ++prev->polltmr;
 8005d86:	7fe3      	ldrb	r3, [r4, #31]
 8005d88:	3301      	adds	r3, #1
 8005d8a:	b2db      	uxtb	r3, r3
 8005d8c:	77e3      	strb	r3, [r4, #31]
      if (prev->polltmr >= prev->pollinterval) {
 8005d8e:	f894 2020 	ldrb.w	r2, [r4, #32]
 8005d92:	429a      	cmp	r2, r3
 8005d94:	d869      	bhi.n	8005e6a <tcp_slowtmr+0x2da>
        prev->polltmr = 0;
 8005d96:	2300      	movs	r3, #0
 8005d98:	77e3      	strb	r3, [r4, #31]
        tcp_active_pcbs_changed = 0;
 8005d9a:	703b      	strb	r3, [r7, #0]
        TCP_EVENT_POLL(prev, err);
 8005d9c:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8005da0:	2b00      	cmp	r3, #0
 8005da2:	d05a      	beq.n	8005e5a <tcp_slowtmr+0x2ca>
 8005da4:	4621      	mov	r1, r4
 8005da6:	6920      	ldr	r0, [r4, #16]
 8005da8:	4798      	blx	r3
        if (tcp_active_pcbs_changed) {
 8005daa:	783b      	ldrb	r3, [r7, #0]
 8005dac:	2b00      	cmp	r3, #0
 8005dae:	f47f aefe 	bne.w	8005bae <tcp_slowtmr+0x1e>
        if (err == ERR_OK) {
 8005db2:	2800      	cmp	r0, #0
 8005db4:	d051      	beq.n	8005e5a <tcp_slowtmr+0x2ca>
 8005db6:	4626      	mov	r6, r4
      pcb = pcb->next;
 8005db8:	4644      	mov	r4, r8
 8005dba:	e700      	b.n	8005bbe <tcp_slowtmr+0x2e>
    pcb_reset = 0;
 8005dbc:	f04f 0900 	mov.w	r9, #0
 8005dc0:	e7ca      	b.n	8005d58 <tcp_slowtmr+0x1c8>
      tcp_segs_free(pcb->ooseq);
 8005dc2:	f7ff fea4 	bl	8005b0e <tcp_segs_free>
      pcb->ooseq = NULL;
 8005dc6:	2300      	movs	r3, #0
 8005dc8:	6763      	str	r3, [r4, #116]	; 0x74
 8005dca:	e7d2      	b.n	8005d72 <tcp_slowtmr+0x1e2>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 8005dcc:	4b28      	ldr	r3, [pc, #160]	; (8005e70 <tcp_slowtmr+0x2e0>)
 8005dce:	681b      	ldr	r3, [r3, #0]
 8005dd0:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8005dd2:	1a9b      	subs	r3, r3, r2
 8005dd4:	2b28      	cmp	r3, #40	; 0x28
 8005dd6:	d9d1      	bls.n	8005d7c <tcp_slowtmr+0x1ec>
        ++pcb_remove;
 8005dd8:	f108 0801 	add.w	r8, r8, #1
 8005ddc:	fa5f f888 	uxtb.w	r8, r8
 8005de0:	e7cc      	b.n	8005d7c <tcp_slowtmr+0x1ec>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8005de2:	4b23      	ldr	r3, [pc, #140]	; (8005e70 <tcp_slowtmr+0x2e0>)
 8005de4:	681b      	ldr	r3, [r3, #0]
 8005de6:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8005de8:	1a9b      	subs	r3, r3, r2
 8005dea:	2bf0      	cmp	r3, #240	; 0xf0
        ++pcb_remove;
 8005dec:	bf84      	itt	hi
 8005dee:	f108 0801 	addhi.w	r8, r8, #1
 8005df2:	fa5f f888 	uxtbhi.w	r8, r8
 8005df6:	e7c1      	b.n	8005d7c <tcp_slowtmr+0x1ec>
      tcp_pcb_purge(pcb);
 8005df8:	4620      	mov	r0, r4
 8005dfa:	f7ff fea8 	bl	8005b4e <tcp_pcb_purge>
      if (prev != NULL) {
 8005dfe:	b1ee      	cbz	r6, 8005e3c <tcp_slowtmr+0x2ac>
        prev->next = pcb->next;
 8005e00:	68e3      	ldr	r3, [r4, #12]
 8005e02:	60f3      	str	r3, [r6, #12]
      if (pcb_reset) {
 8005e04:	f1b9 0f00 	cmp.w	r9, #0
 8005e08:	d11c      	bne.n	8005e44 <tcp_slowtmr+0x2b4>
      err_fn = pcb->errf;
 8005e0a:	f8d4 808c 	ldr.w	r8, [r4, #140]	; 0x8c
      err_arg = pcb->callback_arg;
 8005e0e:	f8d4 a010 	ldr.w	sl, [r4, #16]
      pcb = pcb->next;
 8005e12:	f8d4 900c 	ldr.w	r9, [r4, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 8005e16:	4621      	mov	r1, r4
 8005e18:	2002      	movs	r0, #2
 8005e1a:	f7ff fb35 	bl	8005488 <memp_free>
      tcp_active_pcbs_changed = 0;
 8005e1e:	2300      	movs	r3, #0
 8005e20:	703b      	strb	r3, [r7, #0]
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
 8005e22:	f1b8 0f00 	cmp.w	r8, #0
 8005e26:	d01e      	beq.n	8005e66 <tcp_slowtmr+0x2d6>
 8005e28:	f06f 0109 	mvn.w	r1, #9
 8005e2c:	4650      	mov	r0, sl
 8005e2e:	47c0      	blx	r8
      if (tcp_active_pcbs_changed) {
 8005e30:	783b      	ldrb	r3, [r7, #0]
 8005e32:	2b00      	cmp	r3, #0
 8005e34:	f47f aebb 	bne.w	8005bae <tcp_slowtmr+0x1e>
      pcb = pcb->next;
 8005e38:	464c      	mov	r4, r9
 8005e3a:	e6c0      	b.n	8005bbe <tcp_slowtmr+0x2e>
        tcp_active_pcbs = pcb->next;
 8005e3c:	68e3      	ldr	r3, [r4, #12]
 8005e3e:	4a0f      	ldr	r2, [pc, #60]	; (8005e7c <tcp_slowtmr+0x2ec>)
 8005e40:	6013      	str	r3, [r2, #0]
 8005e42:	e7df      	b.n	8005e04 <tcp_slowtmr+0x274>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8005e44:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8005e46:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8005e48:	8ba3      	ldrh	r3, [r4, #28]
 8005e4a:	9301      	str	r3, [sp, #4]
 8005e4c:	8b63      	ldrh	r3, [r4, #26]
 8005e4e:	9300      	str	r3, [sp, #0]
 8005e50:	1d23      	adds	r3, r4, #4
 8005e52:	4622      	mov	r2, r4
 8005e54:	f001 ffa6 	bl	8007da4 <tcp_rst>
 8005e58:	e7d7      	b.n	8005e0a <tcp_slowtmr+0x27a>
          tcp_output(prev);
 8005e5a:	4620      	mov	r0, r4
 8005e5c:	f001 fe4a 	bl	8007af4 <tcp_output>
 8005e60:	4626      	mov	r6, r4
      pcb = pcb->next;
 8005e62:	4644      	mov	r4, r8
 8005e64:	e6ab      	b.n	8005bbe <tcp_slowtmr+0x2e>
      pcb = pcb->next;
 8005e66:	464c      	mov	r4, r9
 8005e68:	e6a9      	b.n	8005bbe <tcp_slowtmr+0x2e>
 8005e6a:	4626      	mov	r6, r4
      pcb = pcb->next;
 8005e6c:	4644      	mov	r4, r8
 8005e6e:	e6a6      	b.n	8005bbe <tcp_slowtmr+0x2e>
 8005e70:	2000abe4 	.word	0x2000abe4
 8005e74:	20007195 	.word	0x20007195
 8005e78:	2000abdc 	.word	0x2000abdc
 8005e7c:	2000abe0 	.word	0x2000abe0
 8005e80:	0800901c 	.word	0x0800901c
 8005e84:	0800900c 	.word	0x0800900c
 8005e88:	000124f8 	.word	0x000124f8
 8005e8c:	10624dd3 	.word	0x10624dd3
  pcb = tcp_tw_pcbs;
 8005e90:	4b14      	ldr	r3, [pc, #80]	; (8005ee4 <tcp_slowtmr+0x354>)
 8005e92:	681c      	ldr	r4, [r3, #0]
  while (pcb != NULL) {
 8005e94:	b314      	cbz	r4, 8005edc <tcp_slowtmr+0x34c>
 8005e96:	2500      	movs	r5, #0
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8005e98:	4e13      	ldr	r6, [pc, #76]	; (8005ee8 <tcp_slowtmr+0x358>)
      memp_free(MEMP_TCP_PCB, pcb2);
 8005e9a:	2702      	movs	r7, #2
        tcp_tw_pcbs = pcb->next;
 8005e9c:	4698      	mov	r8, r3
 8005e9e:	e006      	b.n	8005eae <tcp_slowtmr+0x31e>
 8005ea0:	68e3      	ldr	r3, [r4, #12]
 8005ea2:	f8c8 3000 	str.w	r3, [r8]
 8005ea6:	e00e      	b.n	8005ec6 <tcp_slowtmr+0x336>
      pcb = pcb->next;
 8005ea8:	4625      	mov	r5, r4
 8005eaa:	68e4      	ldr	r4, [r4, #12]
  while (pcb != NULL) {
 8005eac:	b1b4      	cbz	r4, 8005edc <tcp_slowtmr+0x34c>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8005eae:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8005eb0:	6833      	ldr	r3, [r6, #0]
 8005eb2:	1a9b      	subs	r3, r3, r2
    if (pcb_remove) {
 8005eb4:	2bf0      	cmp	r3, #240	; 0xf0
 8005eb6:	d9f7      	bls.n	8005ea8 <tcp_slowtmr+0x318>
      tcp_pcb_purge(pcb);
 8005eb8:	4620      	mov	r0, r4
 8005eba:	f7ff fe48 	bl	8005b4e <tcp_pcb_purge>
      if (prev != NULL) {
 8005ebe:	2d00      	cmp	r5, #0
 8005ec0:	d0ee      	beq.n	8005ea0 <tcp_slowtmr+0x310>
        prev->next = pcb->next;
 8005ec2:	68e3      	ldr	r3, [r4, #12]
 8005ec4:	60eb      	str	r3, [r5, #12]
      pcb = pcb->next;
 8005ec6:	f8d4 900c 	ldr.w	r9, [r4, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 8005eca:	4621      	mov	r1, r4
 8005ecc:	4638      	mov	r0, r7
 8005ece:	f7ff fadb 	bl	8005488 <memp_free>
      pcb = pcb->next;
 8005ed2:	464c      	mov	r4, r9
 8005ed4:	e7ea      	b.n	8005eac <tcp_slowtmr+0x31c>
    pcb_reset = 0;
 8005ed6:	f04f 0900 	mov.w	r9, #0
 8005eda:	e74f      	b.n	8005d7c <tcp_slowtmr+0x1ec>
}
 8005edc:	b003      	add	sp, #12
 8005ede:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005ee2:	bf00      	nop
 8005ee4:	2000abf4 	.word	0x2000abf4
 8005ee8:	2000abe4 	.word	0x2000abe4

08005eec <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 8005eec:	b510      	push	{r4, lr}
 8005eee:	460c      	mov	r4, r1
  TCP_RMV(pcblist, pcb);
 8005ef0:	6802      	ldr	r2, [r0, #0]
 8005ef2:	428a      	cmp	r2, r1
 8005ef4:	d00b      	beq.n	8005f0e <tcp_pcb_remove+0x22>
 8005ef6:	4b18      	ldr	r3, [pc, #96]	; (8005f58 <tcp_pcb_remove+0x6c>)
 8005ef8:	601a      	str	r2, [r3, #0]
 8005efa:	b17a      	cbz	r2, 8005f1c <tcp_pcb_remove+0x30>
 8005efc:	68d3      	ldr	r3, [r2, #12]
 8005efe:	4299      	cmp	r1, r3
 8005f00:	d01d      	beq.n	8005f3e <tcp_pcb_remove+0x52>
 8005f02:	b1f3      	cbz	r3, 8005f42 <tcp_pcb_remove+0x56>
 8005f04:	68da      	ldr	r2, [r3, #12]
 8005f06:	4294      	cmp	r4, r2
 8005f08:	d004      	beq.n	8005f14 <tcp_pcb_remove+0x28>
 8005f0a:	4613      	mov	r3, r2
 8005f0c:	e7f9      	b.n	8005f02 <tcp_pcb_remove+0x16>
 8005f0e:	68d3      	ldr	r3, [r2, #12]
 8005f10:	6003      	str	r3, [r0, #0]
 8005f12:	e003      	b.n	8005f1c <tcp_pcb_remove+0x30>
 8005f14:	4a10      	ldr	r2, [pc, #64]	; (8005f58 <tcp_pcb_remove+0x6c>)
 8005f16:	6013      	str	r3, [r2, #0]
 8005f18:	68e2      	ldr	r2, [r4, #12]
 8005f1a:	60da      	str	r2, [r3, #12]
 8005f1c:	2300      	movs	r3, #0
 8005f1e:	60e3      	str	r3, [r4, #12]

  tcp_pcb_purge(pcb);
 8005f20:	4620      	mov	r0, r4
 8005f22:	f7ff fe14 	bl	8005b4e <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 8005f26:	7e23      	ldrb	r3, [r4, #24]
 8005f28:	2b0a      	cmp	r3, #10
 8005f2a:	d005      	beq.n	8005f38 <tcp_pcb_remove+0x4c>
 8005f2c:	2b01      	cmp	r3, #1
 8005f2e:	d003      	beq.n	8005f38 <tcp_pcb_remove+0x4c>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 8005f30:	7fa3      	ldrb	r3, [r4, #30]
     pcb->state != LISTEN &&
 8005f32:	f013 0f01 	tst.w	r3, #1
 8005f36:	d108      	bne.n	8005f4a <tcp_pcb_remove+0x5e>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 8005f38:	2300      	movs	r3, #0
 8005f3a:	7623      	strb	r3, [r4, #24]
 8005f3c:	bd10      	pop	{r4, pc}
  TCP_RMV(pcblist, pcb);
 8005f3e:	4613      	mov	r3, r2
 8005f40:	e7ea      	b.n	8005f18 <tcp_pcb_remove+0x2c>
 8005f42:	2200      	movs	r2, #0
 8005f44:	4b04      	ldr	r3, [pc, #16]	; (8005f58 <tcp_pcb_remove+0x6c>)
 8005f46:	601a      	str	r2, [r3, #0]
 8005f48:	e7e8      	b.n	8005f1c <tcp_pcb_remove+0x30>
    pcb->flags |= TF_ACK_NOW;
 8005f4a:	f043 0302 	orr.w	r3, r3, #2
 8005f4e:	77a3      	strb	r3, [r4, #30]
    tcp_output(pcb);
 8005f50:	4620      	mov	r0, r4
 8005f52:	f001 fdcf 	bl	8007af4 <tcp_output>
 8005f56:	e7ef      	b.n	8005f38 <tcp_pcb_remove+0x4c>
 8005f58:	2000abec 	.word	0x2000abec

08005f5c <tcp_close_shutdown>:
{
 8005f5c:	b510      	push	{r4, lr}
 8005f5e:	b082      	sub	sp, #8
 8005f60:	4604      	mov	r4, r0
  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 8005f62:	b121      	cbz	r1, 8005f6e <tcp_close_shutdown+0x12>
 8005f64:	7e03      	ldrb	r3, [r0, #24]
 8005f66:	2b04      	cmp	r3, #4
 8005f68:	d00b      	beq.n	8005f82 <tcp_close_shutdown+0x26>
 8005f6a:	2b07      	cmp	r3, #7
 8005f6c:	d009      	beq.n	8005f82 <tcp_close_shutdown+0x26>
  switch (pcb->state) {
 8005f6e:	7e23      	ldrb	r3, [r4, #24]
 8005f70:	2b07      	cmp	r3, #7
 8005f72:	f200 80ae 	bhi.w	80060d2 <tcp_close_shutdown+0x176>
 8005f76:	e8df f003 	tbb	[pc, r3]
 8005f7a:	774e      	.short	0x774e
 8005f7c:	ac9a8c80 	.word	0xac9a8c80
 8005f80:	a3ac      	.short	0xa3ac
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 8005f82:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8005f84:	b1e3      	cbz	r3, 8005fc0 <tcp_close_shutdown+0x64>
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8005f86:	8ba3      	ldrh	r3, [r4, #28]
 8005f88:	9301      	str	r3, [sp, #4]
 8005f8a:	8b63      	ldrh	r3, [r4, #26]
 8005f8c:	9300      	str	r3, [sp, #0]
 8005f8e:	1d23      	adds	r3, r4, #4
 8005f90:	4622      	mov	r2, r4
 8005f92:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8005f94:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8005f96:	f001 ff05 	bl	8007da4 <tcp_rst>
      tcp_pcb_purge(pcb);
 8005f9a:	4620      	mov	r0, r4
 8005f9c:	f7ff fdd7 	bl	8005b4e <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8005fa0:	4b4e      	ldr	r3, [pc, #312]	; (80060dc <tcp_close_shutdown+0x180>)
 8005fa2:	681a      	ldr	r2, [r3, #0]
 8005fa4:	4294      	cmp	r4, r2
 8005fa6:	d011      	beq.n	8005fcc <tcp_close_shutdown+0x70>
 8005fa8:	4b4d      	ldr	r3, [pc, #308]	; (80060e0 <tcp_close_shutdown+0x184>)
 8005faa:	601a      	str	r2, [r3, #0]
 8005fac:	b1aa      	cbz	r2, 8005fda <tcp_close_shutdown+0x7e>
 8005fae:	68d3      	ldr	r3, [r2, #12]
 8005fb0:	429c      	cmp	r4, r3
 8005fb2:	d020      	beq.n	8005ff6 <tcp_close_shutdown+0x9a>
 8005fb4:	b30b      	cbz	r3, 8005ffa <tcp_close_shutdown+0x9e>
 8005fb6:	68da      	ldr	r2, [r3, #12]
 8005fb8:	4294      	cmp	r4, r2
 8005fba:	d00a      	beq.n	8005fd2 <tcp_close_shutdown+0x76>
 8005fbc:	4613      	mov	r3, r2
 8005fbe:	e7f9      	b.n	8005fb4 <tcp_close_shutdown+0x58>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 8005fc0:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 8005fc2:	f241 63d0 	movw	r3, #5840	; 0x16d0
 8005fc6:	429a      	cmp	r2, r3
 8005fc8:	d1dd      	bne.n	8005f86 <tcp_close_shutdown+0x2a>
 8005fca:	e7d0      	b.n	8005f6e <tcp_close_shutdown+0x12>
      TCP_RMV_ACTIVE(pcb);
 8005fcc:	68d2      	ldr	r2, [r2, #12]
 8005fce:	601a      	str	r2, [r3, #0]
 8005fd0:	e003      	b.n	8005fda <tcp_close_shutdown+0x7e>
 8005fd2:	4a43      	ldr	r2, [pc, #268]	; (80060e0 <tcp_close_shutdown+0x184>)
 8005fd4:	6013      	str	r3, [r2, #0]
 8005fd6:	68e2      	ldr	r2, [r4, #12]
 8005fd8:	60da      	str	r2, [r3, #12]
 8005fda:	2300      	movs	r3, #0
 8005fdc:	60e3      	str	r3, [r4, #12]
 8005fde:	2201      	movs	r2, #1
 8005fe0:	4b40      	ldr	r3, [pc, #256]	; (80060e4 <tcp_close_shutdown+0x188>)
 8005fe2:	701a      	strb	r2, [r3, #0]
      if (pcb->state == ESTABLISHED) {
 8005fe4:	7e23      	ldrb	r3, [r4, #24]
 8005fe6:	2b04      	cmp	r3, #4
 8005fe8:	d00b      	beq.n	8006002 <tcp_close_shutdown+0xa6>
        memp_free(MEMP_TCP_PCB, pcb);
 8005fea:	4621      	mov	r1, r4
 8005fec:	2002      	movs	r0, #2
 8005fee:	f7ff fa4b 	bl	8005488 <memp_free>
      return ERR_OK;
 8005ff2:	2300      	movs	r3, #0
 8005ff4:	e02f      	b.n	8006056 <tcp_close_shutdown+0xfa>
      TCP_RMV_ACTIVE(pcb);
 8005ff6:	4613      	mov	r3, r2
 8005ff8:	e7ed      	b.n	8005fd6 <tcp_close_shutdown+0x7a>
 8005ffa:	2200      	movs	r2, #0
 8005ffc:	4b38      	ldr	r3, [pc, #224]	; (80060e0 <tcp_close_shutdown+0x184>)
 8005ffe:	601a      	str	r2, [r3, #0]
 8006000:	e7eb      	b.n	8005fda <tcp_close_shutdown+0x7e>
        pcb->state = TIME_WAIT;
 8006002:	230a      	movs	r3, #10
 8006004:	7623      	strb	r3, [r4, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 8006006:	4b38      	ldr	r3, [pc, #224]	; (80060e8 <tcp_close_shutdown+0x18c>)
 8006008:	681a      	ldr	r2, [r3, #0]
 800600a:	60e2      	str	r2, [r4, #12]
 800600c:	601c      	str	r4, [r3, #0]
 800600e:	f002 f853 	bl	80080b8 <tcp_timer_needed>
      return ERR_OK;
 8006012:	2300      	movs	r3, #0
 8006014:	e01f      	b.n	8006056 <tcp_close_shutdown+0xfa>
    if (pcb->local_port != 0) {
 8006016:	8b63      	ldrh	r3, [r4, #26]
 8006018:	b1c3      	cbz	r3, 800604c <tcp_close_shutdown+0xf0>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800601a:	4b34      	ldr	r3, [pc, #208]	; (80060ec <tcp_close_shutdown+0x190>)
 800601c:	681a      	ldr	r2, [r3, #0]
 800601e:	4294      	cmp	r4, r2
 8006020:	d00b      	beq.n	800603a <tcp_close_shutdown+0xde>
 8006022:	4b2f      	ldr	r3, [pc, #188]	; (80060e0 <tcp_close_shutdown+0x184>)
 8006024:	601a      	str	r2, [r3, #0]
 8006026:	b17a      	cbz	r2, 8006048 <tcp_close_shutdown+0xec>
 8006028:	68d3      	ldr	r3, [r2, #12]
 800602a:	429c      	cmp	r4, r3
 800602c:	d016      	beq.n	800605c <tcp_close_shutdown+0x100>
 800602e:	b1bb      	cbz	r3, 8006060 <tcp_close_shutdown+0x104>
 8006030:	68da      	ldr	r2, [r3, #12]
 8006032:	4294      	cmp	r4, r2
 8006034:	d004      	beq.n	8006040 <tcp_close_shutdown+0xe4>
 8006036:	4613      	mov	r3, r2
 8006038:	e7f9      	b.n	800602e <tcp_close_shutdown+0xd2>
 800603a:	68d2      	ldr	r2, [r2, #12]
 800603c:	601a      	str	r2, [r3, #0]
 800603e:	e003      	b.n	8006048 <tcp_close_shutdown+0xec>
 8006040:	4a27      	ldr	r2, [pc, #156]	; (80060e0 <tcp_close_shutdown+0x184>)
 8006042:	6013      	str	r3, [r2, #0]
 8006044:	68e2      	ldr	r2, [r4, #12]
 8006046:	60da      	str	r2, [r3, #12]
 8006048:	2300      	movs	r3, #0
 800604a:	60e3      	str	r3, [r4, #12]
    memp_free(MEMP_TCP_PCB, pcb);
 800604c:	4621      	mov	r1, r4
 800604e:	2002      	movs	r0, #2
 8006050:	f7ff fa1a 	bl	8005488 <memp_free>
    err = ERR_OK;
 8006054:	2300      	movs	r3, #0
}
 8006056:	4618      	mov	r0, r3
 8006058:	b002      	add	sp, #8
 800605a:	bd10      	pop	{r4, pc}
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800605c:	4613      	mov	r3, r2
 800605e:	e7f1      	b.n	8006044 <tcp_close_shutdown+0xe8>
 8006060:	2200      	movs	r2, #0
 8006062:	4b1f      	ldr	r3, [pc, #124]	; (80060e0 <tcp_close_shutdown+0x184>)
 8006064:	601a      	str	r2, [r3, #0]
 8006066:	e7ef      	b.n	8006048 <tcp_close_shutdown+0xec>
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 8006068:	4621      	mov	r1, r4
 800606a:	4821      	ldr	r0, [pc, #132]	; (80060f0 <tcp_close_shutdown+0x194>)
 800606c:	f7ff ff3e 	bl	8005eec <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 8006070:	4621      	mov	r1, r4
 8006072:	2003      	movs	r0, #3
 8006074:	f7ff fa08 	bl	8005488 <memp_free>
    break;
 8006078:	e7ec      	b.n	8006054 <tcp_close_shutdown+0xf8>
    TCP_PCB_REMOVE_ACTIVE(pcb);
 800607a:	4621      	mov	r1, r4
 800607c:	4817      	ldr	r0, [pc, #92]	; (80060dc <tcp_close_shutdown+0x180>)
 800607e:	f7ff ff35 	bl	8005eec <tcp_pcb_remove>
 8006082:	2201      	movs	r2, #1
 8006084:	4b17      	ldr	r3, [pc, #92]	; (80060e4 <tcp_close_shutdown+0x188>)
 8006086:	701a      	strb	r2, [r3, #0]
    memp_free(MEMP_TCP_PCB, pcb);
 8006088:	4621      	mov	r1, r4
 800608a:	2002      	movs	r0, #2
 800608c:	f7ff f9fc 	bl	8005488 <memp_free>
    break;
 8006090:	e7e0      	b.n	8006054 <tcp_close_shutdown+0xf8>
    err = tcp_send_fin(pcb);
 8006092:	4620      	mov	r0, r4
 8006094:	f001 fcdc 	bl	8007a50 <tcp_send_fin>
    if (err == ERR_OK) {
 8006098:	4603      	mov	r3, r0
 800609a:	2800      	cmp	r0, #0
 800609c:	d1db      	bne.n	8006056 <tcp_close_shutdown+0xfa>
      pcb->state = FIN_WAIT_1;
 800609e:	2305      	movs	r3, #5
 80060a0:	7623      	strb	r3, [r4, #24]
  if (pcb != NULL && err == ERR_OK) {
 80060a2:	b1c4      	cbz	r4, 80060d6 <tcp_close_shutdown+0x17a>
    tcp_output(pcb);
 80060a4:	4620      	mov	r0, r4
 80060a6:	f001 fd25 	bl	8007af4 <tcp_output>
  return err;
 80060aa:	2300      	movs	r3, #0
 80060ac:	e7d3      	b.n	8006056 <tcp_close_shutdown+0xfa>
    err = tcp_send_fin(pcb);
 80060ae:	4620      	mov	r0, r4
 80060b0:	f001 fcce 	bl	8007a50 <tcp_send_fin>
    if (err == ERR_OK) {
 80060b4:	4603      	mov	r3, r0
 80060b6:	2800      	cmp	r0, #0
 80060b8:	d1cd      	bne.n	8006056 <tcp_close_shutdown+0xfa>
      pcb->state = FIN_WAIT_1;
 80060ba:	2305      	movs	r3, #5
 80060bc:	7623      	strb	r3, [r4, #24]
 80060be:	e7f0      	b.n	80060a2 <tcp_close_shutdown+0x146>
    err = tcp_send_fin(pcb);
 80060c0:	4620      	mov	r0, r4
 80060c2:	f001 fcc5 	bl	8007a50 <tcp_send_fin>
    if (err == ERR_OK) {
 80060c6:	4603      	mov	r3, r0
 80060c8:	2800      	cmp	r0, #0
 80060ca:	d1c4      	bne.n	8006056 <tcp_close_shutdown+0xfa>
      pcb->state = LAST_ACK;
 80060cc:	2309      	movs	r3, #9
 80060ce:	7623      	strb	r3, [r4, #24]
 80060d0:	e7e7      	b.n	80060a2 <tcp_close_shutdown+0x146>
    err = ERR_OK;
 80060d2:	2300      	movs	r3, #0
 80060d4:	e7bf      	b.n	8006056 <tcp_close_shutdown+0xfa>
  if (pcb != NULL && err == ERR_OK) {
 80060d6:	2300      	movs	r3, #0
 80060d8:	e7bd      	b.n	8006056 <tcp_close_shutdown+0xfa>
 80060da:	bf00      	nop
 80060dc:	2000abe0 	.word	0x2000abe0
 80060e0:	2000abec 	.word	0x2000abec
 80060e4:	2000abdc 	.word	0x2000abdc
 80060e8:	2000abf4 	.word	0x2000abf4
 80060ec:	2000abf0 	.word	0x2000abf0
 80060f0:	2000abe8 	.word	0x2000abe8

080060f4 <tcp_close>:
{
 80060f4:	b508      	push	{r3, lr}
  if (pcb->state != LISTEN) {
 80060f6:	7e03      	ldrb	r3, [r0, #24]
 80060f8:	2b01      	cmp	r3, #1
 80060fa:	d003      	beq.n	8006104 <tcp_close+0x10>
    pcb->flags |= TF_RXCLOSED;
 80060fc:	7f83      	ldrb	r3, [r0, #30]
 80060fe:	f043 0310 	orr.w	r3, r3, #16
 8006102:	7783      	strb	r3, [r0, #30]
  return tcp_close_shutdown(pcb, 1);
 8006104:	2101      	movs	r1, #1
 8006106:	f7ff ff29 	bl	8005f5c <tcp_close_shutdown>
}
 800610a:	bd08      	pop	{r3, pc}

0800610c <tcp_recv_null>:
{
 800610c:	b510      	push	{r4, lr}
 800610e:	4608      	mov	r0, r1
  if (p != NULL) {
 8006110:	b142      	cbz	r2, 8006124 <tcp_recv_null+0x18>
 8006112:	4614      	mov	r4, r2
    tcp_recved(pcb, p->tot_len);
 8006114:	8911      	ldrh	r1, [r2, #8]
 8006116:	f7ff fcd1 	bl	8005abc <tcp_recved>
    pbuf_free(p);
 800611a:	4620      	mov	r0, r4
 800611c:	f7ff faab 	bl	8005676 <pbuf_free>
  return ERR_OK;
 8006120:	2000      	movs	r0, #0
 8006122:	bd10      	pop	{r4, pc}
  } else if (err == ERR_OK) {
 8006124:	b10b      	cbz	r3, 800612a <tcp_recv_null+0x1e>
  return ERR_OK;
 8006126:	2000      	movs	r0, #0
}
 8006128:	bd10      	pop	{r4, pc}
    return tcp_close(pcb);
 800612a:	f7ff ffe3 	bl	80060f4 <tcp_close>
 800612e:	bd10      	pop	{r4, pc}

08006130 <tcp_process_refused_data>:
{
 8006130:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006132:	4604      	mov	r4, r0
  u8_t refused_flags = pcb->refused_data->flags;
 8006134:	6f86      	ldr	r6, [r0, #120]	; 0x78
 8006136:	7b77      	ldrb	r7, [r6, #13]
  pcb->refused_data = NULL;
 8006138:	2300      	movs	r3, #0
 800613a:	6783      	str	r3, [r0, #120]	; 0x78
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800613c:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
 8006140:	b1e5      	cbz	r5, 800617c <tcp_process_refused_data+0x4c>
 8006142:	4632      	mov	r2, r6
 8006144:	4601      	mov	r1, r0
 8006146:	6900      	ldr	r0, [r0, #16]
 8006148:	47a8      	blx	r5
 800614a:	4605      	mov	r5, r0
  if (err == ERR_OK) {
 800614c:	b9f5      	cbnz	r5, 800618c <tcp_process_refused_data+0x5c>
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
 800614e:	f017 0f20 	tst.w	r7, #32
 8006152:	d020      	beq.n	8006196 <tcp_process_refused_data+0x66>
      if (pcb->rcv_wnd != TCP_WND) {
 8006154:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006156:	f241 62d0 	movw	r2, #5840	; 0x16d0
 800615a:	4293      	cmp	r3, r2
        pcb->rcv_wnd++;
 800615c:	bf1c      	itt	ne
 800615e:	3301      	addne	r3, #1
 8006160:	85a3      	strhne	r3, [r4, #44]	; 0x2c
      TCP_EVENT_CLOSED(pcb, err);
 8006162:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
 8006166:	b1b6      	cbz	r6, 8006196 <tcp_process_refused_data+0x66>
 8006168:	2300      	movs	r3, #0
 800616a:	461a      	mov	r2, r3
 800616c:	4621      	mov	r1, r4
 800616e:	6920      	ldr	r0, [r4, #16]
 8006170:	47b0      	blx	r6
        return ERR_ABRT;
 8006172:	f110 0f0a 	cmn.w	r0, #10
 8006176:	bf08      	it	eq
 8006178:	4605      	moveq	r5, r0
 800617a:	e00c      	b.n	8006196 <tcp_process_refused_data+0x66>
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800617c:	2300      	movs	r3, #0
 800617e:	4632      	mov	r2, r6
 8006180:	4601      	mov	r1, r0
 8006182:	4618      	mov	r0, r3
 8006184:	f7ff ffc2 	bl	800610c <tcp_recv_null>
 8006188:	4605      	mov	r5, r0
 800618a:	e7df      	b.n	800614c <tcp_process_refused_data+0x1c>
  } else if (err == ERR_ABRT) {
 800618c:	f115 0f0a 	cmn.w	r5, #10
    pcb->refused_data = refused_data;
 8006190:	bf1c      	itt	ne
 8006192:	67a6      	strne	r6, [r4, #120]	; 0x78
  return ERR_OK;
 8006194:	2500      	movne	r5, #0
}
 8006196:	4628      	mov	r0, r5
 8006198:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800619c <tcp_fasttmr>:
{
 800619c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  ++tcp_timer_ctr;
 80061a0:	4a18      	ldr	r2, [pc, #96]	; (8006204 <tcp_fasttmr+0x68>)
 80061a2:	7813      	ldrb	r3, [r2, #0]
 80061a4:	3301      	adds	r3, #1
 80061a6:	7013      	strb	r3, [r2, #0]
  pcb = tcp_active_pcbs;
 80061a8:	4f17      	ldr	r7, [pc, #92]	; (8006208 <tcp_fasttmr+0x6c>)
    if (pcb->last_timer != tcp_timer_ctr) {
 80061aa:	4615      	mov	r5, r2
        tcp_active_pcbs_changed = 0;
 80061ac:	4e17      	ldr	r6, [pc, #92]	; (800620c <tcp_fasttmr+0x70>)
 80061ae:	f04f 0800 	mov.w	r8, #0
  pcb = tcp_active_pcbs;
 80061b2:	683c      	ldr	r4, [r7, #0]
  while(pcb != NULL) {
 80061b4:	b324      	cbz	r4, 8006200 <tcp_fasttmr+0x64>
    if (pcb->last_timer != tcp_timer_ctr) {
 80061b6:	782b      	ldrb	r3, [r5, #0]
 80061b8:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 80061bc:	429a      	cmp	r2, r3
 80061be:	d100      	bne.n	80061c2 <tcp_fasttmr+0x26>
 80061c0:	e7fe      	b.n	80061c0 <tcp_fasttmr+0x24>
      pcb->last_timer = tcp_timer_ctr;
 80061c2:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
      if (pcb->flags & TF_ACK_DELAY) {
 80061c6:	7fa3      	ldrb	r3, [r4, #30]
 80061c8:	f013 0f01 	tst.w	r3, #1
 80061cc:	d10d      	bne.n	80061ea <tcp_fasttmr+0x4e>
      next = pcb->next;
 80061ce:	f8d4 900c 	ldr.w	r9, [r4, #12]
      if (pcb->refused_data != NULL) {
 80061d2:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80061d4:	b13b      	cbz	r3, 80061e6 <tcp_fasttmr+0x4a>
        tcp_active_pcbs_changed = 0;
 80061d6:	f886 8000 	strb.w	r8, [r6]
        tcp_process_refused_data(pcb);
 80061da:	4620      	mov	r0, r4
 80061dc:	f7ff ffa8 	bl	8006130 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 80061e0:	7833      	ldrb	r3, [r6, #0]
 80061e2:	2b00      	cmp	r3, #0
 80061e4:	d1e5      	bne.n	80061b2 <tcp_fasttmr+0x16>
{
 80061e6:	464c      	mov	r4, r9
 80061e8:	e7e4      	b.n	80061b4 <tcp_fasttmr+0x18>
        tcp_ack_now(pcb);
 80061ea:	f043 0302 	orr.w	r3, r3, #2
 80061ee:	77a3      	strb	r3, [r4, #30]
        tcp_output(pcb);
 80061f0:	4620      	mov	r0, r4
 80061f2:	f001 fc7f 	bl	8007af4 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 80061f6:	7fa3      	ldrb	r3, [r4, #30]
 80061f8:	f023 0303 	bic.w	r3, r3, #3
 80061fc:	77a3      	strb	r3, [r4, #30]
 80061fe:	e7e6      	b.n	80061ce <tcp_fasttmr+0x32>
 8006200:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006204:	20007195 	.word	0x20007195
 8006208:	2000abe0 	.word	0x2000abe0
 800620c:	2000abdc 	.word	0x2000abdc

08006210 <tcp_tmr>:
{
 8006210:	b508      	push	{r3, lr}
  tcp_fasttmr();
 8006212:	f7ff ffc3 	bl	800619c <tcp_fasttmr>
  if (++tcp_timer & 1) {
 8006216:	4a06      	ldr	r2, [pc, #24]	; (8006230 <tcp_tmr+0x20>)
 8006218:	7813      	ldrb	r3, [r2, #0]
 800621a:	3301      	adds	r3, #1
 800621c:	b2db      	uxtb	r3, r3
 800621e:	7013      	strb	r3, [r2, #0]
 8006220:	f013 0f01 	tst.w	r3, #1
 8006224:	d100      	bne.n	8006228 <tcp_tmr+0x18>
 8006226:	bd08      	pop	{r3, pc}
    tcp_slowtmr();
 8006228:	f7ff fcb2 	bl	8005b90 <tcp_slowtmr>
}
 800622c:	e7fb      	b.n	8006226 <tcp_tmr+0x16>
 800622e:	bf00      	nop
 8006230:	20007194 	.word	0x20007194

08006234 <tcp_abandon>:
{
 8006234:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006238:	b083      	sub	sp, #12
 800623a:	4604      	mov	r4, r0
  if (pcb->state == TIME_WAIT) {
 800623c:	7e03      	ldrb	r3, [r0, #24]
 800623e:	2b0a      	cmp	r3, #10
 8006240:	d027      	beq.n	8006292 <tcp_abandon+0x5e>
 8006242:	460e      	mov	r6, r1
    seqno = pcb->snd_nxt;
 8006244:	f8d0 8050 	ldr.w	r8, [r0, #80]	; 0x50
    ackno = pcb->rcv_nxt;
 8006248:	f8d0 9028 	ldr.w	r9, [r0, #40]	; 0x28
    errf = pcb->errf;
 800624c:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
    errf_arg = pcb->callback_arg;
 8006250:	6907      	ldr	r7, [r0, #16]
    TCP_PCB_REMOVE_ACTIVE(pcb);
 8006252:	4601      	mov	r1, r0
 8006254:	4819      	ldr	r0, [pc, #100]	; (80062bc <tcp_abandon+0x88>)
 8006256:	f7ff fe49 	bl	8005eec <tcp_pcb_remove>
 800625a:	2201      	movs	r2, #1
 800625c:	4b18      	ldr	r3, [pc, #96]	; (80062c0 <tcp_abandon+0x8c>)
 800625e:	701a      	strb	r2, [r3, #0]
    if (pcb->unacked != NULL) {
 8006260:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8006262:	b108      	cbz	r0, 8006268 <tcp_abandon+0x34>
      tcp_segs_free(pcb->unacked);
 8006264:	f7ff fc53 	bl	8005b0e <tcp_segs_free>
    if (pcb->unsent != NULL) {
 8006268:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800626a:	b108      	cbz	r0, 8006270 <tcp_abandon+0x3c>
      tcp_segs_free(pcb->unsent);
 800626c:	f7ff fc4f 	bl	8005b0e <tcp_segs_free>
    if (pcb->ooseq != NULL) {
 8006270:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8006272:	b108      	cbz	r0, 8006278 <tcp_abandon+0x44>
      tcp_segs_free(pcb->ooseq);
 8006274:	f7ff fc4b 	bl	8005b0e <tcp_segs_free>
    if (reset) {
 8006278:	b9a6      	cbnz	r6, 80062a4 <tcp_abandon+0x70>
    memp_free(MEMP_TCP_PCB, pcb);
 800627a:	4621      	mov	r1, r4
 800627c:	2002      	movs	r0, #2
 800627e:	f7ff f903 	bl	8005488 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 8006282:	b11d      	cbz	r5, 800628c <tcp_abandon+0x58>
 8006284:	f06f 0109 	mvn.w	r1, #9
 8006288:	4638      	mov	r0, r7
 800628a:	47a8      	blx	r5
}
 800628c:	b003      	add	sp, #12
 800628e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 8006292:	4601      	mov	r1, r0
 8006294:	480b      	ldr	r0, [pc, #44]	; (80062c4 <tcp_abandon+0x90>)
 8006296:	f7ff fe29 	bl	8005eec <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 800629a:	4621      	mov	r1, r4
 800629c:	2002      	movs	r0, #2
 800629e:	f7ff f8f3 	bl	8005488 <memp_free>
 80062a2:	e7f3      	b.n	800628c <tcp_abandon+0x58>
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
 80062a4:	8ba3      	ldrh	r3, [r4, #28]
 80062a6:	9301      	str	r3, [sp, #4]
 80062a8:	8b63      	ldrh	r3, [r4, #26]
 80062aa:	9300      	str	r3, [sp, #0]
 80062ac:	1d23      	adds	r3, r4, #4
 80062ae:	4622      	mov	r2, r4
 80062b0:	4649      	mov	r1, r9
 80062b2:	4640      	mov	r0, r8
 80062b4:	f001 fd76 	bl	8007da4 <tcp_rst>
 80062b8:	e7df      	b.n	800627a <tcp_abandon+0x46>
 80062ba:	bf00      	nop
 80062bc:	2000abe0 	.word	0x2000abe0
 80062c0:	2000abdc 	.word	0x2000abdc
 80062c4:	2000abf4 	.word	0x2000abf4

080062c8 <tcp_abort>:
{
 80062c8:	b508      	push	{r3, lr}
  tcp_abandon(pcb, 1);
 80062ca:	2101      	movs	r1, #1
 80062cc:	f7ff ffb2 	bl	8006234 <tcp_abandon>
 80062d0:	bd08      	pop	{r3, pc}
	...

080062d4 <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 80062d4:	4b03      	ldr	r3, [pc, #12]	; (80062e4 <tcp_next_iss+0x10>)
 80062d6:	6818      	ldr	r0, [r3, #0]
 80062d8:	4a03      	ldr	r2, [pc, #12]	; (80062e8 <tcp_next_iss+0x14>)
 80062da:	6812      	ldr	r2, [r2, #0]
 80062dc:	4410      	add	r0, r2
 80062de:	6018      	str	r0, [r3, #0]
  return iss;
}
 80062e0:	4770      	bx	lr
 80062e2:	bf00      	nop
 80062e4:	20000148 	.word	0x20000148
 80062e8:	2000abe4 	.word	0x2000abe4

080062ec <tcp_alloc>:
{
 80062ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80062ee:	4605      	mov	r5, r0
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 80062f0:	2002      	movs	r0, #2
 80062f2:	f7ff f893 	bl	800541c <memp_malloc>
  if (pcb == NULL) {
 80062f6:	4604      	mov	r4, r0
 80062f8:	2800      	cmp	r0, #0
 80062fa:	d03b      	beq.n	8006374 <tcp_alloc+0x88>
    memset(pcb, 0, sizeof(struct tcp_pcb));
 80062fc:	2298      	movs	r2, #152	; 0x98
 80062fe:	2100      	movs	r1, #0
 8006300:	4620      	mov	r0, r4
 8006302:	f002 fdcf 	bl	8008ea4 <memset>
    pcb->prio = prio;
 8006306:	7665      	strb	r5, [r4, #25]
    pcb->snd_buf = TCP_SND_BUF;
 8006308:	f640 3368 	movw	r3, #2920	; 0xb68
 800630c:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
    pcb->snd_queuelen = 0;
 8006310:	2500      	movs	r5, #0
 8006312:	f8a4 5068 	strh.w	r5, [r4, #104]	; 0x68
    pcb->rcv_wnd = TCP_WND;
 8006316:	f241 63d0 	movw	r3, #5840	; 0x16d0
 800631a:	85a3      	strh	r3, [r4, #44]	; 0x2c
    pcb->rcv_ann_wnd = TCP_WND;
 800631c:	85e3      	strh	r3, [r4, #46]	; 0x2e
    pcb->tos = 0;
 800631e:	7265      	strb	r5, [r4, #9]
    pcb->ttl = TCP_TTL;
 8006320:	23ff      	movs	r3, #255	; 0xff
 8006322:	72a3      	strb	r3, [r4, #10]
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 8006324:	f44f 7306 	mov.w	r3, #536	; 0x218
 8006328:	86e3      	strh	r3, [r4, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 800632a:	2306      	movs	r3, #6
 800632c:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
    pcb->sa = 0;
 8006330:	f8a4 5040 	strh.w	r5, [r4, #64]	; 0x40
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 8006334:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
    pcb->rtime = -1;
 8006338:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800633c:	86a3      	strh	r3, [r4, #52]	; 0x34
    pcb->cwnd = 1;
 800633e:	2301      	movs	r3, #1
 8006340:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    iss = tcp_next_iss();
 8006344:	f7ff ffc6 	bl	80062d4 <tcp_next_iss>
    pcb->snd_wl2 = iss;
 8006348:	65a0      	str	r0, [r4, #88]	; 0x58
    pcb->snd_nxt = iss;
 800634a:	6520      	str	r0, [r4, #80]	; 0x50
    pcb->lastack = iss;
 800634c:	64a0      	str	r0, [r4, #72]	; 0x48
    pcb->snd_lbb = iss;   
 800634e:	65e0      	str	r0, [r4, #92]	; 0x5c
    pcb->tmr = tcp_ticks;
 8006350:	4b2c      	ldr	r3, [pc, #176]	; (8006404 <tcp_alloc+0x118>)
 8006352:	681b      	ldr	r3, [r3, #0]
 8006354:	6263      	str	r3, [r4, #36]	; 0x24
    pcb->last_timer = tcp_timer_ctr;
 8006356:	4b2c      	ldr	r3, [pc, #176]	; (8006408 <tcp_alloc+0x11c>)
 8006358:	781b      	ldrb	r3, [r3, #0]
 800635a:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    pcb->polltmr = 0;
 800635e:	77e5      	strb	r5, [r4, #31]
    pcb->recv = tcp_recv_null;
 8006360:	4b2a      	ldr	r3, [pc, #168]	; (800640c <tcp_alloc+0x120>)
 8006362:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 8006366:	4b2a      	ldr	r3, [pc, #168]	; (8006410 <tcp_alloc+0x124>)
 8006368:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    pcb->keep_cnt_sent = 0;
 800636c:	f884 5096 	strb.w	r5, [r4, #150]	; 0x96
}
 8006370:	4620      	mov	r0, r4
 8006372:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8006374:	4b27      	ldr	r3, [pc, #156]	; (8006414 <tcp_alloc+0x128>)
 8006376:	681b      	ldr	r3, [r3, #0]
 8006378:	b17b      	cbz	r3, 800639a <tcp_alloc+0xae>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800637a:	4a22      	ldr	r2, [pc, #136]	; (8006404 <tcp_alloc+0x118>)
 800637c:	6810      	ldr	r0, [r2, #0]
 800637e:	2100      	movs	r1, #0
 8006380:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006382:	1a82      	subs	r2, r0, r2
 8006384:	428a      	cmp	r2, r1
      inactivity = tcp_ticks - pcb->tmr;
 8006386:	bf24      	itt	cs
 8006388:	4611      	movcs	r1, r2
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800638a:	461c      	movcs	r4, r3
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800638c:	68db      	ldr	r3, [r3, #12]
 800638e:	2b00      	cmp	r3, #0
 8006390:	d1f6      	bne.n	8006380 <tcp_alloc+0x94>
  if (inactive != NULL) {
 8006392:	b114      	cbz	r4, 800639a <tcp_alloc+0xae>
    tcp_abort(inactive);
 8006394:	4620      	mov	r0, r4
 8006396:	f7ff ff97 	bl	80062c8 <tcp_abort>
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800639a:	2002      	movs	r0, #2
 800639c:	f7ff f83e 	bl	800541c <memp_malloc>
    if (pcb == NULL) {
 80063a0:	4604      	mov	r4, r0
 80063a2:	b130      	cbz	r0, 80063b2 <tcp_alloc+0xc6>
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 80063a4:	4a1c      	ldr	r2, [pc, #112]	; (8006418 <tcp_alloc+0x12c>)
 80063a6:	f8b2 30cc 	ldrh.w	r3, [r2, #204]	; 0xcc
 80063aa:	3b01      	subs	r3, #1
 80063ac:	f8a2 30cc 	strh.w	r3, [r2, #204]	; 0xcc
 80063b0:	e7a4      	b.n	80062fc <tcp_alloc+0x10>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80063b2:	4b1a      	ldr	r3, [pc, #104]	; (800641c <tcp_alloc+0x130>)
 80063b4:	681b      	ldr	r3, [r3, #0]
 80063b6:	b1bb      	cbz	r3, 80063e8 <tcp_alloc+0xfc>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80063b8:	4a12      	ldr	r2, [pc, #72]	; (8006404 <tcp_alloc+0x118>)
 80063ba:	6817      	ldr	r7, [r2, #0]
 80063bc:	2600      	movs	r6, #0
 80063be:	207f      	movs	r0, #127	; 0x7f
 80063c0:	e001      	b.n	80063c6 <tcp_alloc+0xda>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80063c2:	68db      	ldr	r3, [r3, #12]
 80063c4:	b163      	cbz	r3, 80063e0 <tcp_alloc+0xf4>
    if (pcb->prio <= prio &&
 80063c6:	7e5a      	ldrb	r2, [r3, #25]
 80063c8:	4295      	cmp	r5, r2
 80063ca:	d3fa      	bcc.n	80063c2 <tcp_alloc+0xd6>
 80063cc:	4282      	cmp	r2, r0
 80063ce:	d8f8      	bhi.n	80063c2 <tcp_alloc+0xd6>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80063d0:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80063d2:	1a79      	subs	r1, r7, r1
       pcb->prio <= mprio &&
 80063d4:	42b1      	cmp	r1, r6
 80063d6:	d3f4      	bcc.n	80063c2 <tcp_alloc+0xd6>
      mprio = pcb->prio;
 80063d8:	4610      	mov	r0, r2
      inactivity = tcp_ticks - pcb->tmr;
 80063da:	460e      	mov	r6, r1
       pcb->prio <= mprio &&
 80063dc:	461c      	mov	r4, r3
 80063de:	e7f0      	b.n	80063c2 <tcp_alloc+0xd6>
  if (inactive != NULL) {
 80063e0:	b114      	cbz	r4, 80063e8 <tcp_alloc+0xfc>
    tcp_abort(inactive);
 80063e2:	4620      	mov	r0, r4
 80063e4:	f7ff ff70 	bl	80062c8 <tcp_abort>
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 80063e8:	2002      	movs	r0, #2
 80063ea:	f7ff f817 	bl	800541c <memp_malloc>
      if (pcb != NULL) {
 80063ee:	4604      	mov	r4, r0
 80063f0:	2800      	cmp	r0, #0
 80063f2:	d0bd      	beq.n	8006370 <tcp_alloc+0x84>
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 80063f4:	4a08      	ldr	r2, [pc, #32]	; (8006418 <tcp_alloc+0x12c>)
 80063f6:	f8b2 30cc 	ldrh.w	r3, [r2, #204]	; 0xcc
 80063fa:	3b01      	subs	r3, #1
 80063fc:	f8a2 30cc 	strh.w	r3, [r2, #204]	; 0xcc
 8006400:	e7d0      	b.n	80063a4 <tcp_alloc+0xb8>
 8006402:	bf00      	nop
 8006404:	2000abe4 	.word	0x2000abe4
 8006408:	20007195 	.word	0x20007195
 800640c:	0800610d 	.word	0x0800610d
 8006410:	006ddd00 	.word	0x006ddd00
 8006414:	2000abf4 	.word	0x2000abf4
 8006418:	2000aac4 	.word	0x2000aac4
 800641c:	2000abe0 	.word	0x2000abe0

08006420 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
 8006420:	b510      	push	{r4, lr}
 8006422:	4604      	mov	r4, r0
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
 8006424:	4608      	mov	r0, r1
 8006426:	f7fe f8bb 	bl	80045a0 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
 800642a:	b138      	cbz	r0, 800643c <tcp_eff_send_mss+0x1c>
 800642c:	8c00      	ldrh	r0, [r0, #32]
 800642e:	b138      	cbz	r0, 8006440 <tcp_eff_send_mss+0x20>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
 8006430:	3828      	subs	r0, #40	; 0x28
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 8006432:	b280      	uxth	r0, r0
 8006434:	42a0      	cmp	r0, r4
 8006436:	bf28      	it	cs
 8006438:	4620      	movcs	r0, r4
 800643a:	bd10      	pop	{r4, pc}
 800643c:	4620      	mov	r0, r4
 800643e:	bd10      	pop	{r4, pc}
 8006440:	4620      	mov	r0, r4
  }
  return sendmss;
}
 8006442:	bd10      	pop	{r4, pc}

08006444 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 8006444:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006446:	4605      	mov	r5, r0
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 8006448:	4b22      	ldr	r3, [pc, #136]	; (80064d4 <tcp_parseopt+0x90>)
 800644a:	681c      	ldr	r4, [r3, #0]

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
 800644c:	89a0      	ldrh	r0, [r4, #12]
 800644e:	f7fd fe9c 	bl	800418a <lwip_ntohs>
 8006452:	f3c0 300f 	ubfx	r0, r0, #12, #16
 8006456:	2805      	cmp	r0, #5
 8006458:	d800      	bhi.n	800645c <tcp_parseopt+0x18>
 800645a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 800645c:	4b1d      	ldr	r3, [pc, #116]	; (80064d4 <tcp_parseopt+0x90>)
 800645e:	681b      	ldr	r3, [r3, #0]
 8006460:	8998      	ldrh	r0, [r3, #12]
 8006462:	f7fd fe92 	bl	800418a <lwip_ntohs>
 8006466:	0b06      	lsrs	r6, r0, #12
 8006468:	3e05      	subs	r6, #5
 800646a:	00b6      	lsls	r6, r6, #2
 800646c:	b2b6      	uxth	r6, r6
    for (c = 0; c < max_c; ) {
 800646e:	2e00      	cmp	r6, #0
 8006470:	d0f3      	beq.n	800645a <tcp_parseopt+0x16>
  opts = (u8_t *)tcphdr + TCP_HLEN;
 8006472:	f104 0214 	add.w	r2, r4, #20
 8006476:	2300      	movs	r3, #0
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 8006478:	f240 57b3 	movw	r7, #1459	; 0x5b3
 800647c:	f240 54b4 	movw	r4, #1460	; 0x5b4
 8006480:	e003      	b.n	800648a <tcp_parseopt+0x46>
        ++c;
 8006482:	3301      	adds	r3, #1
 8006484:	b29b      	uxth	r3, r3
    for (c = 0; c < max_c; ) {
 8006486:	429e      	cmp	r6, r3
 8006488:	d9e7      	bls.n	800645a <tcp_parseopt+0x16>
      opt = opts[c];
 800648a:	4618      	mov	r0, r3
      switch (opt) {
 800648c:	5cd1      	ldrb	r1, [r2, r3]
 800648e:	2901      	cmp	r1, #1
 8006490:	d0f7      	beq.n	8006482 <tcp_parseopt+0x3e>
 8006492:	2900      	cmp	r1, #0
 8006494:	d0e1      	beq.n	800645a <tcp_parseopt+0x16>
 8006496:	2902      	cmp	r1, #2
 8006498:	d006      	beq.n	80064a8 <tcp_parseopt+0x64>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
 800649a:	4410      	add	r0, r2
 800649c:	7841      	ldrb	r1, [r0, #1]
 800649e:	2900      	cmp	r1, #0
 80064a0:	d0db      	beq.n	800645a <tcp_parseopt+0x16>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
 80064a2:	440b      	add	r3, r1
 80064a4:	b29b      	uxth	r3, r3
 80064a6:	e7ee      	b.n	8006486 <tcp_parseopt+0x42>
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
 80064a8:	18d1      	adds	r1, r2, r3
 80064aa:	7849      	ldrb	r1, [r1, #1]
 80064ac:	2904      	cmp	r1, #4
 80064ae:	d1d4      	bne.n	800645a <tcp_parseopt+0x16>
 80064b0:	1d19      	adds	r1, r3, #4
 80064b2:	42b1      	cmp	r1, r6
 80064b4:	dcd1      	bgt.n	800645a <tcp_parseopt+0x16>
        mss = (opts[c + 2] << 8) | opts[c + 3];
 80064b6:	4410      	add	r0, r2
 80064b8:	f890 e002 	ldrb.w	lr, [r0, #2]
 80064bc:	78c1      	ldrb	r1, [r0, #3]
 80064be:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 80064c2:	1e48      	subs	r0, r1, #1
 80064c4:	b280      	uxth	r0, r0
 80064c6:	42b8      	cmp	r0, r7
 80064c8:	bf88      	it	hi
 80064ca:	4621      	movhi	r1, r4
 80064cc:	86e9      	strh	r1, [r5, #54]	; 0x36
        c += 0x04;
 80064ce:	3304      	adds	r3, #4
 80064d0:	b29b      	uxth	r3, r3
        break;
 80064d2:	e7d8      	b.n	8006486 <tcp_parseopt+0x42>
 80064d4:	200071bc 	.word	0x200071bc

080064d8 <tcp_oos_insert_segment>:
{
 80064d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80064dc:	4605      	mov	r5, r0
 80064de:	4688      	mov	r8, r1
  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 80064e0:	68c3      	ldr	r3, [r0, #12]
 80064e2:	8998      	ldrh	r0, [r3, #12]
 80064e4:	f7fd fe51 	bl	800418a <lwip_ntohs>
 80064e8:	f010 0f01 	tst.w	r0, #1
 80064ec:	d114      	bne.n	8006518 <tcp_oos_insert_segment+0x40>
    while (next &&
 80064ee:	f1b8 0f00 	cmp.w	r8, #0
 80064f2:	d04a      	beq.n	800658a <tcp_oos_insert_segment+0xb2>
           TCP_SEQ_GEQ((seqno + cseg->len),
 80064f4:	f8d8 200c 	ldr.w	r2, [r8, #12]
 80064f8:	892b      	ldrh	r3, [r5, #8]
 80064fa:	6851      	ldr	r1, [r2, #4]
 80064fc:	1a5b      	subs	r3, r3, r1
 80064fe:	4924      	ldr	r1, [pc, #144]	; (8006590 <tcp_oos_insert_segment+0xb8>)
 8006500:	6809      	ldr	r1, [r1, #0]
 8006502:	440b      	add	r3, r1
 8006504:	f8b8 1008 	ldrh.w	r1, [r8, #8]
 8006508:	1a5b      	subs	r3, r3, r1
    while (next &&
 800650a:	2b00      	cmp	r3, #0
 800650c:	bfb8      	it	lt
 800650e:	4644      	movlt	r4, r8
 8006510:	db29      	blt.n	8006566 <tcp_oos_insert_segment+0x8e>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 8006512:	2701      	movs	r7, #1
           TCP_SEQ_GEQ((seqno + cseg->len),
 8006514:	4e1e      	ldr	r6, [pc, #120]	; (8006590 <tcp_oos_insert_segment+0xb8>)
 8006516:	e015      	b.n	8006544 <tcp_oos_insert_segment+0x6c>
    tcp_segs_free(next);
 8006518:	4640      	mov	r0, r8
 800651a:	f7ff faf8 	bl	8005b0e <tcp_segs_free>
    next = NULL;
 800651e:	2400      	movs	r4, #0
 8006520:	e030      	b.n	8006584 <tcp_oos_insert_segment+0xac>
      next = next->next;
 8006522:	f8d8 4000 	ldr.w	r4, [r8]
      tcp_seg_free(old_seg);
 8006526:	4640      	mov	r0, r8
 8006528:	f7ff fae4 	bl	8005af4 <tcp_seg_free>
    while (next &&
 800652c:	b36c      	cbz	r4, 800658a <tcp_oos_insert_segment+0xb2>
           TCP_SEQ_GEQ((seqno + cseg->len),
 800652e:	68e2      	ldr	r2, [r4, #12]
 8006530:	892b      	ldrh	r3, [r5, #8]
 8006532:	6831      	ldr	r1, [r6, #0]
 8006534:	440b      	add	r3, r1
 8006536:	6851      	ldr	r1, [r2, #4]
 8006538:	1a5b      	subs	r3, r3, r1
 800653a:	8921      	ldrh	r1, [r4, #8]
 800653c:	1a5b      	subs	r3, r3, r1
    while (next &&
 800653e:	2b00      	cmp	r3, #0
 8006540:	db11      	blt.n	8006566 <tcp_oos_insert_segment+0x8e>
      next = next->next;
 8006542:	46a0      	mov	r8, r4
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 8006544:	8990      	ldrh	r0, [r2, #12]
 8006546:	f7fd fe20 	bl	800418a <lwip_ntohs>
 800654a:	f010 0f01 	tst.w	r0, #1
 800654e:	d0e8      	beq.n	8006522 <tcp_oos_insert_segment+0x4a>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 8006550:	f8d5 900c 	ldr.w	r9, [r5, #12]
 8006554:	f8b9 400c 	ldrh.w	r4, [r9, #12]
 8006558:	4638      	mov	r0, r7
 800655a:	f7fd fe11 	bl	8004180 <lwip_htons>
 800655e:	4320      	orrs	r0, r4
 8006560:	f8a9 000c 	strh.w	r0, [r9, #12]
 8006564:	e7dd      	b.n	8006522 <tcp_oos_insert_segment+0x4a>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 8006566:	4b0a      	ldr	r3, [pc, #40]	; (8006590 <tcp_oos_insert_segment+0xb8>)
 8006568:	6819      	ldr	r1, [r3, #0]
 800656a:	68e3      	ldr	r3, [r4, #12]
 800656c:	685a      	ldr	r2, [r3, #4]
 800656e:	892b      	ldrh	r3, [r5, #8]
 8006570:	440b      	add	r3, r1
 8006572:	1a9b      	subs	r3, r3, r2
    if (next &&
 8006574:	2b00      	cmp	r3, #0
 8006576:	dd05      	ble.n	8006584 <tcp_oos_insert_segment+0xac>
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 8006578:	1a52      	subs	r2, r2, r1
 800657a:	b291      	uxth	r1, r2
 800657c:	8129      	strh	r1, [r5, #8]
      pbuf_realloc(cseg->p, cseg->len);
 800657e:	6868      	ldr	r0, [r5, #4]
 8006580:	f7ff f940 	bl	8005804 <pbuf_realloc>
  cseg->next = next;
 8006584:	602c      	str	r4, [r5, #0]
}
 8006586:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    next = NULL;
 800658a:	2400      	movs	r4, #0
 800658c:	e7fa      	b.n	8006584 <tcp_oos_insert_segment+0xac>
 800658e:	bf00      	nop
 8006590:	200071b8 	.word	0x200071b8

08006594 <tcp_receive>:
{
 8006594:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006598:	4604      	mov	r4, r0
  if (flags & TCP_ACK) {
 800659a:	4bae      	ldr	r3, [pc, #696]	; (8006854 <tcp_receive+0x2c0>)
 800659c:	781b      	ldrb	r3, [r3, #0]
 800659e:	f013 0f10 	tst.w	r3, #16
 80065a2:	f000 8169 	beq.w	8006878 <tcp_receive+0x2e4>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 80065a6:	7e00      	ldrb	r0, [r0, #24]
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 80065a8:	f8b4 6060 	ldrh.w	r6, [r4, #96]	; 0x60
 80065ac:	6da5      	ldr	r5, [r4, #88]	; 0x58
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 80065ae:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80065b0:	4ba9      	ldr	r3, [pc, #676]	; (8006858 <tcp_receive+0x2c4>)
 80065b2:	681b      	ldr	r3, [r3, #0]
 80065b4:	1ad1      	subs	r1, r2, r3
 80065b6:	2900      	cmp	r1, #0
 80065b8:	db26      	blt.n	8006608 <tcp_receive+0x74>
 80065ba:	429a      	cmp	r2, r3
 80065bc:	d019      	beq.n	80065f2 <tcp_receive+0x5e>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 80065be:	4aa7      	ldr	r2, [pc, #668]	; (800685c <tcp_receive+0x2c8>)
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 80065c0:	6812      	ldr	r2, [r2, #0]
 80065c2:	4295      	cmp	r5, r2
 80065c4:	d01b      	beq.n	80065fe <tcp_receive+0x6a>
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 80065c6:	4ba5      	ldr	r3, [pc, #660]	; (800685c <tcp_receive+0x2c8>)
 80065c8:	681a      	ldr	r2, [r3, #0]
 80065ca:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80065cc:	1ad1      	subs	r1, r2, r3
 80065ce:	2900      	cmp	r1, #0
 80065d0:	dd3f      	ble.n	8006652 <tcp_receive+0xbe>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
 80065d2:	2901      	cmp	r1, #1
 80065d4:	d403      	bmi.n	80065de <tcp_receive+0x4a>
 80065d6:	6d21      	ldr	r1, [r4, #80]	; 0x50
 80065d8:	1a51      	subs	r1, r2, r1
 80065da:	2900      	cmp	r1, #0
 80065dc:	dd6c      	ble.n	80066b8 <tcp_receive+0x124>
      pcb->acked = 0;
 80065de:	2300      	movs	r3, #0
 80065e0:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    while (pcb->unsent != NULL &&
 80065e4:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80065e6:	2b00      	cmp	r3, #0
 80065e8:	f000 813e 	beq.w	8006868 <tcp_receive+0x2d4>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 80065ec:	4e9b      	ldr	r6, [pc, #620]	; (800685c <tcp_receive+0x2c8>)
        pcb->unsent_oversize = 0;
 80065ee:	2700      	movs	r7, #0
 80065f0:	e0fa      	b.n	80067e8 <tcp_receive+0x254>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 80065f2:	4a9a      	ldr	r2, [pc, #616]	; (800685c <tcp_receive+0x2c8>)
 80065f4:	6812      	ldr	r2, [r2, #0]
 80065f6:	1aaa      	subs	r2, r5, r2
 80065f8:	2a00      	cmp	r2, #0
 80065fa:	dae0      	bge.n	80065be <tcp_receive+0x2a>
 80065fc:	e004      	b.n	8006608 <tcp_receive+0x74>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 80065fe:	4a98      	ldr	r2, [pc, #608]	; (8006860 <tcp_receive+0x2cc>)
 8006600:	6812      	ldr	r2, [r2, #0]
 8006602:	89d2      	ldrh	r2, [r2, #14]
 8006604:	42b2      	cmp	r2, r6
 8006606:	d9de      	bls.n	80065c6 <tcp_receive+0x32>
      pcb->snd_wnd = tcphdr->wnd;
 8006608:	4a95      	ldr	r2, [pc, #596]	; (8006860 <tcp_receive+0x2cc>)
 800660a:	6812      	ldr	r2, [r2, #0]
 800660c:	89d1      	ldrh	r1, [r2, #14]
 800660e:	b28f      	uxth	r7, r1
 8006610:	f8a4 1060 	strh.w	r1, [r4, #96]	; 0x60
      if (pcb->snd_wnd_max < tcphdr->wnd) {
 8006614:	89d2      	ldrh	r2, [r2, #14]
 8006616:	b291      	uxth	r1, r2
 8006618:	f8b4 e062 	ldrh.w	lr, [r4, #98]	; 0x62
 800661c:	458e      	cmp	lr, r1
        pcb->snd_wnd_max = tcphdr->wnd;
 800661e:	bf38      	it	cc
 8006620:	f8a4 2062 	strhcc.w	r2, [r4, #98]	; 0x62
      pcb->snd_wl1 = seqno;
 8006624:	6563      	str	r3, [r4, #84]	; 0x54
      pcb->snd_wl2 = ackno;
 8006626:	4b8d      	ldr	r3, [pc, #564]	; (800685c <tcp_receive+0x2c8>)
 8006628:	681b      	ldr	r3, [r3, #0]
 800662a:	65a3      	str	r3, [r4, #88]	; 0x58
      if (pcb->snd_wnd == 0) {
 800662c:	b94f      	cbnz	r7, 8006642 <tcp_receive+0xae>
        if (pcb->persist_backoff == 0) {
 800662e:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
 8006632:	2b00      	cmp	r3, #0
 8006634:	d1c7      	bne.n	80065c6 <tcp_receive+0x32>
          pcb->persist_cnt = 0;
 8006636:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
          pcb->persist_backoff = 1;
 800663a:	2301      	movs	r3, #1
 800663c:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
 8006640:	e7c1      	b.n	80065c6 <tcp_receive+0x32>
      } else if (pcb->persist_backoff > 0) {
 8006642:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
 8006646:	2b00      	cmp	r3, #0
 8006648:	d0bd      	beq.n	80065c6 <tcp_receive+0x32>
          pcb->persist_backoff = 0;
 800664a:	2300      	movs	r3, #0
 800664c:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
 8006650:	e7b9      	b.n	80065c6 <tcp_receive+0x32>
      pcb->acked = 0;
 8006652:	2100      	movs	r1, #0
 8006654:	f8a4 1064 	strh.w	r1, [r4, #100]	; 0x64
      if (tcplen == 0) {
 8006658:	4982      	ldr	r1, [pc, #520]	; (8006864 <tcp_receive+0x2d0>)
 800665a:	8809      	ldrh	r1, [r1, #0]
 800665c:	b931      	cbnz	r1, 800666c <tcp_receive+0xd8>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 800665e:	4435      	add	r5, r6
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
 8006660:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
 8006664:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8006666:	4401      	add	r1, r0
 8006668:	428d      	cmp	r5, r1
 800666a:	d003      	beq.n	8006674 <tcp_receive+0xe0>
        pcb->dupacks = 0;
 800666c:	2300      	movs	r3, #0
 800666e:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
 8006672:	e7b7      	b.n	80065e4 <tcp_receive+0x50>
          if (pcb->rtime >= 0) {
 8006674:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
 8006678:	2900      	cmp	r1, #0
 800667a:	dbf7      	blt.n	800666c <tcp_receive+0xd8>
            if (pcb->lastack == ackno) {
 800667c:	429a      	cmp	r2, r3
 800667e:	d1f5      	bne.n	800666c <tcp_receive+0xd8>
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 8006680:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
 8006684:	1c53      	adds	r3, r2, #1
 8006686:	b2db      	uxtb	r3, r3
 8006688:	429a      	cmp	r2, r3
                ++pcb->dupacks;
 800668a:	bf38      	it	cc
 800668c:	f884 3047 	strbcc.w	r3, [r4, #71]	; 0x47
              if (pcb->dupacks > 3) {
 8006690:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
 8006694:	2b03      	cmp	r3, #3
 8006696:	d909      	bls.n	80066ac <tcp_receive+0x118>
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 8006698:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 800669c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800669e:	4413      	add	r3, r2
 80066a0:	b29b      	uxth	r3, r3
 80066a2:	429a      	cmp	r2, r3
 80066a4:	d29e      	bcs.n	80065e4 <tcp_receive+0x50>
                  pcb->cwnd += pcb->mss;
 80066a6:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 80066aa:	e79b      	b.n	80065e4 <tcp_receive+0x50>
              } else if (pcb->dupacks == 3) {
 80066ac:	2b03      	cmp	r3, #3
 80066ae:	d199      	bne.n	80065e4 <tcp_receive+0x50>
                tcp_rexmit_fast(pcb);
 80066b0:	4620      	mov	r0, r4
 80066b2:	f001 fc0b 	bl	8007ecc <tcp_rexmit_fast>
 80066b6:	e795      	b.n	80065e4 <tcp_receive+0x50>
      if (pcb->flags & TF_INFR) {
 80066b8:	7fa1      	ldrb	r1, [r4, #30]
 80066ba:	f011 0f04 	tst.w	r1, #4
 80066be:	d006      	beq.n	80066ce <tcp_receive+0x13a>
        pcb->flags &= ~TF_INFR;
 80066c0:	f021 0104 	bic.w	r1, r1, #4
 80066c4:	77a1      	strb	r1, [r4, #30]
        pcb->cwnd = pcb->ssthresh;
 80066c6:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
 80066ca:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
      pcb->nrtx = 0;
 80066ce:	2500      	movs	r5, #0
 80066d0:	f884 5046 	strb.w	r5, [r4, #70]	; 0x46
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 80066d4:	f9b4 6040 	ldrsh.w	r6, [r4, #64]	; 0x40
 80066d8:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
 80066dc:	eb01 01e6 	add.w	r1, r1, r6, asr #3
 80066e0:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 80066e4:	1ad3      	subs	r3, r2, r3
 80066e6:	b29b      	uxth	r3, r3
 80066e8:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
      pcb->snd_buf += pcb->acked;
 80066ec:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
 80066f0:	440b      	add	r3, r1
 80066f2:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
      pcb->dupacks = 0;
 80066f6:	f884 5047 	strb.w	r5, [r4, #71]	; 0x47
      pcb->lastack = ackno;
 80066fa:	64a2      	str	r2, [r4, #72]	; 0x48
      if (pcb->state >= ESTABLISHED) {
 80066fc:	2803      	cmp	r0, #3
 80066fe:	d918      	bls.n	8006732 <tcp_receive+0x19e>
        if (pcb->cwnd < pcb->ssthresh) {
 8006700:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 8006704:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 8006708:	4293      	cmp	r3, r2
 800670a:	d907      	bls.n	800671c <tcp_receive+0x188>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 800670c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800670e:	4413      	add	r3, r2
 8006710:	b29b      	uxth	r3, r3
 8006712:	429a      	cmp	r2, r3
 8006714:	d20d      	bcs.n	8006732 <tcp_receive+0x19e>
            pcb->cwnd += pcb->mss;
 8006716:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 800671a:	e00a      	b.n	8006732 <tcp_receive+0x19e>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 800671c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800671e:	fb03 f303 	mul.w	r3, r3, r3
 8006722:	fb93 f3f2 	sdiv	r3, r3, r2
 8006726:	4413      	add	r3, r2
 8006728:	b29b      	uxth	r3, r3
          if (new_cwnd > pcb->cwnd) {
 800672a:	429a      	cmp	r2, r3
            pcb->cwnd = new_cwnd;
 800672c:	bf38      	it	cc
 800672e:	f8a4 304c 	strhcc.w	r3, [r4, #76]	; 0x4c
      while (pcb->unacked != NULL &&
 8006732:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8006734:	2b00      	cmp	r3, #0
 8006736:	d042      	beq.n	80067be <tcp_receive+0x22a>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 8006738:	4e48      	ldr	r6, [pc, #288]	; (800685c <tcp_receive+0x2c8>)
 800673a:	e00d      	b.n	8006758 <tcp_receive+0x1c4>
        pcb->snd_queuelen -= pbuf_clen(next->p);
 800673c:	6868      	ldr	r0, [r5, #4]
 800673e:	f7ff f88c 	bl	800585a <pbuf_clen>
 8006742:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8006746:	1a18      	subs	r0, r3, r0
 8006748:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
        tcp_seg_free(next);
 800674c:	4628      	mov	r0, r5
 800674e:	f7ff f9d1 	bl	8005af4 <tcp_seg_free>
      while (pcb->unacked != NULL &&
 8006752:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8006754:	2b00      	cmp	r3, #0
 8006756:	d032      	beq.n	80067be <tcp_receive+0x22a>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 8006758:	68db      	ldr	r3, [r3, #12]
 800675a:	6858      	ldr	r0, [r3, #4]
 800675c:	f7fd fd26 	bl	80041ac <lwip_ntohl>
 8006760:	4605      	mov	r5, r0
 8006762:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8006764:	891f      	ldrh	r7, [r3, #8]
 8006766:	68db      	ldr	r3, [r3, #12]
 8006768:	8998      	ldrh	r0, [r3, #12]
 800676a:	f7fd fd0e 	bl	800418a <lwip_ntohs>
 800676e:	f010 0003 	ands.w	r0, r0, #3
 8006772:	bf18      	it	ne
 8006774:	2001      	movne	r0, #1
 8006776:	4438      	add	r0, r7
 8006778:	6833      	ldr	r3, [r6, #0]
 800677a:	1aed      	subs	r5, r5, r3
 800677c:	4428      	add	r0, r5
      while (pcb->unacked != NULL &&
 800677e:	2800      	cmp	r0, #0
 8006780:	dc16      	bgt.n	80067b0 <tcp_receive+0x21c>
        next = pcb->unacked;
 8006782:	6f25      	ldr	r5, [r4, #112]	; 0x70
        pcb->unacked = pcb->unacked->next;
 8006784:	682b      	ldr	r3, [r5, #0]
 8006786:	6723      	str	r3, [r4, #112]	; 0x70
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 8006788:	6868      	ldr	r0, [r5, #4]
 800678a:	f7ff f866 	bl	800585a <pbuf_clen>
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 800678e:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8006792:	2b00      	cmp	r3, #0
 8006794:	d0d2      	beq.n	800673c <tcp_receive+0x1a8>
 8006796:	68eb      	ldr	r3, [r5, #12]
 8006798:	8998      	ldrh	r0, [r3, #12]
 800679a:	f7fd fcf6 	bl	800418a <lwip_ntohs>
 800679e:	f010 0f01 	tst.w	r0, #1
 80067a2:	d0cb      	beq.n	800673c <tcp_receive+0x1a8>
          pcb->acked--;
 80067a4:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 80067a8:	3b01      	subs	r3, #1
 80067aa:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 80067ae:	e7c5      	b.n	800673c <tcp_receive+0x1a8>
      if(pcb->unacked == NULL)
 80067b0:	6f23      	ldr	r3, [r4, #112]	; 0x70
 80067b2:	b123      	cbz	r3, 80067be <tcp_receive+0x22a>
        pcb->rtime = 0;
 80067b4:	2300      	movs	r3, #0
 80067b6:	86a3      	strh	r3, [r4, #52]	; 0x34
      pcb->polltmr = 0;
 80067b8:	2300      	movs	r3, #0
 80067ba:	77e3      	strb	r3, [r4, #31]
 80067bc:	e712      	b.n	80065e4 <tcp_receive+0x50>
        pcb->rtime = -1;
 80067be:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80067c2:	86a3      	strh	r3, [r4, #52]	; 0x34
 80067c4:	e7f8      	b.n	80067b8 <tcp_receive+0x224>
        pcb->unsent_oversize = 0;
 80067c6:	f8a4 706a 	strh.w	r7, [r4, #106]	; 0x6a
 80067ca:	e02e      	b.n	800682a <tcp_receive+0x296>
      pcb->snd_queuelen -= pbuf_clen(next->p);
 80067cc:	6868      	ldr	r0, [r5, #4]
 80067ce:	f7ff f844 	bl	800585a <pbuf_clen>
 80067d2:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 80067d6:	1a18      	subs	r0, r3, r0
 80067d8:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
      tcp_seg_free(next);
 80067dc:	4628      	mov	r0, r5
 80067de:	f7ff f989 	bl	8005af4 <tcp_seg_free>
    while (pcb->unsent != NULL &&
 80067e2:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80067e4:	2b00      	cmp	r3, #0
 80067e6:	d03f      	beq.n	8006868 <tcp_receive+0x2d4>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 80067e8:	6835      	ldr	r5, [r6, #0]
 80067ea:	68db      	ldr	r3, [r3, #12]
 80067ec:	6858      	ldr	r0, [r3, #4]
 80067ee:	f7fd fcdd 	bl	80041ac <lwip_ntohl>
 80067f2:	4681      	mov	r9, r0
 80067f4:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80067f6:	f8b3 8008 	ldrh.w	r8, [r3, #8]
 80067fa:	68db      	ldr	r3, [r3, #12]
 80067fc:	8998      	ldrh	r0, [r3, #12]
 80067fe:	f7fd fcc4 	bl	800418a <lwip_ntohs>
 8006802:	eba5 0509 	sub.w	r5, r5, r9
 8006806:	f010 0003 	ands.w	r0, r0, #3
 800680a:	bf18      	it	ne
 800680c:	2001      	movne	r0, #1
 800680e:	4440      	add	r0, r8
 8006810:	1a2d      	subs	r5, r5, r0
    while (pcb->unsent != NULL &&
 8006812:	2d00      	cmp	r5, #0
 8006814:	db28      	blt.n	8006868 <tcp_receive+0x2d4>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 8006816:	6833      	ldr	r3, [r6, #0]
 8006818:	6d22      	ldr	r2, [r4, #80]	; 0x50
 800681a:	1a9b      	subs	r3, r3, r2
 800681c:	2b00      	cmp	r3, #0
 800681e:	dc23      	bgt.n	8006868 <tcp_receive+0x2d4>
      next = pcb->unsent;
 8006820:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
      pcb->unsent = pcb->unsent->next;
 8006822:	682b      	ldr	r3, [r5, #0]
 8006824:	66e3      	str	r3, [r4, #108]	; 0x6c
      if (pcb->unsent == NULL) {
 8006826:	2b00      	cmp	r3, #0
 8006828:	d0cd      	beq.n	80067c6 <tcp_receive+0x232>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 800682a:	6868      	ldr	r0, [r5, #4]
 800682c:	f7ff f815 	bl	800585a <pbuf_clen>
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 8006830:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8006834:	2b00      	cmp	r3, #0
 8006836:	d0c9      	beq.n	80067cc <tcp_receive+0x238>
 8006838:	68eb      	ldr	r3, [r5, #12]
 800683a:	8998      	ldrh	r0, [r3, #12]
 800683c:	f7fd fca5 	bl	800418a <lwip_ntohs>
 8006840:	f010 0f01 	tst.w	r0, #1
 8006844:	d0c2      	beq.n	80067cc <tcp_receive+0x238>
        pcb->acked--;
 8006846:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 800684a:	3b01      	subs	r3, #1
 800684c:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 8006850:	e7bc      	b.n	80067cc <tcp_receive+0x238>
 8006852:	bf00      	nop
 8006854:	2000719c 	.word	0x2000719c
 8006858:	200071b8 	.word	0x200071b8
 800685c:	20007198 	.word	0x20007198
 8006860:	200071bc 	.word	0x200071bc
 8006864:	200071c0 	.word	0x200071c0
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 8006868:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800686a:	b12b      	cbz	r3, 8006878 <tcp_receive+0x2e4>
 800686c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800686e:	49a1      	ldr	r1, [pc, #644]	; (8006af4 <tcp_receive+0x560>)
 8006870:	6809      	ldr	r1, [r1, #0]
 8006872:	1a52      	subs	r2, r2, r1
 8006874:	2a00      	cmp	r2, #0
 8006876:	db23      	blt.n	80068c0 <tcp_receive+0x32c>
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 8006878:	4b9f      	ldr	r3, [pc, #636]	; (8006af8 <tcp_receive+0x564>)
 800687a:	881b      	ldrh	r3, [r3, #0]
 800687c:	2b00      	cmp	r3, #0
 800687e:	f000 8256 	beq.w	8006d2e <tcp_receive+0x79a>
 8006882:	7e22      	ldrb	r2, [r4, #24]
 8006884:	2a06      	cmp	r2, #6
 8006886:	f200 8252 	bhi.w	8006d2e <tcp_receive+0x79a>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
 800688a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800688c:	4a9b      	ldr	r2, [pc, #620]	; (8006afc <tcp_receive+0x568>)
 800688e:	6812      	ldr	r2, [r2, #0]
 8006890:	1a8d      	subs	r5, r1, r2
 8006892:	2d01      	cmp	r5, #1
 8006894:	d405      	bmi.n	80068a2 <tcp_receive+0x30e>
 8006896:	f1c2 0001 	rsb	r0, r2, #1
 800689a:	1ac3      	subs	r3, r0, r3
 800689c:	440b      	add	r3, r1
 800689e:	2b00      	cmp	r3, #0
 80068a0:	dd2e      	ble.n	8006900 <tcp_receive+0x36c>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
 80068a2:	1a53      	subs	r3, r2, r1
 80068a4:	2b00      	cmp	r3, #0
 80068a6:	db55      	blt.n	8006954 <tcp_receive+0x3c0>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 80068a8:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 80068aa:	f1c3 0301 	rsb	r3, r3, #1
 80068ae:	4413      	add	r3, r2
 80068b0:	1a5b      	subs	r3, r3, r1
 80068b2:	2b00      	cmp	r3, #0
 80068b4:	dd53      	ble.n	800695e <tcp_receive+0x3ca>
      tcp_send_empty_ack(pcb);
 80068b6:	4620      	mov	r0, r4
 80068b8:	f001 f8ec 	bl	8007a94 <tcp_send_empty_ack>
 80068bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      m = m - (pcb->sa >> 3);
 80068c0:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
      m = (s16_t)(tcp_ticks - pcb->rttest);
 80068c4:	4a8e      	ldr	r2, [pc, #568]	; (8006b00 <tcp_receive+0x56c>)
 80068c6:	6812      	ldr	r2, [r2, #0]
 80068c8:	1ad3      	subs	r3, r2, r3
      m = m - (pcb->sa >> 3);
 80068ca:	eba3 03e1 	sub.w	r3, r3, r1, asr #3
 80068ce:	b29b      	uxth	r3, r3
 80068d0:	b218      	sxth	r0, r3
      pcb->sa += m;
 80068d2:	185a      	adds	r2, r3, r1
 80068d4:	b212      	sxth	r2, r2
 80068d6:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
      if (m < 0) {
 80068da:	2800      	cmp	r0, #0
        m = -m;
 80068dc:	bfbc      	itt	lt
 80068de:	425b      	neglt	r3, r3
 80068e0:	b218      	sxthlt	r0, r3
      m = m - (pcb->sv >> 2);
 80068e2:	f9b4 3042 	ldrsh.w	r3, [r4, #66]	; 0x42
      pcb->sv += m;
 80068e6:	eba3 03a3 	sub.w	r3, r3, r3, asr #2
 80068ea:	4403      	add	r3, r0
 80068ec:	b29b      	uxth	r3, r3
 80068ee:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 80068f2:	eb03 03e2 	add.w	r3, r3, r2, asr #3
 80068f6:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
      pcb->rttest = 0;
 80068fa:	2300      	movs	r3, #0
 80068fc:	63a3      	str	r3, [r4, #56]	; 0x38
 80068fe:	e7bb      	b.n	8006878 <tcp_receive+0x2e4>
      off = pcb->rcv_nxt - seqno;
 8006900:	462b      	mov	r3, r5
      p = inseg.p;
 8006902:	4a80      	ldr	r2, [pc, #512]	; (8006b04 <tcp_receive+0x570>)
 8006904:	6850      	ldr	r0, [r2, #4]
      if (inseg.p->len < off) {
 8006906:	8942      	ldrh	r2, [r0, #10]
 8006908:	4295      	cmp	r5, r2
 800690a:	dd1e      	ble.n	800694a <tcp_receive+0x3b6>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 800690c:	8901      	ldrh	r1, [r0, #8]
 800690e:	1b49      	subs	r1, r1, r5
 8006910:	b289      	uxth	r1, r1
          p->len = 0;
 8006912:	2500      	movs	r5, #0
          off -= p->len;
 8006914:	1a9b      	subs	r3, r3, r2
          p->tot_len = new_tot_len;
 8006916:	8101      	strh	r1, [r0, #8]
          p->len = 0;
 8006918:	8145      	strh	r5, [r0, #10]
          p = p->next;
 800691a:	6800      	ldr	r0, [r0, #0]
        while (p->len < off) {
 800691c:	8942      	ldrh	r2, [r0, #10]
 800691e:	429a      	cmp	r2, r3
 8006920:	dbf8      	blt.n	8006914 <tcp_receive+0x380>
        if(pbuf_header(p, (s16_t)-off)) {
 8006922:	425b      	negs	r3, r3
 8006924:	b219      	sxth	r1, r3
 8006926:	f7fe fe68 	bl	80055fa <pbuf_header>
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 800692a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800692c:	4975      	ldr	r1, [pc, #468]	; (8006b04 <tcp_receive+0x570>)
 800692e:	4873      	ldr	r0, [pc, #460]	; (8006afc <tcp_receive+0x568>)
 8006930:	6803      	ldr	r3, [r0, #0]
 8006932:	890d      	ldrh	r5, [r1, #8]
 8006934:	442b      	add	r3, r5
 8006936:	1a9b      	subs	r3, r3, r2
 8006938:	810b      	strh	r3, [r1, #8]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 800693a:	68cb      	ldr	r3, [r1, #12]
 800693c:	6002      	str	r2, [r0, #0]
 800693e:	605a      	str	r2, [r3, #4]
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 8006940:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006942:	1a53      	subs	r3, r2, r1
 8006944:	2b00      	cmp	r3, #0
 8006946:	daaf      	bge.n	80068a8 <tcp_receive+0x314>
 8006948:	e7b5      	b.n	80068b6 <tcp_receive+0x322>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
 800694a:	4269      	negs	r1, r5
 800694c:	b209      	sxth	r1, r1
 800694e:	f7fe fe54 	bl	80055fa <pbuf_header>
 8006952:	e7ea      	b.n	800692a <tcp_receive+0x396>
        tcp_ack_now(pcb);
 8006954:	7fa3      	ldrb	r3, [r4, #30]
 8006956:	f043 0302 	orr.w	r3, r3, #2
 800695a:	77a3      	strb	r3, [r4, #30]
 800695c:	e7ab      	b.n	80068b6 <tcp_receive+0x322>
      if (pcb->rcv_nxt == seqno) {
 800695e:	428a      	cmp	r2, r1
 8006960:	d013      	beq.n	800698a <tcp_receive+0x3f6>
        tcp_send_empty_ack(pcb);
 8006962:	4620      	mov	r0, r4
 8006964:	f001 f896 	bl	8007a94 <tcp_send_empty_ack>
        if (pcb->ooseq == NULL) {
 8006968:	6f66      	ldr	r6, [r4, #116]	; 0x74
 800696a:	2e00      	cmp	r6, #0
 800696c:	f000 8128 	beq.w	8006bc0 <tcp_receive+0x62c>
            if (seqno == next->tcphdr->seqno) {
 8006970:	68f1      	ldr	r1, [r6, #12]
 8006972:	684a      	ldr	r2, [r1, #4]
 8006974:	4b61      	ldr	r3, [pc, #388]	; (8006afc <tcp_receive+0x568>)
 8006976:	6818      	ldr	r0, [r3, #0]
 8006978:	4282      	cmp	r2, r0
 800697a:	f000 8127 	beq.w	8006bcc <tcp_receive+0x638>
 800697e:	2700      	movs	r7, #0
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 8006980:	f100 3eff 	add.w	lr, r0, #4294967295
 8006984:	f100 0c01 	add.w	ip, r0, #1
 8006988:	e143      	b.n	8006c12 <tcp_receive+0x67e>
        tcplen = TCP_TCPLEN(&inseg);
 800698a:	4b5e      	ldr	r3, [pc, #376]	; (8006b04 <tcp_receive+0x570>)
 800698c:	891d      	ldrh	r5, [r3, #8]
 800698e:	68db      	ldr	r3, [r3, #12]
 8006990:	8998      	ldrh	r0, [r3, #12]
 8006992:	f7fd fbfa 	bl	800418a <lwip_ntohs>
 8006996:	f010 0303 	ands.w	r3, r0, #3
 800699a:	bf18      	it	ne
 800699c:	2301      	movne	r3, #1
 800699e:	442b      	add	r3, r5
 80069a0:	b29b      	uxth	r3, r3
 80069a2:	4a55      	ldr	r2, [pc, #340]	; (8006af8 <tcp_receive+0x564>)
 80069a4:	8013      	strh	r3, [r2, #0]
        if (tcplen > pcb->rcv_wnd) {
 80069a6:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 80069a8:	429a      	cmp	r2, r3
 80069aa:	d317      	bcc.n	80069dc <tcp_receive+0x448>
        if (pcb->ooseq != NULL) {
 80069ac:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80069ae:	2b00      	cmp	r3, #0
 80069b0:	f000 81d1 	beq.w	8006d56 <tcp_receive+0x7c2>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 80069b4:	4b53      	ldr	r3, [pc, #332]	; (8006b04 <tcp_receive+0x570>)
 80069b6:	68db      	ldr	r3, [r3, #12]
 80069b8:	8998      	ldrh	r0, [r3, #12]
 80069ba:	f7fd fbe6 	bl	800418a <lwip_ntohs>
 80069be:	f010 0f01 	tst.w	r0, #1
 80069c2:	d042      	beq.n	8006a4a <tcp_receive+0x4b6>
            while (pcb->ooseq != NULL) {
 80069c4:	6f60      	ldr	r0, [r4, #116]	; 0x74
 80069c6:	2800      	cmp	r0, #0
 80069c8:	f000 81c5 	beq.w	8006d56 <tcp_receive+0x7c2>
              pcb->ooseq = pcb->ooseq->next;
 80069cc:	6803      	ldr	r3, [r0, #0]
 80069ce:	6763      	str	r3, [r4, #116]	; 0x74
              tcp_seg_free(old_ooseq);
 80069d0:	f7ff f890 	bl	8005af4 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
 80069d4:	6f60      	ldr	r0, [r4, #116]	; 0x74
 80069d6:	2800      	cmp	r0, #0
 80069d8:	d1f8      	bne.n	80069cc <tcp_receive+0x438>
 80069da:	e1bc      	b.n	8006d56 <tcp_receive+0x7c2>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 80069dc:	4b49      	ldr	r3, [pc, #292]	; (8006b04 <tcp_receive+0x570>)
 80069de:	68db      	ldr	r3, [r3, #12]
 80069e0:	8998      	ldrh	r0, [r3, #12]
 80069e2:	f7fd fbd2 	bl	800418a <lwip_ntohs>
 80069e6:	f010 0f01 	tst.w	r0, #1
 80069ea:	d11f      	bne.n	8006a2c <tcp_receive+0x498>
          inseg.len = pcb->rcv_wnd;
 80069ec:	4b45      	ldr	r3, [pc, #276]	; (8006b04 <tcp_receive+0x570>)
 80069ee:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 80069f0:	811a      	strh	r2, [r3, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 80069f2:	68db      	ldr	r3, [r3, #12]
 80069f4:	8998      	ldrh	r0, [r3, #12]
 80069f6:	f7fd fbc8 	bl	800418a <lwip_ntohs>
 80069fa:	f010 0f02 	tst.w	r0, #2
 80069fe:	d003      	beq.n	8006a08 <tcp_receive+0x474>
            inseg.len -= 1;
 8006a00:	4a40      	ldr	r2, [pc, #256]	; (8006b04 <tcp_receive+0x570>)
 8006a02:	8913      	ldrh	r3, [r2, #8]
 8006a04:	3b01      	subs	r3, #1
 8006a06:	8113      	strh	r3, [r2, #8]
          pbuf_realloc(inseg.p, inseg.len);
 8006a08:	4d3e      	ldr	r5, [pc, #248]	; (8006b04 <tcp_receive+0x570>)
 8006a0a:	8929      	ldrh	r1, [r5, #8]
 8006a0c:	6868      	ldr	r0, [r5, #4]
 8006a0e:	f7fe fef9 	bl	8005804 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 8006a12:	892e      	ldrh	r6, [r5, #8]
 8006a14:	68eb      	ldr	r3, [r5, #12]
 8006a16:	8998      	ldrh	r0, [r3, #12]
 8006a18:	f7fd fbb7 	bl	800418a <lwip_ntohs>
 8006a1c:	f010 0003 	ands.w	r0, r0, #3
 8006a20:	bf18      	it	ne
 8006a22:	2001      	movne	r0, #1
 8006a24:	4406      	add	r6, r0
 8006a26:	4b34      	ldr	r3, [pc, #208]	; (8006af8 <tcp_receive+0x564>)
 8006a28:	801e      	strh	r6, [r3, #0]
 8006a2a:	e7bf      	b.n	80069ac <tcp_receive+0x418>
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
 8006a2c:	4b35      	ldr	r3, [pc, #212]	; (8006b04 <tcp_receive+0x570>)
 8006a2e:	68de      	ldr	r6, [r3, #12]
 8006a30:	89b5      	ldrh	r5, [r6, #12]
 8006a32:	4628      	mov	r0, r5
 8006a34:	f7fd fba9 	bl	800418a <lwip_ntohs>
 8006a38:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 8006a3c:	f7fd fba0 	bl	8004180 <lwip_htons>
 8006a40:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 8006a44:	4305      	orrs	r5, r0
 8006a46:	81b5      	strh	r5, [r6, #12]
 8006a48:	e7d0      	b.n	80069ec <tcp_receive+0x458>
            next = pcb->ooseq;
 8006a4a:	f8d4 9074 	ldr.w	r9, [r4, #116]	; 0x74
            while (next &&
 8006a4e:	f1b9 0f00 	cmp.w	r9, #0
 8006a52:	f000 817e 	beq.w	8006d52 <tcp_receive+0x7be>
                   TCP_SEQ_GEQ(seqno + tcplen,
 8006a56:	f8d9 200c 	ldr.w	r2, [r9, #12]
 8006a5a:	4b27      	ldr	r3, [pc, #156]	; (8006af8 <tcp_receive+0x564>)
 8006a5c:	881b      	ldrh	r3, [r3, #0]
 8006a5e:	4927      	ldr	r1, [pc, #156]	; (8006afc <tcp_receive+0x568>)
 8006a60:	6809      	ldr	r1, [r1, #0]
 8006a62:	440b      	add	r3, r1
 8006a64:	6851      	ldr	r1, [r2, #4]
 8006a66:	1a5b      	subs	r3, r3, r1
 8006a68:	f8b9 1008 	ldrh.w	r1, [r9, #8]
 8006a6c:	1a5b      	subs	r3, r3, r1
            while (next &&
 8006a6e:	2b00      	cmp	r3, #0
 8006a70:	f2c0 81a2 	blt.w	8006db8 <tcp_receive+0x824>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 8006a74:	f8df 808c 	ldr.w	r8, [pc, #140]	; 8006b04 <tcp_receive+0x570>
                tcplen = TCP_TCPLEN(&inseg);
 8006a78:	4e1f      	ldr	r6, [pc, #124]	; (8006af8 <tcp_receive+0x564>)
                   TCP_SEQ_GEQ(seqno + tcplen,
 8006a7a:	4f20      	ldr	r7, [pc, #128]	; (8006afc <tcp_receive+0x568>)
 8006a7c:	e013      	b.n	8006aa6 <tcp_receive+0x512>
              next = next->next;
 8006a7e:	f8d9 5000 	ldr.w	r5, [r9]
              tcp_seg_free(prev);
 8006a82:	4648      	mov	r0, r9
 8006a84:	f7ff f836 	bl	8005af4 <tcp_seg_free>
            while (next &&
 8006a88:	2d00      	cmp	r5, #0
 8006a8a:	f000 8162 	beq.w	8006d52 <tcp_receive+0x7be>
                   TCP_SEQ_GEQ(seqno + tcplen,
 8006a8e:	68ea      	ldr	r2, [r5, #12]
 8006a90:	8833      	ldrh	r3, [r6, #0]
 8006a92:	6839      	ldr	r1, [r7, #0]
 8006a94:	440b      	add	r3, r1
 8006a96:	6851      	ldr	r1, [r2, #4]
 8006a98:	1a5b      	subs	r3, r3, r1
 8006a9a:	8929      	ldrh	r1, [r5, #8]
 8006a9c:	1a5b      	subs	r3, r3, r1
            while (next &&
 8006a9e:	2b00      	cmp	r3, #0
 8006aa0:	f2c0 818b 	blt.w	8006dba <tcp_receive+0x826>
              next = next->next;
 8006aa4:	46a9      	mov	r9, r5
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 8006aa6:	8990      	ldrh	r0, [r2, #12]
 8006aa8:	f7fd fb6f 	bl	800418a <lwip_ntohs>
 8006aac:	f010 0f01 	tst.w	r0, #1
 8006ab0:	d0e5      	beq.n	8006a7e <tcp_receive+0x4ea>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 8006ab2:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8006ab6:	8998      	ldrh	r0, [r3, #12]
 8006ab8:	f7fd fb67 	bl	800418a <lwip_ntohs>
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 8006abc:	f010 0f02 	tst.w	r0, #2
 8006ac0:	d1dd      	bne.n	8006a7e <tcp_receive+0x4ea>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 8006ac2:	f8d8 a00c 	ldr.w	sl, [r8, #12]
 8006ac6:	f8ba 500c 	ldrh.w	r5, [sl, #12]
 8006aca:	2001      	movs	r0, #1
 8006acc:	f7fd fb58 	bl	8004180 <lwip_htons>
 8006ad0:	4328      	orrs	r0, r5
 8006ad2:	f8aa 000c 	strh.w	r0, [sl, #12]
                tcplen = TCP_TCPLEN(&inseg);
 8006ad6:	f8b8 5008 	ldrh.w	r5, [r8, #8]
 8006ada:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8006ade:	8998      	ldrh	r0, [r3, #12]
 8006ae0:	f7fd fb53 	bl	800418a <lwip_ntohs>
 8006ae4:	f010 0003 	ands.w	r0, r0, #3
 8006ae8:	bf18      	it	ne
 8006aea:	2001      	movne	r0, #1
 8006aec:	4405      	add	r5, r0
 8006aee:	8035      	strh	r5, [r6, #0]
 8006af0:	e7c5      	b.n	8006a7e <tcp_receive+0x4ea>
 8006af2:	bf00      	nop
 8006af4:	20007198 	.word	0x20007198
 8006af8:	200071c0 	.word	0x200071c0
 8006afc:	200071b8 	.word	0x200071b8
 8006b00:	2000abe4 	.word	0x2000abe4
 8006b04:	200071a0 	.word	0x200071a0
              recv_data = cseg->p;
 8006b08:	f8c8 1000 	str.w	r1, [r8]
            cseg->p = NULL;
 8006b0c:	2300      	movs	r3, #0
 8006b0e:	606b      	str	r3, [r5, #4]
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 8006b10:	68eb      	ldr	r3, [r5, #12]
 8006b12:	8998      	ldrh	r0, [r3, #12]
 8006b14:	f7fd fb39 	bl	800418a <lwip_ntohs>
 8006b18:	f010 0f01 	tst.w	r0, #1
 8006b1c:	d008      	beq.n	8006b30 <tcp_receive+0x59c>
            recv_flags |= TF_GOT_FIN;
 8006b1e:	7833      	ldrb	r3, [r6, #0]
 8006b20:	f043 0320 	orr.w	r3, r3, #32
 8006b24:	7033      	strb	r3, [r6, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 8006b26:	7e23      	ldrb	r3, [r4, #24]
 8006b28:	2b04      	cmp	r3, #4
              pcb->state = CLOSE_WAIT;
 8006b2a:	bf04      	itt	eq
 8006b2c:	2307      	moveq	r3, #7
 8006b2e:	7623      	strbeq	r3, [r4, #24]
          pcb->ooseq = cseg->next;
 8006b30:	682b      	ldr	r3, [r5, #0]
 8006b32:	6763      	str	r3, [r4, #116]	; 0x74
          tcp_seg_free(cseg);
 8006b34:	4628      	mov	r0, r5
 8006b36:	f7fe ffdd 	bl	8005af4 <tcp_seg_free>
        while (pcb->ooseq != NULL &&
 8006b3a:	6f65      	ldr	r5, [r4, #116]	; 0x74
 8006b3c:	2d00      	cmp	r5, #0
 8006b3e:	d032      	beq.n	8006ba6 <tcp_receive+0x612>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 8006b40:	68eb      	ldr	r3, [r5, #12]
 8006b42:	685a      	ldr	r2, [r3, #4]
        while (pcb->ooseq != NULL &&
 8006b44:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006b46:	428a      	cmp	r2, r1
 8006b48:	d12d      	bne.n	8006ba6 <tcp_receive+0x612>
          seqno = pcb->ooseq->tcphdr->seqno;
 8006b4a:	603a      	str	r2, [r7, #0]
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 8006b4c:	f8b5 9008 	ldrh.w	r9, [r5, #8]
 8006b50:	8998      	ldrh	r0, [r3, #12]
 8006b52:	f7fd fb1a 	bl	800418a <lwip_ntohs>
 8006b56:	f010 0003 	ands.w	r0, r0, #3
 8006b5a:	bf18      	it	ne
 8006b5c:	2001      	movne	r0, #1
 8006b5e:	4448      	add	r0, r9
 8006b60:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8006b62:	4418      	add	r0, r3
 8006b64:	62a0      	str	r0, [r4, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 8006b66:	68eb      	ldr	r3, [r5, #12]
 8006b68:	8998      	ldrh	r0, [r3, #12]
 8006b6a:	f7fd fb0e 	bl	800418a <lwip_ntohs>
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 8006b6e:	f8b5 9008 	ldrh.w	r9, [r5, #8]
 8006b72:	68eb      	ldr	r3, [r5, #12]
 8006b74:	8998      	ldrh	r0, [r3, #12]
 8006b76:	f7fd fb08 	bl	800418a <lwip_ntohs>
 8006b7a:	f010 0003 	ands.w	r0, r0, #3
 8006b7e:	bf18      	it	ne
 8006b80:	2001      	movne	r0, #1
 8006b82:	4448      	add	r0, r9
 8006b84:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006b86:	1a18      	subs	r0, r3, r0
 8006b88:	85a0      	strh	r0, [r4, #44]	; 0x2c
          tcp_update_rcv_ann_wnd(pcb);
 8006b8a:	4620      	mov	r0, r4
 8006b8c:	f7fe ff78 	bl	8005a80 <tcp_update_rcv_ann_wnd>
          if (cseg->p->tot_len > 0) {
 8006b90:	6869      	ldr	r1, [r5, #4]
 8006b92:	890b      	ldrh	r3, [r1, #8]
 8006b94:	2b00      	cmp	r3, #0
 8006b96:	d0bb      	beq.n	8006b10 <tcp_receive+0x57c>
            if (recv_data) {
 8006b98:	f8d8 0000 	ldr.w	r0, [r8]
 8006b9c:	2800      	cmp	r0, #0
 8006b9e:	d0b3      	beq.n	8006b08 <tcp_receive+0x574>
              pbuf_cat(recv_data, cseg->p);
 8006ba0:	f7fe fe6b 	bl	800587a <pbuf_cat>
 8006ba4:	e7b2      	b.n	8006b0c <tcp_receive+0x578>
        tcp_ack(pcb);
 8006ba6:	7fa3      	ldrb	r3, [r4, #30]
 8006ba8:	f013 0f01 	tst.w	r3, #1
 8006bac:	bf1a      	itte	ne
 8006bae:	f023 0301 	bicne.w	r3, r3, #1
 8006bb2:	f043 0302 	orrne.w	r3, r3, #2
 8006bb6:	f043 0301 	orreq.w	r3, r3, #1
 8006bba:	77a3      	strb	r3, [r4, #30]
 8006bbc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          pcb->ooseq = tcp_seg_copy(&inseg);
 8006bc0:	4893      	ldr	r0, [pc, #588]	; (8006e10 <tcp_receive+0x87c>)
 8006bc2:	f7fe ffb0 	bl	8005b26 <tcp_seg_copy>
 8006bc6:	6760      	str	r0, [r4, #116]	; 0x74
 8006bc8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if (seqno == next->tcphdr->seqno) {
 8006bcc:	4635      	mov	r5, r6
 8006bce:	2600      	movs	r6, #0
              if (inseg.len > next->len) {
 8006bd0:	4b8f      	ldr	r3, [pc, #572]	; (8006e10 <tcp_receive+0x87c>)
 8006bd2:	891a      	ldrh	r2, [r3, #8]
 8006bd4:	892b      	ldrh	r3, [r5, #8]
 8006bd6:	429a      	cmp	r2, r3
 8006bd8:	d94f      	bls.n	8006c7a <tcp_receive+0x6e6>
                cseg = tcp_seg_copy(&inseg);
 8006bda:	488d      	ldr	r0, [pc, #564]	; (8006e10 <tcp_receive+0x87c>)
 8006bdc:	f7fe ffa3 	bl	8005b26 <tcp_seg_copy>
                if (cseg != NULL) {
 8006be0:	4603      	mov	r3, r0
 8006be2:	2800      	cmp	r0, #0
 8006be4:	d049      	beq.n	8006c7a <tcp_receive+0x6e6>
                  if (prev != NULL) {
 8006be6:	b136      	cbz	r6, 8006bf6 <tcp_receive+0x662>
                    prev->next = cseg;
 8006be8:	6030      	str	r0, [r6, #0]
                  tcp_oos_insert_segment(cseg, next);
 8006bea:	4629      	mov	r1, r5
 8006bec:	4618      	mov	r0, r3
 8006bee:	f7ff fc73 	bl	80064d8 <tcp_oos_insert_segment>
 8006bf2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                    pcb->ooseq = cseg;
 8006bf6:	6760      	str	r0, [r4, #116]	; 0x74
 8006bf8:	e7f7      	b.n	8006bea <tcp_receive+0x656>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 8006bfa:	1a83      	subs	r3, r0, r2
 8006bfc:	2b00      	cmp	r3, #0
 8006bfe:	db2f      	blt.n	8006c60 <tcp_receive+0x6cc>
              if (next->next == NULL &&
 8006c00:	6835      	ldr	r5, [r6, #0]
 8006c02:	2d00      	cmp	r5, #0
 8006c04:	d036      	beq.n	8006c74 <tcp_receive+0x6e0>
            if (seqno == next->tcphdr->seqno) {
 8006c06:	68e9      	ldr	r1, [r5, #12]
 8006c08:	684a      	ldr	r2, [r1, #4]
 8006c0a:	4637      	mov	r7, r6
 8006c0c:	4282      	cmp	r2, r0
 8006c0e:	d0df      	beq.n	8006bd0 <tcp_receive+0x63c>
              if (next->next == NULL &&
 8006c10:	462e      	mov	r6, r5
              if (prev == NULL) {
 8006c12:	2f00      	cmp	r7, #0
 8006c14:	d0f1      	beq.n	8006bfa <tcp_receive+0x666>
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 8006c16:	68fb      	ldr	r3, [r7, #12]
 8006c18:	685b      	ldr	r3, [r3, #4]
 8006c1a:	ebae 0303 	sub.w	r3, lr, r3
 8006c1e:	2b00      	cmp	r3, #0
 8006c20:	dbee      	blt.n	8006c00 <tcp_receive+0x66c>
 8006c22:	ebac 0302 	sub.w	r3, ip, r2
 8006c26:	2b00      	cmp	r3, #0
 8006c28:	dcea      	bgt.n	8006c00 <tcp_receive+0x66c>
                  cseg = tcp_seg_copy(&inseg);
 8006c2a:	4879      	ldr	r0, [pc, #484]	; (8006e10 <tcp_receive+0x87c>)
 8006c2c:	f7fe ff7b 	bl	8005b26 <tcp_seg_copy>
                  if (cseg != NULL) {
 8006c30:	4604      	mov	r4, r0
 8006c32:	b310      	cbz	r0, 8006c7a <tcp_receive+0x6e6>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 8006c34:	68fb      	ldr	r3, [r7, #12]
 8006c36:	6859      	ldr	r1, [r3, #4]
 8006c38:	4b76      	ldr	r3, [pc, #472]	; (8006e14 <tcp_receive+0x880>)
 8006c3a:	681b      	ldr	r3, [r3, #0]
 8006c3c:	893a      	ldrh	r2, [r7, #8]
 8006c3e:	440a      	add	r2, r1
 8006c40:	1ad2      	subs	r2, r2, r3
 8006c42:	2a00      	cmp	r2, #0
 8006c44:	dd05      	ble.n	8006c52 <tcp_receive+0x6be>
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 8006c46:	1a5b      	subs	r3, r3, r1
 8006c48:	b299      	uxth	r1, r3
 8006c4a:	8139      	strh	r1, [r7, #8]
                      pbuf_realloc(prev->p, prev->len);
 8006c4c:	6878      	ldr	r0, [r7, #4]
 8006c4e:	f7fe fdd9 	bl	8005804 <pbuf_realloc>
                    prev->next = cseg;
 8006c52:	603c      	str	r4, [r7, #0]
                    tcp_oos_insert_segment(cseg, next);
 8006c54:	4631      	mov	r1, r6
 8006c56:	4620      	mov	r0, r4
 8006c58:	f7ff fc3e 	bl	80064d8 <tcp_oos_insert_segment>
 8006c5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                  cseg = tcp_seg_copy(&inseg);
 8006c60:	486b      	ldr	r0, [pc, #428]	; (8006e10 <tcp_receive+0x87c>)
 8006c62:	f7fe ff60 	bl	8005b26 <tcp_seg_copy>
                  if (cseg != NULL) {
 8006c66:	b140      	cbz	r0, 8006c7a <tcp_receive+0x6e6>
                    pcb->ooseq = cseg;
 8006c68:	6760      	str	r0, [r4, #116]	; 0x74
                    tcp_oos_insert_segment(cseg, next);
 8006c6a:	4631      	mov	r1, r6
 8006c6c:	f7ff fc34 	bl	80064d8 <tcp_oos_insert_segment>
 8006c70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 8006c74:	1a82      	subs	r2, r0, r2
              if (next->next == NULL &&
 8006c76:	2a00      	cmp	r2, #0
 8006c78:	dc01      	bgt.n	8006c7e <tcp_receive+0x6ea>
 8006c7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 8006c7e:	8988      	ldrh	r0, [r1, #12]
 8006c80:	f7fd fa83 	bl	800418a <lwip_ntohs>
 8006c84:	f010 0f01 	tst.w	r0, #1
 8006c88:	d1f7      	bne.n	8006c7a <tcp_receive+0x6e6>
                next->next = tcp_seg_copy(&inseg);
 8006c8a:	4861      	ldr	r0, [pc, #388]	; (8006e10 <tcp_receive+0x87c>)
 8006c8c:	f7fe ff4b 	bl	8005b26 <tcp_seg_copy>
 8006c90:	6030      	str	r0, [r6, #0]
                if (next->next != NULL) {
 8006c92:	2800      	cmp	r0, #0
 8006c94:	d0f1      	beq.n	8006c7a <tcp_receive+0x6e6>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 8006c96:	68f3      	ldr	r3, [r6, #12]
 8006c98:	6859      	ldr	r1, [r3, #4]
 8006c9a:	4b5e      	ldr	r3, [pc, #376]	; (8006e14 <tcp_receive+0x880>)
 8006c9c:	681b      	ldr	r3, [r3, #0]
 8006c9e:	8932      	ldrh	r2, [r6, #8]
 8006ca0:	440a      	add	r2, r1
 8006ca2:	1ad2      	subs	r2, r2, r3
 8006ca4:	2a00      	cmp	r2, #0
 8006ca6:	dd05      	ble.n	8006cb4 <tcp_receive+0x720>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 8006ca8:	1a5b      	subs	r3, r3, r1
 8006caa:	b299      	uxth	r1, r3
 8006cac:	8131      	strh	r1, [r6, #8]
                    pbuf_realloc(next->p, next->len);
 8006cae:	6870      	ldr	r0, [r6, #4]
 8006cb0:	f7fe fda8 	bl	8005804 <pbuf_realloc>
                  if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
 8006cb4:	4b58      	ldr	r3, [pc, #352]	; (8006e18 <tcp_receive+0x884>)
 8006cb6:	881a      	ldrh	r2, [r3, #0]
 8006cb8:	4b56      	ldr	r3, [pc, #344]	; (8006e14 <tcp_receive+0x880>)
 8006cba:	681b      	ldr	r3, [r3, #0]
 8006cbc:	441a      	add	r2, r3
 8006cbe:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006cc0:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006cc2:	440b      	add	r3, r1
 8006cc4:	429a      	cmp	r2, r3
 8006cc6:	d9d8      	bls.n	8006c7a <tcp_receive+0x6e6>
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 8006cc8:	6833      	ldr	r3, [r6, #0]
 8006cca:	68db      	ldr	r3, [r3, #12]
 8006ccc:	8998      	ldrh	r0, [r3, #12]
 8006cce:	f7fd fa5c 	bl	800418a <lwip_ntohs>
 8006cd2:	f010 0f01 	tst.w	r0, #1
 8006cd6:	d11b      	bne.n	8006d10 <tcp_receive+0x77c>
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
 8006cd8:	6832      	ldr	r2, [r6, #0]
 8006cda:	4b4e      	ldr	r3, [pc, #312]	; (8006e14 <tcp_receive+0x880>)
 8006cdc:	6819      	ldr	r1, [r3, #0]
 8006cde:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006ce0:	1a5b      	subs	r3, r3, r1
 8006ce2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006ce4:	440b      	add	r3, r1
 8006ce6:	8113      	strh	r3, [r2, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 8006ce8:	6833      	ldr	r3, [r6, #0]
 8006cea:	8919      	ldrh	r1, [r3, #8]
 8006cec:	6858      	ldr	r0, [r3, #4]
 8006cee:	f7fe fd89 	bl	8005804 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 8006cf2:	6833      	ldr	r3, [r6, #0]
 8006cf4:	891c      	ldrh	r4, [r3, #8]
 8006cf6:	68db      	ldr	r3, [r3, #12]
 8006cf8:	8998      	ldrh	r0, [r3, #12]
 8006cfa:	f7fd fa46 	bl	800418a <lwip_ntohs>
 8006cfe:	f010 0003 	ands.w	r0, r0, #3
 8006d02:	bf18      	it	ne
 8006d04:	2001      	movne	r0, #1
 8006d06:	4404      	add	r4, r0
 8006d08:	4b43      	ldr	r3, [pc, #268]	; (8006e18 <tcp_receive+0x884>)
 8006d0a:	801c      	strh	r4, [r3, #0]
 8006d0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
 8006d10:	6833      	ldr	r3, [r6, #0]
 8006d12:	68df      	ldr	r7, [r3, #12]
 8006d14:	89bd      	ldrh	r5, [r7, #12]
 8006d16:	4628      	mov	r0, r5
 8006d18:	f7fd fa37 	bl	800418a <lwip_ntohs>
 8006d1c:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 8006d20:	f7fd fa2e 	bl	8004180 <lwip_htons>
 8006d24:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 8006d28:	4305      	orrs	r5, r0
 8006d2a:	81bd      	strh	r5, [r7, #12]
 8006d2c:	e7d4      	b.n	8006cd8 <tcp_receive+0x744>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
 8006d2e:	4b39      	ldr	r3, [pc, #228]	; (8006e14 <tcp_receive+0x880>)
 8006d30:	681b      	ldr	r3, [r3, #0]
 8006d32:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006d34:	1a99      	subs	r1, r3, r2
 8006d36:	2900      	cmp	r1, #0
 8006d38:	db05      	blt.n	8006d46 <tcp_receive+0x7b2>
 8006d3a:	3301      	adds	r3, #1
 8006d3c:	1a9b      	subs	r3, r3, r2
 8006d3e:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 8006d40:	1a9b      	subs	r3, r3, r2
 8006d42:	2b00      	cmp	r3, #0
 8006d44:	dd99      	ble.n	8006c7a <tcp_receive+0x6e6>
      tcp_ack_now(pcb);
 8006d46:	7fa3      	ldrb	r3, [r4, #30]
 8006d48:	f043 0302 	orr.w	r3, r3, #2
 8006d4c:	77a3      	strb	r3, [r4, #30]
}
 8006d4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
              next = next->next;
 8006d52:	2500      	movs	r5, #0
            pcb->ooseq = next;
 8006d54:	6765      	str	r5, [r4, #116]	; 0x74
        pcb->rcv_nxt = seqno + tcplen;
 8006d56:	4b30      	ldr	r3, [pc, #192]	; (8006e18 <tcp_receive+0x884>)
 8006d58:	881a      	ldrh	r2, [r3, #0]
 8006d5a:	4b2e      	ldr	r3, [pc, #184]	; (8006e14 <tcp_receive+0x880>)
 8006d5c:	681b      	ldr	r3, [r3, #0]
 8006d5e:	4413      	add	r3, r2
 8006d60:	62a3      	str	r3, [r4, #40]	; 0x28
        pcb->rcv_wnd -= tcplen;
 8006d62:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006d64:	1a9b      	subs	r3, r3, r2
 8006d66:	85a3      	strh	r3, [r4, #44]	; 0x2c
        tcp_update_rcv_ann_wnd(pcb);
 8006d68:	4620      	mov	r0, r4
 8006d6a:	f7fe fe89 	bl	8005a80 <tcp_update_rcv_ann_wnd>
        if (inseg.p->tot_len > 0) {
 8006d6e:	4b28      	ldr	r3, [pc, #160]	; (8006e10 <tcp_receive+0x87c>)
 8006d70:	685b      	ldr	r3, [r3, #4]
 8006d72:	891a      	ldrh	r2, [r3, #8]
 8006d74:	b122      	cbz	r2, 8006d80 <tcp_receive+0x7ec>
          recv_data = inseg.p;
 8006d76:	4a29      	ldr	r2, [pc, #164]	; (8006e1c <tcp_receive+0x888>)
 8006d78:	6013      	str	r3, [r2, #0]
          inseg.p = NULL;
 8006d7a:	2200      	movs	r2, #0
 8006d7c:	4b24      	ldr	r3, [pc, #144]	; (8006e10 <tcp_receive+0x87c>)
 8006d7e:	605a      	str	r2, [r3, #4]
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8006d80:	4b23      	ldr	r3, [pc, #140]	; (8006e10 <tcp_receive+0x87c>)
 8006d82:	68db      	ldr	r3, [r3, #12]
 8006d84:	8998      	ldrh	r0, [r3, #12]
 8006d86:	f7fd fa00 	bl	800418a <lwip_ntohs>
 8006d8a:	f010 0f01 	tst.w	r0, #1
 8006d8e:	d004      	beq.n	8006d9a <tcp_receive+0x806>
          recv_flags |= TF_GOT_FIN;
 8006d90:	4a23      	ldr	r2, [pc, #140]	; (8006e20 <tcp_receive+0x88c>)
 8006d92:	7813      	ldrb	r3, [r2, #0]
 8006d94:	f043 0320 	orr.w	r3, r3, #32
 8006d98:	7013      	strb	r3, [r2, #0]
        while (pcb->ooseq != NULL &&
 8006d9a:	6f65      	ldr	r5, [r4, #116]	; 0x74
 8006d9c:	2d00      	cmp	r5, #0
 8006d9e:	f43f af02 	beq.w	8006ba6 <tcp_receive+0x612>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 8006da2:	68eb      	ldr	r3, [r5, #12]
 8006da4:	685a      	ldr	r2, [r3, #4]
        while (pcb->ooseq != NULL &&
 8006da6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006da8:	428a      	cmp	r2, r1
 8006daa:	f47f aefc 	bne.w	8006ba6 <tcp_receive+0x612>
          seqno = pcb->ooseq->tcphdr->seqno;
 8006dae:	4f19      	ldr	r7, [pc, #100]	; (8006e14 <tcp_receive+0x880>)
            if (recv_data) {
 8006db0:	f8df 8068 	ldr.w	r8, [pc, #104]	; 8006e1c <tcp_receive+0x888>
            recv_flags |= TF_GOT_FIN;
 8006db4:	4e1a      	ldr	r6, [pc, #104]	; (8006e20 <tcp_receive+0x88c>)
 8006db6:	e6c8      	b.n	8006b4a <tcp_receive+0x5b6>
            next = pcb->ooseq;
 8006db8:	464d      	mov	r5, r9
                TCP_SEQ_GT(seqno + tcplen,
 8006dba:	4b16      	ldr	r3, [pc, #88]	; (8006e14 <tcp_receive+0x880>)
 8006dbc:	6819      	ldr	r1, [r3, #0]
 8006dbe:	68eb      	ldr	r3, [r5, #12]
 8006dc0:	685a      	ldr	r2, [r3, #4]
 8006dc2:	4b15      	ldr	r3, [pc, #84]	; (8006e18 <tcp_receive+0x884>)
 8006dc4:	881b      	ldrh	r3, [r3, #0]
 8006dc6:	440b      	add	r3, r1
 8006dc8:	1a9b      	subs	r3, r3, r2
            if (next &&
 8006dca:	2b00      	cmp	r3, #0
 8006dcc:	ddc2      	ble.n	8006d54 <tcp_receive+0x7c0>
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 8006dce:	4b10      	ldr	r3, [pc, #64]	; (8006e10 <tcp_receive+0x87c>)
 8006dd0:	1a52      	subs	r2, r2, r1
 8006dd2:	811a      	strh	r2, [r3, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8006dd4:	68db      	ldr	r3, [r3, #12]
 8006dd6:	8998      	ldrh	r0, [r3, #12]
 8006dd8:	f7fd f9d7 	bl	800418a <lwip_ntohs>
 8006ddc:	f010 0f02 	tst.w	r0, #2
 8006de0:	d003      	beq.n	8006dea <tcp_receive+0x856>
                inseg.len -= 1;
 8006de2:	4a0b      	ldr	r2, [pc, #44]	; (8006e10 <tcp_receive+0x87c>)
 8006de4:	8913      	ldrh	r3, [r2, #8]
 8006de6:	3b01      	subs	r3, #1
 8006de8:	8113      	strh	r3, [r2, #8]
              pbuf_realloc(inseg.p, inseg.len);
 8006dea:	4e09      	ldr	r6, [pc, #36]	; (8006e10 <tcp_receive+0x87c>)
 8006dec:	8931      	ldrh	r1, [r6, #8]
 8006dee:	6870      	ldr	r0, [r6, #4]
 8006df0:	f7fe fd08 	bl	8005804 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 8006df4:	8937      	ldrh	r7, [r6, #8]
 8006df6:	68f3      	ldr	r3, [r6, #12]
 8006df8:	8998      	ldrh	r0, [r3, #12]
 8006dfa:	f7fd f9c6 	bl	800418a <lwip_ntohs>
 8006dfe:	f010 0003 	ands.w	r0, r0, #3
 8006e02:	bf18      	it	ne
 8006e04:	2001      	movne	r0, #1
 8006e06:	4407      	add	r7, r0
 8006e08:	4b03      	ldr	r3, [pc, #12]	; (8006e18 <tcp_receive+0x884>)
 8006e0a:	801f      	strh	r7, [r3, #0]
 8006e0c:	e7a2      	b.n	8006d54 <tcp_receive+0x7c0>
 8006e0e:	bf00      	nop
 8006e10:	200071a0 	.word	0x200071a0
 8006e14:	200071b8 	.word	0x200071b8
 8006e18:	200071c0 	.word	0x200071c0
 8006e1c:	200071b0 	.word	0x200071b0
 8006e20:	200071b4 	.word	0x200071b4

08006e24 <tcp_input>:
{
 8006e24:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006e28:	b083      	sub	sp, #12
 8006e2a:	4604      	mov	r4, r0
 8006e2c:	460d      	mov	r5, r1
  TCP_STATS_INC(tcp.recv);
 8006e2e:	4aa5      	ldr	r2, [pc, #660]	; (80070c4 <tcp_input+0x2a0>)
 8006e30:	f8b2 3092 	ldrh.w	r3, [r2, #146]	; 0x92
 8006e34:	3301      	adds	r3, #1
 8006e36:	f8a2 3092 	strh.w	r3, [r2, #146]	; 0x92
  iphdr = (struct ip_hdr *)p->payload;
 8006e3a:	6843      	ldr	r3, [r0, #4]
 8006e3c:	7819      	ldrb	r1, [r3, #0]
 8006e3e:	f001 010f 	and.w	r1, r1, #15
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 8006e42:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8006e46:	4aa0      	ldr	r2, [pc, #640]	; (80070c8 <tcp_input+0x2a4>)
 8006e48:	6013      	str	r3, [r2, #0]
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 8006e4a:	0089      	lsls	r1, r1, #2
 8006e4c:	4249      	negs	r1, r1
 8006e4e:	f7fe fbd4 	bl	80055fa <pbuf_header>
 8006e52:	b910      	cbnz	r0, 8006e5a <tcp_input+0x36>
 8006e54:	8923      	ldrh	r3, [r4, #8]
 8006e56:	2b13      	cmp	r3, #19
 8006e58:	d811      	bhi.n	8006e7e <tcp_input+0x5a>
    TCP_STATS_INC(tcp.lenerr);
 8006e5a:	4a9a      	ldr	r2, [pc, #616]	; (80070c4 <tcp_input+0x2a0>)
 8006e5c:	f8b2 309a 	ldrh.w	r3, [r2, #154]	; 0x9a
 8006e60:	3301      	adds	r3, #1
 8006e62:	f8a2 309a 	strh.w	r3, [r2, #154]	; 0x9a
  TCP_STATS_INC(tcp.drop);
 8006e66:	4a97      	ldr	r2, [pc, #604]	; (80070c4 <tcp_input+0x2a0>)
 8006e68:	f8b2 3096 	ldrh.w	r3, [r2, #150]	; 0x96
 8006e6c:	3301      	adds	r3, #1
 8006e6e:	f8a2 3096 	strh.w	r3, [r2, #150]	; 0x96
  pbuf_free(p);
 8006e72:	4620      	mov	r0, r4
 8006e74:	f7fe fbff 	bl	8005676 <pbuf_free>
}
 8006e78:	b003      	add	sp, #12
 8006e7a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 8006e7e:	4629      	mov	r1, r5
 8006e80:	4b92      	ldr	r3, [pc, #584]	; (80070cc <tcp_input+0x2a8>)
 8006e82:	6818      	ldr	r0, [r3, #0]
 8006e84:	f7fd fd78 	bl	8004978 <ip4_addr_isbroadcast>
 8006e88:	b9a8      	cbnz	r0, 8006eb6 <tcp_input+0x92>
      ip_addr_ismulticast(&current_iphdr_dest)) {
 8006e8a:	4b90      	ldr	r3, [pc, #576]	; (80070cc <tcp_input+0x2a8>)
 8006e8c:	681b      	ldr	r3, [r3, #0]
 8006e8e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 8006e92:	2be0      	cmp	r3, #224	; 0xe0
 8006e94:	d00f      	beq.n	8006eb6 <tcp_input+0x92>
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 8006e96:	8923      	ldrh	r3, [r4, #8]
 8006e98:	9300      	str	r3, [sp, #0]
 8006e9a:	2306      	movs	r3, #6
 8006e9c:	4a8b      	ldr	r2, [pc, #556]	; (80070cc <tcp_input+0x2a8>)
 8006e9e:	498c      	ldr	r1, [pc, #560]	; (80070d0 <tcp_input+0x2ac>)
 8006ea0:	4620      	mov	r0, r4
 8006ea2:	f7fd fb05 	bl	80044b0 <inet_chksum_pseudo>
 8006ea6:	b168      	cbz	r0, 8006ec4 <tcp_input+0xa0>
    TCP_STATS_INC(tcp.chkerr);
 8006ea8:	4a86      	ldr	r2, [pc, #536]	; (80070c4 <tcp_input+0x2a0>)
 8006eaa:	f8b2 3098 	ldrh.w	r3, [r2, #152]	; 0x98
 8006eae:	3301      	adds	r3, #1
 8006eb0:	f8a2 3098 	strh.w	r3, [r2, #152]	; 0x98
    goto dropped;
 8006eb4:	e7d7      	b.n	8006e66 <tcp_input+0x42>
    TCP_STATS_INC(tcp.proterr);
 8006eb6:	4a83      	ldr	r2, [pc, #524]	; (80070c4 <tcp_input+0x2a0>)
 8006eb8:	f8b2 30a0 	ldrh.w	r3, [r2, #160]	; 0xa0
 8006ebc:	3301      	adds	r3, #1
 8006ebe:	f8a2 30a0 	strh.w	r3, [r2, #160]	; 0xa0
    goto dropped;
 8006ec2:	e7d0      	b.n	8006e66 <tcp_input+0x42>
  hdrlen = TCPH_HDRLEN(tcphdr);
 8006ec4:	4b80      	ldr	r3, [pc, #512]	; (80070c8 <tcp_input+0x2a4>)
 8006ec6:	681b      	ldr	r3, [r3, #0]
 8006ec8:	8998      	ldrh	r0, [r3, #12]
 8006eca:	f7fd f95e 	bl	800418a <lwip_ntohs>
 8006ece:	0b00      	lsrs	r0, r0, #12
  if(pbuf_header(p, -(hdrlen * 4))){
 8006ed0:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
 8006ed4:	0081      	lsls	r1, r0, #2
 8006ed6:	b209      	sxth	r1, r1
 8006ed8:	4620      	mov	r0, r4
 8006eda:	f7fe fb8e 	bl	80055fa <pbuf_header>
 8006ede:	b130      	cbz	r0, 8006eee <tcp_input+0xca>
    TCP_STATS_INC(tcp.lenerr);
 8006ee0:	4a78      	ldr	r2, [pc, #480]	; (80070c4 <tcp_input+0x2a0>)
 8006ee2:	f8b2 309a 	ldrh.w	r3, [r2, #154]	; 0x9a
 8006ee6:	3301      	adds	r3, #1
 8006ee8:	f8a2 309a 	strh.w	r3, [r2, #154]	; 0x9a
    goto dropped;
 8006eec:	e7bb      	b.n	8006e66 <tcp_input+0x42>
  tcphdr->src = ntohs(tcphdr->src);
 8006eee:	4d76      	ldr	r5, [pc, #472]	; (80070c8 <tcp_input+0x2a4>)
 8006ef0:	682e      	ldr	r6, [r5, #0]
 8006ef2:	8830      	ldrh	r0, [r6, #0]
 8006ef4:	f7fd f949 	bl	800418a <lwip_ntohs>
 8006ef8:	8030      	strh	r0, [r6, #0]
  tcphdr->dest = ntohs(tcphdr->dest);
 8006efa:	682e      	ldr	r6, [r5, #0]
 8006efc:	8870      	ldrh	r0, [r6, #2]
 8006efe:	f7fd f944 	bl	800418a <lwip_ntohs>
 8006f02:	8070      	strh	r0, [r6, #2]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 8006f04:	682e      	ldr	r6, [r5, #0]
 8006f06:	6870      	ldr	r0, [r6, #4]
 8006f08:	f7fd f950 	bl	80041ac <lwip_ntohl>
 8006f0c:	6070      	str	r0, [r6, #4]
 8006f0e:	4b71      	ldr	r3, [pc, #452]	; (80070d4 <tcp_input+0x2b0>)
 8006f10:	6018      	str	r0, [r3, #0]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8006f12:	682e      	ldr	r6, [r5, #0]
 8006f14:	68b0      	ldr	r0, [r6, #8]
 8006f16:	f7fd f949 	bl	80041ac <lwip_ntohl>
 8006f1a:	60b0      	str	r0, [r6, #8]
 8006f1c:	4b6e      	ldr	r3, [pc, #440]	; (80070d8 <tcp_input+0x2b4>)
 8006f1e:	6018      	str	r0, [r3, #0]
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8006f20:	682e      	ldr	r6, [r5, #0]
 8006f22:	89f0      	ldrh	r0, [r6, #14]
 8006f24:	f7fd f931 	bl	800418a <lwip_ntohs>
 8006f28:	81f0      	strh	r0, [r6, #14]
  flags = TCPH_FLAGS(tcphdr);
 8006f2a:	682b      	ldr	r3, [r5, #0]
 8006f2c:	8998      	ldrh	r0, [r3, #12]
 8006f2e:	f7fd f92c 	bl	800418a <lwip_ntohs>
 8006f32:	fa5f fe80 	uxtb.w	lr, r0
 8006f36:	f00e 023f 	and.w	r2, lr, #63	; 0x3f
 8006f3a:	4b68      	ldr	r3, [pc, #416]	; (80070dc <tcp_input+0x2b8>)
 8006f3c:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 8006f3e:	f01e 0303 	ands.w	r3, lr, #3
 8006f42:	bf18      	it	ne
 8006f44:	2301      	movne	r3, #1
 8006f46:	8921      	ldrh	r1, [r4, #8]
 8006f48:	440b      	add	r3, r1
 8006f4a:	b299      	uxth	r1, r3
 8006f4c:	4b64      	ldr	r3, [pc, #400]	; (80070e0 <tcp_input+0x2bc>)
 8006f4e:	8019      	strh	r1, [r3, #0]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8006f50:	4b64      	ldr	r3, [pc, #400]	; (80070e4 <tcp_input+0x2c0>)
 8006f52:	6818      	ldr	r0, [r3, #0]
 8006f54:	2800      	cmp	r0, #0
 8006f56:	d060      	beq.n	800701a <tcp_input+0x1f6>
    if (pcb->remote_port == tcphdr->src &&
 8006f58:	682f      	ldr	r7, [r5, #0]
 8006f5a:	883e      	ldrh	r6, [r7, #0]
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8006f5c:	4b5c      	ldr	r3, [pc, #368]	; (80070d0 <tcp_input+0x2ac>)
 8006f5e:	f8d3 c000 	ldr.w	ip, [r3]
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
 8006f62:	4b5a      	ldr	r3, [pc, #360]	; (80070cc <tcp_input+0x2a8>)
 8006f64:	f8d3 8000 	ldr.w	r8, [r3]
 8006f68:	4605      	mov	r5, r0
 8006f6a:	2200      	movs	r2, #0
 8006f6c:	e004      	b.n	8006f78 <tcp_input+0x154>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8006f6e:	68eb      	ldr	r3, [r5, #12]
 8006f70:	462a      	mov	r2, r5
 8006f72:	2b00      	cmp	r3, #0
 8006f74:	d051      	beq.n	800701a <tcp_input+0x1f6>
 8006f76:	461d      	mov	r5, r3
    if (pcb->remote_port == tcphdr->src &&
 8006f78:	8bab      	ldrh	r3, [r5, #28]
 8006f7a:	42b3      	cmp	r3, r6
 8006f7c:	d1f7      	bne.n	8006f6e <tcp_input+0x14a>
 8006f7e:	f8b5 901a 	ldrh.w	r9, [r5, #26]
 8006f82:	887b      	ldrh	r3, [r7, #2]
 8006f84:	4599      	cmp	r9, r3
 8006f86:	d1f2      	bne.n	8006f6e <tcp_input+0x14a>
       pcb->local_port == tcphdr->dest &&
 8006f88:	686b      	ldr	r3, [r5, #4]
 8006f8a:	4563      	cmp	r3, ip
 8006f8c:	d1ef      	bne.n	8006f6e <tcp_input+0x14a>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8006f8e:	682b      	ldr	r3, [r5, #0]
 8006f90:	4543      	cmp	r3, r8
 8006f92:	d1ec      	bne.n	8006f6e <tcp_input+0x14a>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 8006f94:	68eb      	ldr	r3, [r5, #12]
      if (prev != NULL) {
 8006f96:	b11a      	cbz	r2, 8006fa0 <tcp_input+0x17c>
        prev->next = pcb->next;
 8006f98:	60d3      	str	r3, [r2, #12]
        pcb->next = tcp_active_pcbs;
 8006f9a:	60e8      	str	r0, [r5, #12]
        tcp_active_pcbs = pcb;
 8006f9c:	4b51      	ldr	r3, [pc, #324]	; (80070e4 <tcp_input+0x2c0>)
 8006f9e:	601d      	str	r5, [r3, #0]
  if (pcb == NULL) {
 8006fa0:	2d00      	cmp	r5, #0
 8006fa2:	d03a      	beq.n	800701a <tcp_input+0x1f6>
    inseg.next = NULL;
 8006fa4:	4b50      	ldr	r3, [pc, #320]	; (80070e8 <tcp_input+0x2c4>)
 8006fa6:	2200      	movs	r2, #0
 8006fa8:	601a      	str	r2, [r3, #0]
    inseg.len = p->tot_len;
 8006faa:	8921      	ldrh	r1, [r4, #8]
 8006fac:	8119      	strh	r1, [r3, #8]
    inseg.p = p;
 8006fae:	605c      	str	r4, [r3, #4]
    inseg.tcphdr = tcphdr;
 8006fb0:	60df      	str	r7, [r3, #12]
    recv_data = NULL;
 8006fb2:	4b4e      	ldr	r3, [pc, #312]	; (80070ec <tcp_input+0x2c8>)
 8006fb4:	601a      	str	r2, [r3, #0]
    recv_flags = 0;
 8006fb6:	4b4e      	ldr	r3, [pc, #312]	; (80070f0 <tcp_input+0x2cc>)
 8006fb8:	701a      	strb	r2, [r3, #0]
    if (flags & TCP_PSH) {
 8006fba:	f01e 0f08 	tst.w	lr, #8
 8006fbe:	d003      	beq.n	8006fc8 <tcp_input+0x1a4>
      p->flags |= PBUF_FLAG_PUSH;
 8006fc0:	7b63      	ldrb	r3, [r4, #13]
 8006fc2:	f043 0301 	orr.w	r3, r3, #1
 8006fc6:	7363      	strb	r3, [r4, #13]
    if (pcb->refused_data != NULL) {
 8006fc8:	6fab      	ldr	r3, [r5, #120]	; 0x78
 8006fca:	2b00      	cmp	r3, #0
 8006fcc:	f000 811d 	beq.w	800720a <tcp_input+0x3e6>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 8006fd0:	4628      	mov	r0, r5
 8006fd2:	f7ff f8ad 	bl	8006130 <tcp_process_refused_data>
 8006fd6:	f110 0f0a 	cmn.w	r0, #10
 8006fda:	d008      	beq.n	8006fee <tcp_input+0x1ca>
 8006fdc:	6fab      	ldr	r3, [r5, #120]	; 0x78
 8006fde:	2b00      	cmp	r3, #0
 8006fe0:	f000 8113 	beq.w	800720a <tcp_input+0x3e6>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 8006fe4:	4b3e      	ldr	r3, [pc, #248]	; (80070e0 <tcp_input+0x2bc>)
 8006fe6:	881b      	ldrh	r3, [r3, #0]
 8006fe8:	2b00      	cmp	r3, #0
 8006fea:	f000 810e 	beq.w	800720a <tcp_input+0x3e6>
        TCP_STATS_INC(tcp.drop);
 8006fee:	4a35      	ldr	r2, [pc, #212]	; (80070c4 <tcp_input+0x2a0>)
 8006ff0:	f8b2 3096 	ldrh.w	r3, [r2, #150]	; 0x96
 8006ff4:	3301      	adds	r3, #1
 8006ff6:	f8a2 3096 	strh.w	r3, [r2, #150]	; 0x96
    tcp_input_pcb = NULL;
 8006ffa:	2300      	movs	r3, #0
 8006ffc:	4a3d      	ldr	r2, [pc, #244]	; (80070f4 <tcp_input+0x2d0>)
 8006ffe:	6013      	str	r3, [r2, #0]
    recv_data = NULL;
 8007000:	4a3a      	ldr	r2, [pc, #232]	; (80070ec <tcp_input+0x2c8>)
 8007002:	6013      	str	r3, [r2, #0]
    if (inseg.p != NULL)
 8007004:	4b38      	ldr	r3, [pc, #224]	; (80070e8 <tcp_input+0x2c4>)
 8007006:	6858      	ldr	r0, [r3, #4]
 8007008:	2800      	cmp	r0, #0
 800700a:	f43f af35 	beq.w	8006e78 <tcp_input+0x54>
      pbuf_free(inseg.p);
 800700e:	f7fe fb32 	bl	8005676 <pbuf_free>
      inseg.p = NULL;
 8007012:	2200      	movs	r2, #0
 8007014:	4b34      	ldr	r3, [pc, #208]	; (80070e8 <tcp_input+0x2c4>)
 8007016:	605a      	str	r2, [r3, #4]
 8007018:	e72e      	b.n	8006e78 <tcp_input+0x54>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800701a:	4b37      	ldr	r3, [pc, #220]	; (80070f8 <tcp_input+0x2d4>)
 800701c:	6818      	ldr	r0, [r3, #0]
 800701e:	2800      	cmp	r0, #0
 8007020:	d042      	beq.n	80070a8 <tcp_input+0x284>
      if (pcb->remote_port == tcphdr->src &&
 8007022:	4b29      	ldr	r3, [pc, #164]	; (80070c8 <tcp_input+0x2a4>)
 8007024:	681f      	ldr	r7, [r3, #0]
 8007026:	883a      	ldrh	r2, [r7, #0]
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8007028:	4b29      	ldr	r3, [pc, #164]	; (80070d0 <tcp_input+0x2ac>)
 800702a:	f8d3 8000 	ldr.w	r8, [r3]
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
 800702e:	4b27      	ldr	r3, [pc, #156]	; (80070cc <tcp_input+0x2a8>)
 8007030:	f8d3 c000 	ldr.w	ip, [r3]
 8007034:	e00f      	b.n	8007056 <tcp_input+0x232>
  } else if (flags & TCP_FIN) {
 8007036:	f01e 0f01 	tst.w	lr, #1
 800703a:	d002      	beq.n	8007042 <tcp_input+0x21e>
    pcb->tmr = tcp_ticks;
 800703c:	4b2f      	ldr	r3, [pc, #188]	; (80070fc <tcp_input+0x2d8>)
 800703e:	681b      	ldr	r3, [r3, #0]
 8007040:	6243      	str	r3, [r0, #36]	; 0x24
  if ((tcplen > 0))  {
 8007042:	b369      	cbz	r1, 80070a0 <tcp_input+0x27c>
    pcb->flags |= TF_ACK_NOW;
 8007044:	7f83      	ldrb	r3, [r0, #30]
 8007046:	f043 0302 	orr.w	r3, r3, #2
 800704a:	7783      	strb	r3, [r0, #30]
    return tcp_output(pcb);
 800704c:	f000 fd52 	bl	8007af4 <tcp_output>
 8007050:	e026      	b.n	80070a0 <tcp_input+0x27c>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8007052:	68c0      	ldr	r0, [r0, #12]
 8007054:	b340      	cbz	r0, 80070a8 <tcp_input+0x284>
      if (pcb->remote_port == tcphdr->src &&
 8007056:	8b83      	ldrh	r3, [r0, #28]
 8007058:	4293      	cmp	r3, r2
 800705a:	d1fa      	bne.n	8007052 <tcp_input+0x22e>
         pcb->local_port == tcphdr->dest &&
 800705c:	8b45      	ldrh	r5, [r0, #26]
      if (pcb->remote_port == tcphdr->src &&
 800705e:	887e      	ldrh	r6, [r7, #2]
 8007060:	42ae      	cmp	r6, r5
 8007062:	d1f6      	bne.n	8007052 <tcp_input+0x22e>
         pcb->local_port == tcphdr->dest &&
 8007064:	6846      	ldr	r6, [r0, #4]
 8007066:	4546      	cmp	r6, r8
 8007068:	d1f3      	bne.n	8007052 <tcp_input+0x22e>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 800706a:	6806      	ldr	r6, [r0, #0]
 800706c:	4566      	cmp	r6, ip
 800706e:	d1f0      	bne.n	8007052 <tcp_input+0x22e>
  if (flags & TCP_RST)  {
 8007070:	f01e 0f04 	tst.w	lr, #4
 8007074:	d114      	bne.n	80070a0 <tcp_input+0x27c>
  if (flags & TCP_SYN) {
 8007076:	f01e 0f02 	tst.w	lr, #2
 800707a:	d0dc      	beq.n	8007036 <tcp_input+0x212>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
 800707c:	4a15      	ldr	r2, [pc, #84]	; (80070d4 <tcp_input+0x2b0>)
 800707e:	6816      	ldr	r6, [r2, #0]
 8007080:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8007082:	1ab2      	subs	r2, r6, r2
 8007084:	d4dd      	bmi.n	8007042 <tcp_input+0x21e>
 8007086:	8d87      	ldrh	r7, [r0, #44]	; 0x2c
 8007088:	1bd2      	subs	r2, r2, r7
 800708a:	2a00      	cmp	r2, #0
 800708c:	dcd9      	bgt.n	8007042 <tcp_input+0x21e>
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 800708e:	9301      	str	r3, [sp, #4]
 8007090:	9500      	str	r5, [sp, #0]
 8007092:	4b0f      	ldr	r3, [pc, #60]	; (80070d0 <tcp_input+0x2ac>)
 8007094:	4a0d      	ldr	r2, [pc, #52]	; (80070cc <tcp_input+0x2a8>)
 8007096:	4431      	add	r1, r6
 8007098:	480f      	ldr	r0, [pc, #60]	; (80070d8 <tcp_input+0x2b4>)
 800709a:	6800      	ldr	r0, [r0, #0]
 800709c:	f000 fe82 	bl	8007da4 <tcp_rst>
        pbuf_free(p);
 80070a0:	4620      	mov	r0, r4
 80070a2:	f7fe fae8 	bl	8005676 <pbuf_free>
        return;
 80070a6:	e6e7      	b.n	8006e78 <tcp_input+0x54>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80070a8:	4b15      	ldr	r3, [pc, #84]	; (8007100 <tcp_input+0x2dc>)
 80070aa:	681f      	ldr	r7, [r3, #0]
 80070ac:	2f00      	cmp	r7, #0
 80070ae:	f000 837c 	beq.w	80077aa <tcp_input+0x986>
      if (lpcb->local_port == tcphdr->dest) {
 80070b2:	4b05      	ldr	r3, [pc, #20]	; (80070c8 <tcp_input+0x2a4>)
 80070b4:	681e      	ldr	r6, [r3, #0]
 80070b6:	8870      	ldrh	r0, [r6, #2]
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
 80070b8:	4b04      	ldr	r3, [pc, #16]	; (80070cc <tcp_input+0x2a8>)
 80070ba:	f8d3 c000 	ldr.w	ip, [r3]
 80070be:	463d      	mov	r5, r7
 80070c0:	2200      	movs	r2, #0
 80070c2:	e025      	b.n	8007110 <tcp_input+0x2ec>
 80070c4:	2000aac4 	.word	0x2000aac4
 80070c8:	200071bc 	.word	0x200071bc
 80070cc:	2000838c 	.word	0x2000838c
 80070d0:	20008384 	.word	0x20008384
 80070d4:	200071b8 	.word	0x200071b8
 80070d8:	20007198 	.word	0x20007198
 80070dc:	2000719c 	.word	0x2000719c
 80070e0:	200071c0 	.word	0x200071c0
 80070e4:	2000abe0 	.word	0x2000abe0
 80070e8:	200071a0 	.word	0x200071a0
 80070ec:	200071b0 	.word	0x200071b0
 80070f0:	200071b4 	.word	0x200071b4
 80070f4:	2000abf8 	.word	0x2000abf8
 80070f8:	2000abf4 	.word	0x2000abf4
 80070fc:	2000abe4 	.word	0x2000abe4
 8007100:	2000abe8 	.word	0x2000abe8
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8007104:	68eb      	ldr	r3, [r5, #12]
 8007106:	462a      	mov	r2, r5
 8007108:	2b00      	cmp	r3, #0
 800710a:	f000 834e 	beq.w	80077aa <tcp_input+0x986>
 800710e:	461d      	mov	r5, r3
      if (lpcb->local_port == tcphdr->dest) {
 8007110:	8b6b      	ldrh	r3, [r5, #26]
 8007112:	4283      	cmp	r3, r0
 8007114:	d1f6      	bne.n	8007104 <tcp_input+0x2e0>
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
 8007116:	682b      	ldr	r3, [r5, #0]
 8007118:	4563      	cmp	r3, ip
 800711a:	d002      	beq.n	8007122 <tcp_input+0x2fe>
 800711c:	b10d      	cbz	r5, 8007122 <tcp_input+0x2fe>
            ip_addr_isany(&(lpcb->local_ip))) {
 800711e:	2b00      	cmp	r3, #0
 8007120:	d1f0      	bne.n	8007104 <tcp_input+0x2e0>
    if (lpcb != NULL) {
 8007122:	2d00      	cmp	r5, #0
 8007124:	f000 8341 	beq.w	80077aa <tcp_input+0x986>
      if (prev != NULL) {
 8007128:	b122      	cbz	r2, 8007134 <tcp_input+0x310>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 800712a:	68eb      	ldr	r3, [r5, #12]
 800712c:	60d3      	str	r3, [r2, #12]
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 800712e:	60ef      	str	r7, [r5, #12]
        tcp_listen_pcbs.listen_pcbs = lpcb;
 8007130:	4ba3      	ldr	r3, [pc, #652]	; (80073c0 <tcp_input+0x59c>)
 8007132:	601d      	str	r5, [r3, #0]
  if (flags & TCP_RST) {
 8007134:	f01e 0f04 	tst.w	lr, #4
 8007138:	d157      	bne.n	80071ea <tcp_input+0x3c6>
  if (flags & TCP_ACK) {
 800713a:	f01e 0f10 	tst.w	lr, #16
 800713e:	d147      	bne.n	80071d0 <tcp_input+0x3ac>
  } else if (flags & TCP_SYN) {
 8007140:	f01e 0f02 	tst.w	lr, #2
 8007144:	d051      	beq.n	80071ea <tcp_input+0x3c6>
    npcb = tcp_alloc(pcb->prio);
 8007146:	7e68      	ldrb	r0, [r5, #25]
 8007148:	f7ff f8d0 	bl	80062ec <tcp_alloc>
    if (npcb == NULL) {
 800714c:	4606      	mov	r6, r0
 800714e:	2800      	cmp	r0, #0
 8007150:	d04f      	beq.n	80071f2 <tcp_input+0x3ce>
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
 8007152:	4b9c      	ldr	r3, [pc, #624]	; (80073c4 <tcp_input+0x5a0>)
 8007154:	681b      	ldr	r3, [r3, #0]
 8007156:	6003      	str	r3, [r0, #0]
    npcb->local_port = pcb->local_port;
 8007158:	8b6b      	ldrh	r3, [r5, #26]
 800715a:	8343      	strh	r3, [r0, #26]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 800715c:	4b9a      	ldr	r3, [pc, #616]	; (80073c8 <tcp_input+0x5a4>)
 800715e:	681b      	ldr	r3, [r3, #0]
 8007160:	6043      	str	r3, [r0, #4]
    npcb->remote_port = tcphdr->src;
 8007162:	4b9a      	ldr	r3, [pc, #616]	; (80073cc <tcp_input+0x5a8>)
 8007164:	681a      	ldr	r2, [r3, #0]
 8007166:	8813      	ldrh	r3, [r2, #0]
 8007168:	8383      	strh	r3, [r0, #28]
    npcb->state = SYN_RCVD;
 800716a:	2303      	movs	r3, #3
 800716c:	7603      	strb	r3, [r0, #24]
    npcb->rcv_nxt = seqno + 1;
 800716e:	4b98      	ldr	r3, [pc, #608]	; (80073d0 <tcp_input+0x5ac>)
 8007170:	681b      	ldr	r3, [r3, #0]
 8007172:	1c59      	adds	r1, r3, #1
 8007174:	6281      	str	r1, [r0, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 8007176:	6301      	str	r1, [r0, #48]	; 0x30
    npcb->snd_wnd = tcphdr->wnd;
 8007178:	89d1      	ldrh	r1, [r2, #14]
 800717a:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60
    npcb->snd_wnd_max = tcphdr->wnd;
 800717e:	89d2      	ldrh	r2, [r2, #14]
 8007180:	f8a0 2062 	strh.w	r2, [r0, #98]	; 0x62
    npcb->ssthresh = npcb->snd_wnd;
 8007184:	f8a0 104e 	strh.w	r1, [r0, #78]	; 0x4e
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 8007188:	3b01      	subs	r3, #1
 800718a:	6543      	str	r3, [r0, #84]	; 0x54
    npcb->callback_arg = pcb->callback_arg;
 800718c:	692b      	ldr	r3, [r5, #16]
 800718e:	6103      	str	r3, [r0, #16]
    npcb->accept = pcb->accept;
 8007190:	696b      	ldr	r3, [r5, #20]
 8007192:	6143      	str	r3, [r0, #20]
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 8007194:	7a2b      	ldrb	r3, [r5, #8]
 8007196:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 800719a:	7203      	strb	r3, [r0, #8]
    TCP_REG_ACTIVE(npcb);
 800719c:	4b8d      	ldr	r3, [pc, #564]	; (80073d4 <tcp_input+0x5b0>)
 800719e:	681a      	ldr	r2, [r3, #0]
 80071a0:	60c2      	str	r2, [r0, #12]
 80071a2:	6018      	str	r0, [r3, #0]
 80071a4:	f000 ff88 	bl	80080b8 <tcp_timer_needed>
 80071a8:	2201      	movs	r2, #1
 80071aa:	4b8b      	ldr	r3, [pc, #556]	; (80073d8 <tcp_input+0x5b4>)
 80071ac:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
 80071ae:	4630      	mov	r0, r6
 80071b0:	f7ff f948 	bl	8006444 <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 80071b4:	1d31      	adds	r1, r6, #4
 80071b6:	8ef0      	ldrh	r0, [r6, #54]	; 0x36
 80071b8:	f7ff f932 	bl	8006420 <tcp_eff_send_mss>
 80071bc:	86f0      	strh	r0, [r6, #54]	; 0x36
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 80071be:	2112      	movs	r1, #18
 80071c0:	4630      	mov	r0, r6
 80071c2:	f000 fbc5 	bl	8007950 <tcp_enqueue_flags>
    if (rc != ERR_OK) {
 80071c6:	b9d8      	cbnz	r0, 8007200 <tcp_input+0x3dc>
    return tcp_output(npcb);
 80071c8:	4630      	mov	r0, r6
 80071ca:	f000 fc93 	bl	8007af4 <tcp_output>
 80071ce:	e00c      	b.n	80071ea <tcp_input+0x3c6>
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 80071d0:	4b7f      	ldr	r3, [pc, #508]	; (80073d0 <tcp_input+0x5ac>)
 80071d2:	6818      	ldr	r0, [r3, #0]
 80071d4:	8833      	ldrh	r3, [r6, #0]
 80071d6:	9301      	str	r3, [sp, #4]
 80071d8:	8873      	ldrh	r3, [r6, #2]
 80071da:	9300      	str	r3, [sp, #0]
 80071dc:	4b7a      	ldr	r3, [pc, #488]	; (80073c8 <tcp_input+0x5a4>)
 80071de:	4a79      	ldr	r2, [pc, #484]	; (80073c4 <tcp_input+0x5a0>)
 80071e0:	4401      	add	r1, r0
 80071e2:	487e      	ldr	r0, [pc, #504]	; (80073dc <tcp_input+0x5b8>)
 80071e4:	6800      	ldr	r0, [r0, #0]
 80071e6:	f000 fddd 	bl	8007da4 <tcp_rst>
      pbuf_free(p);
 80071ea:	4620      	mov	r0, r4
 80071ec:	f7fe fa43 	bl	8005676 <pbuf_free>
      return;
 80071f0:	e642      	b.n	8006e78 <tcp_input+0x54>
      TCP_STATS_INC(tcp.memerr);
 80071f2:	4a7b      	ldr	r2, [pc, #492]	; (80073e0 <tcp_input+0x5bc>)
 80071f4:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 80071f8:	3301      	adds	r3, #1
 80071fa:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
 80071fe:	e7f4      	b.n	80071ea <tcp_input+0x3c6>
      tcp_abandon(npcb, 0);
 8007200:	2100      	movs	r1, #0
 8007202:	4630      	mov	r0, r6
 8007204:	f7ff f816 	bl	8006234 <tcp_abandon>
 8007208:	e7ef      	b.n	80071ea <tcp_input+0x3c6>
    tcp_input_pcb = pcb;
 800720a:	4b76      	ldr	r3, [pc, #472]	; (80073e4 <tcp_input+0x5c0>)
 800720c:	601d      	str	r5, [r3, #0]
  if (flags & TCP_RST) {
 800720e:	4b76      	ldr	r3, [pc, #472]	; (80073e8 <tcp_input+0x5c4>)
 8007210:	781b      	ldrb	r3, [r3, #0]
 8007212:	f013 0f04 	tst.w	r3, #4
 8007216:	d036      	beq.n	8007286 <tcp_input+0x462>
    if (pcb->state == SYN_SENT) {
 8007218:	7e2b      	ldrb	r3, [r5, #24]
 800721a:	2b02      	cmp	r3, #2
 800721c:	d021      	beq.n	8007262 <tcp_input+0x43e>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 800721e:	4b6c      	ldr	r3, [pc, #432]	; (80073d0 <tcp_input+0x5ac>)
 8007220:	681b      	ldr	r3, [r3, #0]
 8007222:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8007224:	1a9b      	subs	r3, r3, r2
 8007226:	d406      	bmi.n	8007236 <tcp_input+0x412>
 8007228:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
 800722a:	1a9b      	subs	r3, r3, r2
  u8_t acceptable = 0;
 800722c:	2b00      	cmp	r3, #0
 800722e:	bfcc      	ite	gt
 8007230:	2300      	movgt	r3, #0
 8007232:	2301      	movle	r3, #1
    if (acceptable) {
 8007234:	b9eb      	cbnz	r3, 8007272 <tcp_input+0x44e>
      if (recv_flags & TF_RESET) {
 8007236:	4b6d      	ldr	r3, [pc, #436]	; (80073ec <tcp_input+0x5c8>)
 8007238:	781b      	ldrb	r3, [r3, #0]
 800723a:	f013 0f08 	tst.w	r3, #8
 800723e:	f000 8248 	beq.w	80076d2 <tcp_input+0x8ae>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
 8007242:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 8007246:	b11b      	cbz	r3, 8007250 <tcp_input+0x42c>
 8007248:	f06f 010a 	mvn.w	r1, #10
 800724c:	6928      	ldr	r0, [r5, #16]
 800724e:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 8007250:	4629      	mov	r1, r5
 8007252:	4860      	ldr	r0, [pc, #384]	; (80073d4 <tcp_input+0x5b0>)
 8007254:	f7fe fe4a 	bl	8005eec <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 8007258:	4629      	mov	r1, r5
 800725a:	2002      	movs	r0, #2
 800725c:	f7fe f914 	bl	8005488 <memp_free>
 8007260:	e6cb      	b.n	8006ffa <tcp_input+0x1d6>
      if (ackno == pcb->snd_nxt) {
 8007262:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8007264:	4a5d      	ldr	r2, [pc, #372]	; (80073dc <tcp_input+0x5b8>)
 8007266:	6812      	ldr	r2, [r2, #0]
  u8_t acceptable = 0;
 8007268:	4293      	cmp	r3, r2
 800726a:	bf14      	ite	ne
 800726c:	2300      	movne	r3, #0
 800726e:	2301      	moveq	r3, #1
 8007270:	e7e0      	b.n	8007234 <tcp_input+0x410>
      recv_flags |= TF_RESET;
 8007272:	4a5e      	ldr	r2, [pc, #376]	; (80073ec <tcp_input+0x5c8>)
 8007274:	7813      	ldrb	r3, [r2, #0]
 8007276:	f043 0308 	orr.w	r3, r3, #8
 800727a:	7013      	strb	r3, [r2, #0]
      pcb->flags &= ~TF_ACK_DELAY;
 800727c:	7fab      	ldrb	r3, [r5, #30]
 800727e:	f023 0301 	bic.w	r3, r3, #1
 8007282:	77ab      	strb	r3, [r5, #30]
 8007284:	e7d7      	b.n	8007236 <tcp_input+0x412>
  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
 8007286:	f013 0f02 	tst.w	r3, #2
 800728a:	d009      	beq.n	80072a0 <tcp_input+0x47c>
 800728c:	7e2b      	ldrb	r3, [r5, #24]
 800728e:	3b02      	subs	r3, #2
 8007290:	b2db      	uxtb	r3, r3
 8007292:	2b01      	cmp	r3, #1
 8007294:	d904      	bls.n	80072a0 <tcp_input+0x47c>
    tcp_ack_now(pcb);
 8007296:	7fab      	ldrb	r3, [r5, #30]
 8007298:	f043 0302 	orr.w	r3, r3, #2
 800729c:	77ab      	strb	r3, [r5, #30]
 800729e:	e7ca      	b.n	8007236 <tcp_input+0x412>
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 80072a0:	7fab      	ldrb	r3, [r5, #30]
 80072a2:	f013 0f10 	tst.w	r3, #16
 80072a6:	d102      	bne.n	80072ae <tcp_input+0x48a>
    pcb->tmr = tcp_ticks;
 80072a8:	4b51      	ldr	r3, [pc, #324]	; (80073f0 <tcp_input+0x5cc>)
 80072aa:	681b      	ldr	r3, [r3, #0]
 80072ac:	626b      	str	r3, [r5, #36]	; 0x24
  pcb->keep_cnt_sent = 0;
 80072ae:	2300      	movs	r3, #0
 80072b0:	f885 3096 	strb.w	r3, [r5, #150]	; 0x96
  tcp_parseopt(pcb);
 80072b4:	4628      	mov	r0, r5
 80072b6:	f7ff f8c5 	bl	8006444 <tcp_parseopt>
  switch (pcb->state) {
 80072ba:	7e2b      	ldrb	r3, [r5, #24]
 80072bc:	3b02      	subs	r3, #2
 80072be:	2b07      	cmp	r3, #7
 80072c0:	d8b9      	bhi.n	8007236 <tcp_input+0x412>
 80072c2:	e8df f013 	tbh	[pc, r3, lsl #1]
 80072c6:	0008      	.short	0x0008
 80072c8:	00f70099 	.word	0x00f70099
 80072cc:	01600107 	.word	0x01600107
 80072d0:	019b00f7 	.word	0x019b00f7
 80072d4:	01f1      	.short	0x01f1
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 80072d6:	4b44      	ldr	r3, [pc, #272]	; (80073e8 <tcp_input+0x5c4>)
 80072d8:	781b      	ldrb	r3, [r3, #0]
 80072da:	f003 0312 	and.w	r3, r3, #18
 80072de:	2b12      	cmp	r3, #18
 80072e0:	d016      	beq.n	8007310 <tcp_input+0x4ec>
    else if (flags & TCP_ACK) {
 80072e2:	4b41      	ldr	r3, [pc, #260]	; (80073e8 <tcp_input+0x5c4>)
 80072e4:	781b      	ldrb	r3, [r3, #0]
 80072e6:	f013 0f10 	tst.w	r3, #16
 80072ea:	d0a4      	beq.n	8007236 <tcp_input+0x412>
        tcphdr->dest, tcphdr->src);
 80072ec:	4b37      	ldr	r3, [pc, #220]	; (80073cc <tcp_input+0x5a8>)
 80072ee:	681b      	ldr	r3, [r3, #0]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 80072f0:	4a40      	ldr	r2, [pc, #256]	; (80073f4 <tcp_input+0x5d0>)
 80072f2:	8810      	ldrh	r0, [r2, #0]
 80072f4:	4a36      	ldr	r2, [pc, #216]	; (80073d0 <tcp_input+0x5ac>)
 80072f6:	6811      	ldr	r1, [r2, #0]
 80072f8:	881a      	ldrh	r2, [r3, #0]
 80072fa:	9201      	str	r2, [sp, #4]
 80072fc:	885b      	ldrh	r3, [r3, #2]
 80072fe:	9300      	str	r3, [sp, #0]
 8007300:	4b31      	ldr	r3, [pc, #196]	; (80073c8 <tcp_input+0x5a4>)
 8007302:	4a30      	ldr	r2, [pc, #192]	; (80073c4 <tcp_input+0x5a0>)
 8007304:	4401      	add	r1, r0
 8007306:	4835      	ldr	r0, [pc, #212]	; (80073dc <tcp_input+0x5b8>)
 8007308:	6800      	ldr	r0, [r0, #0]
 800730a:	f000 fd4b 	bl	8007da4 <tcp_rst>
 800730e:	e792      	b.n	8007236 <tcp_input+0x412>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
 8007310:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007312:	68db      	ldr	r3, [r3, #12]
 8007314:	6858      	ldr	r0, [r3, #4]
 8007316:	f7fc ff49 	bl	80041ac <lwip_ntohl>
 800731a:	3001      	adds	r0, #1
 800731c:	4b2f      	ldr	r3, [pc, #188]	; (80073dc <tcp_input+0x5b8>)
 800731e:	681b      	ldr	r3, [r3, #0]
 8007320:	4298      	cmp	r0, r3
 8007322:	d1de      	bne.n	80072e2 <tcp_input+0x4be>
      pcb->snd_buf++;
 8007324:	f8b5 3066 	ldrh.w	r3, [r5, #102]	; 0x66
 8007328:	3301      	adds	r3, #1
 800732a:	f8a5 3066 	strh.w	r3, [r5, #102]	; 0x66
      pcb->rcv_nxt = seqno + 1;
 800732e:	4b28      	ldr	r3, [pc, #160]	; (80073d0 <tcp_input+0x5ac>)
 8007330:	681b      	ldr	r3, [r3, #0]
 8007332:	1c5a      	adds	r2, r3, #1
 8007334:	62aa      	str	r2, [r5, #40]	; 0x28
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 8007336:	632a      	str	r2, [r5, #48]	; 0x30
      pcb->lastack = ackno;
 8007338:	64a8      	str	r0, [r5, #72]	; 0x48
      pcb->snd_wnd = tcphdr->wnd;
 800733a:	4a24      	ldr	r2, [pc, #144]	; (80073cc <tcp_input+0x5a8>)
 800733c:	6812      	ldr	r2, [r2, #0]
 800733e:	89d1      	ldrh	r1, [r2, #14]
 8007340:	f8a5 1060 	strh.w	r1, [r5, #96]	; 0x60
      pcb->snd_wnd_max = tcphdr->wnd;
 8007344:	89d2      	ldrh	r2, [r2, #14]
 8007346:	f8a5 2062 	strh.w	r2, [r5, #98]	; 0x62
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 800734a:	3b01      	subs	r3, #1
 800734c:	656b      	str	r3, [r5, #84]	; 0x54
      pcb->state = ESTABLISHED;
 800734e:	2304      	movs	r3, #4
 8007350:	762b      	strb	r3, [r5, #24]
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 8007352:	18e9      	adds	r1, r5, r3
 8007354:	8ee8      	ldrh	r0, [r5, #54]	; 0x36
 8007356:	f7ff f863 	bl	8006420 <tcp_eff_send_mss>
 800735a:	86e8      	strh	r0, [r5, #54]	; 0x36
      pcb->ssthresh = pcb->mss * 10;
 800735c:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 8007360:	005b      	lsls	r3, r3, #1
 8007362:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 8007366:	f8b5 304c 	ldrh.w	r3, [r5, #76]	; 0x4c
 800736a:	2b01      	cmp	r3, #1
 800736c:	bf04      	itt	eq
 800736e:	0040      	lsleq	r0, r0, #1
 8007370:	b280      	uxtheq	r0, r0
 8007372:	f8a5 004c 	strh.w	r0, [r5, #76]	; 0x4c
      --pcb->snd_queuelen;
 8007376:	f8b5 3068 	ldrh.w	r3, [r5, #104]	; 0x68
 800737a:	3b01      	subs	r3, #1
 800737c:	f8a5 3068 	strh.w	r3, [r5, #104]	; 0x68
      rseg = pcb->unacked;
 8007380:	6f28      	ldr	r0, [r5, #112]	; 0x70
      pcb->unacked = rseg->next;
 8007382:	6803      	ldr	r3, [r0, #0]
 8007384:	672b      	str	r3, [r5, #112]	; 0x70
      tcp_seg_free(rseg);
 8007386:	f7fe fbb5 	bl	8005af4 <tcp_seg_free>
      if(pcb->unacked == NULL)
 800738a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800738c:	b993      	cbnz	r3, 80073b4 <tcp_input+0x590>
        pcb->rtime = -1;
 800738e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8007392:	86ab      	strh	r3, [r5, #52]	; 0x34
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 8007394:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 8007398:	b13b      	cbz	r3, 80073aa <tcp_input+0x586>
 800739a:	2200      	movs	r2, #0
 800739c:	4629      	mov	r1, r5
 800739e:	6928      	ldr	r0, [r5, #16]
 80073a0:	4798      	blx	r3
      if (err == ERR_ABRT) {
 80073a2:	f110 0f0a 	cmn.w	r0, #10
 80073a6:	f43f ae28 	beq.w	8006ffa <tcp_input+0x1d6>
      tcp_ack_now(pcb);
 80073aa:	7fab      	ldrb	r3, [r5, #30]
 80073ac:	f043 0302 	orr.w	r3, r3, #2
 80073b0:	77ab      	strb	r3, [r5, #30]
 80073b2:	e740      	b.n	8007236 <tcp_input+0x412>
        pcb->rtime = 0;
 80073b4:	2300      	movs	r3, #0
 80073b6:	86ab      	strh	r3, [r5, #52]	; 0x34
        pcb->nrtx = 0;
 80073b8:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
 80073bc:	e7ea      	b.n	8007394 <tcp_input+0x570>
 80073be:	bf00      	nop
 80073c0:	2000abe8 	.word	0x2000abe8
 80073c4:	2000838c 	.word	0x2000838c
 80073c8:	20008384 	.word	0x20008384
 80073cc:	200071bc 	.word	0x200071bc
 80073d0:	200071b8 	.word	0x200071b8
 80073d4:	2000abe0 	.word	0x2000abe0
 80073d8:	2000abdc 	.word	0x2000abdc
 80073dc:	20007198 	.word	0x20007198
 80073e0:	2000aac4 	.word	0x2000aac4
 80073e4:	2000abf8 	.word	0x2000abf8
 80073e8:	2000719c 	.word	0x2000719c
 80073ec:	200071b4 	.word	0x200071b4
 80073f0:	2000abe4 	.word	0x2000abe4
 80073f4:	200071c0 	.word	0x200071c0
    if (flags & TCP_ACK) {
 80073f8:	4b9f      	ldr	r3, [pc, #636]	; (8007678 <tcp_input+0x854>)
 80073fa:	781b      	ldrb	r3, [r3, #0]
 80073fc:	f013 0f10 	tst.w	r3, #16
 8007400:	d049      	beq.n	8007496 <tcp_input+0x672>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 8007402:	4b9e      	ldr	r3, [pc, #632]	; (800767c <tcp_input+0x858>)
 8007404:	6818      	ldr	r0, [r3, #0]
 8007406:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8007408:	43db      	mvns	r3, r3
 800740a:	42c3      	cmn	r3, r0
 800740c:	d433      	bmi.n	8007476 <tcp_input+0x652>
 800740e:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8007410:	1ac3      	subs	r3, r0, r3
 8007412:	2b00      	cmp	r3, #0
 8007414:	dc2f      	bgt.n	8007476 <tcp_input+0x652>
        pcb->state = ESTABLISHED;
 8007416:	2304      	movs	r3, #4
 8007418:	762b      	strb	r3, [r5, #24]
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
 800741a:	696b      	ldr	r3, [r5, #20]
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 800741c:	b143      	cbz	r3, 8007430 <tcp_input+0x60c>
 800741e:	2200      	movs	r2, #0
 8007420:	4629      	mov	r1, r5
 8007422:	6928      	ldr	r0, [r5, #16]
 8007424:	4798      	blx	r3
        if (err != ERR_OK) {
 8007426:	b138      	cbz	r0, 8007438 <tcp_input+0x614>
          if (err != ERR_ABRT) {
 8007428:	f110 0f0a 	cmn.w	r0, #10
 800742c:	f43f ade5 	beq.w	8006ffa <tcp_input+0x1d6>
            tcp_abort(pcb);
 8007430:	4628      	mov	r0, r5
 8007432:	f7fe ff49 	bl	80062c8 <tcp_abort>
 8007436:	e5e0      	b.n	8006ffa <tcp_input+0x1d6>
        old_cwnd = pcb->cwnd;
 8007438:	f8b5 404c 	ldrh.w	r4, [r5, #76]	; 0x4c
        tcp_receive(pcb);
 800743c:	4628      	mov	r0, r5
 800743e:	f7ff f8a9 	bl	8006594 <tcp_receive>
        if (pcb->acked != 0) {
 8007442:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
 8007446:	b113      	cbz	r3, 800744e <tcp_input+0x62a>
          pcb->acked--;
 8007448:	3b01      	subs	r3, #1
 800744a:	f8a5 3064 	strh.w	r3, [r5, #100]	; 0x64
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 800744e:	2c01      	cmp	r4, #1
 8007450:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
 8007452:	bf04      	itt	eq
 8007454:	005b      	lsleq	r3, r3, #1
 8007456:	b29b      	uxtheq	r3, r3
 8007458:	f8a5 304c 	strh.w	r3, [r5, #76]	; 0x4c
        if (recv_flags & TF_GOT_FIN) {
 800745c:	4b88      	ldr	r3, [pc, #544]	; (8007680 <tcp_input+0x85c>)
 800745e:	781b      	ldrb	r3, [r3, #0]
 8007460:	f013 0f20 	tst.w	r3, #32
 8007464:	f43f aee7 	beq.w	8007236 <tcp_input+0x412>
          tcp_ack_now(pcb);
 8007468:	7fab      	ldrb	r3, [r5, #30]
 800746a:	f043 0302 	orr.w	r3, r3, #2
 800746e:	77ab      	strb	r3, [r5, #30]
          pcb->state = CLOSE_WAIT;
 8007470:	2307      	movs	r3, #7
 8007472:	762b      	strb	r3, [r5, #24]
 8007474:	e6df      	b.n	8007236 <tcp_input+0x412>
                tcphdr->dest, tcphdr->src);
 8007476:	4b83      	ldr	r3, [pc, #524]	; (8007684 <tcp_input+0x860>)
 8007478:	681b      	ldr	r3, [r3, #0]
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 800747a:	4a83      	ldr	r2, [pc, #524]	; (8007688 <tcp_input+0x864>)
 800747c:	8814      	ldrh	r4, [r2, #0]
 800747e:	4a83      	ldr	r2, [pc, #524]	; (800768c <tcp_input+0x868>)
 8007480:	6811      	ldr	r1, [r2, #0]
 8007482:	881a      	ldrh	r2, [r3, #0]
 8007484:	9201      	str	r2, [sp, #4]
 8007486:	885b      	ldrh	r3, [r3, #2]
 8007488:	9300      	str	r3, [sp, #0]
 800748a:	4b81      	ldr	r3, [pc, #516]	; (8007690 <tcp_input+0x86c>)
 800748c:	4a81      	ldr	r2, [pc, #516]	; (8007694 <tcp_input+0x870>)
 800748e:	4421      	add	r1, r4
 8007490:	f000 fc88 	bl	8007da4 <tcp_rst>
 8007494:	e6cf      	b.n	8007236 <tcp_input+0x412>
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 8007496:	f013 0f02 	tst.w	r3, #2
 800749a:	f43f aecc 	beq.w	8007236 <tcp_input+0x412>
 800749e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80074a0:	3b01      	subs	r3, #1
 80074a2:	4a7a      	ldr	r2, [pc, #488]	; (800768c <tcp_input+0x868>)
 80074a4:	6812      	ldr	r2, [r2, #0]
 80074a6:	4293      	cmp	r3, r2
 80074a8:	f47f aec5 	bne.w	8007236 <tcp_input+0x412>
      tcp_rexmit(pcb);
 80074ac:	4628      	mov	r0, r5
 80074ae:	f000 fce3 	bl	8007e78 <tcp_rexmit>
 80074b2:	e6c0      	b.n	8007236 <tcp_input+0x412>
    tcp_receive(pcb);
 80074b4:	4628      	mov	r0, r5
 80074b6:	f7ff f86d 	bl	8006594 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 80074ba:	4b71      	ldr	r3, [pc, #452]	; (8007680 <tcp_input+0x85c>)
 80074bc:	781b      	ldrb	r3, [r3, #0]
 80074be:	f013 0f20 	tst.w	r3, #32
 80074c2:	f43f aeb8 	beq.w	8007236 <tcp_input+0x412>
      tcp_ack_now(pcb);
 80074c6:	7fab      	ldrb	r3, [r5, #30]
 80074c8:	f043 0302 	orr.w	r3, r3, #2
 80074cc:	77ab      	strb	r3, [r5, #30]
      pcb->state = CLOSE_WAIT;
 80074ce:	2307      	movs	r3, #7
 80074d0:	762b      	strb	r3, [r5, #24]
 80074d2:	e6b0      	b.n	8007236 <tcp_input+0x412>
    tcp_receive(pcb);
 80074d4:	4628      	mov	r0, r5
 80074d6:	f7ff f85d 	bl	8006594 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 80074da:	4b69      	ldr	r3, [pc, #420]	; (8007680 <tcp_input+0x85c>)
 80074dc:	781b      	ldrb	r3, [r3, #0]
 80074de:	f013 0f20 	tst.w	r3, #32
 80074e2:	d041      	beq.n	8007568 <tcp_input+0x744>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 80074e4:	4b64      	ldr	r3, [pc, #400]	; (8007678 <tcp_input+0x854>)
 80074e6:	781b      	ldrb	r3, [r3, #0]
 80074e8:	f013 0f10 	tst.w	r3, #16
 80074ec:	d035      	beq.n	800755a <tcp_input+0x736>
 80074ee:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 80074f0:	4b62      	ldr	r3, [pc, #392]	; (800767c <tcp_input+0x858>)
 80074f2:	681b      	ldr	r3, [r3, #0]
 80074f4:	429a      	cmp	r2, r3
 80074f6:	d130      	bne.n	800755a <tcp_input+0x736>
        tcp_ack_now(pcb);
 80074f8:	7fab      	ldrb	r3, [r5, #30]
 80074fa:	f043 0302 	orr.w	r3, r3, #2
 80074fe:	77ab      	strb	r3, [r5, #30]
        tcp_pcb_purge(pcb);
 8007500:	4628      	mov	r0, r5
 8007502:	f7fe fb24 	bl	8005b4e <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 8007506:	4b64      	ldr	r3, [pc, #400]	; (8007698 <tcp_input+0x874>)
 8007508:	681b      	ldr	r3, [r3, #0]
 800750a:	429d      	cmp	r5, r3
 800750c:	d10e      	bne.n	800752c <tcp_input+0x708>
 800750e:	68ea      	ldr	r2, [r5, #12]
 8007510:	4b61      	ldr	r3, [pc, #388]	; (8007698 <tcp_input+0x874>)
 8007512:	601a      	str	r2, [r3, #0]
 8007514:	2201      	movs	r2, #1
 8007516:	4b61      	ldr	r3, [pc, #388]	; (800769c <tcp_input+0x878>)
 8007518:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 800751a:	230a      	movs	r3, #10
 800751c:	762b      	strb	r3, [r5, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800751e:	4b60      	ldr	r3, [pc, #384]	; (80076a0 <tcp_input+0x87c>)
 8007520:	681a      	ldr	r2, [r3, #0]
 8007522:	60ea      	str	r2, [r5, #12]
 8007524:	601d      	str	r5, [r3, #0]
 8007526:	f000 fdc7 	bl	80080b8 <tcp_timer_needed>
 800752a:	e684      	b.n	8007236 <tcp_input+0x412>
        TCP_RMV_ACTIVE(pcb);
 800752c:	4a5d      	ldr	r2, [pc, #372]	; (80076a4 <tcp_input+0x880>)
 800752e:	6013      	str	r3, [r2, #0]
 8007530:	2200      	movs	r2, #0
 8007532:	2001      	movs	r0, #1
 8007534:	b92b      	cbnz	r3, 8007542 <tcp_input+0x71e>
 8007536:	2a00      	cmp	r2, #0
 8007538:	d0ec      	beq.n	8007514 <tcp_input+0x6f0>
 800753a:	2200      	movs	r2, #0
 800753c:	4b59      	ldr	r3, [pc, #356]	; (80076a4 <tcp_input+0x880>)
 800753e:	601a      	str	r2, [r3, #0]
 8007540:	e7e8      	b.n	8007514 <tcp_input+0x6f0>
 8007542:	68d9      	ldr	r1, [r3, #12]
 8007544:	428d      	cmp	r5, r1
 8007546:	d105      	bne.n	8007554 <tcp_input+0x730>
 8007548:	b10a      	cbz	r2, 800754e <tcp_input+0x72a>
 800754a:	4a56      	ldr	r2, [pc, #344]	; (80076a4 <tcp_input+0x880>)
 800754c:	6013      	str	r3, [r2, #0]
 800754e:	68ea      	ldr	r2, [r5, #12]
 8007550:	60da      	str	r2, [r3, #12]
 8007552:	e7df      	b.n	8007514 <tcp_input+0x6f0>
 8007554:	4602      	mov	r2, r0
 8007556:	460b      	mov	r3, r1
 8007558:	e7ec      	b.n	8007534 <tcp_input+0x710>
        tcp_ack_now(pcb);
 800755a:	7fab      	ldrb	r3, [r5, #30]
 800755c:	f043 0302 	orr.w	r3, r3, #2
 8007560:	77ab      	strb	r3, [r5, #30]
        pcb->state = CLOSING;
 8007562:	2308      	movs	r3, #8
 8007564:	762b      	strb	r3, [r5, #24]
 8007566:	e666      	b.n	8007236 <tcp_input+0x412>
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 8007568:	4b43      	ldr	r3, [pc, #268]	; (8007678 <tcp_input+0x854>)
 800756a:	781b      	ldrb	r3, [r3, #0]
 800756c:	f013 0f10 	tst.w	r3, #16
 8007570:	f43f ae61 	beq.w	8007236 <tcp_input+0x412>
 8007574:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8007576:	4b41      	ldr	r3, [pc, #260]	; (800767c <tcp_input+0x858>)
 8007578:	681b      	ldr	r3, [r3, #0]
 800757a:	429a      	cmp	r2, r3
 800757c:	f47f ae5b 	bne.w	8007236 <tcp_input+0x412>
      pcb->state = FIN_WAIT_2;
 8007580:	2306      	movs	r3, #6
 8007582:	762b      	strb	r3, [r5, #24]
 8007584:	e657      	b.n	8007236 <tcp_input+0x412>
    tcp_receive(pcb);
 8007586:	4628      	mov	r0, r5
 8007588:	f7ff f804 	bl	8006594 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 800758c:	4b3c      	ldr	r3, [pc, #240]	; (8007680 <tcp_input+0x85c>)
 800758e:	781b      	ldrb	r3, [r3, #0]
 8007590:	f013 0f20 	tst.w	r3, #32
 8007594:	f43f ae4f 	beq.w	8007236 <tcp_input+0x412>
      tcp_ack_now(pcb);
 8007598:	7fab      	ldrb	r3, [r5, #30]
 800759a:	f043 0302 	orr.w	r3, r3, #2
 800759e:	77ab      	strb	r3, [r5, #30]
      tcp_pcb_purge(pcb);
 80075a0:	4628      	mov	r0, r5
 80075a2:	f7fe fad4 	bl	8005b4e <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 80075a6:	4b3c      	ldr	r3, [pc, #240]	; (8007698 <tcp_input+0x874>)
 80075a8:	681b      	ldr	r3, [r3, #0]
 80075aa:	429d      	cmp	r5, r3
 80075ac:	d10e      	bne.n	80075cc <tcp_input+0x7a8>
 80075ae:	68ea      	ldr	r2, [r5, #12]
 80075b0:	4b39      	ldr	r3, [pc, #228]	; (8007698 <tcp_input+0x874>)
 80075b2:	601a      	str	r2, [r3, #0]
 80075b4:	2201      	movs	r2, #1
 80075b6:	4b39      	ldr	r3, [pc, #228]	; (800769c <tcp_input+0x878>)
 80075b8:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
 80075ba:	230a      	movs	r3, #10
 80075bc:	762b      	strb	r3, [r5, #24]
      TCP_REG(&tcp_tw_pcbs, pcb);
 80075be:	4b38      	ldr	r3, [pc, #224]	; (80076a0 <tcp_input+0x87c>)
 80075c0:	681a      	ldr	r2, [r3, #0]
 80075c2:	60ea      	str	r2, [r5, #12]
 80075c4:	601d      	str	r5, [r3, #0]
 80075c6:	f000 fd77 	bl	80080b8 <tcp_timer_needed>
 80075ca:	e634      	b.n	8007236 <tcp_input+0x412>
      TCP_RMV_ACTIVE(pcb);
 80075cc:	4a35      	ldr	r2, [pc, #212]	; (80076a4 <tcp_input+0x880>)
 80075ce:	6013      	str	r3, [r2, #0]
 80075d0:	2200      	movs	r2, #0
 80075d2:	2001      	movs	r0, #1
 80075d4:	e004      	b.n	80075e0 <tcp_input+0x7bc>
 80075d6:	68d9      	ldr	r1, [r3, #12]
 80075d8:	428d      	cmp	r5, r1
 80075da:	d009      	beq.n	80075f0 <tcp_input+0x7cc>
 80075dc:	4602      	mov	r2, r0
 80075de:	460b      	mov	r3, r1
 80075e0:	2b00      	cmp	r3, #0
 80075e2:	d1f8      	bne.n	80075d6 <tcp_input+0x7b2>
 80075e4:	2a00      	cmp	r2, #0
 80075e6:	d0e5      	beq.n	80075b4 <tcp_input+0x790>
 80075e8:	2200      	movs	r2, #0
 80075ea:	4b2e      	ldr	r3, [pc, #184]	; (80076a4 <tcp_input+0x880>)
 80075ec:	601a      	str	r2, [r3, #0]
 80075ee:	e7e1      	b.n	80075b4 <tcp_input+0x790>
 80075f0:	b10a      	cbz	r2, 80075f6 <tcp_input+0x7d2>
 80075f2:	4a2c      	ldr	r2, [pc, #176]	; (80076a4 <tcp_input+0x880>)
 80075f4:	6013      	str	r3, [r2, #0]
 80075f6:	68ea      	ldr	r2, [r5, #12]
 80075f8:	60da      	str	r2, [r3, #12]
 80075fa:	e7db      	b.n	80075b4 <tcp_input+0x790>
    tcp_receive(pcb);
 80075fc:	4628      	mov	r0, r5
 80075fe:	f7fe ffc9 	bl	8006594 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 8007602:	4b1d      	ldr	r3, [pc, #116]	; (8007678 <tcp_input+0x854>)
 8007604:	781b      	ldrb	r3, [r3, #0]
 8007606:	f013 0f10 	tst.w	r3, #16
 800760a:	f43f ae14 	beq.w	8007236 <tcp_input+0x412>
 800760e:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8007610:	4b1a      	ldr	r3, [pc, #104]	; (800767c <tcp_input+0x858>)
 8007612:	681b      	ldr	r3, [r3, #0]
 8007614:	429a      	cmp	r2, r3
 8007616:	f47f ae0e 	bne.w	8007236 <tcp_input+0x412>
      tcp_pcb_purge(pcb);
 800761a:	4628      	mov	r0, r5
 800761c:	f7fe fa97 	bl	8005b4e <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8007620:	4b1d      	ldr	r3, [pc, #116]	; (8007698 <tcp_input+0x874>)
 8007622:	681b      	ldr	r3, [r3, #0]
 8007624:	429d      	cmp	r5, r3
 8007626:	d10e      	bne.n	8007646 <tcp_input+0x822>
 8007628:	68ea      	ldr	r2, [r5, #12]
 800762a:	4b1b      	ldr	r3, [pc, #108]	; (8007698 <tcp_input+0x874>)
 800762c:	601a      	str	r2, [r3, #0]
 800762e:	2201      	movs	r2, #1
 8007630:	4b1a      	ldr	r3, [pc, #104]	; (800769c <tcp_input+0x878>)
 8007632:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
 8007634:	230a      	movs	r3, #10
 8007636:	762b      	strb	r3, [r5, #24]
      TCP_REG(&tcp_tw_pcbs, pcb);
 8007638:	4b19      	ldr	r3, [pc, #100]	; (80076a0 <tcp_input+0x87c>)
 800763a:	681a      	ldr	r2, [r3, #0]
 800763c:	60ea      	str	r2, [r5, #12]
 800763e:	601d      	str	r5, [r3, #0]
 8007640:	f000 fd3a 	bl	80080b8 <tcp_timer_needed>
 8007644:	e5f7      	b.n	8007236 <tcp_input+0x412>
      TCP_RMV_ACTIVE(pcb);
 8007646:	4a17      	ldr	r2, [pc, #92]	; (80076a4 <tcp_input+0x880>)
 8007648:	6013      	str	r3, [r2, #0]
 800764a:	2200      	movs	r2, #0
 800764c:	2001      	movs	r0, #1
 800764e:	e004      	b.n	800765a <tcp_input+0x836>
 8007650:	68d9      	ldr	r1, [r3, #12]
 8007652:	428d      	cmp	r5, r1
 8007654:	d009      	beq.n	800766a <tcp_input+0x846>
 8007656:	4602      	mov	r2, r0
 8007658:	460b      	mov	r3, r1
 800765a:	2b00      	cmp	r3, #0
 800765c:	d1f8      	bne.n	8007650 <tcp_input+0x82c>
 800765e:	2a00      	cmp	r2, #0
 8007660:	d0e5      	beq.n	800762e <tcp_input+0x80a>
 8007662:	2200      	movs	r2, #0
 8007664:	4b0f      	ldr	r3, [pc, #60]	; (80076a4 <tcp_input+0x880>)
 8007666:	601a      	str	r2, [r3, #0]
 8007668:	e7e1      	b.n	800762e <tcp_input+0x80a>
 800766a:	b10a      	cbz	r2, 8007670 <tcp_input+0x84c>
 800766c:	4a0d      	ldr	r2, [pc, #52]	; (80076a4 <tcp_input+0x880>)
 800766e:	6013      	str	r3, [r2, #0]
 8007670:	68ea      	ldr	r2, [r5, #12]
 8007672:	60da      	str	r2, [r3, #12]
 8007674:	e7db      	b.n	800762e <tcp_input+0x80a>
 8007676:	bf00      	nop
 8007678:	2000719c 	.word	0x2000719c
 800767c:	20007198 	.word	0x20007198
 8007680:	200071b4 	.word	0x200071b4
 8007684:	200071bc 	.word	0x200071bc
 8007688:	200071c0 	.word	0x200071c0
 800768c:	200071b8 	.word	0x200071b8
 8007690:	20008384 	.word	0x20008384
 8007694:	2000838c 	.word	0x2000838c
 8007698:	2000abe0 	.word	0x2000abe0
 800769c:	2000abdc 	.word	0x2000abdc
 80076a0:	2000abf4 	.word	0x2000abf4
 80076a4:	2000abec 	.word	0x2000abec
    tcp_receive(pcb);
 80076a8:	4628      	mov	r0, r5
 80076aa:	f7fe ff73 	bl	8006594 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 80076ae:	4b53      	ldr	r3, [pc, #332]	; (80077fc <tcp_input+0x9d8>)
 80076b0:	781b      	ldrb	r3, [r3, #0]
 80076b2:	f013 0f10 	tst.w	r3, #16
 80076b6:	f43f adbe 	beq.w	8007236 <tcp_input+0x412>
 80076ba:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 80076bc:	4b50      	ldr	r3, [pc, #320]	; (8007800 <tcp_input+0x9dc>)
 80076be:	681b      	ldr	r3, [r3, #0]
 80076c0:	429a      	cmp	r2, r3
 80076c2:	f47f adb8 	bne.w	8007236 <tcp_input+0x412>
      recv_flags |= TF_CLOSED;
 80076c6:	4a4f      	ldr	r2, [pc, #316]	; (8007804 <tcp_input+0x9e0>)
 80076c8:	7813      	ldrb	r3, [r2, #0]
 80076ca:	f043 0310 	orr.w	r3, r3, #16
 80076ce:	7013      	strb	r3, [r2, #0]
 80076d0:	e5b1      	b.n	8007236 <tcp_input+0x412>
      } else if (recv_flags & TF_CLOSED) {
 80076d2:	f013 0f10 	tst.w	r3, #16
 80076d6:	d013      	beq.n	8007700 <tcp_input+0x8dc>
        if (!(pcb->flags & TF_RXCLOSED)) {
 80076d8:	7fab      	ldrb	r3, [r5, #30]
 80076da:	f013 0f10 	tst.w	r3, #16
 80076de:	d106      	bne.n	80076ee <tcp_input+0x8ca>
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
 80076e0:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 80076e4:	b11b      	cbz	r3, 80076ee <tcp_input+0x8ca>
 80076e6:	f06f 010b 	mvn.w	r1, #11
 80076ea:	6928      	ldr	r0, [r5, #16]
 80076ec:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 80076ee:	4629      	mov	r1, r5
 80076f0:	4845      	ldr	r0, [pc, #276]	; (8007808 <tcp_input+0x9e4>)
 80076f2:	f7fe fbfb 	bl	8005eec <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 80076f6:	4629      	mov	r1, r5
 80076f8:	2002      	movs	r0, #2
 80076fa:	f7fd fec5 	bl	8005488 <memp_free>
 80076fe:	e47c      	b.n	8006ffa <tcp_input+0x1d6>
        if (pcb->acked > 0) {
 8007700:	f8b5 2064 	ldrh.w	r2, [r5, #100]	; 0x64
 8007704:	b142      	cbz	r2, 8007718 <tcp_input+0x8f4>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
 8007706:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 8007708:	b133      	cbz	r3, 8007718 <tcp_input+0x8f4>
 800770a:	4629      	mov	r1, r5
 800770c:	6928      	ldr	r0, [r5, #16]
 800770e:	4798      	blx	r3
          if (err == ERR_ABRT) {
 8007710:	f110 0f0a 	cmn.w	r0, #10
 8007714:	f43f ac71 	beq.w	8006ffa <tcp_input+0x1d6>
        if (recv_data != NULL) {
 8007718:	4b3c      	ldr	r3, [pc, #240]	; (800780c <tcp_input+0x9e8>)
 800771a:	681a      	ldr	r2, [r3, #0]
 800771c:	b1ca      	cbz	r2, 8007752 <tcp_input+0x92e>
          if (pcb->flags & TF_RXCLOSED) {
 800771e:	7fab      	ldrb	r3, [r5, #30]
 8007720:	f013 0f10 	tst.w	r3, #16
 8007724:	d006      	beq.n	8007734 <tcp_input+0x910>
            pbuf_free(recv_data);
 8007726:	4610      	mov	r0, r2
 8007728:	f7fd ffa5 	bl	8005676 <pbuf_free>
            tcp_abort(pcb);
 800772c:	4628      	mov	r0, r5
 800772e:	f7fe fdcb 	bl	80062c8 <tcp_abort>
            goto aborted;
 8007732:	e462      	b.n	8006ffa <tcp_input+0x1d6>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 8007734:	f8d5 4080 	ldr.w	r4, [r5, #128]	; 0x80
 8007738:	b1ec      	cbz	r4, 8007776 <tcp_input+0x952>
 800773a:	2300      	movs	r3, #0
 800773c:	4629      	mov	r1, r5
 800773e:	6928      	ldr	r0, [r5, #16]
 8007740:	47a0      	blx	r4
          if (err == ERR_ABRT) {
 8007742:	f110 0f0a 	cmn.w	r0, #10
 8007746:	f43f ac58 	beq.w	8006ffa <tcp_input+0x1d6>
          if (err != ERR_OK) {
 800774a:	b110      	cbz	r0, 8007752 <tcp_input+0x92e>
            pcb->refused_data = recv_data;
 800774c:	4b2f      	ldr	r3, [pc, #188]	; (800780c <tcp_input+0x9e8>)
 800774e:	681b      	ldr	r3, [r3, #0]
 8007750:	67ab      	str	r3, [r5, #120]	; 0x78
        if (recv_flags & TF_GOT_FIN) {
 8007752:	4b2c      	ldr	r3, [pc, #176]	; (8007804 <tcp_input+0x9e0>)
 8007754:	781b      	ldrb	r3, [r3, #0]
 8007756:	f013 0f20 	tst.w	r3, #32
 800775a:	d005      	beq.n	8007768 <tcp_input+0x944>
          if (pcb->refused_data != NULL) {
 800775c:	6fab      	ldr	r3, [r5, #120]	; 0x78
 800775e:	b183      	cbz	r3, 8007782 <tcp_input+0x95e>
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 8007760:	7b5a      	ldrb	r2, [r3, #13]
 8007762:	f042 0220 	orr.w	r2, r2, #32
 8007766:	735a      	strb	r2, [r3, #13]
        tcp_input_pcb = NULL;
 8007768:	2200      	movs	r2, #0
 800776a:	4b29      	ldr	r3, [pc, #164]	; (8007810 <tcp_input+0x9ec>)
 800776c:	601a      	str	r2, [r3, #0]
        tcp_output(pcb);
 800776e:	4628      	mov	r0, r5
 8007770:	f000 f9c0 	bl	8007af4 <tcp_output>
 8007774:	e441      	b.n	8006ffa <tcp_input+0x1d6>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 8007776:	2300      	movs	r3, #0
 8007778:	4629      	mov	r1, r5
 800777a:	4618      	mov	r0, r3
 800777c:	f7fe fcc6 	bl	800610c <tcp_recv_null>
 8007780:	e7df      	b.n	8007742 <tcp_input+0x91e>
            if (pcb->rcv_wnd != TCP_WND) {
 8007782:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
 8007784:	f241 62d0 	movw	r2, #5840	; 0x16d0
 8007788:	4293      	cmp	r3, r2
              pcb->rcv_wnd++;
 800778a:	bf1c      	itt	ne
 800778c:	3301      	addne	r3, #1
 800778e:	85ab      	strhne	r3, [r5, #44]	; 0x2c
            TCP_EVENT_CLOSED(pcb, err);
 8007790:	f8d5 4080 	ldr.w	r4, [r5, #128]	; 0x80
 8007794:	2c00      	cmp	r4, #0
 8007796:	d0e7      	beq.n	8007768 <tcp_input+0x944>
 8007798:	2300      	movs	r3, #0
 800779a:	461a      	mov	r2, r3
 800779c:	4629      	mov	r1, r5
 800779e:	6928      	ldr	r0, [r5, #16]
 80077a0:	47a0      	blx	r4
            if (err == ERR_ABRT) {
 80077a2:	f110 0f0a 	cmn.w	r0, #10
 80077a6:	d1df      	bne.n	8007768 <tcp_input+0x944>
 80077a8:	e427      	b.n	8006ffa <tcp_input+0x1d6>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 80077aa:	4b1a      	ldr	r3, [pc, #104]	; (8007814 <tcp_input+0x9f0>)
 80077ac:	681b      	ldr	r3, [r3, #0]
 80077ae:	8998      	ldrh	r0, [r3, #12]
 80077b0:	f7fc fceb 	bl	800418a <lwip_ntohs>
 80077b4:	f010 0f04 	tst.w	r0, #4
 80077b8:	d11b      	bne.n	80077f2 <tcp_input+0x9ce>
      TCP_STATS_INC(tcp.proterr);
 80077ba:	4b17      	ldr	r3, [pc, #92]	; (8007818 <tcp_input+0x9f4>)
 80077bc:	f8b3 20a0 	ldrh.w	r2, [r3, #160]	; 0xa0
 80077c0:	3201      	adds	r2, #1
 80077c2:	f8a3 20a0 	strh.w	r2, [r3, #160]	; 0xa0
      TCP_STATS_INC(tcp.drop);
 80077c6:	f8b3 2096 	ldrh.w	r2, [r3, #150]	; 0x96
 80077ca:	3201      	adds	r2, #1
 80077cc:	f8a3 2096 	strh.w	r2, [r3, #150]	; 0x96
        tcphdr->dest, tcphdr->src);
 80077d0:	4b10      	ldr	r3, [pc, #64]	; (8007814 <tcp_input+0x9f0>)
 80077d2:	681b      	ldr	r3, [r3, #0]
      tcp_rst(ackno, seqno + tcplen,
 80077d4:	4a11      	ldr	r2, [pc, #68]	; (800781c <tcp_input+0x9f8>)
 80077d6:	8810      	ldrh	r0, [r2, #0]
 80077d8:	4a11      	ldr	r2, [pc, #68]	; (8007820 <tcp_input+0x9fc>)
 80077da:	6811      	ldr	r1, [r2, #0]
 80077dc:	881a      	ldrh	r2, [r3, #0]
 80077de:	9201      	str	r2, [sp, #4]
 80077e0:	885b      	ldrh	r3, [r3, #2]
 80077e2:	9300      	str	r3, [sp, #0]
 80077e4:	4b0f      	ldr	r3, [pc, #60]	; (8007824 <tcp_input+0xa00>)
 80077e6:	4a10      	ldr	r2, [pc, #64]	; (8007828 <tcp_input+0xa04>)
 80077e8:	4401      	add	r1, r0
 80077ea:	4805      	ldr	r0, [pc, #20]	; (8007800 <tcp_input+0x9dc>)
 80077ec:	6800      	ldr	r0, [r0, #0]
 80077ee:	f000 fad9 	bl	8007da4 <tcp_rst>
    pbuf_free(p);
 80077f2:	4620      	mov	r0, r4
 80077f4:	f7fd ff3f 	bl	8005676 <pbuf_free>
 80077f8:	f7ff bb3e 	b.w	8006e78 <tcp_input+0x54>
 80077fc:	2000719c 	.word	0x2000719c
 8007800:	20007198 	.word	0x20007198
 8007804:	200071b4 	.word	0x200071b4
 8007808:	2000abe0 	.word	0x2000abe0
 800780c:	200071b0 	.word	0x200071b0
 8007810:	2000abf8 	.word	0x2000abf8
 8007814:	200071bc 	.word	0x200071bc
 8007818:	2000aac4 	.word	0x2000aac4
 800781c:	200071c0 	.word	0x200071c0
 8007820:	200071b8 	.word	0x200071b8
 8007824:	20008384 	.word	0x20008384
 8007828:	2000838c 	.word	0x2000838c

0800782c <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
 800782c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007830:	4681      	mov	r9, r0
 8007832:	4688      	mov	r8, r1
 8007834:	4616      	mov	r6, r2
 8007836:	469a      	mov	sl, r3
 8007838:	f89d 7020 	ldrb.w	r7, [sp, #32]
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800783c:	f007 0301 	and.w	r3, r7, #1
 8007840:	f007 0202 	and.w	r2, r7, #2
 8007844:	2a00      	cmp	r2, #0
 8007846:	bf14      	ite	ne
 8007848:	250c      	movne	r5, #12
 800784a:	2500      	moveq	r5, #0
 800784c:	eb05 0583 	add.w	r5, r5, r3, lsl #2

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 8007850:	2004      	movs	r0, #4
 8007852:	f7fd fde3 	bl	800541c <memp_malloc>
 8007856:	4604      	mov	r4, r0
 8007858:	b388      	cbz	r0, 80078be <tcp_create_segment+0x92>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
 800785a:	7287      	strb	r7, [r0, #10]
  seg->next = NULL;
 800785c:	2300      	movs	r3, #0
 800785e:	6003      	str	r3, [r0, #0]
  seg->p = p;
 8007860:	f8c0 8004 	str.w	r8, [r0, #4]
  seg->len = p->tot_len - optlen;
 8007864:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 8007868:	1b5b      	subs	r3, r3, r5
 800786a:	8103      	strh	r3, [r0, #8]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 800786c:	2114      	movs	r1, #20
 800786e:	4640      	mov	r0, r8
 8007870:	f7fd fec3 	bl	80055fa <pbuf_header>
 8007874:	bb38      	cbnz	r0, 80078c6 <tcp_create_segment+0x9a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 8007876:	6863      	ldr	r3, [r4, #4]
 8007878:	685f      	ldr	r7, [r3, #4]
 800787a:	60e7      	str	r7, [r4, #12]
  seg->tcphdr->src = htons(pcb->local_port);
 800787c:	f8b9 001a 	ldrh.w	r0, [r9, #26]
 8007880:	f7fc fc7e 	bl	8004180 <lwip_htons>
 8007884:	8038      	strh	r0, [r7, #0]
  seg->tcphdr->dest = htons(pcb->remote_port);
 8007886:	68e7      	ldr	r7, [r4, #12]
 8007888:	f8b9 001c 	ldrh.w	r0, [r9, #28]
 800788c:	f7fc fc78 	bl	8004180 <lwip_htons>
 8007890:	8078      	strh	r0, [r7, #2]
  seg->tcphdr->seqno = htonl(seqno);
 8007892:	68e7      	ldr	r7, [r4, #12]
 8007894:	4650      	mov	r0, sl
 8007896:	f7fc fc7d 	bl	8004194 <lwip_htonl>
 800789a:	6078      	str	r0, [r7, #4]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800789c:	68e7      	ldr	r7, [r4, #12]
 800789e:	f3c5 0587 	ubfx	r5, r5, #2, #8
 80078a2:	3505      	adds	r5, #5
 80078a4:	ea46 3505 	orr.w	r5, r6, r5, lsl #12
 80078a8:	b2a8      	uxth	r0, r5
 80078aa:	f7fc fc69 	bl	8004180 <lwip_htons>
 80078ae:	81b8      	strh	r0, [r7, #12]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 80078b0:	68e3      	ldr	r3, [r4, #12]
 80078b2:	2200      	movs	r2, #0
 80078b4:	749a      	strb	r2, [r3, #18]
 80078b6:	74da      	strb	r2, [r3, #19]
  return seg;
} 
 80078b8:	4620      	mov	r0, r4
 80078ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    pbuf_free(p);
 80078be:	4640      	mov	r0, r8
 80078c0:	f7fd fed9 	bl	8005676 <pbuf_free>
    return NULL;
 80078c4:	e7f8      	b.n	80078b8 <tcp_create_segment+0x8c>
    TCP_STATS_INC(tcp.err);
 80078c6:	4a05      	ldr	r2, [pc, #20]	; (80078dc <tcp_create_segment+0xb0>)
 80078c8:	f8b2 30a4 	ldrh.w	r3, [r2, #164]	; 0xa4
 80078cc:	3301      	adds	r3, #1
 80078ce:	f8a2 30a4 	strh.w	r3, [r2, #164]	; 0xa4
    tcp_seg_free(seg);
 80078d2:	4620      	mov	r0, r4
 80078d4:	f7fe f90e 	bl	8005af4 <tcp_seg_free>
    return NULL;
 80078d8:	2400      	movs	r4, #0
 80078da:	e7ed      	b.n	80078b8 <tcp_create_segment+0x8c>
 80078dc:	2000aac4 	.word	0x2000aac4

080078e0 <tcp_output_alloc_header>:
{
 80078e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80078e4:	4606      	mov	r6, r0
 80078e6:	460c      	mov	r4, r1
 80078e8:	4698      	mov	r8, r3
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 80078ea:	3214      	adds	r2, #20
 80078ec:	4411      	add	r1, r2
 80078ee:	2200      	movs	r2, #0
 80078f0:	b289      	uxth	r1, r1
 80078f2:	2001      	movs	r0, #1
 80078f4:	f7fd feee 	bl	80056d4 <pbuf_alloc>
  if (p != NULL) {
 80078f8:	4607      	mov	r7, r0
 80078fa:	b328      	cbz	r0, 8007948 <tcp_output_alloc_header+0x68>
    tcphdr = (struct tcp_hdr *)p->payload;
 80078fc:	6845      	ldr	r5, [r0, #4]
    tcphdr->src = htons(pcb->local_port);
 80078fe:	8b70      	ldrh	r0, [r6, #26]
 8007900:	f7fc fc3e 	bl	8004180 <lwip_htons>
 8007904:	8028      	strh	r0, [r5, #0]
    tcphdr->dest = htons(pcb->remote_port);
 8007906:	8bb0      	ldrh	r0, [r6, #28]
 8007908:	f7fc fc3a 	bl	8004180 <lwip_htons>
 800790c:	8068      	strh	r0, [r5, #2]
    tcphdr->seqno = seqno_be;
 800790e:	f8c5 8004 	str.w	r8, [r5, #4]
    tcphdr->ackno = htonl(pcb->rcv_nxt);
 8007912:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 8007914:	f7fc fc3e 	bl	8004194 <lwip_htonl>
 8007918:	60a8      	str	r0, [r5, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 800791a:	08a0      	lsrs	r0, r4, #2
 800791c:	3005      	adds	r0, #5
 800791e:	0300      	lsls	r0, r0, #12
 8007920:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
 8007924:	f040 0010 	orr.w	r0, r0, #16
 8007928:	f7fc fc2a 	bl	8004180 <lwip_htons>
 800792c:	81a8      	strh	r0, [r5, #12]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 800792e:	8df0      	ldrh	r0, [r6, #46]	; 0x2e
 8007930:	f7fc fc26 	bl	8004180 <lwip_htons>
 8007934:	81e8      	strh	r0, [r5, #14]
    tcphdr->chksum = 0;
 8007936:	2300      	movs	r3, #0
 8007938:	742b      	strb	r3, [r5, #16]
 800793a:	746b      	strb	r3, [r5, #17]
    tcphdr->urgp = 0;
 800793c:	74ab      	strb	r3, [r5, #18]
 800793e:	74eb      	strb	r3, [r5, #19]
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8007940:	8df2      	ldrh	r2, [r6, #46]	; 0x2e
 8007942:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8007944:	4413      	add	r3, r2
 8007946:	6333      	str	r3, [r6, #48]	; 0x30
}
 8007948:	4638      	mov	r0, r7
 800794a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08007950 <tcp_enqueue_flags>:

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8007950:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
 8007954:	2b07      	cmp	r3, #7
 8007956:	d825      	bhi.n	80079a4 <tcp_enqueue_flags+0x54>
{
 8007958:	b5f0      	push	{r4, r5, r6, r7, lr}
 800795a:	b083      	sub	sp, #12
 800795c:	f001 0603 	and.w	r6, r1, #3
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

  if (flags & TCP_SYN) {
 8007960:	f001 0302 	and.w	r3, r1, #2
  u8_t optflags = 0;
 8007964:	f3c1 0740 	ubfx	r7, r1, #1, #1
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 8007968:	2b00      	cmp	r3, #0
 800796a:	bf14      	ite	ne
 800796c:	f04f 0e04 	movne.w	lr, #4
 8007970:	f04f 0e00 	moveq.w	lr, #0

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
 8007974:	f8b0 3066 	ldrh.w	r3, [r0, #102]	; 0x66
 8007978:	b30b      	cbz	r3, 80079be <tcp_enqueue_flags+0x6e>
 800797a:	460d      	mov	r5, r1
 800797c:	4604      	mov	r4, r0
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800797e:	2200      	movs	r2, #0
 8007980:	4671      	mov	r1, lr
 8007982:	4610      	mov	r0, r2
 8007984:	f7fd fea6 	bl	80056d4 <pbuf_alloc>
 8007988:	4601      	mov	r1, r0
 800798a:	b308      	cbz	r0, 80079d0 <tcp_enqueue_flags+0x80>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 800798c:	9700      	str	r7, [sp, #0]
 800798e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8007990:	462a      	mov	r2, r5
 8007992:	4620      	mov	r0, r4
 8007994:	f7ff ff4a 	bl	800782c <tcp_create_segment>
 8007998:	4601      	mov	r1, r0
 800799a:	b330      	cbz	r0, 80079ea <tcp_enqueue_flags+0x9a>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 800799c:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800799e:	bb92      	cbnz	r2, 8007a06 <tcp_enqueue_flags+0xb6>
    pcb->unsent = seg;
 80079a0:	66e0      	str	r0, [r4, #108]	; 0x6c
 80079a2:	e034      	b.n	8007a0e <tcp_enqueue_flags+0xbe>
    TCP_STATS_INC(tcp.memerr);
 80079a4:	4a29      	ldr	r2, [pc, #164]	; (8007a4c <tcp_enqueue_flags+0xfc>)
 80079a6:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 80079aa:	3301      	adds	r3, #1
 80079ac:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    pcb->flags |= TF_NAGLEMEMERR;
 80079b0:	7f83      	ldrb	r3, [r0, #30]
 80079b2:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80079b6:	7783      	strb	r3, [r0, #30]
    return ERR_MEM;
 80079b8:	f04f 30ff 	mov.w	r0, #4294967295
 80079bc:	4770      	bx	lr
    TCP_STATS_INC(tcp.memerr);
 80079be:	4a23      	ldr	r2, [pc, #140]	; (8007a4c <tcp_enqueue_flags+0xfc>)
 80079c0:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 80079c4:	3301      	adds	r3, #1
 80079c6:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    return ERR_MEM;
 80079ca:	f04f 30ff 	mov.w	r0, #4294967295
 80079ce:	e03a      	b.n	8007a46 <tcp_enqueue_flags+0xf6>
    pcb->flags |= TF_NAGLEMEMERR;
 80079d0:	7fa3      	ldrb	r3, [r4, #30]
 80079d2:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80079d6:	77a3      	strb	r3, [r4, #30]
    TCP_STATS_INC(tcp.memerr);
 80079d8:	4a1c      	ldr	r2, [pc, #112]	; (8007a4c <tcp_enqueue_flags+0xfc>)
 80079da:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 80079de:	3301      	adds	r3, #1
 80079e0:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    return ERR_MEM;
 80079e4:	f04f 30ff 	mov.w	r0, #4294967295
 80079e8:	e02d      	b.n	8007a46 <tcp_enqueue_flags+0xf6>
    pcb->flags |= TF_NAGLEMEMERR;
 80079ea:	7fa3      	ldrb	r3, [r4, #30]
 80079ec:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80079f0:	77a3      	strb	r3, [r4, #30]
    TCP_STATS_INC(tcp.memerr);
 80079f2:	4a16      	ldr	r2, [pc, #88]	; (8007a4c <tcp_enqueue_flags+0xfc>)
 80079f4:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 80079f8:	3301      	adds	r3, #1
 80079fa:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    return ERR_MEM;
 80079fe:	f04f 30ff 	mov.w	r0, #4294967295
 8007a02:	e020      	b.n	8007a46 <tcp_enqueue_flags+0xf6>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 8007a04:	461a      	mov	r2, r3
 8007a06:	6813      	ldr	r3, [r2, #0]
 8007a08:	2b00      	cmp	r3, #0
 8007a0a:	d1fb      	bne.n	8007a04 <tcp_enqueue_flags+0xb4>
    useg->next = seg;
 8007a0c:	6011      	str	r1, [r2, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 8007a0e:	2300      	movs	r3, #0
 8007a10:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 8007a14:	b13e      	cbz	r6, 8007a26 <tcp_enqueue_flags+0xd6>
    pcb->snd_lbb++;
 8007a16:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8007a18:	3301      	adds	r3, #1
 8007a1a:	65e3      	str	r3, [r4, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 8007a1c:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
 8007a20:	3b01      	subs	r3, #1
 8007a22:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
  }
  if (flags & TCP_FIN) {
 8007a26:	f015 0f01 	tst.w	r5, #1
 8007a2a:	d003      	beq.n	8007a34 <tcp_enqueue_flags+0xe4>
    pcb->flags |= TF_FIN;
 8007a2c:	7fa3      	ldrb	r3, [r4, #30]
 8007a2e:	f043 0320 	orr.w	r3, r3, #32
 8007a32:	77a3      	strb	r3, [r4, #30]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 8007a34:	6848      	ldr	r0, [r1, #4]
 8007a36:	f7fd ff10 	bl	800585a <pbuf_clen>
 8007a3a:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8007a3e:	4418      	add	r0, r3
 8007a40:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 8007a44:	2000      	movs	r0, #0
}
 8007a46:	b003      	add	sp, #12
 8007a48:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007a4a:	bf00      	nop
 8007a4c:	2000aac4 	.word	0x2000aac4

08007a50 <tcp_send_fin>:
{
 8007a50:	b570      	push	{r4, r5, r6, lr}
 8007a52:	4605      	mov	r5, r0
  if (pcb->unsent != NULL) {
 8007a54:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
 8007a56:	b90c      	cbnz	r4, 8007a5c <tcp_send_fin+0xc>
 8007a58:	e00a      	b.n	8007a70 <tcp_send_fin+0x20>
         last_unsent = last_unsent->next);
 8007a5a:	461c      	mov	r4, r3
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8007a5c:	6823      	ldr	r3, [r4, #0]
 8007a5e:	2b00      	cmp	r3, #0
 8007a60:	d1fb      	bne.n	8007a5a <tcp_send_fin+0xa>
    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 8007a62:	68e3      	ldr	r3, [r4, #12]
 8007a64:	8998      	ldrh	r0, [r3, #12]
 8007a66:	f7fc fb90 	bl	800418a <lwip_ntohs>
 8007a6a:	f010 0f07 	tst.w	r0, #7
 8007a6e:	d004      	beq.n	8007a7a <tcp_send_fin+0x2a>
  return tcp_enqueue_flags(pcb, TCP_FIN);
 8007a70:	2101      	movs	r1, #1
 8007a72:	4628      	mov	r0, r5
 8007a74:	f7ff ff6c 	bl	8007950 <tcp_enqueue_flags>
}
 8007a78:	bd70      	pop	{r4, r5, r6, pc}
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 8007a7a:	68e6      	ldr	r6, [r4, #12]
 8007a7c:	89b4      	ldrh	r4, [r6, #12]
 8007a7e:	2001      	movs	r0, #1
 8007a80:	f7fc fb7e 	bl	8004180 <lwip_htons>
 8007a84:	4320      	orrs	r0, r4
 8007a86:	81b0      	strh	r0, [r6, #12]
      pcb->flags |= TF_FIN;
 8007a88:	7fab      	ldrb	r3, [r5, #30]
 8007a8a:	f043 0320 	orr.w	r3, r3, #32
 8007a8e:	77ab      	strb	r3, [r5, #30]
      return ERR_OK;
 8007a90:	2000      	movs	r0, #0
 8007a92:	bd70      	pop	{r4, r5, r6, pc}

08007a94 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 8007a94:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007a96:	b083      	sub	sp, #12
 8007a98:	4604      	mov	r4, r0
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
 8007a9a:	6d00      	ldr	r0, [r0, #80]	; 0x50
 8007a9c:	f7fc fb7a 	bl	8004194 <lwip_htonl>
 8007aa0:	4603      	mov	r3, r0
 8007aa2:	2200      	movs	r2, #0
 8007aa4:	4611      	mov	r1, r2
 8007aa6:	4620      	mov	r0, r4
 8007aa8:	f7ff ff1a 	bl	80078e0 <tcp_output_alloc_header>
  if (p == NULL) {
 8007aac:	b1f0      	cbz	r0, 8007aec <tcp_send_empty_ack+0x58>
 8007aae:	4605      	mov	r5, r0
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8007ab0:	6847      	ldr	r7, [r0, #4]
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8007ab2:	7fa3      	ldrb	r3, [r4, #30]
 8007ab4:	f023 0303 	bic.w	r3, r3, #3
 8007ab8:	77a3      	strb	r3, [r4, #30]
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
 8007aba:	1d26      	adds	r6, r4, #4
 8007abc:	8903      	ldrh	r3, [r0, #8]
 8007abe:	9300      	str	r3, [sp, #0]
 8007ac0:	2306      	movs	r3, #6
 8007ac2:	4632      	mov	r2, r6
 8007ac4:	4621      	mov	r1, r4
 8007ac6:	f7fc fcf3 	bl	80044b0 <inet_chksum_pseudo>
 8007aca:	8238      	strh	r0, [r7, #16]
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 8007acc:	7aa3      	ldrb	r3, [r4, #10]
 8007ace:	2206      	movs	r2, #6
 8007ad0:	9201      	str	r2, [sp, #4]
 8007ad2:	7a62      	ldrb	r2, [r4, #9]
 8007ad4:	9200      	str	r2, [sp, #0]
 8007ad6:	4632      	mov	r2, r6
 8007ad8:	4621      	mov	r1, r4
 8007ada:	4628      	mov	r0, r5
 8007adc:	f7fc ff28 	bl	8004930 <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
 8007ae0:	4628      	mov	r0, r5
 8007ae2:	f7fd fdc8 	bl	8005676 <pbuf_free>

  return ERR_OK;
 8007ae6:	2000      	movs	r0, #0
}
 8007ae8:	b003      	add	sp, #12
 8007aea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return ERR_BUF;
 8007aec:	f06f 0001 	mvn.w	r0, #1
 8007af0:	e7fa      	b.n	8007ae8 <tcp_send_empty_ack+0x54>
	...

08007af4 <tcp_output>:

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 8007af4:	4ba8      	ldr	r3, [pc, #672]	; (8007d98 <tcp_output+0x2a4>)
 8007af6:	681b      	ldr	r3, [r3, #0]
 8007af8:	4298      	cmp	r0, r3
 8007afa:	f000 814a 	beq.w	8007d92 <tcp_output+0x29e>
{
 8007afe:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007b02:	b083      	sub	sp, #12
 8007b04:	4605      	mov	r5, r0
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 8007b06:	f8b0 a060 	ldrh.w	sl, [r0, #96]	; 0x60
 8007b0a:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
 8007b0e:	459a      	cmp	sl, r3
 8007b10:	bf28      	it	cs
 8007b12:	469a      	movcs	sl, r3

  seg = pcb->unsent;
 8007b14:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 8007b16:	7f83      	ldrb	r3, [r0, #30]
 8007b18:	f013 0f02 	tst.w	r3, #2
 8007b1c:	d014      	beq.n	8007b48 <tcp_output+0x54>
 8007b1e:	b17c      	cbz	r4, 8007b40 <tcp_output+0x4c>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 8007b20:	68e3      	ldr	r3, [r4, #12]
 8007b22:	6858      	ldr	r0, [r3, #4]
 8007b24:	f7fc fb42 	bl	80041ac <lwip_ntohl>
 8007b28:	8923      	ldrh	r3, [r4, #8]
 8007b2a:	6caa      	ldr	r2, [r5, #72]	; 0x48
 8007b2c:	1a9b      	subs	r3, r3, r2
 8007b2e:	4418      	add	r0, r3
     (seg == NULL ||
 8007b30:	4582      	cmp	sl, r0
 8007b32:	d305      	bcc.n	8007b40 <tcp_output+0x4c>
     return tcp_send_empty_ack(pcb);
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 8007b34:	f8d5 8070 	ldr.w	r8, [r5, #112]	; 0x70
  if (useg != NULL) {
 8007b38:	f1b8 0f00 	cmp.w	r8, #0
 8007b3c:	d10f      	bne.n	8007b5e <tcp_output+0x6a>
 8007b3e:	e015      	b.n	8007b6c <tcp_output+0x78>
     return tcp_send_empty_ack(pcb);
 8007b40:	4628      	mov	r0, r5
 8007b42:	f7ff ffa7 	bl	8007a94 <tcp_send_empty_ack>
 8007b46:	e121      	b.n	8007d8c <tcp_output+0x298>
  useg = pcb->unacked;
 8007b48:	f8d0 8070 	ldr.w	r8, [r0, #112]	; 0x70
  if (useg != NULL) {
 8007b4c:	f1b8 0f00 	cmp.w	r8, #0
 8007b50:	d105      	bne.n	8007b5e <tcp_output+0x6a>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 8007b52:	b95c      	cbnz	r4, 8007b6c <tcp_output+0x78>
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8007b54:	2300      	movs	r3, #0
 8007b56:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
 8007b5a:	e112      	b.n	8007d82 <tcp_output+0x28e>
    for (; useg->next != NULL; useg = useg->next);
 8007b5c:	4698      	mov	r8, r3
 8007b5e:	f8d8 3000 	ldr.w	r3, [r8]
 8007b62:	2b00      	cmp	r3, #0
 8007b64:	d1fa      	bne.n	8007b5c <tcp_output+0x68>
  while (seg != NULL &&
 8007b66:	2c00      	cmp	r4, #0
 8007b68:	f000 8107 	beq.w	8007d7a <tcp_output+0x286>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
 8007b6c:	f8df 922c 	ldr.w	r9, [pc, #556]	; 8007d9c <tcp_output+0x2a8>
    pcb->rttest = tcp_ticks;
 8007b70:	f8df b22c 	ldr.w	fp, [pc, #556]	; 8007da0 <tcp_output+0x2ac>
 8007b74:	e0a8      	b.n	8007cc8 <tcp_output+0x1d4>
    if((tcp_do_output_nagle(pcb) == 0) &&
 8007b76:	f8b5 2066 	ldrh.w	r2, [r5, #102]	; 0x66
 8007b7a:	b13a      	cbz	r2, 8007b8c <tcp_output+0x98>
 8007b7c:	f8b5 2068 	ldrh.w	r2, [r5, #104]	; 0x68
 8007b80:	2a07      	cmp	r2, #7
 8007b82:	d803      	bhi.n	8007b8c <tcp_output+0x98>
 8007b84:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 8007b88:	f000 80f7 	beq.w	8007d7a <tcp_output+0x286>
    pcb->unsent = seg->next;
 8007b8c:	6823      	ldr	r3, [r4, #0]
 8007b8e:	66eb      	str	r3, [r5, #108]	; 0x6c
    if (pcb->state != SYN_SENT) {
 8007b90:	7e2b      	ldrb	r3, [r5, #24]
 8007b92:	2b02      	cmp	r3, #2
 8007b94:	d00a      	beq.n	8007bac <tcp_output+0xb8>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 8007b96:	68e7      	ldr	r7, [r4, #12]
 8007b98:	89be      	ldrh	r6, [r7, #12]
 8007b9a:	2010      	movs	r0, #16
 8007b9c:	f7fc faf0 	bl	8004180 <lwip_htons>
 8007ba0:	4330      	orrs	r0, r6
 8007ba2:	81b8      	strh	r0, [r7, #12]
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8007ba4:	7fab      	ldrb	r3, [r5, #30]
 8007ba6:	f023 0303 	bic.w	r3, r3, #3
 8007baa:	77ab      	strb	r3, [r5, #30]
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
 8007bac:	68e6      	ldr	r6, [r4, #12]
 8007bae:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 8007bb0:	f7fc faf0 	bl	8004194 <lwip_htonl>
 8007bb4:	60b0      	str	r0, [r6, #8]
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8007bb6:	68e6      	ldr	r6, [r4, #12]
 8007bb8:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
 8007bba:	f7fc fae1 	bl	8004180 <lwip_htons>
 8007bbe:	81f0      	strh	r0, [r6, #14]
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8007bc0:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
 8007bc2:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8007bc4:	4413      	add	r3, r2
 8007bc6:	632b      	str	r3, [r5, #48]	; 0x30
  if (seg->flags & TF_SEG_OPTS_MSS) {
 8007bc8:	7aa3      	ldrb	r3, [r4, #10]
 8007bca:	f013 0f01 	tst.w	r3, #1
 8007bce:	f040 80a0 	bne.w	8007d12 <tcp_output+0x21e>
  if (pcb->rtime == -1) {
 8007bd2:	f9b5 3034 	ldrsh.w	r3, [r5, #52]	; 0x34
 8007bd6:	f1b3 3fff 	cmp.w	r3, #4294967295
    pcb->rtime = 0;
 8007bda:	bf04      	itt	eq
 8007bdc:	2300      	moveq	r3, #0
 8007bde:	86ab      	strheq	r3, [r5, #52]	; 0x34
  if (ip_addr_isany(&(pcb->local_ip))) {
 8007be0:	b10d      	cbz	r5, 8007be6 <tcp_output+0xf2>
 8007be2:	682b      	ldr	r3, [r5, #0]
 8007be4:	b933      	cbnz	r3, 8007bf4 <tcp_output+0x100>
    netif = ip_route(&(pcb->remote_ip));
 8007be6:	1d28      	adds	r0, r5, #4
 8007be8:	f7fc fcda 	bl	80045a0 <ip_route>
    if (netif == NULL) {
 8007bec:	2800      	cmp	r0, #0
 8007bee:	d032      	beq.n	8007c56 <tcp_output+0x162>
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
 8007bf0:	6843      	ldr	r3, [r0, #4]
 8007bf2:	602b      	str	r3, [r5, #0]
  if (pcb->rttest == 0) {
 8007bf4:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8007bf6:	2b00      	cmp	r3, #0
 8007bf8:	f000 8097 	beq.w	8007d2a <tcp_output+0x236>
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8007bfc:	6862      	ldr	r2, [r4, #4]
 8007bfe:	68e3      	ldr	r3, [r4, #12]
 8007c00:	6851      	ldr	r1, [r2, #4]
 8007c02:	1a5b      	subs	r3, r3, r1
 8007c04:	b29b      	uxth	r3, r3
  seg->p->len -= len;
 8007c06:	8951      	ldrh	r1, [r2, #10]
 8007c08:	1ac9      	subs	r1, r1, r3
 8007c0a:	8151      	strh	r1, [r2, #10]
  seg->p->tot_len -= len;
 8007c0c:	6861      	ldr	r1, [r4, #4]
 8007c0e:	890a      	ldrh	r2, [r1, #8]
 8007c10:	1ad3      	subs	r3, r2, r3
 8007c12:	810b      	strh	r3, [r1, #8]
  seg->p->payload = seg->tcphdr;
 8007c14:	6863      	ldr	r3, [r4, #4]
 8007c16:	68e2      	ldr	r2, [r4, #12]
 8007c18:	605a      	str	r2, [r3, #4]
  seg->tcphdr->chksum = 0;
 8007c1a:	68e3      	ldr	r3, [r4, #12]
 8007c1c:	2200      	movs	r2, #0
 8007c1e:	741a      	strb	r2, [r3, #16]
 8007c20:	745a      	strb	r2, [r3, #17]
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
 8007c22:	68e7      	ldr	r7, [r4, #12]
 8007c24:	6860      	ldr	r0, [r4, #4]
 8007c26:	1d2e      	adds	r6, r5, #4
 8007c28:	8903      	ldrh	r3, [r0, #8]
 8007c2a:	9300      	str	r3, [sp, #0]
 8007c2c:	2306      	movs	r3, #6
 8007c2e:	4632      	mov	r2, r6
 8007c30:	4629      	mov	r1, r5
 8007c32:	f7fc fc3d 	bl	80044b0 <inet_chksum_pseudo>
 8007c36:	8238      	strh	r0, [r7, #16]
  TCP_STATS_INC(tcp.xmit);
 8007c38:	f8b9 3090 	ldrh.w	r3, [r9, #144]	; 0x90
 8007c3c:	3301      	adds	r3, #1
 8007c3e:	f8a9 3090 	strh.w	r3, [r9, #144]	; 0x90

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 8007c42:	7aab      	ldrb	r3, [r5, #10]
 8007c44:	6860      	ldr	r0, [r4, #4]
 8007c46:	2206      	movs	r2, #6
 8007c48:	9201      	str	r2, [sp, #4]
 8007c4a:	7a6a      	ldrb	r2, [r5, #9]
 8007c4c:	9200      	str	r2, [sp, #0]
 8007c4e:	4632      	mov	r2, r6
 8007c50:	4629      	mov	r1, r5
 8007c52:	f7fc fe6d 	bl	8004930 <ip_output>
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 8007c56:	68e3      	ldr	r3, [r4, #12]
 8007c58:	6858      	ldr	r0, [r3, #4]
 8007c5a:	f7fc faa7 	bl	80041ac <lwip_ntohl>
 8007c5e:	4606      	mov	r6, r0
 8007c60:	8927      	ldrh	r7, [r4, #8]
 8007c62:	68e3      	ldr	r3, [r4, #12]
 8007c64:	8998      	ldrh	r0, [r3, #12]
 8007c66:	f7fc fa90 	bl	800418a <lwip_ntohs>
 8007c6a:	f010 0003 	ands.w	r0, r0, #3
 8007c6e:	bf18      	it	ne
 8007c70:	2001      	movne	r0, #1
 8007c72:	4438      	add	r0, r7
 8007c74:	4406      	add	r6, r0
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 8007c76:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8007c78:	1b9b      	subs	r3, r3, r6
 8007c7a:	2b00      	cmp	r3, #0
      pcb->snd_nxt = snd_nxt;
 8007c7c:	bfb8      	it	lt
 8007c7e:	652e      	strlt	r6, [r5, #80]	; 0x50
    if (TCP_TCPLEN(seg) > 0) {
 8007c80:	8926      	ldrh	r6, [r4, #8]
 8007c82:	68e3      	ldr	r3, [r4, #12]
 8007c84:	8998      	ldrh	r0, [r3, #12]
 8007c86:	f7fc fa80 	bl	800418a <lwip_ntohs>
 8007c8a:	f010 0003 	ands.w	r0, r0, #3
 8007c8e:	bf18      	it	ne
 8007c90:	2001      	movne	r0, #1
 8007c92:	42f0      	cmn	r0, r6
 8007c94:	d06d      	beq.n	8007d72 <tcp_output+0x27e>
      seg->next = NULL;
 8007c96:	2300      	movs	r3, #0
 8007c98:	6023      	str	r3, [r4, #0]
      if (pcb->unacked == NULL) {
 8007c9a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007c9c:	2b00      	cmp	r3, #0
 8007c9e:	d04d      	beq.n	8007d3c <tcp_output+0x248>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
 8007ca0:	68e3      	ldr	r3, [r4, #12]
 8007ca2:	6858      	ldr	r0, [r3, #4]
 8007ca4:	f7fc fa82 	bl	80041ac <lwip_ntohl>
 8007ca8:	4606      	mov	r6, r0
 8007caa:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8007cae:	6858      	ldr	r0, [r3, #4]
 8007cb0:	f7fc fa7c 	bl	80041ac <lwip_ntohl>
 8007cb4:	1a30      	subs	r0, r6, r0
 8007cb6:	2800      	cmp	r0, #0
 8007cb8:	db43      	blt.n	8007d42 <tcp_output+0x24e>
          useg->next = seg;
 8007cba:	f8c8 4000 	str.w	r4, [r8]
 8007cbe:	46a0      	mov	r8, r4
    seg = pcb->unsent;
 8007cc0:	6eec      	ldr	r4, [r5, #108]	; 0x6c
  while (seg != NULL &&
 8007cc2:	2c00      	cmp	r4, #0
 8007cc4:	f43f af46 	beq.w	8007b54 <tcp_output+0x60>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 8007cc8:	68e3      	ldr	r3, [r4, #12]
 8007cca:	6858      	ldr	r0, [r3, #4]
 8007ccc:	f7fc fa6e 	bl	80041ac <lwip_ntohl>
 8007cd0:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8007cd2:	1ac0      	subs	r0, r0, r3
 8007cd4:	8923      	ldrh	r3, [r4, #8]
 8007cd6:	4418      	add	r0, r3
  while (seg != NULL &&
 8007cd8:	4582      	cmp	sl, r0
 8007cda:	d34e      	bcc.n	8007d7a <tcp_output+0x286>
    LWIP_ASSERT("RST not expected here!", 
 8007cdc:	68e3      	ldr	r3, [r4, #12]
 8007cde:	8998      	ldrh	r0, [r3, #12]
 8007ce0:	f7fc fa53 	bl	800418a <lwip_ntohs>
    if((tcp_do_output_nagle(pcb) == 0) &&
 8007ce4:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007ce6:	2b00      	cmp	r3, #0
 8007ce8:	f43f af50 	beq.w	8007b8c <tcp_output+0x98>
 8007cec:	7fab      	ldrb	r3, [r5, #30]
 8007cee:	f013 0f44 	tst.w	r3, #68	; 0x44
 8007cf2:	f47f af4b 	bne.w	8007b8c <tcp_output+0x98>
 8007cf6:	6eea      	ldr	r2, [r5, #108]	; 0x6c
 8007cf8:	2a00      	cmp	r2, #0
 8007cfa:	f43f af3c 	beq.w	8007b76 <tcp_output+0x82>
 8007cfe:	6811      	ldr	r1, [r2, #0]
 8007d00:	2900      	cmp	r1, #0
 8007d02:	f47f af43 	bne.w	8007b8c <tcp_output+0x98>
 8007d06:	8911      	ldrh	r1, [r2, #8]
 8007d08:	8eea      	ldrh	r2, [r5, #54]	; 0x36
 8007d0a:	4291      	cmp	r1, r2
 8007d0c:	f4bf af3e 	bcs.w	8007b8c <tcp_output+0x98>
 8007d10:	e731      	b.n	8007b76 <tcp_output+0x82>
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 8007d12:	68e6      	ldr	r6, [r4, #12]
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
 8007d14:	1d29      	adds	r1, r5, #4
 8007d16:	f240 50b4 	movw	r0, #1460	; 0x5b4
 8007d1a:	f7fe fb81 	bl	8006420 <tcp_eff_send_mss>
    *opts = TCP_BUILD_MSS_OPTION(mss);
 8007d1e:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
 8007d22:	f7fc fa37 	bl	8004194 <lwip_htonl>
 8007d26:	6170      	str	r0, [r6, #20]
 8007d28:	e753      	b.n	8007bd2 <tcp_output+0xde>
    pcb->rttest = tcp_ticks;
 8007d2a:	f8db 3000 	ldr.w	r3, [fp]
 8007d2e:	63ab      	str	r3, [r5, #56]	; 0x38
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 8007d30:	68e3      	ldr	r3, [r4, #12]
 8007d32:	6858      	ldr	r0, [r3, #4]
 8007d34:	f7fc fa3a 	bl	80041ac <lwip_ntohl>
 8007d38:	63e8      	str	r0, [r5, #60]	; 0x3c
 8007d3a:	e75f      	b.n	8007bfc <tcp_output+0x108>
        pcb->unacked = seg;
 8007d3c:	672c      	str	r4, [r5, #112]	; 0x70
 8007d3e:	46a0      	mov	r8, r4
 8007d40:	e7be      	b.n	8007cc0 <tcp_output+0x1cc>
          struct tcp_seg **cur_seg = &(pcb->unacked);
 8007d42:	f105 0770 	add.w	r7, r5, #112	; 0x70
          while (*cur_seg &&
 8007d46:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007d48:	b17b      	cbz	r3, 8007d6a <tcp_output+0x276>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 8007d4a:	68db      	ldr	r3, [r3, #12]
 8007d4c:	6858      	ldr	r0, [r3, #4]
 8007d4e:	f7fc fa2d 	bl	80041ac <lwip_ntohl>
 8007d52:	4606      	mov	r6, r0
 8007d54:	68e3      	ldr	r3, [r4, #12]
 8007d56:	6858      	ldr	r0, [r3, #4]
 8007d58:	f7fc fa28 	bl	80041ac <lwip_ntohl>
 8007d5c:	1a30      	subs	r0, r6, r0
          while (*cur_seg &&
 8007d5e:	2800      	cmp	r0, #0
 8007d60:	da03      	bge.n	8007d6a <tcp_output+0x276>
              cur_seg = &((*cur_seg)->next );
 8007d62:	683f      	ldr	r7, [r7, #0]
          while (*cur_seg &&
 8007d64:	683b      	ldr	r3, [r7, #0]
 8007d66:	2b00      	cmp	r3, #0
 8007d68:	d1ef      	bne.n	8007d4a <tcp_output+0x256>
          seg->next = (*cur_seg);
 8007d6a:	683b      	ldr	r3, [r7, #0]
 8007d6c:	6023      	str	r3, [r4, #0]
          (*cur_seg) = seg;
 8007d6e:	603c      	str	r4, [r7, #0]
 8007d70:	e7a6      	b.n	8007cc0 <tcp_output+0x1cc>
      tcp_seg_free(seg);
 8007d72:	4620      	mov	r0, r4
 8007d74:	f7fd febe 	bl	8005af4 <tcp_seg_free>
 8007d78:	e7a2      	b.n	8007cc0 <tcp_output+0x1cc>
  if (pcb->unsent == NULL) {
 8007d7a:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 8007d7c:	2b00      	cmp	r3, #0
 8007d7e:	f43f aee9 	beq.w	8007b54 <tcp_output+0x60>
  pcb->flags &= ~TF_NAGLEMEMERR;
 8007d82:	7fab      	ldrb	r3, [r5, #30]
 8007d84:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8007d88:	77ab      	strb	r3, [r5, #30]
  return ERR_OK;
 8007d8a:	2000      	movs	r0, #0
}
 8007d8c:	b003      	add	sp, #12
 8007d8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return ERR_OK;
 8007d92:	2000      	movs	r0, #0
 8007d94:	4770      	bx	lr
 8007d96:	bf00      	nop
 8007d98:	2000abf8 	.word	0x2000abf8
 8007d9c:	2000aac4 	.word	0x2000aac4
 8007da0:	2000abe4 	.word	0x2000abe4

08007da4 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 8007da4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8007da8:	b083      	sub	sp, #12
 8007daa:	4681      	mov	r9, r0
 8007dac:	460e      	mov	r6, r1
 8007dae:	4617      	mov	r7, r2
 8007db0:	4698      	mov	r8, r3
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 8007db2:	2200      	movs	r2, #0
 8007db4:	2114      	movs	r1, #20
 8007db6:	2001      	movs	r0, #1
 8007db8:	f7fd fc8c 	bl	80056d4 <pbuf_alloc>
  if (p == NULL) {
 8007dbc:	2800      	cmp	r0, #0
 8007dbe:	d03d      	beq.n	8007e3c <tcp_rst+0x98>
 8007dc0:	4605      	mov	r5, r0
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
 8007dc2:	6844      	ldr	r4, [r0, #4]
  tcphdr->src = htons(local_port);
 8007dc4:	f8bd 0028 	ldrh.w	r0, [sp, #40]	; 0x28
 8007dc8:	f7fc f9da 	bl	8004180 <lwip_htons>
 8007dcc:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = htons(remote_port);
 8007dce:	f8bd 002c 	ldrh.w	r0, [sp, #44]	; 0x2c
 8007dd2:	f7fc f9d5 	bl	8004180 <lwip_htons>
 8007dd6:	8060      	strh	r0, [r4, #2]
  tcphdr->seqno = htonl(seqno);
 8007dd8:	4648      	mov	r0, r9
 8007dda:	f7fc f9db 	bl	8004194 <lwip_htonl>
 8007dde:	6060      	str	r0, [r4, #4]
  tcphdr->ackno = htonl(ackno);
 8007de0:	4630      	mov	r0, r6
 8007de2:	f7fc f9d7 	bl	8004194 <lwip_htonl>
 8007de6:	60a0      	str	r0, [r4, #8]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 8007de8:	f245 0014 	movw	r0, #20500	; 0x5014
 8007dec:	f7fc f9c8 	bl	8004180 <lwip_htons>
 8007df0:	81a0      	strh	r0, [r4, #12]
  tcphdr->wnd = PP_HTONS(TCP_WND);
 8007df2:	2600      	movs	r6, #0
 8007df4:	2316      	movs	r3, #22
 8007df6:	73a3      	strb	r3, [r4, #14]
 8007df8:	f06f 032f 	mvn.w	r3, #47	; 0x2f
 8007dfc:	73e3      	strb	r3, [r4, #15]
  tcphdr->chksum = 0;
 8007dfe:	7426      	strb	r6, [r4, #16]
 8007e00:	7466      	strb	r6, [r4, #17]
  tcphdr->urgp = 0;
 8007e02:	74a6      	strb	r6, [r4, #18]
 8007e04:	74e6      	strb	r6, [r4, #19]

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
 8007e06:	892b      	ldrh	r3, [r5, #8]
 8007e08:	9300      	str	r3, [sp, #0]
 8007e0a:	2306      	movs	r3, #6
 8007e0c:	4642      	mov	r2, r8
 8007e0e:	4639      	mov	r1, r7
 8007e10:	4628      	mov	r0, r5
 8007e12:	f7fc fb4d 	bl	80044b0 <inet_chksum_pseudo>
 8007e16:	8220      	strh	r0, [r4, #16]
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 8007e18:	4a0a      	ldr	r2, [pc, #40]	; (8007e44 <tcp_rst+0xa0>)
 8007e1a:	f8b2 3090 	ldrh.w	r3, [r2, #144]	; 0x90
 8007e1e:	3301      	adds	r3, #1
 8007e20:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 8007e24:	2306      	movs	r3, #6
 8007e26:	9301      	str	r3, [sp, #4]
 8007e28:	9600      	str	r6, [sp, #0]
 8007e2a:	23ff      	movs	r3, #255	; 0xff
 8007e2c:	4642      	mov	r2, r8
 8007e2e:	4639      	mov	r1, r7
 8007e30:	4628      	mov	r0, r5
 8007e32:	f7fc fd7d 	bl	8004930 <ip_output>
  pbuf_free(p);
 8007e36:	4628      	mov	r0, r5
 8007e38:	f7fd fc1d 	bl	8005676 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 8007e3c:	b003      	add	sp, #12
 8007e3e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8007e42:	bf00      	nop
 8007e44:	2000aac4 	.word	0x2000aac4

08007e48 <tcp_rexmit_rto>:
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 8007e48:	6f02      	ldr	r2, [r0, #112]	; 0x70
 8007e4a:	b10a      	cbz	r2, 8007e50 <tcp_rexmit_rto+0x8>
{
 8007e4c:	b508      	push	{r3, lr}
 8007e4e:	e001      	b.n	8007e54 <tcp_rexmit_rto+0xc>
 8007e50:	4770      	bx	lr
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 8007e52:	461a      	mov	r2, r3
 8007e54:	6813      	ldr	r3, [r2, #0]
 8007e56:	2b00      	cmp	r3, #0
 8007e58:	d1fb      	bne.n	8007e52 <tcp_rexmit_rto+0xa>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 8007e5a:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8007e5c:	6013      	str	r3, [r2, #0]
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 8007e5e:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8007e60:	66c3      	str	r3, [r0, #108]	; 0x6c
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 8007e62:	2200      	movs	r2, #0
 8007e64:	6702      	str	r2, [r0, #112]	; 0x70
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
 8007e66:	f890 3046 	ldrb.w	r3, [r0, #70]	; 0x46
 8007e6a:	3301      	adds	r3, #1
 8007e6c:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 8007e70:	6382      	str	r2, [r0, #56]	; 0x38

  /* Do the actual retransmission */
  tcp_output(pcb);
 8007e72:	f7ff fe3f 	bl	8007af4 <tcp_output>
 8007e76:	bd08      	pop	{r3, pc}

08007e78 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 8007e78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 8007e7a:	6f06      	ldr	r6, [r0, #112]	; 0x70
 8007e7c:	b316      	cbz	r6, 8007ec4 <tcp_rexmit+0x4c>
 8007e7e:	4607      	mov	r7, r0
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
 8007e80:	6833      	ldr	r3, [r6, #0]
 8007e82:	6703      	str	r3, [r0, #112]	; 0x70

  cur_seg = &(pcb->unsent);
 8007e84:	f100 056c 	add.w	r5, r0, #108	; 0x6c
  while (*cur_seg &&
 8007e88:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8007e8a:	b17b      	cbz	r3, 8007eac <tcp_rexmit+0x34>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 8007e8c:	68db      	ldr	r3, [r3, #12]
 8007e8e:	6858      	ldr	r0, [r3, #4]
 8007e90:	f7fc f98c 	bl	80041ac <lwip_ntohl>
 8007e94:	4604      	mov	r4, r0
 8007e96:	68f3      	ldr	r3, [r6, #12]
 8007e98:	6858      	ldr	r0, [r3, #4]
 8007e9a:	f7fc f987 	bl	80041ac <lwip_ntohl>
 8007e9e:	1a20      	subs	r0, r4, r0
  while (*cur_seg &&
 8007ea0:	2800      	cmp	r0, #0
 8007ea2:	da03      	bge.n	8007eac <tcp_rexmit+0x34>
      cur_seg = &((*cur_seg)->next );
 8007ea4:	682d      	ldr	r5, [r5, #0]
  while (*cur_seg &&
 8007ea6:	682b      	ldr	r3, [r5, #0]
 8007ea8:	2b00      	cmp	r3, #0
 8007eaa:	d1ef      	bne.n	8007e8c <tcp_rexmit+0x14>
  }
  seg->next = *cur_seg;
 8007eac:	682b      	ldr	r3, [r5, #0]
 8007eae:	6033      	str	r3, [r6, #0]
  *cur_seg = seg;
 8007eb0:	602e      	str	r6, [r5, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 8007eb2:	6833      	ldr	r3, [r6, #0]
 8007eb4:	b13b      	cbz	r3, 8007ec6 <tcp_rexmit+0x4e>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 8007eb6:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 8007eba:	3301      	adds	r3, #1
 8007ebc:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 8007ec0:	2300      	movs	r3, #0
 8007ec2:	63bb      	str	r3, [r7, #56]	; 0x38
 8007ec4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pcb->unsent_oversize = 0;
 8007ec6:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 8007eca:	e7f4      	b.n	8007eb6 <tcp_rexmit+0x3e>

08007ecc <tcp_rexmit_fast>:
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 8007ecc:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8007ece:	b11b      	cbz	r3, 8007ed8 <tcp_rexmit_fast+0xc>
 8007ed0:	7f83      	ldrb	r3, [r0, #30]
 8007ed2:	f013 0f04 	tst.w	r3, #4
 8007ed6:	d000      	beq.n	8007eda <tcp_rexmit_fast+0xe>
 8007ed8:	4770      	bx	lr
{
 8007eda:	b510      	push	{r4, lr}
 8007edc:	4604      	mov	r4, r0
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
 8007ede:	f7ff ffcb 	bl	8007e78 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
 8007ee2:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
 8007ee6:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
 8007eea:	4293      	cmp	r3, r2
      pcb->ssthresh = pcb->snd_wnd / 2;
 8007eec:	bf87      	ittee	hi
 8007eee:	0852      	lsrhi	r2, r2, #1
 8007ef0:	f8a4 204e 	strhhi.w	r2, [r4, #78]	; 0x4e
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
 8007ef4:	085b      	lsrls	r3, r3, #1
 8007ef6:	f8a4 304e 	strhls.w	r3, [r4, #78]	; 0x4e
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 8007efa:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8007efc:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
 8007f00:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 8007f04:	bfbc      	itt	lt
 8007f06:	005a      	lsllt	r2, r3, #1
 8007f08:	f8a4 204e 	strhlt.w	r2, [r4, #78]	; 0x4e
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 8007f0c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8007f10:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
 8007f14:	4413      	add	r3, r2
 8007f16:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    pcb->flags |= TF_INFR;
 8007f1a:	7fa3      	ldrb	r3, [r4, #30]
 8007f1c:	f043 0304 	orr.w	r3, r3, #4
 8007f20:	77a3      	strb	r3, [r4, #30]
 8007f22:	bd10      	pop	{r4, pc}

08007f24 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 8007f24:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007f26:	b083      	sub	sp, #12
 8007f28:	4604      	mov	r4, r0
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 8007f2a:	6d00      	ldr	r0, [r0, #80]	; 0x50
 8007f2c:	3801      	subs	r0, #1
 8007f2e:	f7fc f931 	bl	8004194 <lwip_htonl>
 8007f32:	4603      	mov	r3, r0
 8007f34:	2200      	movs	r2, #0
 8007f36:	4611      	mov	r1, r2
 8007f38:	4620      	mov	r0, r4
 8007f3a:	f7ff fcd1 	bl	80078e0 <tcp_output_alloc_header>
  if(p == NULL) {
 8007f3e:	b1e8      	cbz	r0, 8007f7c <tcp_keepalive+0x58>
 8007f40:	4605      	mov	r5, r0
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8007f42:	6847      	ldr	r7, [r0, #4]

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 8007f44:	1d26      	adds	r6, r4, #4
 8007f46:	8903      	ldrh	r3, [r0, #8]
 8007f48:	9300      	str	r3, [sp, #0]
 8007f4a:	2306      	movs	r3, #6
 8007f4c:	4632      	mov	r2, r6
 8007f4e:	4621      	mov	r1, r4
 8007f50:	f7fc faae 	bl	80044b0 <inet_chksum_pseudo>
 8007f54:	8238      	strh	r0, [r7, #16]
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 8007f56:	4a0a      	ldr	r2, [pc, #40]	; (8007f80 <tcp_keepalive+0x5c>)
 8007f58:	f8b2 3090 	ldrh.w	r3, [r2, #144]	; 0x90
 8007f5c:	3301      	adds	r3, #1
 8007f5e:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 8007f62:	7aa3      	ldrb	r3, [r4, #10]
 8007f64:	2206      	movs	r2, #6
 8007f66:	9201      	str	r2, [sp, #4]
 8007f68:	2200      	movs	r2, #0
 8007f6a:	9200      	str	r2, [sp, #0]
 8007f6c:	4632      	mov	r2, r6
 8007f6e:	4621      	mov	r1, r4
 8007f70:	4628      	mov	r0, r5
 8007f72:	f7fc fcdd 	bl	8004930 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 8007f76:	4628      	mov	r0, r5
 8007f78:	f7fd fb7d 	bl	8005676 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 8007f7c:	b003      	add	sp, #12
 8007f7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007f80:	2000aac4 	.word	0x2000aac4

08007f84 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 8007f84:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007f86:	b083      	sub	sp, #12
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
 8007f88:	6f05      	ldr	r5, [r0, #112]	; 0x70

  if(seg == NULL) {
 8007f8a:	b1fd      	cbz	r5, 8007fcc <tcp_zero_window_probe+0x48>
 8007f8c:	4604      	mov	r4, r0
  }
  if(seg == NULL) {
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8007f8e:	68eb      	ldr	r3, [r5, #12]
 8007f90:	8998      	ldrh	r0, [r3, #12]
 8007f92:	f7fc f8fa 	bl	800418a <lwip_ntohs>
 8007f96:	f010 0f01 	tst.w	r0, #1
 8007f9a:	d001      	beq.n	8007fa0 <tcp_zero_window_probe+0x1c>
 8007f9c:	892b      	ldrh	r3, [r5, #8]
 8007f9e:	b1c3      	cbz	r3, 8007fd2 <tcp_zero_window_probe+0x4e>
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 8007fa0:	68eb      	ldr	r3, [r5, #12]
 8007fa2:	685b      	ldr	r3, [r3, #4]
 8007fa4:	2201      	movs	r2, #1
 8007fa6:	2100      	movs	r1, #0
 8007fa8:	4620      	mov	r0, r4
 8007faa:	f7ff fc99 	bl	80078e0 <tcp_output_alloc_header>
  if(p == NULL) {
 8007fae:	4606      	mov	r6, r0
 8007fb0:	2800      	cmp	r0, #0
 8007fb2:	d03e      	beq.n	8008032 <tcp_zero_window_probe+0xae>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8007fb4:	6877      	ldr	r7, [r6, #4]
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 8007fb6:	6868      	ldr	r0, [r5, #4]
 8007fb8:	8903      	ldrh	r3, [r0, #8]
 8007fba:	892a      	ldrh	r2, [r5, #8]
 8007fbc:	1a9b      	subs	r3, r3, r2
 8007fbe:	b29b      	uxth	r3, r3
 8007fc0:	2201      	movs	r2, #1
 8007fc2:	f107 0114 	add.w	r1, r7, #20
 8007fc6:	f7fd fce9 	bl	800599c <pbuf_copy_partial>
 8007fca:	e015      	b.n	8007ff8 <tcp_zero_window_probe+0x74>
    seg = pcb->unsent;
 8007fcc:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
  if(seg == NULL) {
 8007fce:	b385      	cbz	r5, 8008032 <tcp_zero_window_probe+0xae>
 8007fd0:	e7dc      	b.n	8007f8c <tcp_zero_window_probe+0x8>
  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 8007fd2:	68eb      	ldr	r3, [r5, #12]
 8007fd4:	685b      	ldr	r3, [r3, #4]
 8007fd6:	2200      	movs	r2, #0
 8007fd8:	4611      	mov	r1, r2
 8007fda:	4620      	mov	r0, r4
 8007fdc:	f7ff fc80 	bl	80078e0 <tcp_output_alloc_header>
  if(p == NULL) {
 8007fe0:	4606      	mov	r6, r0
 8007fe2:	b330      	cbz	r0, 8008032 <tcp_zero_window_probe+0xae>
  tcphdr = (struct tcp_hdr *)p->payload;
 8007fe4:	6877      	ldr	r7, [r6, #4]
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 8007fe6:	f9b7 500c 	ldrsh.w	r5, [r7, #12]
 8007fea:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 8007fee:	2011      	movs	r0, #17
 8007ff0:	f7fc f8c6 	bl	8004180 <lwip_htons>
 8007ff4:	4328      	orrs	r0, r5
 8007ff6:	81b8      	strh	r0, [r7, #12]
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 8007ff8:	1d25      	adds	r5, r4, #4
 8007ffa:	8933      	ldrh	r3, [r6, #8]
 8007ffc:	9300      	str	r3, [sp, #0]
 8007ffe:	2306      	movs	r3, #6
 8008000:	462a      	mov	r2, r5
 8008002:	4621      	mov	r1, r4
 8008004:	4630      	mov	r0, r6
 8008006:	f7fc fa53 	bl	80044b0 <inet_chksum_pseudo>
 800800a:	8238      	strh	r0, [r7, #16]
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 800800c:	4a0a      	ldr	r2, [pc, #40]	; (8008038 <tcp_zero_window_probe+0xb4>)
 800800e:	f8b2 3090 	ldrh.w	r3, [r2, #144]	; 0x90
 8008012:	3301      	adds	r3, #1
 8008014:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 8008018:	7aa3      	ldrb	r3, [r4, #10]
 800801a:	2206      	movs	r2, #6
 800801c:	9201      	str	r2, [sp, #4]
 800801e:	2200      	movs	r2, #0
 8008020:	9200      	str	r2, [sp, #0]
 8008022:	462a      	mov	r2, r5
 8008024:	4621      	mov	r1, r4
 8008026:	4630      	mov	r0, r6
 8008028:	f7fc fc82 	bl	8004930 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 800802c:	4630      	mov	r0, r6
 800802e:	f7fd fb22 	bl	8005676 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 8008032:	b003      	add	sp, #12
 8008034:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008036:	bf00      	nop
 8008038:	2000aac4 	.word	0x2000aac4

0800803c <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 800803c:	b570      	push	{r4, r5, r6, lr}
 800803e:	4604      	mov	r4, r0
 8008040:	460e      	mov	r6, r1
 8008042:	4615      	mov	r5, r2
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 8008044:	2007      	movs	r0, #7
 8008046:	f7fd f9e9 	bl	800541c <memp_malloc>
  if (timeout == NULL) {
 800804a:	2800      	cmp	r0, #0
 800804c:	d030      	beq.n	80080b0 <sys_timeout+0x74>
 800804e:	4601      	mov	r1, r0
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
 8008050:	2300      	movs	r3, #0
 8008052:	6003      	str	r3, [r0, #0]
  timeout->h = handler;
 8008054:	6086      	str	r6, [r0, #8]
  timeout->arg = arg;
 8008056:	60c5      	str	r5, [r0, #12]
  timeout->time = msecs;
 8008058:	6044      	str	r4, [r0, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 800805a:	4b16      	ldr	r3, [pc, #88]	; (80080b4 <sys_timeout+0x78>)
 800805c:	681d      	ldr	r5, [r3, #0]
 800805e:	b1a5      	cbz	r5, 800808a <sys_timeout+0x4e>
    next_timeout = timeout;
    return;
  }

  if (next_timeout->time > msecs) {
 8008060:	6868      	ldr	r0, [r5, #4]
 8008062:	4284      	cmp	r4, r0
 8008064:	d313      	bcc.n	800808e <sys_timeout+0x52>
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
      timeout->time -= t->time;
 8008066:	1a20      	subs	r0, r4, r0
 8008068:	6048      	str	r0, [r1, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 800806a:	682a      	ldr	r2, [r5, #0]
 800806c:	b1f2      	cbz	r2, 80080ac <sys_timeout+0x70>
 800806e:	6853      	ldr	r3, [r2, #4]
 8008070:	4298      	cmp	r0, r3
 8008072:	d312      	bcc.n	800809a <sys_timeout+0x5e>
      timeout->time -= t->time;
 8008074:	6848      	ldr	r0, [r1, #4]
 8008076:	6853      	ldr	r3, [r2, #4]
 8008078:	1ac0      	subs	r0, r0, r3
 800807a:	6048      	str	r0, [r1, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 800807c:	6813      	ldr	r3, [r2, #0]
 800807e:	b18b      	cbz	r3, 80080a4 <sys_timeout+0x68>
 8008080:	685c      	ldr	r4, [r3, #4]
 8008082:	42a0      	cmp	r0, r4
 8008084:	d30b      	bcc.n	800809e <sys_timeout+0x62>
 8008086:	461a      	mov	r2, r3
 8008088:	e7f4      	b.n	8008074 <sys_timeout+0x38>
    next_timeout = timeout;
 800808a:	6018      	str	r0, [r3, #0]
    return;
 800808c:	bd70      	pop	{r4, r5, r6, pc}
    next_timeout->time -= msecs;
 800808e:	1b00      	subs	r0, r0, r4
 8008090:	6068      	str	r0, [r5, #4]
    timeout->next = next_timeout;
 8008092:	600d      	str	r5, [r1, #0]
    next_timeout = timeout;
 8008094:	4b07      	ldr	r3, [pc, #28]	; (80080b4 <sys_timeout+0x78>)
 8008096:	6019      	str	r1, [r3, #0]
 8008098:	bd70      	pop	{r4, r5, r6, pc}
      if (t->next == NULL || t->next->time > timeout->time) {
 800809a:	4613      	mov	r3, r2
 800809c:	462a      	mov	r2, r5
        if (t->next != NULL) {
          t->next->time -= timeout->time;
 800809e:	685c      	ldr	r4, [r3, #4]
 80080a0:	1a20      	subs	r0, r4, r0
 80080a2:	6058      	str	r0, [r3, #4]
        }
        timeout->next = t->next;
 80080a4:	6813      	ldr	r3, [r2, #0]
 80080a6:	600b      	str	r3, [r1, #0]
        t->next = timeout;
 80080a8:	6011      	str	r1, [r2, #0]
        break;
 80080aa:	bd70      	pop	{r4, r5, r6, pc}
      if (t->next == NULL || t->next->time > timeout->time) {
 80080ac:	462a      	mov	r2, r5
 80080ae:	e7f9      	b.n	80080a4 <sys_timeout+0x68>
 80080b0:	bd70      	pop	{r4, r5, r6, pc}
 80080b2:	bf00      	nop
 80080b4:	200071c4 	.word	0x200071c4

080080b8 <tcp_timer_needed>:
{
 80080b8:	b508      	push	{r3, lr}
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 80080ba:	4b0a      	ldr	r3, [pc, #40]	; (80080e4 <tcp_timer_needed+0x2c>)
 80080bc:	681b      	ldr	r3, [r3, #0]
 80080be:	b953      	cbnz	r3, 80080d6 <tcp_timer_needed+0x1e>
 80080c0:	4b09      	ldr	r3, [pc, #36]	; (80080e8 <tcp_timer_needed+0x30>)
 80080c2:	681b      	ldr	r3, [r3, #0]
 80080c4:	b143      	cbz	r3, 80080d8 <tcp_timer_needed+0x20>
    tcpip_tcp_timer_active = 1;
 80080c6:	2201      	movs	r2, #1
 80080c8:	4b06      	ldr	r3, [pc, #24]	; (80080e4 <tcp_timer_needed+0x2c>)
 80080ca:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 80080cc:	2200      	movs	r2, #0
 80080ce:	4907      	ldr	r1, [pc, #28]	; (80080ec <tcp_timer_needed+0x34>)
 80080d0:	20fa      	movs	r0, #250	; 0xfa
 80080d2:	f7ff ffb3 	bl	800803c <sys_timeout>
 80080d6:	bd08      	pop	{r3, pc}
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 80080d8:	4b05      	ldr	r3, [pc, #20]	; (80080f0 <tcp_timer_needed+0x38>)
 80080da:	681b      	ldr	r3, [r3, #0]
 80080dc:	2b00      	cmp	r3, #0
 80080de:	d1f2      	bne.n	80080c6 <tcp_timer_needed+0xe>
 80080e0:	e7f9      	b.n	80080d6 <tcp_timer_needed+0x1e>
 80080e2:	bf00      	nop
 80080e4:	200071c8 	.word	0x200071c8
 80080e8:	2000abe0 	.word	0x2000abe0
 80080ec:	080080f5 	.word	0x080080f5
 80080f0:	2000abf4 	.word	0x2000abf4

080080f4 <tcpip_tcp_timer>:
{
 80080f4:	b508      	push	{r3, lr}
  tcp_tmr();
 80080f6:	f7fe f88b 	bl	8006210 <tcp_tmr>
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 80080fa:	4b08      	ldr	r3, [pc, #32]	; (800811c <tcpip_tcp_timer+0x28>)
 80080fc:	681b      	ldr	r3, [r3, #0]
 80080fe:	b12b      	cbz	r3, 800810c <tcpip_tcp_timer+0x18>
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8008100:	2200      	movs	r2, #0
 8008102:	4907      	ldr	r1, [pc, #28]	; (8008120 <tcpip_tcp_timer+0x2c>)
 8008104:	20fa      	movs	r0, #250	; 0xfa
 8008106:	f7ff ff99 	bl	800803c <sys_timeout>
 800810a:	bd08      	pop	{r3, pc}
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 800810c:	4b05      	ldr	r3, [pc, #20]	; (8008124 <tcpip_tcp_timer+0x30>)
 800810e:	681b      	ldr	r3, [r3, #0]
 8008110:	2b00      	cmp	r3, #0
 8008112:	d1f5      	bne.n	8008100 <tcpip_tcp_timer+0xc>
    tcpip_tcp_timer_active = 0;
 8008114:	2200      	movs	r2, #0
 8008116:	4b04      	ldr	r3, [pc, #16]	; (8008128 <tcpip_tcp_timer+0x34>)
 8008118:	601a      	str	r2, [r3, #0]
 800811a:	bd08      	pop	{r3, pc}
 800811c:	2000abe0 	.word	0x2000abe0
 8008120:	080080f5 	.word	0x080080f5
 8008124:	2000abf4 	.word	0x2000abf4
 8008128:	200071c8 	.word	0x200071c8

0800812c <sys_timeouts_init>:
{
 800812c:	b508      	push	{r3, lr}
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 800812e:	2200      	movs	r2, #0
 8008130:	4907      	ldr	r1, [pc, #28]	; (8008150 <sys_timeouts_init+0x24>)
 8008132:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008136:	f7ff ff81 	bl	800803c <sys_timeout>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 800813a:	2200      	movs	r2, #0
 800813c:	4905      	ldr	r1, [pc, #20]	; (8008154 <sys_timeouts_init+0x28>)
 800813e:	f241 3088 	movw	r0, #5000	; 0x1388
 8008142:	f7ff ff7b 	bl	800803c <sys_timeout>
  timeouts_last_time = sys_now();
 8008146:	f7fb fa41 	bl	80035cc <sys_now>
 800814a:	4b03      	ldr	r3, [pc, #12]	; (8008158 <sys_timeouts_init+0x2c>)
 800814c:	6018      	str	r0, [r3, #0]
 800814e:	bd08      	pop	{r3, pc}
 8008150:	08008175 	.word	0x08008175
 8008154:	0800815d 	.word	0x0800815d
 8008158:	200071cc 	.word	0x200071cc

0800815c <arp_timer>:
{
 800815c:	b508      	push	{r3, lr}
  etharp_tmr();
 800815e:	f000 fb61 	bl	8008824 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 8008162:	2200      	movs	r2, #0
 8008164:	4902      	ldr	r1, [pc, #8]	; (8008170 <arp_timer+0x14>)
 8008166:	f241 3088 	movw	r0, #5000	; 0x1388
 800816a:	f7ff ff67 	bl	800803c <sys_timeout>
 800816e:	bd08      	pop	{r3, pc}
 8008170:	0800815d 	.word	0x0800815d

08008174 <ip_reass_timer>:
{
 8008174:	b508      	push	{r3, lr}
  ip_reass_tmr();
 8008176:	f7fc fcb1 	bl	8004adc <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 800817a:	2200      	movs	r2, #0
 800817c:	4902      	ldr	r1, [pc, #8]	; (8008188 <ip_reass_timer+0x14>)
 800817e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008182:	f7ff ff5b 	bl	800803c <sys_timeout>
 8008186:	bd08      	pop	{r3, pc}
 8008188:	08008175 	.word	0x08008175

0800818c <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 800818c:	4770      	bx	lr
	...

08008190 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 8008190:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008194:	b085      	sub	sp, #20
 8008196:	4604      	mov	r4, r0
 8008198:	4689      	mov	r9, r1
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
 800819a:	4a7c      	ldr	r2, [pc, #496]	; (800838c <udp_input+0x1fc>)
 800819c:	f8b2 307a 	ldrh.w	r3, [r2, #122]	; 0x7a
 80081a0:	3301      	adds	r3, #1
 80081a2:	f8a2 307a 	strh.w	r3, [r2, #122]	; 0x7a

  iphdr = (struct ip_hdr *)p->payload;
 80081a6:	f8d0 8004 	ldr.w	r8, [r0, #4]
 80081aa:	f898 1000 	ldrb.w	r1, [r8]
 80081ae:	f001 010f 	and.w	r1, r1, #15

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 80081b2:	8903      	ldrh	r3, [r0, #8]
 80081b4:	1c8a      	adds	r2, r1, #2
 80081b6:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80081ba:	db04      	blt.n	80081c6 <udp_input+0x36>
 80081bc:	0089      	lsls	r1, r1, #2
 80081be:	4249      	negs	r1, r1
 80081c0:	f7fd fa1b 	bl	80055fa <pbuf_header>
 80081c4:	b180      	cbz	r0, 80081e8 <udp_input+0x58>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
 80081c6:	4b71      	ldr	r3, [pc, #452]	; (800838c <udp_input+0x1fc>)
 80081c8:	f8b3 2082 	ldrh.w	r2, [r3, #130]	; 0x82
 80081cc:	3201      	adds	r2, #1
 80081ce:	f8a3 2082 	strh.w	r2, [r3, #130]	; 0x82
    UDP_STATS_INC(udp.drop);
 80081d2:	f8b3 207e 	ldrh.w	r2, [r3, #126]	; 0x7e
 80081d6:	3201      	adds	r2, #1
 80081d8:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
    snmp_inc_udpinerrors();
    pbuf_free(p);
 80081dc:	4620      	mov	r0, r4
 80081de:	f7fd fa4a 	bl	8005676 <pbuf_free>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
 80081e2:	b005      	add	sp, #20
 80081e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  udphdr = (struct udp_hdr *)p->payload;
 80081e8:	f8d4 a004 	ldr.w	sl, [r4, #4]
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 80081ec:	4649      	mov	r1, r9
 80081ee:	4b68      	ldr	r3, [pc, #416]	; (8008390 <udp_input+0x200>)
 80081f0:	6818      	ldr	r0, [r3, #0]
 80081f2:	f7fc fbc1 	bl	8004978 <ip4_addr_isbroadcast>
 80081f6:	4607      	mov	r7, r0
  src = ntohs(udphdr->src);
 80081f8:	f8ba 0000 	ldrh.w	r0, [sl]
 80081fc:	f7fb ffc5 	bl	800418a <lwip_ntohs>
 8008200:	4605      	mov	r5, r0
  dest = ntohs(udphdr->dest);
 8008202:	f8ba 0002 	ldrh.w	r0, [sl, #2]
 8008206:	f7fb ffc0 	bl	800418a <lwip_ntohs>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800820a:	4b62      	ldr	r3, [pc, #392]	; (8008394 <udp_input+0x204>)
 800820c:	f8d3 e000 	ldr.w	lr, [r3]
 8008210:	f1be 0f00 	cmp.w	lr, #0
 8008214:	d049      	beq.n	80082aa <udp_input+0x11a>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 8008216:	4b5e      	ldr	r3, [pc, #376]	; (8008390 <udp_input+0x200>)
 8008218:	f8d3 c000 	ldr.w	ip, [r3]
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 800821c:	4b5e      	ldr	r3, [pc, #376]	; (8008398 <udp_input+0x208>)
 800821e:	f8d3 b000 	ldr.w	fp, [r3]
 8008222:	4673      	mov	r3, lr
 8008224:	2600      	movs	r6, #0
 8008226:	4632      	mov	r2, r6
 8008228:	9403      	str	r4, [sp, #12]
 800822a:	e0a2      	b.n	8008372 <udp_input+0x1e2>
          if ((uncon_pcb == NULL) && 
 800822c:	7c19      	ldrb	r1, [r3, #16]
 800822e:	f001 0104 	and.w	r1, r1, #4
 8008232:	2900      	cmp	r1, #0
 8008234:	bf08      	it	eq
 8008236:	461e      	moveq	r6, r3
 8008238:	e091      	b.n	800835e <udp_input+0x1ce>
          (pcb->remote_port == src) &&
 800823a:	f113 0f04 	cmn.w	r3, #4
 800823e:	d004      	beq.n	800824a <udp_input+0xba>
          (ip_addr_isany(&pcb->remote_ip) ||
 8008240:	6859      	ldr	r1, [r3, #4]
 8008242:	b111      	cbz	r1, 800824a <udp_input+0xba>
 8008244:	4559      	cmp	r1, fp
 8008246:	f040 808e 	bne.w	8008366 <udp_input+0x1d6>
 800824a:	9c03      	ldr	r4, [sp, #12]
        if (prev != NULL) {
 800824c:	b142      	cbz	r2, 8008260 <udp_input+0xd0>
          prev->next = pcb->next;
 800824e:	68d9      	ldr	r1, [r3, #12]
 8008250:	60d1      	str	r1, [r2, #12]
          pcb->next = udp_pcbs;
 8008252:	f8c3 e00c 	str.w	lr, [r3, #12]
          udp_pcbs = pcb;
 8008256:	4a4f      	ldr	r2, [pc, #316]	; (8008394 <udp_input+0x204>)
 8008258:	6013      	str	r3, [r2, #0]
    if (pcb == NULL) {
 800825a:	b14b      	cbz	r3, 8008270 <udp_input+0xe0>
 800825c:	461e      	mov	r6, r3
 800825e:	e008      	b.n	8008272 <udp_input+0xe2>
          UDP_STATS_INC(udp.cachehit);
 8008260:	494a      	ldr	r1, [pc, #296]	; (800838c <udp_input+0x1fc>)
 8008262:	f8b1 208e 	ldrh.w	r2, [r1, #142]	; 0x8e
 8008266:	3201      	adds	r2, #1
 8008268:	f8a1 208e 	strh.w	r2, [r1, #142]	; 0x8e
 800826c:	e7f5      	b.n	800825a <udp_input+0xca>
 800826e:	9c03      	ldr	r4, [sp, #12]
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 8008270:	b1de      	cbz	r6, 80082aa <udp_input+0x11a>
      if (udphdr->chksum != 0) {
 8008272:	f8ba 3006 	ldrh.w	r3, [sl, #6]
 8008276:	b143      	cbz	r3, 800828a <udp_input+0xfa>
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 8008278:	8923      	ldrh	r3, [r4, #8]
 800827a:	9300      	str	r3, [sp, #0]
 800827c:	2311      	movs	r3, #17
 800827e:	4a44      	ldr	r2, [pc, #272]	; (8008390 <udp_input+0x200>)
 8008280:	4945      	ldr	r1, [pc, #276]	; (8008398 <udp_input+0x208>)
 8008282:	4620      	mov	r0, r4
 8008284:	f7fc f914 	bl	80044b0 <inet_chksum_pseudo>
 8008288:	b9d8      	cbnz	r0, 80082c2 <udp_input+0x132>
    if(pbuf_header(p, -UDP_HLEN)) {
 800828a:	f06f 0107 	mvn.w	r1, #7
 800828e:	4620      	mov	r0, r4
 8008290:	f7fd f9b3 	bl	80055fa <pbuf_header>
 8008294:	bb20      	cbnz	r0, 80082e0 <udp_input+0x150>
    if (pcb != NULL) {
 8008296:	b38e      	cbz	r6, 80082fc <udp_input+0x16c>
      if (pcb->recv != NULL) {
 8008298:	69b7      	ldr	r7, [r6, #24]
 800829a:	b35f      	cbz	r7, 80082f4 <udp_input+0x164>
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 800829c:	69f0      	ldr	r0, [r6, #28]
 800829e:	9500      	str	r5, [sp, #0]
 80082a0:	4b3d      	ldr	r3, [pc, #244]	; (8008398 <udp_input+0x208>)
 80082a2:	4622      	mov	r2, r4
 80082a4:	4631      	mov	r1, r6
 80082a6:	47b8      	blx	r7
 80082a8:	e79b      	b.n	80081e2 <udp_input+0x52>
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 80082aa:	f8d9 2004 	ldr.w	r2, [r9, #4]
 80082ae:	4b38      	ldr	r3, [pc, #224]	; (8008390 <udp_input+0x200>)
 80082b0:	681b      	ldr	r3, [r3, #0]
 80082b2:	429a      	cmp	r2, r3
 80082b4:	d003      	beq.n	80082be <udp_input+0x12e>
    pbuf_free(p);
 80082b6:	4620      	mov	r0, r4
 80082b8:	f7fd f9dd 	bl	8005676 <pbuf_free>
}
 80082bc:	e791      	b.n	80081e2 <udp_input+0x52>
 80082be:	2600      	movs	r6, #0
 80082c0:	e7d7      	b.n	8008272 <udp_input+0xe2>
          UDP_STATS_INC(udp.chkerr);
 80082c2:	4b32      	ldr	r3, [pc, #200]	; (800838c <udp_input+0x1fc>)
 80082c4:	f8b3 2080 	ldrh.w	r2, [r3, #128]	; 0x80
 80082c8:	3201      	adds	r2, #1
 80082ca:	f8a3 2080 	strh.w	r2, [r3, #128]	; 0x80
          UDP_STATS_INC(udp.drop);
 80082ce:	f8b3 207e 	ldrh.w	r2, [r3, #126]	; 0x7e
 80082d2:	3201      	adds	r2, #1
 80082d4:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
          pbuf_free(p);
 80082d8:	4620      	mov	r0, r4
 80082da:	f7fd f9cc 	bl	8005676 <pbuf_free>
          goto end;
 80082de:	e780      	b.n	80081e2 <udp_input+0x52>
      UDP_STATS_INC(udp.drop);
 80082e0:	4a2a      	ldr	r2, [pc, #168]	; (800838c <udp_input+0x1fc>)
 80082e2:	f8b2 307e 	ldrh.w	r3, [r2, #126]	; 0x7e
 80082e6:	3301      	adds	r3, #1
 80082e8:	f8a2 307e 	strh.w	r3, [r2, #126]	; 0x7e
      pbuf_free(p);
 80082ec:	4620      	mov	r0, r4
 80082ee:	f7fd f9c2 	bl	8005676 <pbuf_free>
      goto end;
 80082f2:	e776      	b.n	80081e2 <udp_input+0x52>
        pbuf_free(p);
 80082f4:	4620      	mov	r0, r4
 80082f6:	f7fd f9be 	bl	8005676 <pbuf_free>
        goto end;
 80082fa:	e772      	b.n	80081e2 <udp_input+0x52>
      if (!broadcast &&
 80082fc:	b997      	cbnz	r7, 8008324 <udp_input+0x194>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 80082fe:	4b24      	ldr	r3, [pc, #144]	; (8008390 <udp_input+0x200>)
 8008300:	681b      	ldr	r3, [r3, #0]
 8008302:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      if (!broadcast &&
 8008306:	2be0      	cmp	r3, #224	; 0xe0
 8008308:	d00c      	beq.n	8008324 <udp_input+0x194>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
 800830a:	f898 1000 	ldrb.w	r1, [r8]
 800830e:	f001 010f 	and.w	r1, r1, #15
 8008312:	3102      	adds	r1, #2
 8008314:	0089      	lsls	r1, r1, #2
 8008316:	4620      	mov	r0, r4
 8008318:	f7fd f96f 	bl	80055fa <pbuf_header>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
 800831c:	2103      	movs	r1, #3
 800831e:	4620      	mov	r0, r4
 8008320:	f7fc f87e 	bl	8004420 <icmp_dest_unreach>
      UDP_STATS_INC(udp.proterr);
 8008324:	4b19      	ldr	r3, [pc, #100]	; (800838c <udp_input+0x1fc>)
 8008326:	f8b3 2088 	ldrh.w	r2, [r3, #136]	; 0x88
 800832a:	3201      	adds	r2, #1
 800832c:	f8a3 2088 	strh.w	r2, [r3, #136]	; 0x88
      UDP_STATS_INC(udp.drop);
 8008330:	f8b3 207e 	ldrh.w	r2, [r3, #126]	; 0x7e
 8008334:	3201      	adds	r2, #1
 8008336:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
      pbuf_free(p);
 800833a:	4620      	mov	r0, r4
 800833c:	f7fd f99b 	bl	8005676 <pbuf_free>
 8008340:	e74f      	b.n	80081e2 <udp_input+0x52>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 8008342:	6819      	ldr	r1, [r3, #0]
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 8008344:	458c      	cmp	ip, r1
 8008346:	d007      	beq.n	8008358 <udp_input+0x1c8>
            (broadcast &&
 8008348:	b133      	cbz	r3, 8008358 <udp_input+0x1c8>
             (ip_addr_isany(&pcb->local_ip) ||
 800834a:	b129      	cbz	r1, 8008358 <udp_input+0x1c8>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
 800834c:	ea8c 0401 	eor.w	r4, ip, r1
             (ip_addr_isany(&pcb->local_ip) ||
 8008350:	f8d9 1008 	ldr.w	r1, [r9, #8]
 8008354:	420c      	tst	r4, r1
 8008356:	d106      	bne.n	8008366 <udp_input+0x1d6>
          if ((uncon_pcb == NULL) && 
 8008358:	2e00      	cmp	r6, #0
 800835a:	f43f af67 	beq.w	800822c <udp_input+0x9c>
      if ((local_match != 0) &&
 800835e:	8a99      	ldrh	r1, [r3, #20]
 8008360:	42a9      	cmp	r1, r5
 8008362:	f43f af6a 	beq.w	800823a <udp_input+0xaa>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008366:	68d9      	ldr	r1, [r3, #12]
 8008368:	461a      	mov	r2, r3
 800836a:	2900      	cmp	r1, #0
 800836c:	f43f af7f 	beq.w	800826e <udp_input+0xde>
 8008370:	460b      	mov	r3, r1
      if (pcb->local_port == dest) {
 8008372:	8a59      	ldrh	r1, [r3, #18]
 8008374:	4281      	cmp	r1, r0
 8008376:	d1f6      	bne.n	8008366 <udp_input+0x1d6>
        if (
 8008378:	2f00      	cmp	r7, #0
 800837a:	d1e2      	bne.n	8008342 <udp_input+0x1b2>
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 800837c:	2b00      	cmp	r3, #0
 800837e:	d0eb      	beq.n	8008358 <udp_input+0x1c8>
 8008380:	6819      	ldr	r1, [r3, #0]
 8008382:	2900      	cmp	r1, #0
 8008384:	d0e8      	beq.n	8008358 <udp_input+0x1c8>
 8008386:	4561      	cmp	r1, ip
 8008388:	d1ed      	bne.n	8008366 <udp_input+0x1d6>
 800838a:	e7e5      	b.n	8008358 <udp_input+0x1c8>
 800838c:	2000aac4 	.word	0x2000aac4
 8008390:	2000838c 	.word	0x2000838c
 8008394:	2000abfc 	.word	0x2000abfc
 8008398:	20008384 	.word	0x20008384

0800839c <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 800839c:	b5f0      	push	{r4, r5, r6, r7, lr}
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 800839e:	4b34      	ldr	r3, [pc, #208]	; (8008470 <udp_bind+0xd4>)
 80083a0:	681b      	ldr	r3, [r3, #0]
 80083a2:	b1cb      	cbz	r3, 80083d8 <udp_bind+0x3c>
 80083a4:	2600      	movs	r6, #0
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
 80083a6:	2701      	movs	r7, #1
 80083a8:	e002      	b.n	80083b0 <udp_bind+0x14>
 80083aa:	463e      	mov	r6, r7
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80083ac:	68db      	ldr	r3, [r3, #12]
 80083ae:	b1a3      	cbz	r3, 80083da <udp_bind+0x3e>
    if (pcb == ipcb) {
 80083b0:	4298      	cmp	r0, r3
 80083b2:	d0fa      	beq.n	80083aa <udp_bind+0xe>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 80083b4:	8a5c      	ldrh	r4, [r3, #18]
 80083b6:	4294      	cmp	r4, r2
 80083b8:	d1f8      	bne.n	80083ac <udp_bind+0x10>
 80083ba:	2b00      	cmp	r3, #0
 80083bc:	d04a      	beq.n	8008454 <udp_bind+0xb8>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
 80083be:	681c      	ldr	r4, [r3, #0]
 80083c0:	2c00      	cmp	r4, #0
 80083c2:	d04a      	beq.n	800845a <udp_bind+0xbe>
 80083c4:	2900      	cmp	r1, #0
 80083c6:	d04b      	beq.n	8008460 <udp_bind+0xc4>
           ip_addr_isany(ipaddr) ||
 80083c8:	680d      	ldr	r5, [r1, #0]
 80083ca:	2d00      	cmp	r5, #0
 80083cc:	d04b      	beq.n	8008466 <udp_bind+0xca>
 80083ce:	42ac      	cmp	r4, r5
 80083d0:	d1ec      	bne.n	80083ac <udp_bind+0x10>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
 80083d2:	f06f 0007 	mvn.w	r0, #7
 80083d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  rebind = 0;
 80083d8:	2600      	movs	r6, #0
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
 80083da:	b159      	cbz	r1, 80083f4 <udp_bind+0x58>
 80083dc:	680b      	ldr	r3, [r1, #0]
 80083de:	6003      	str	r3, [r0, #0]

  /* no port specified? */
  if (port == 0) {
 80083e0:	b152      	cbz	r2, 80083f8 <udp_bind+0x5c>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
 80083e2:	8242      	strh	r2, [r0, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 80083e4:	2e00      	cmp	r6, #0
 80083e6:	d141      	bne.n	800846c <udp_bind+0xd0>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 80083e8:	4b21      	ldr	r3, [pc, #132]	; (8008470 <udp_bind+0xd4>)
 80083ea:	681a      	ldr	r2, [r3, #0]
 80083ec:	60c2      	str	r2, [r0, #12]
    udp_pcbs = pcb;
 80083ee:	6018      	str	r0, [r3, #0]
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
 80083f0:	2000      	movs	r0, #0
 80083f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  ip_addr_set(&pcb->local_ip, ipaddr);
 80083f4:	2300      	movs	r3, #0
 80083f6:	e7f2      	b.n	80083de <udp_bind+0x42>
 80083f8:	4b1e      	ldr	r3, [pc, #120]	; (8008474 <udp_bind+0xd8>)
 80083fa:	8819      	ldrh	r1, [r3, #0]
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80083fc:	4b1c      	ldr	r3, [pc, #112]	; (8008470 <udp_bind+0xd4>)
 80083fe:	681c      	ldr	r4, [r3, #0]
 8008400:	f44f 4580 	mov.w	r5, #16384	; 0x4000
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 8008404:	f64f 77ff 	movw	r7, #65535	; 0xffff
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8008408:	f44f 4e40 	mov.w	lr, #49152	; 0xc000
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 800840c:	42b9      	cmp	r1, r7
 800840e:	bf1a      	itte	ne
 8008410:	3101      	addne	r1, #1
 8008412:	b289      	uxthne	r1, r1
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8008414:	4671      	moveq	r1, lr
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008416:	b18c      	cbz	r4, 800843c <udp_bind+0xa0>
    if (pcb->local_port == udp_port) {
 8008418:	8a63      	ldrh	r3, [r4, #18]
 800841a:	428b      	cmp	r3, r1
 800841c:	d005      	beq.n	800842a <udp_bind+0x8e>
 800841e:	4623      	mov	r3, r4
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008420:	68db      	ldr	r3, [r3, #12]
 8008422:	b173      	cbz	r3, 8008442 <udp_bind+0xa6>
    if (pcb->local_port == udp_port) {
 8008424:	8a5a      	ldrh	r2, [r3, #18]
 8008426:	428a      	cmp	r2, r1
 8008428:	d1fa      	bne.n	8008420 <udp_bind+0x84>
 800842a:	3d01      	subs	r5, #1
 800842c:	b2ad      	uxth	r5, r5
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 800842e:	2d00      	cmp	r5, #0
 8008430:	d1ec      	bne.n	800840c <udp_bind+0x70>
 8008432:	4b10      	ldr	r3, [pc, #64]	; (8008474 <udp_bind+0xd8>)
 8008434:	8019      	strh	r1, [r3, #0]
      return ERR_USE;
 8008436:	f06f 0007 	mvn.w	r0, #7
 800843a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800843c:	4b0d      	ldr	r3, [pc, #52]	; (8008474 <udp_bind+0xd8>)
 800843e:	8019      	strh	r1, [r3, #0]
 8008440:	e001      	b.n	8008446 <udp_bind+0xaa>
 8008442:	4b0c      	ldr	r3, [pc, #48]	; (8008474 <udp_bind+0xd8>)
 8008444:	8019      	strh	r1, [r3, #0]
  return udp_port;
 8008446:	4b0b      	ldr	r3, [pc, #44]	; (8008474 <udp_bind+0xd8>)
 8008448:	881a      	ldrh	r2, [r3, #0]
    if (port == 0) {
 800844a:	2a00      	cmp	r2, #0
 800844c:	d1c9      	bne.n	80083e2 <udp_bind+0x46>
      return ERR_USE;
 800844e:	f06f 0007 	mvn.w	r0, #7
 8008452:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return ERR_USE;
 8008454:	f06f 0007 	mvn.w	r0, #7
 8008458:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800845a:	f06f 0007 	mvn.w	r0, #7
 800845e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008460:	f06f 0007 	mvn.w	r0, #7
 8008464:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008466:	f06f 0007 	mvn.w	r0, #7
 800846a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return ERR_OK;
 800846c:	2000      	movs	r0, #0
}
 800846e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008470:	2000abfc 	.word	0x2000abfc
 8008474:	2000014c 	.word	0x2000014c

08008478 <udp_sendto_if>:
{
 8008478:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800847c:	b084      	sub	sp, #16
 800847e:	4604      	mov	r4, r0
 8008480:	460f      	mov	r7, r1
 8008482:	4691      	mov	r9, r2
 8008484:	469a      	mov	sl, r3
 8008486:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
  if (pcb->local_port == 0) {
 800848a:	8a43      	ldrh	r3, [r0, #18]
 800848c:	b933      	cbnz	r3, 800849c <udp_sendto_if+0x24>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 800848e:	2200      	movs	r2, #0
 8008490:	4601      	mov	r1, r0
 8008492:	f7ff ff83 	bl	800839c <udp_bind>
    if (err != ERR_OK) {
 8008496:	4605      	mov	r5, r0
 8008498:	2800      	cmp	r0, #0
 800849a:	d145      	bne.n	8008528 <udp_sendto_if+0xb0>
  if (pbuf_header(p, UDP_HLEN)) {
 800849c:	2108      	movs	r1, #8
 800849e:	4638      	mov	r0, r7
 80084a0:	f7fd f8ab 	bl	80055fa <pbuf_header>
 80084a4:	b168      	cbz	r0, 80084c2 <udp_sendto_if+0x4a>
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 80084a6:	2200      	movs	r2, #0
 80084a8:	2108      	movs	r1, #8
 80084aa:	2001      	movs	r0, #1
 80084ac:	f7fd f912 	bl	80056d4 <pbuf_alloc>
    if (q == NULL) {
 80084b0:	4606      	mov	r6, r0
 80084b2:	2800      	cmp	r0, #0
 80084b4:	d057      	beq.n	8008566 <udp_sendto_if+0xee>
    if (p->tot_len != 0) {
 80084b6:	893b      	ldrh	r3, [r7, #8]
 80084b8:	b123      	cbz	r3, 80084c4 <udp_sendto_if+0x4c>
      pbuf_chain(q, p);
 80084ba:	4639      	mov	r1, r7
 80084bc:	f7fd f9f6 	bl	80058ac <pbuf_chain>
 80084c0:	e000      	b.n	80084c4 <udp_sendto_if+0x4c>
    q = p;
 80084c2:	463e      	mov	r6, r7
  udphdr = (struct udp_hdr *)q->payload;
 80084c4:	6875      	ldr	r5, [r6, #4]
  udphdr->src = htons(pcb->local_port);
 80084c6:	8a60      	ldrh	r0, [r4, #18]
 80084c8:	f7fb fe5a 	bl	8004180 <lwip_htons>
 80084cc:	8028      	strh	r0, [r5, #0]
  udphdr->dest = htons(dst_port);
 80084ce:	4650      	mov	r0, sl
 80084d0:	f7fb fe56 	bl	8004180 <lwip_htons>
 80084d4:	8068      	strh	r0, [r5, #2]
  udphdr->chksum = 0x0000; 
 80084d6:	2300      	movs	r3, #0
 80084d8:	71ab      	strb	r3, [r5, #6]
 80084da:	71eb      	strb	r3, [r5, #7]
  if (ip_addr_isany(&pcb->local_ip)) {
 80084dc:	46a2      	mov	sl, r4
 80084de:	b10c      	cbz	r4, 80084e4 <udp_sendto_if+0x6c>
 80084e0:	6823      	ldr	r3, [r4, #0]
 80084e2:	bb2b      	cbnz	r3, 8008530 <udp_sendto_if+0xb8>
    src_ip = &(netif->ip_addr);
 80084e4:	f108 0a04 	add.w	sl, r8, #4
    udphdr->len = htons(q->tot_len);
 80084e8:	8930      	ldrh	r0, [r6, #8]
 80084ea:	f7fb fe49 	bl	8004180 <lwip_htons>
 80084ee:	80a8      	strh	r0, [r5, #4]
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 80084f0:	7c23      	ldrb	r3, [r4, #16]
 80084f2:	f013 0f01 	tst.w	r3, #1
 80084f6:	d027      	beq.n	8008548 <udp_sendto_if+0xd0>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 80084f8:	7aa3      	ldrb	r3, [r4, #10]
 80084fa:	f8cd 8008 	str.w	r8, [sp, #8]
 80084fe:	2211      	movs	r2, #17
 8008500:	9201      	str	r2, [sp, #4]
 8008502:	7a62      	ldrb	r2, [r4, #9]
 8008504:	9200      	str	r2, [sp, #0]
 8008506:	464a      	mov	r2, r9
 8008508:	4651      	mov	r1, sl
 800850a:	4630      	mov	r0, r6
 800850c:	f7fc f98e 	bl	800482c <ip_output_if>
 8008510:	4605      	mov	r5, r0
  if (q != p) {
 8008512:	42be      	cmp	r6, r7
 8008514:	d002      	beq.n	800851c <udp_sendto_if+0xa4>
    pbuf_free(q);
 8008516:	4630      	mov	r0, r6
 8008518:	f7fd f8ad 	bl	8005676 <pbuf_free>
  UDP_STATS_INC(udp.xmit);
 800851c:	4a15      	ldr	r2, [pc, #84]	; (8008574 <udp_sendto_if+0xfc>)
 800851e:	f8b2 3078 	ldrh.w	r3, [r2, #120]	; 0x78
 8008522:	3301      	adds	r3, #1
 8008524:	f8a2 3078 	strh.w	r3, [r2, #120]	; 0x78
}
 8008528:	4628      	mov	r0, r5
 800852a:	b004      	add	sp, #16
 800852c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 8008530:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8008534:	4293      	cmp	r3, r2
 8008536:	d0d7      	beq.n	80084e8 <udp_sendto_if+0x70>
      if (q != p) {
 8008538:	42be      	cmp	r6, r7
 800853a:	d017      	beq.n	800856c <udp_sendto_if+0xf4>
        pbuf_free(q);
 800853c:	4630      	mov	r0, r6
 800853e:	f7fd f89a 	bl	8005676 <pbuf_free>
      return ERR_VAL;
 8008542:	f06f 0505 	mvn.w	r5, #5
 8008546:	e7ef      	b.n	8008528 <udp_sendto_if+0xb0>
        udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
 8008548:	8933      	ldrh	r3, [r6, #8]
 800854a:	9300      	str	r3, [sp, #0]
 800854c:	2311      	movs	r3, #17
 800854e:	464a      	mov	r2, r9
 8008550:	4651      	mov	r1, sl
 8008552:	4630      	mov	r0, r6
 8008554:	f7fb ffac 	bl	80044b0 <inet_chksum_pseudo>
      udphdr->chksum = udpchksum;
 8008558:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800855c:	2800      	cmp	r0, #0
 800855e:	bf08      	it	eq
 8008560:	4618      	moveq	r0, r3
 8008562:	80e8      	strh	r0, [r5, #6]
 8008564:	e7c8      	b.n	80084f8 <udp_sendto_if+0x80>
      return ERR_MEM;
 8008566:	f04f 35ff 	mov.w	r5, #4294967295
 800856a:	e7dd      	b.n	8008528 <udp_sendto_if+0xb0>
      return ERR_VAL;
 800856c:	f06f 0505 	mvn.w	r5, #5
 8008570:	e7da      	b.n	8008528 <udp_sendto_if+0xb0>
 8008572:	bf00      	nop
 8008574:	2000aac4 	.word	0x2000aac4

08008578 <udp_sendto>:
{
 8008578:	b5f0      	push	{r4, r5, r6, r7, lr}
 800857a:	b083      	sub	sp, #12
 800857c:	4605      	mov	r5, r0
 800857e:	460e      	mov	r6, r1
 8008580:	4614      	mov	r4, r2
 8008582:	461f      	mov	r7, r3
  netif = ip_route(dst_ip);
 8008584:	4610      	mov	r0, r2
 8008586:	f7fc f80b 	bl	80045a0 <ip_route>
  if (netif == NULL) {
 800858a:	b140      	cbz	r0, 800859e <udp_sendto+0x26>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 800858c:	9000      	str	r0, [sp, #0]
 800858e:	463b      	mov	r3, r7
 8008590:	4622      	mov	r2, r4
 8008592:	4631      	mov	r1, r6
 8008594:	4628      	mov	r0, r5
 8008596:	f7ff ff6f 	bl	8008478 <udp_sendto_if>
}
 800859a:	b003      	add	sp, #12
 800859c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    UDP_STATS_INC(udp.rterr);
 800859e:	4a04      	ldr	r2, [pc, #16]	; (80085b0 <udp_sendto+0x38>)
 80085a0:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80085a4:	3301      	adds	r3, #1
 80085a6:	f8a2 3086 	strh.w	r3, [r2, #134]	; 0x86
    return ERR_RTE;
 80085aa:	f06f 0003 	mvn.w	r0, #3
 80085ae:	e7f4      	b.n	800859a <udp_sendto+0x22>
 80085b0:	2000aac4 	.word	0x2000aac4

080085b4 <udp_recv>:
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
 80085b4:	6181      	str	r1, [r0, #24]
  pcb->recv_arg = recv_arg;
 80085b6:	61c2      	str	r2, [r0, #28]
 80085b8:	4770      	bx	lr
	...

080085bc <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 80085bc:	b508      	push	{r3, lr}
 80085be:	4601      	mov	r1, r0
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 80085c0:	4b0b      	ldr	r3, [pc, #44]	; (80085f0 <udp_remove+0x34>)
 80085c2:	681a      	ldr	r2, [r3, #0]
 80085c4:	4282      	cmp	r2, r0
 80085c6:	d001      	beq.n	80085cc <udp_remove+0x10>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 80085c8:	b942      	cbnz	r2, 80085dc <udp_remove+0x20>
 80085ca:	e002      	b.n	80085d2 <udp_remove+0x16>
    udp_pcbs = udp_pcbs->next;
 80085cc:	68d2      	ldr	r2, [r2, #12]
 80085ce:	4b08      	ldr	r3, [pc, #32]	; (80085f0 <udp_remove+0x34>)
 80085d0:	601a      	str	r2, [r3, #0]
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 80085d2:	2001      	movs	r0, #1
 80085d4:	f7fc ff58 	bl	8005488 <memp_free>
 80085d8:	bd08      	pop	{r3, pc}
{
 80085da:	461a      	mov	r2, r3
      if (pcb2->next != NULL && pcb2->next == pcb) {
 80085dc:	68d3      	ldr	r3, [r2, #12]
 80085de:	2b00      	cmp	r3, #0
 80085e0:	d0f7      	beq.n	80085d2 <udp_remove+0x16>
 80085e2:	4299      	cmp	r1, r3
 80085e4:	d1f9      	bne.n	80085da <udp_remove+0x1e>
        pcb2->next = pcb->next;
 80085e6:	68cb      	ldr	r3, [r1, #12]
 80085e8:	60d3      	str	r3, [r2, #12]
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 80085ea:	2b00      	cmp	r3, #0
 80085ec:	d1f5      	bne.n	80085da <udp_remove+0x1e>
 80085ee:	e7f0      	b.n	80085d2 <udp_remove+0x16>
 80085f0:	2000abfc 	.word	0x2000abfc

080085f4 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 80085f4:	b510      	push	{r4, lr}
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 80085f6:	2001      	movs	r0, #1
 80085f8:	f7fc ff10 	bl	800541c <memp_malloc>
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 80085fc:	4604      	mov	r4, r0
 80085fe:	b128      	cbz	r0, 800860c <udp_new+0x18>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 8008600:	2220      	movs	r2, #32
 8008602:	2100      	movs	r1, #0
 8008604:	f000 fc4e 	bl	8008ea4 <memset>
    pcb->ttl = UDP_TTL;
 8008608:	23ff      	movs	r3, #255	; 0xff
 800860a:	72a3      	strb	r3, [r4, #10]
  }
  return pcb;
}
 800860c:	4620      	mov	r0, r4
 800860e:	bd10      	pop	{r4, pc}

08008610 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 8008610:	b510      	push	{r4, lr}
 8008612:	4604      	mov	r4, r0
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8008614:	eb00 0280 	add.w	r2, r0, r0, lsl #2
 8008618:	4b09      	ldr	r3, [pc, #36]	; (8008640 <etharp_free_entry+0x30>)
 800861a:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 800861e:	b138      	cbz	r0, 8008630 <etharp_free_entry+0x20>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8008620:	f7fd f829 	bl	8005676 <pbuf_free>
    arp_table[i].q = NULL;
 8008624:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 8008628:	009b      	lsls	r3, r3, #2
 800862a:	2100      	movs	r1, #0
 800862c:	4a04      	ldr	r2, [pc, #16]	; (8008640 <etharp_free_entry+0x30>)
 800862e:	50d1      	str	r1, [r2, r3]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8008630:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8008634:	4b02      	ldr	r3, [pc, #8]	; (8008640 <etharp_free_entry+0x30>)
 8008636:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 800863a:	2300      	movs	r3, #0
 800863c:	74a3      	strb	r3, [r4, #18]
 800863e:	bd10      	pop	{r4, pc}
 8008640:	200071d0 	.word	0x200071d0

08008644 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
 8008644:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008648:	b083      	sub	sp, #12
 800864a:	4a3f      	ldr	r2, [pc, #252]	; (8008748 <etharp_find_entry+0x104>)
 800864c:	2300      	movs	r3, #0
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u8_t age_queue = 0;
 800864e:	4698      	mov	r8, r3
  s8_t old_queue = ARP_TABLE_SIZE;
 8008650:	f04f 0e0a 	mov.w	lr, #10
  u8_t i = 0, age_pending = 0, age_stable = 0;
 8008654:	469c      	mov	ip, r3
  s8_t empty = ARP_TABLE_SIZE;
 8008656:	4675      	mov	r5, lr
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8008658:	46f1      	mov	r9, lr
 800865a:	46f2      	mov	sl, lr
 800865c:	9301      	str	r3, [sp, #4]
 800865e:	e005      	b.n	800866c <etharp_find_entry+0x28>
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8008660:	b957      	cbnz	r7, 8008678 <etharp_find_entry+0x34>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8008662:	b25d      	sxtb	r5, r3
 8008664:	3301      	adds	r3, #1
 8008666:	3214      	adds	r2, #20
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8008668:	2b0a      	cmp	r3, #10
 800866a:	d02e      	beq.n	80086ca <etharp_find_entry+0x86>
 800866c:	4614      	mov	r4, r2
    u8_t state = arp_table[i].state;
 800866e:	7c97      	ldrb	r7, [r2, #18]
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8008670:	2d0a      	cmp	r5, #10
 8008672:	d0f5      	beq.n	8008660 <etharp_find_entry+0x1c>
    } else if (state != ETHARP_STATE_EMPTY) {
 8008674:	2f00      	cmp	r7, #0
 8008676:	d0f5      	beq.n	8008664 <etharp_find_entry+0x20>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 8008678:	b120      	cbz	r0, 8008684 <etharp_find_entry+0x40>
 800867a:	6806      	ldr	r6, [r0, #0]
 800867c:	46b3      	mov	fp, r6
 800867e:	6866      	ldr	r6, [r4, #4]
 8008680:	45b3      	cmp	fp, r6
 8008682:	d00f      	beq.n	80086a4 <etharp_find_entry+0x60>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8008684:	2f01      	cmp	r7, #1
 8008686:	d00f      	beq.n	80086a8 <etharp_find_entry+0x64>
            old_pending = i;
            age_pending = arp_table[i].ctime;
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
 8008688:	f1a7 0b02 	sub.w	fp, r7, #2
 800868c:	fa5f fb8b 	uxtb.w	fp, fp
 8008690:	f1bb 0f01 	cmp.w	fp, #1
 8008694:	d8e6      	bhi.n	8008664 <etharp_find_entry+0x20>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8008696:	7ce4      	ldrb	r4, [r4, #19]
 8008698:	4564      	cmp	r4, ip
            old_stable = i;
 800869a:	bf24      	itt	cs
 800869c:	fa4f f983 	sxtbcs.w	r9, r3
            age_stable = arp_table[i].ctime;
 80086a0:	46a4      	movcs	ip, r4
 80086a2:	e7df      	b.n	8008664 <etharp_find_entry+0x20>
        return i;
 80086a4:	b258      	sxtb	r0, r3
 80086a6:	e02a      	b.n	80086fe <etharp_find_entry+0xba>
        if (arp_table[i].q != NULL) {
 80086a8:	6827      	ldr	r7, [r4, #0]
 80086aa:	b137      	cbz	r7, 80086ba <etharp_find_entry+0x76>
          if (arp_table[i].ctime >= age_queue) {
 80086ac:	7ce4      	ldrb	r4, [r4, #19]
 80086ae:	4544      	cmp	r4, r8
 80086b0:	d3d8      	bcc.n	8008664 <etharp_find_entry+0x20>
            old_queue = i;
 80086b2:	fa4f fe83 	sxtb.w	lr, r3
            age_queue = arp_table[i].ctime;
 80086b6:	46a0      	mov	r8, r4
 80086b8:	e7d4      	b.n	8008664 <etharp_find_entry+0x20>
          if (arp_table[i].ctime >= age_pending) {
 80086ba:	7ce4      	ldrb	r4, [r4, #19]
 80086bc:	9e01      	ldr	r6, [sp, #4]
 80086be:	42b4      	cmp	r4, r6
 80086c0:	d3d0      	bcc.n	8008664 <etharp_find_entry+0x20>
            old_pending = i;
 80086c2:	fa4f fa83 	sxtb.w	sl, r3
            age_pending = arp_table[i].ctime;
 80086c6:	9401      	str	r4, [sp, #4]
 80086c8:	e7cc      	b.n	8008664 <etharp_find_entry+0x20>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 80086ca:	f011 0f02 	tst.w	r1, #2
 80086ce:	d131      	bne.n	8008734 <etharp_find_entry+0xf0>
 80086d0:	4604      	mov	r4, r0
 80086d2:	2d0a      	cmp	r5, #10
 80086d4:	d016      	beq.n	8008704 <etharp_find_entry+0xc0>
   * 
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 80086d6:	2d09      	cmp	r5, #9
 80086d8:	dc17      	bgt.n	800870a <etharp_find_entry+0xc6>
    i = empty;
 80086da:	b2ed      	uxtb	r5, r5
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 80086dc:	462b      	mov	r3, r5
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 80086de:	b134      	cbz	r4, 80086ee <etharp_find_entry+0xaa>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
 80086e0:	6820      	ldr	r0, [r4, #0]
 80086e2:	eb05 0285 	add.w	r2, r5, r5, lsl #2
 80086e6:	4918      	ldr	r1, [pc, #96]	; (8008748 <etharp_find_entry+0x104>)
 80086e8:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 80086ec:	6050      	str	r0, [r2, #4]
  }
  arp_table[i].ctime = 0;
 80086ee:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80086f2:	4a15      	ldr	r2, [pc, #84]	; (8008748 <etharp_find_entry+0x104>)
 80086f4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80086f8:	2200      	movs	r2, #0
 80086fa:	74da      	strb	r2, [r3, #19]
  return (err_t)i;
 80086fc:	b268      	sxtb	r0, r5
}
 80086fe:	b003      	add	sp, #12
 8008700:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 8008704:	f011 0f01 	tst.w	r1, #1
 8008708:	d017      	beq.n	800873a <etharp_find_entry+0xf6>
    if (old_stable < ARP_TABLE_SIZE) {
 800870a:	f1b9 0f09 	cmp.w	r9, #9
 800870e:	dc05      	bgt.n	800871c <etharp_find_entry+0xd8>
      i = old_stable;
 8008710:	fa5f f589 	uxtb.w	r5, r9
    etharp_free_entry(i);
 8008714:	4628      	mov	r0, r5
 8008716:	f7ff ff7b 	bl	8008610 <etharp_free_entry>
 800871a:	e7df      	b.n	80086dc <etharp_find_entry+0x98>
    } else if (old_pending < ARP_TABLE_SIZE) {
 800871c:	f1ba 0f09 	cmp.w	sl, #9
 8008720:	dc02      	bgt.n	8008728 <etharp_find_entry+0xe4>
      i = old_pending;
 8008722:	fa5f f58a 	uxtb.w	r5, sl
 8008726:	e7f5      	b.n	8008714 <etharp_find_entry+0xd0>
    } else if (old_queue < ARP_TABLE_SIZE) {
 8008728:	f1be 0f09 	cmp.w	lr, #9
 800872c:	dc08      	bgt.n	8008740 <etharp_find_entry+0xfc>
      i = old_queue;
 800872e:	fa5f f58e 	uxtb.w	r5, lr
 8008732:	e7ef      	b.n	8008714 <etharp_find_entry+0xd0>
    return (s8_t)ERR_MEM;
 8008734:	f04f 30ff 	mov.w	r0, #4294967295
 8008738:	e7e1      	b.n	80086fe <etharp_find_entry+0xba>
 800873a:	f04f 30ff 	mov.w	r0, #4294967295
 800873e:	e7de      	b.n	80086fe <etharp_find_entry+0xba>
      return (s8_t)ERR_MEM;
 8008740:	f04f 30ff 	mov.w	r0, #4294967295
 8008744:	e7db      	b.n	80086fe <etharp_find_entry+0xba>
 8008746:	bf00      	nop
 8008748:	200071d0 	.word	0x200071d0

0800874c <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
 800874c:	b538      	push	{r3, r4, r5, lr}
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 800874e:	684c      	ldr	r4, [r1, #4]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 8008750:	681d      	ldr	r5, [r3, #0]
 8008752:	6025      	str	r5, [r4, #0]
 8008754:	889b      	ldrh	r3, [r3, #4]
 8008756:	80a3      	strh	r3, [r4, #4]
  ETHADDR16_COPY(&ethhdr->src, src);
 8008758:	6813      	ldr	r3, [r2, #0]
 800875a:	f8c4 3006 	str.w	r3, [r4, #6]
 800875e:	8893      	ldrh	r3, [r2, #4]
 8008760:	8163      	strh	r3, [r4, #10]
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 8008762:	2308      	movs	r3, #8
 8008764:	7323      	strb	r3, [r4, #12]
 8008766:	2300      	movs	r3, #0
 8008768:	7363      	strb	r3, [r4, #13]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 800876a:	6983      	ldr	r3, [r0, #24]
 800876c:	4798      	blx	r3
}
 800876e:	bd38      	pop	{r3, r4, r5, pc}

08008770 <etharp_update_arp_entry>:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 8008770:	2900      	cmp	r1, #0
 8008772:	d045      	beq.n	8008800 <etharp_update_arp_entry+0x90>
{
 8008774:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008776:	4604      	mov	r4, r0
 8008778:	460e      	mov	r6, r1
  if (ip_addr_isany(ipaddr) ||
 800877a:	6808      	ldr	r0, [r1, #0]
 800877c:	2800      	cmp	r0, #0
 800877e:	d043      	beq.n	8008808 <etharp_update_arp_entry+0x98>
 8008780:	461f      	mov	r7, r3
 8008782:	4615      	mov	r5, r2
      ip_addr_isbroadcast(ipaddr, netif) ||
 8008784:	4621      	mov	r1, r4
 8008786:	f7fc f8f7 	bl	8004978 <ip4_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
 800878a:	2800      	cmp	r0, #0
 800878c:	d13f      	bne.n	800880e <etharp_update_arp_entry+0x9e>
      ip_addr_ismulticast(ipaddr)) {
 800878e:	6832      	ldr	r2, [r6, #0]
 8008790:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
      ip_addr_isbroadcast(ipaddr, netif) ||
 8008794:	2ae0      	cmp	r2, #224	; 0xe0
 8008796:	d03d      	beq.n	8008814 <etharp_update_arp_entry+0xa4>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
 8008798:	4639      	mov	r1, r7
 800879a:	4630      	mov	r0, r6
 800879c:	f7ff ff52 	bl	8008644 <etharp_find_entry>
  /* bail out if no entry could be found */
  if (i < 0) {
 80087a0:	1e01      	subs	r1, r0, #0
 80087a2:	db2b      	blt.n	80087fc <etharp_update_arp_entry+0x8c>
    return (err_t)i;
  }

#if ETHARP_SUPPORT_STATIC_ENTRIES
  if (flags & ETHARP_FLAG_STATIC_ENTRY) {
 80087a4:	f017 0f04 	tst.w	r7, #4
    /* record static type */
    arp_table[i].state = ETHARP_STATE_STATIC;
 80087a8:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 80087ac:	4a1c      	ldr	r2, [pc, #112]	; (8008820 <etharp_update_arp_entry+0xb0>)
 80087ae:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80087b2:	bf14      	ite	ne
 80087b4:	2204      	movne	r2, #4
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 80087b6:	2202      	moveq	r2, #2
 80087b8:	749a      	strb	r2, [r3, #18]
  }

  /* record network interface */
  arp_table[i].netif = netif;
 80087ba:	4e19      	ldr	r6, [pc, #100]	; (8008820 <etharp_update_arp_entry+0xb0>)
 80087bc:	008b      	lsls	r3, r1, #2
 80087be:	185a      	adds	r2, r3, r1
 80087c0:	0092      	lsls	r2, r2, #2
 80087c2:	18b7      	adds	r7, r6, r2
 80087c4:	60bc      	str	r4, [r7, #8]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 80087c6:	4613      	mov	r3, r2
 80087c8:	330c      	adds	r3, #12
 80087ca:	eb06 0e03 	add.w	lr, r6, r3
 80087ce:	6828      	ldr	r0, [r5, #0]
 80087d0:	50f0      	str	r0, [r6, r3]
 80087d2:	88ab      	ldrh	r3, [r5, #4]
 80087d4:	f8ae 3004 	strh.w	r3, [lr, #4]
  /* reset time stamp */
  arp_table[i].ctime = 0;
 80087d8:	2300      	movs	r3, #0
 80087da:	74fb      	strb	r3, [r7, #19]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
 80087dc:	58b6      	ldr	r6, [r6, r2]
 80087de:	b1e6      	cbz	r6, 800881a <etharp_update_arp_entry+0xaa>
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
 80087e0:	461f      	mov	r7, r3
 80087e2:	4b0f      	ldr	r3, [pc, #60]	; (8008820 <etharp_update_arp_entry+0xb0>)
 80087e4:	509f      	str	r7, [r3, r2]
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
 80087e6:	462b      	mov	r3, r5
 80087e8:	f104 0223 	add.w	r2, r4, #35	; 0x23
 80087ec:	4631      	mov	r1, r6
 80087ee:	4620      	mov	r0, r4
 80087f0:	f7ff ffac 	bl	800874c <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
 80087f4:	4630      	mov	r0, r6
 80087f6:	f7fc ff3e 	bl	8005676 <pbuf_free>
  }
  return ERR_OK;
 80087fa:	4639      	mov	r1, r7
}
 80087fc:	4608      	mov	r0, r1
 80087fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return ERR_ARG;
 8008800:	f06f 010d 	mvn.w	r1, #13
}
 8008804:	4608      	mov	r0, r1
 8008806:	4770      	bx	lr
    return ERR_ARG;
 8008808:	f06f 010d 	mvn.w	r1, #13
 800880c:	e7f6      	b.n	80087fc <etharp_update_arp_entry+0x8c>
 800880e:	f06f 010d 	mvn.w	r1, #13
 8008812:	e7f3      	b.n	80087fc <etharp_update_arp_entry+0x8c>
 8008814:	f06f 010d 	mvn.w	r1, #13
 8008818:	e7f0      	b.n	80087fc <etharp_update_arp_entry+0x8c>
  return ERR_OK;
 800881a:	2100      	movs	r1, #0
 800881c:	e7ee      	b.n	80087fc <etharp_update_arp_entry+0x8c>
 800881e:	bf00      	nop
 8008820:	200071d0 	.word	0x200071d0

08008824 <etharp_tmr>:
{
 8008824:	b570      	push	{r4, r5, r6, lr}
 8008826:	4c0f      	ldr	r4, [pc, #60]	; (8008864 <etharp_tmr+0x40>)
 8008828:	2500      	movs	r5, #0
        arp_table[i].state = ETHARP_STATE_STABLE;
 800882a:	2602      	movs	r6, #2
 800882c:	e007      	b.n	800883e <etharp_tmr+0x1a>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 800882e:	2b01      	cmp	r3, #1
 8008830:	d901      	bls.n	8008836 <etharp_tmr+0x12>
        etharp_free_entry(i);
 8008832:	f7ff feed 	bl	8008610 <etharp_free_entry>
 8008836:	3501      	adds	r5, #1
 8008838:	3414      	adds	r4, #20
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800883a:	2d0a      	cmp	r5, #10
 800883c:	d010      	beq.n	8008860 <etharp_tmr+0x3c>
    u8_t state = arp_table[i].state;
 800883e:	4628      	mov	r0, r5
 8008840:	7ca2      	ldrb	r2, [r4, #18]
    if (state != ETHARP_STATE_EMPTY
 8008842:	f012 0ffb 	tst.w	r2, #251	; 0xfb
 8008846:	d0f6      	beq.n	8008836 <etharp_tmr+0x12>
      arp_table[i].ctime++;
 8008848:	7ce3      	ldrb	r3, [r4, #19]
 800884a:	3301      	adds	r3, #1
 800884c:	b2db      	uxtb	r3, r3
 800884e:	74e3      	strb	r3, [r4, #19]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 8008850:	2bef      	cmp	r3, #239	; 0xef
 8008852:	d8ee      	bhi.n	8008832 <etharp_tmr+0xe>
 8008854:	2a01      	cmp	r2, #1
 8008856:	d0ea      	beq.n	800882e <etharp_tmr+0xa>
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
 8008858:	2a03      	cmp	r2, #3
        arp_table[i].state = ETHARP_STATE_STABLE;
 800885a:	bf08      	it	eq
 800885c:	74a6      	strbeq	r6, [r4, #18]
 800885e:	e7ea      	b.n	8008836 <etharp_tmr+0x12>
}
 8008860:	bd70      	pop	{r4, r5, r6, pc}
 8008862:	bf00      	nop
 8008864:	200071d0 	.word	0x200071d0

08008868 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
 8008868:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800886c:	4605      	mov	r5, r0
 800886e:	4688      	mov	r8, r1
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 8008870:	f100 0623 	add.w	r6, r0, #35	; 0x23
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 8008874:	2200      	movs	r2, #0
 8008876:	212a      	movs	r1, #42	; 0x2a
 8008878:	2003      	movs	r0, #3
 800887a:	f7fc ff2b 	bl	80056d4 <pbuf_alloc>
  if (p == NULL) {
 800887e:	2800      	cmp	r0, #0
 8008880:	d03c      	beq.n	80088fc <etharp_request+0x94>
 8008882:	4607      	mov	r7, r0
  ethhdr = (struct eth_hdr *)p->payload;
 8008884:	6844      	ldr	r4, [r0, #4]
  hdr->opcode = htons(opcode);
 8008886:	2001      	movs	r0, #1
 8008888:	f7fb fc7a 	bl	8004180 <lwip_htons>
 800888c:	82a0      	strh	r0, [r4, #20]
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 800888e:	6833      	ldr	r3, [r6, #0]
 8008890:	f8c4 3016 	str.w	r3, [r4, #22]
 8008894:	88b3      	ldrh	r3, [r6, #4]
 8008896:	8363      	strh	r3, [r4, #26]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 8008898:	4b1c      	ldr	r3, [pc, #112]	; (800890c <etharp_request+0xa4>)
 800889a:	6818      	ldr	r0, [r3, #0]
 800889c:	6220      	str	r0, [r4, #32]
 800889e:	889b      	ldrh	r3, [r3, #4]
 80088a0:	84a3      	strh	r3, [r4, #36]	; 0x24
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 80088a2:	4b1b      	ldr	r3, [pc, #108]	; (8008910 <etharp_request+0xa8>)
 80088a4:	6818      	ldr	r0, [r3, #0]
 80088a6:	6020      	str	r0, [r4, #0]
 80088a8:	889b      	ldrh	r3, [r3, #4]
 80088aa:	80a3      	strh	r3, [r4, #4]
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
 80088ac:	6833      	ldr	r3, [r6, #0]
 80088ae:	f8c4 3006 	str.w	r3, [r4, #6]
 80088b2:	88b3      	ldrh	r3, [r6, #4]
 80088b4:	8163      	strh	r3, [r4, #10]
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 80088b6:	686b      	ldr	r3, [r5, #4]
 80088b8:	61e3      	str	r3, [r4, #28]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 80088ba:	f8d8 3000 	ldr.w	r3, [r8]
 80088be:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 80088c2:	2200      	movs	r2, #0
 80088c4:	73a2      	strb	r2, [r4, #14]
 80088c6:	2301      	movs	r3, #1
 80088c8:	73e3      	strb	r3, [r4, #15]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 80088ca:	2308      	movs	r3, #8
 80088cc:	7423      	strb	r3, [r4, #16]
 80088ce:	7462      	strb	r2, [r4, #17]
  hdr->hwlen = ETHARP_HWADDR_LEN;
 80088d0:	2206      	movs	r2, #6
 80088d2:	74a2      	strb	r2, [r4, #18]
  hdr->protolen = sizeof(ip_addr_t);
 80088d4:	2204      	movs	r2, #4
 80088d6:	74e2      	strb	r2, [r4, #19]
  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 80088d8:	7323      	strb	r3, [r4, #12]
 80088da:	2306      	movs	r3, #6
 80088dc:	7363      	strb	r3, [r4, #13]
  result = netif->linkoutput(netif, p);
 80088de:	69ab      	ldr	r3, [r5, #24]
 80088e0:	4639      	mov	r1, r7
 80088e2:	4628      	mov	r0, r5
 80088e4:	4798      	blx	r3
 80088e6:	4604      	mov	r4, r0
  ETHARP_STATS_INC(etharp.xmit);
 80088e8:	4a0a      	ldr	r2, [pc, #40]	; (8008914 <etharp_request+0xac>)
 80088ea:	8b13      	ldrh	r3, [r2, #24]
 80088ec:	3301      	adds	r3, #1
 80088ee:	8313      	strh	r3, [r2, #24]
  pbuf_free(p);
 80088f0:	4638      	mov	r0, r7
 80088f2:	f7fc fec0 	bl	8005676 <pbuf_free>
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
 80088f6:	4620      	mov	r0, r4
 80088f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ETHARP_STATS_INC(etharp.memerr);
 80088fc:	4a05      	ldr	r2, [pc, #20]	; (8008914 <etharp_request+0xac>)
 80088fe:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8008900:	3301      	adds	r3, #1
 8008902:	8493      	strh	r3, [r2, #36]	; 0x24
    return ERR_MEM;
 8008904:	f04f 34ff 	mov.w	r4, #4294967295
 8008908:	e7f5      	b.n	80088f6 <etharp_request+0x8e>
 800890a:	bf00      	nop
 800890c:	0800902c 	.word	0x0800902c
 8008910:	08009024 	.word	0x08009024
 8008914:	2000aac4 	.word	0x2000aac4

08008918 <etharp_output_to_arp_index>:
{
 8008918:	b570      	push	{r4, r5, r6, lr}
 800891a:	4605      	mov	r5, r0
 800891c:	460e      	mov	r6, r1
 800891e:	4614      	mov	r4, r2
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 8008920:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8008924:	4b15      	ldr	r3, [pc, #84]	; (800897c <etharp_output_to_arp_index+0x64>)
 8008926:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 800892a:	7c9b      	ldrb	r3, [r3, #18]
 800892c:	2b02      	cmp	r3, #2
 800892e:	d00c      	beq.n	800894a <etharp_output_to_arp_index+0x32>
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 8008930:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8008934:	4b11      	ldr	r3, [pc, #68]	; (800897c <etharp_output_to_arp_index+0x64>)
 8008936:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 800893a:	330c      	adds	r3, #12
 800893c:	f105 0223 	add.w	r2, r5, #35	; 0x23
 8008940:	4631      	mov	r1, r6
 8008942:	4628      	mov	r0, r5
 8008944:	f7ff ff02 	bl	800874c <etharp_send_ip>
}
 8008948:	bd70      	pop	{r4, r5, r6, pc}
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
 800894a:	4613      	mov	r3, r2
 800894c:	4a0b      	ldr	r2, [pc, #44]	; (800897c <etharp_output_to_arp_index+0x64>)
 800894e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 8008952:	7cdb      	ldrb	r3, [r3, #19]
 8008954:	2be3      	cmp	r3, #227	; 0xe3
 8008956:	d9eb      	bls.n	8008930 <etharp_output_to_arp_index+0x18>
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 8008958:	eb04 0184 	add.w	r1, r4, r4, lsl #2
 800895c:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8008960:	3104      	adds	r1, #4
 8008962:	f7ff ff81 	bl	8008868 <etharp_request>
 8008966:	2800      	cmp	r0, #0
 8008968:	d1e2      	bne.n	8008930 <etharp_output_to_arp_index+0x18>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
 800896a:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 800896e:	4a03      	ldr	r2, [pc, #12]	; (800897c <etharp_output_to_arp_index+0x64>)
 8008970:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008974:	2203      	movs	r2, #3
 8008976:	749a      	strb	r2, [r3, #18]
 8008978:	e7da      	b.n	8008930 <etharp_output_to_arp_index+0x18>
 800897a:	bf00      	nop
 800897c:	200071d0 	.word	0x200071d0

08008980 <etharp_query>:
{
 8008980:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008984:	4606      	mov	r6, r0
 8008986:	460d      	mov	r5, r1
 8008988:	4617      	mov	r7, r2
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 800898a:	4601      	mov	r1, r0
 800898c:	6828      	ldr	r0, [r5, #0]
 800898e:	f7fb fff3 	bl	8004978 <ip4_addr_isbroadcast>
 8008992:	2800      	cmp	r0, #0
 8008994:	d16c      	bne.n	8008a70 <etharp_query+0xf0>
      ip_addr_ismulticast(ipaddr) ||
 8008996:	682b      	ldr	r3, [r5, #0]
 8008998:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 800899c:	2ae0      	cmp	r2, #224	; 0xe0
 800899e:	d06a      	beq.n	8008a76 <etharp_query+0xf6>
      ip_addr_ismulticast(ipaddr) ||
 80089a0:	2d00      	cmp	r5, #0
 80089a2:	d06b      	beq.n	8008a7c <etharp_query+0xfc>
      ip_addr_isany(ipaddr)) {
 80089a4:	2b00      	cmp	r3, #0
 80089a6:	d06c      	beq.n	8008a82 <etharp_query+0x102>
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
 80089a8:	2101      	movs	r1, #1
 80089aa:	4628      	mov	r0, r5
 80089ac:	f7ff fe4a 	bl	8008644 <etharp_find_entry>
  if (i < 0) {
 80089b0:	1e04      	subs	r4, r0, #0
 80089b2:	db36      	blt.n	8008a22 <etharp_query+0xa2>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 80089b4:	46a0      	mov	r8, r4
 80089b6:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 80089ba:	4a44      	ldr	r2, [pc, #272]	; (8008acc <etharp_query+0x14c>)
 80089bc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80089c0:	7c9b      	ldrb	r3, [r3, #18]
 80089c2:	2b00      	cmp	r3, #0
 80089c4:	d133      	bne.n	8008a2e <etharp_query+0xae>
    arp_table[i].state = ETHARP_STATE_PENDING;
 80089c6:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 80089ca:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80089ce:	2201      	movs	r2, #1
 80089d0:	749a      	strb	r2, [r3, #18]
    result = etharp_request(netif, ipaddr);
 80089d2:	4629      	mov	r1, r5
 80089d4:	4630      	mov	r0, r6
 80089d6:	f7ff ff47 	bl	8008868 <etharp_request>
    if (q == NULL) {
 80089da:	2f00      	cmp	r7, #0
 80089dc:	d054      	beq.n	8008a88 <etharp_query+0x108>
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 80089de:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 80089e2:	4a3a      	ldr	r2, [pc, #232]	; (8008acc <etharp_query+0x14c>)
 80089e4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80089e8:	7c9b      	ldrb	r3, [r3, #18]
 80089ea:	2b01      	cmp	r3, #1
 80089ec:	d824      	bhi.n	8008a38 <etharp_query+0xb8>
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 80089ee:	2b01      	cmp	r3, #1
 80089f0:	d14c      	bne.n	8008a8c <etharp_query+0x10c>
      if(p->type != PBUF_ROM) {
 80089f2:	7b3b      	ldrb	r3, [r7, #12]
 80089f4:	2b01      	cmp	r3, #1
 80089f6:	d154      	bne.n	8008aa2 <etharp_query+0x122>
 80089f8:	463b      	mov	r3, r7
      p = p->next;
 80089fa:	681b      	ldr	r3, [r3, #0]
    while (p) {
 80089fc:	2b00      	cmp	r3, #0
 80089fe:	d052      	beq.n	8008aa6 <etharp_query+0x126>
      if(p->type != PBUF_ROM) {
 8008a00:	7b1a      	ldrb	r2, [r3, #12]
 8008a02:	2a01      	cmp	r2, #1
 8008a04:	d0f9      	beq.n	80089fa <etharp_query+0x7a>
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 8008a06:	2200      	movs	r2, #0
 8008a08:	8919      	ldrh	r1, [r3, #8]
 8008a0a:	2003      	movs	r0, #3
 8008a0c:	f7fc fe62 	bl	80056d4 <pbuf_alloc>
      if(p != NULL) {
 8008a10:	4604      	mov	r4, r0
 8008a12:	b330      	cbz	r0, 8008a62 <etharp_query+0xe2>
        if (pbuf_copy(p, q) != ERR_OK) {
 8008a14:	4639      	mov	r1, r7
 8008a16:	4620      	mov	r0, r4
 8008a18:	f7fc ff50 	bl	80058bc <pbuf_copy>
 8008a1c:	b9f0      	cbnz	r0, 8008a5c <etharp_query+0xdc>
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 8008a1e:	4627      	mov	r7, r4
 8008a20:	e044      	b.n	8008aac <etharp_query+0x12c>
    if (q) {
 8008a22:	b1c7      	cbz	r7, 8008a56 <etharp_query+0xd6>
      ETHARP_STATS_INC(etharp.memerr);
 8008a24:	4a2a      	ldr	r2, [pc, #168]	; (8008ad0 <etharp_query+0x150>)
 8008a26:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8008a28:	3301      	adds	r3, #1
 8008a2a:	8493      	strh	r3, [r2, #36]	; 0x24
 8008a2c:	e013      	b.n	8008a56 <etharp_query+0xd6>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 8008a2e:	2b01      	cmp	r3, #1
 8008a30:	d0cf      	beq.n	80089d2 <etharp_query+0x52>
 8008a32:	b36f      	cbz	r7, 8008a90 <etharp_query+0x110>
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 8008a34:	2b01      	cmp	r3, #1
 8008a36:	d931      	bls.n	8008a9c <etharp_query+0x11c>
    ETHARP_SET_HINT(netif, i);
 8008a38:	4b26      	ldr	r3, [pc, #152]	; (8008ad4 <etharp_query+0x154>)
 8008a3a:	701c      	strb	r4, [r3, #0]
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 8008a3c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8008a40:	4b22      	ldr	r3, [pc, #136]	; (8008acc <etharp_query+0x14c>)
 8008a42:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8008a46:	330c      	adds	r3, #12
 8008a48:	f106 0223 	add.w	r2, r6, #35	; 0x23
 8008a4c:	4639      	mov	r1, r7
 8008a4e:	4630      	mov	r0, r6
 8008a50:	f7ff fe7c 	bl	800874c <etharp_send_ip>
 8008a54:	4604      	mov	r4, r0
}
 8008a56:	4620      	mov	r0, r4
 8008a58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          pbuf_free(p);
 8008a5c:	4620      	mov	r0, r4
 8008a5e:	f7fc fe0a 	bl	8005676 <pbuf_free>
      ETHARP_STATS_INC(etharp.memerr);
 8008a62:	4a1b      	ldr	r2, [pc, #108]	; (8008ad0 <etharp_query+0x150>)
 8008a64:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8008a66:	3301      	adds	r3, #1
 8008a68:	8493      	strh	r3, [r2, #36]	; 0x24
      result = ERR_MEM;
 8008a6a:	f04f 34ff 	mov.w	r4, #4294967295
 8008a6e:	e7f2      	b.n	8008a56 <etharp_query+0xd6>
    return ERR_ARG;
 8008a70:	f06f 040d 	mvn.w	r4, #13
 8008a74:	e7ef      	b.n	8008a56 <etharp_query+0xd6>
 8008a76:	f06f 040d 	mvn.w	r4, #13
 8008a7a:	e7ec      	b.n	8008a56 <etharp_query+0xd6>
 8008a7c:	f06f 040d 	mvn.w	r4, #13
 8008a80:	e7e9      	b.n	8008a56 <etharp_query+0xd6>
 8008a82:	f06f 040d 	mvn.w	r4, #13
 8008a86:	e7e6      	b.n	8008a56 <etharp_query+0xd6>
    result = etharp_request(netif, ipaddr);
 8008a88:	4604      	mov	r4, r0
 8008a8a:	e7e4      	b.n	8008a56 <etharp_query+0xd6>
 8008a8c:	4604      	mov	r4, r0
 8008a8e:	e7e2      	b.n	8008a56 <etharp_query+0xd6>
 8008a90:	4629      	mov	r1, r5
 8008a92:	4630      	mov	r0, r6
 8008a94:	f7ff fee8 	bl	8008868 <etharp_request>
 8008a98:	4604      	mov	r4, r0
 8008a9a:	e7dc      	b.n	8008a56 <etharp_query+0xd6>
  err_t result = ERR_MEM;
 8008a9c:	f04f 34ff 	mov.w	r4, #4294967295
 8008aa0:	e7d9      	b.n	8008a56 <etharp_query+0xd6>
      if(p->type != PBUF_ROM) {
 8008aa2:	463b      	mov	r3, r7
 8008aa4:	e7af      	b.n	8008a06 <etharp_query+0x86>
      pbuf_ref(p);
 8008aa6:	4638      	mov	r0, r7
 8008aa8:	f7fc fee2 	bl	8005870 <pbuf_ref>
      if (arp_table[i].q != NULL) {
 8008aac:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 8008ab0:	4a06      	ldr	r2, [pc, #24]	; (8008acc <etharp_query+0x14c>)
 8008ab2:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8008ab6:	b108      	cbz	r0, 8008abc <etharp_query+0x13c>
        pbuf_free(arp_table[i].q);
 8008ab8:	f7fc fddd 	bl	8005676 <pbuf_free>
      arp_table[i].q = p;
 8008abc:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 8008ac0:	4b02      	ldr	r3, [pc, #8]	; (8008acc <etharp_query+0x14c>)
 8008ac2:	f843 7028 	str.w	r7, [r3, r8, lsl #2]
      result = ERR_OK;
 8008ac6:	2400      	movs	r4, #0
 8008ac8:	e7c5      	b.n	8008a56 <etharp_query+0xd6>
 8008aca:	bf00      	nop
 8008acc:	200071d0 	.word	0x200071d0
 8008ad0:	2000aac4 	.word	0x2000aac4
 8008ad4:	20007298 	.word	0x20007298

08008ad8 <etharp_output>:
{
 8008ad8:	b570      	push	{r4, r5, r6, lr}
 8008ada:	b082      	sub	sp, #8
 8008adc:	4605      	mov	r5, r0
 8008ade:	460e      	mov	r6, r1
 8008ae0:	4614      	mov	r4, r2
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 8008ae2:	210e      	movs	r1, #14
 8008ae4:	4630      	mov	r0, r6
 8008ae6:	f7fc fd88 	bl	80055fa <pbuf_header>
 8008aea:	2800      	cmp	r0, #0
 8008aec:	d12f      	bne.n	8008b4e <etharp_output+0x76>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
 8008aee:	4629      	mov	r1, r5
 8008af0:	6820      	ldr	r0, [r4, #0]
 8008af2:	f7fb ff41 	bl	8004978 <ip4_addr_isbroadcast>
 8008af6:	2800      	cmp	r0, #0
 8008af8:	d168      	bne.n	8008bcc <etharp_output+0xf4>
  } else if (ip_addr_ismulticast(ipaddr)) {
 8008afa:	6823      	ldr	r3, [r4, #0]
 8008afc:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8008b00:	2ae0      	cmp	r2, #224	; 0xe0
 8008b02:	d02b      	beq.n	8008b5c <etharp_output+0x84>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 8008b04:	686a      	ldr	r2, [r5, #4]
 8008b06:	405a      	eors	r2, r3
 8008b08:	68a9      	ldr	r1, [r5, #8]
 8008b0a:	420a      	tst	r2, r1
 8008b0c:	d00a      	beq.n	8008b24 <etharp_output+0x4c>
        !ip_addr_islinklocal(ipaddr)) {
 8008b0e:	b29b      	uxth	r3, r3
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 8008b10:	f64f 62a9 	movw	r2, #65193	; 0xfea9
 8008b14:	4293      	cmp	r3, r2
 8008b16:	d005      	beq.n	8008b24 <etharp_output+0x4c>
        if (!ip_addr_isany(&netif->gw)) {
 8008b18:	f115 040c 	adds.w	r4, r5, #12
 8008b1c:	d05f      	beq.n	8008bde <etharp_output+0x106>
 8008b1e:	68eb      	ldr	r3, [r5, #12]
 8008b20:	2b00      	cmp	r3, #0
 8008b22:	d05f      	beq.n	8008be4 <etharp_output+0x10c>
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 8008b24:	4b31      	ldr	r3, [pc, #196]	; (8008bec <etharp_output+0x114>)
 8008b26:	781a      	ldrb	r2, [r3, #0]
 8008b28:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 8008b2c:	4b30      	ldr	r3, [pc, #192]	; (8008bf0 <etharp_output+0x118>)
 8008b2e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8008b32:	7c9b      	ldrb	r3, [r3, #18]
 8008b34:	2b01      	cmp	r3, #1
 8008b36:	d907      	bls.n	8008b48 <etharp_output+0x70>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 8008b38:	460b      	mov	r3, r1
 8008b3a:	492d      	ldr	r1, [pc, #180]	; (8008bf0 <etharp_output+0x118>)
 8008b3c:	eb01 0383 	add.w	r3, r1, r3, lsl #2
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 8008b40:	6821      	ldr	r1, [r4, #0]
 8008b42:	685b      	ldr	r3, [r3, #4]
 8008b44:	4299      	cmp	r1, r3
 8008b46:	d01f      	beq.n	8008b88 <etharp_output+0xb0>
 8008b48:	4b29      	ldr	r3, [pc, #164]	; (8008bf0 <etharp_output+0x118>)
{
 8008b4a:	2200      	movs	r2, #0
 8008b4c:	e029      	b.n	8008ba2 <etharp_output+0xca>
    LINK_STATS_INC(link.lenerr);
 8008b4e:	4a29      	ldr	r2, [pc, #164]	; (8008bf4 <etharp_output+0x11c>)
 8008b50:	8953      	ldrh	r3, [r2, #10]
 8008b52:	3301      	adds	r3, #1
 8008b54:	8153      	strh	r3, [r2, #10]
    return ERR_BUF;
 8008b56:	f06f 0001 	mvn.w	r0, #1
 8008b5a:	e03e      	b.n	8008bda <etharp_output+0x102>
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 8008b5c:	2301      	movs	r3, #1
 8008b5e:	f88d 3000 	strb.w	r3, [sp]
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
 8008b62:	2300      	movs	r3, #0
 8008b64:	f88d 3001 	strb.w	r3, [sp, #1]
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 8008b68:	235e      	movs	r3, #94	; 0x5e
 8008b6a:	f88d 3002 	strb.w	r3, [sp, #2]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 8008b6e:	7863      	ldrb	r3, [r4, #1]
 8008b70:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8008b74:	f88d 3003 	strb.w	r3, [sp, #3]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 8008b78:	78a3      	ldrb	r3, [r4, #2]
 8008b7a:	f88d 3004 	strb.w	r3, [sp, #4]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 8008b7e:	78e3      	ldrb	r3, [r4, #3]
 8008b80:	f88d 3005 	strb.w	r3, [sp, #5]
    dest = &mcastaddr;
 8008b84:	466b      	mov	r3, sp
 8008b86:	e022      	b.n	8008bce <etharp_output+0xf6>
          ETHARP_STATS_INC(etharp.cachehit);
 8008b88:	491a      	ldr	r1, [pc, #104]	; (8008bf4 <etharp_output+0x11c>)
 8008b8a:	8dcb      	ldrh	r3, [r1, #46]	; 0x2e
 8008b8c:	3301      	adds	r3, #1
 8008b8e:	85cb      	strh	r3, [r1, #46]	; 0x2e
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 8008b90:	4631      	mov	r1, r6
 8008b92:	4628      	mov	r0, r5
 8008b94:	f7ff fec0 	bl	8008918 <etharp_output_to_arp_index>
 8008b98:	e01f      	b.n	8008bda <etharp_output+0x102>
 8008b9a:	3201      	adds	r2, #1
 8008b9c:	3314      	adds	r3, #20
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 8008b9e:	2a0a      	cmp	r2, #10
 8008ba0:	d00e      	beq.n	8008bc0 <etharp_output+0xe8>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 8008ba2:	7c99      	ldrb	r1, [r3, #18]
 8008ba4:	2901      	cmp	r1, #1
 8008ba6:	d9f8      	bls.n	8008b9a <etharp_output+0xc2>
 8008ba8:	6820      	ldr	r0, [r4, #0]
 8008baa:	6859      	ldr	r1, [r3, #4]
 8008bac:	4288      	cmp	r0, r1
 8008bae:	d1f4      	bne.n	8008b9a <etharp_output+0xc2>
        ETHARP_SET_HINT(netif, i);
 8008bb0:	b2d2      	uxtb	r2, r2
 8008bb2:	4b0e      	ldr	r3, [pc, #56]	; (8008bec <etharp_output+0x114>)
 8008bb4:	701a      	strb	r2, [r3, #0]
        return etharp_output_to_arp_index(netif, q, i);
 8008bb6:	4631      	mov	r1, r6
 8008bb8:	4628      	mov	r0, r5
 8008bba:	f7ff fead 	bl	8008918 <etharp_output_to_arp_index>
 8008bbe:	e00c      	b.n	8008bda <etharp_output+0x102>
    return etharp_query(netif, dst_addr, q);
 8008bc0:	4632      	mov	r2, r6
 8008bc2:	4621      	mov	r1, r4
 8008bc4:	4628      	mov	r0, r5
 8008bc6:	f7ff fedb 	bl	8008980 <etharp_query>
 8008bca:	e006      	b.n	8008bda <etharp_output+0x102>
    dest = (struct eth_addr *)&ethbroadcast;
 8008bcc:	4b0a      	ldr	r3, [pc, #40]	; (8008bf8 <etharp_output+0x120>)
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
 8008bce:	f105 0223 	add.w	r2, r5, #35	; 0x23
 8008bd2:	4631      	mov	r1, r6
 8008bd4:	4628      	mov	r0, r5
 8008bd6:	f7ff fdb9 	bl	800874c <etharp_send_ip>
}
 8008bda:	b002      	add	sp, #8
 8008bdc:	bd70      	pop	{r4, r5, r6, pc}
          return ERR_RTE;
 8008bde:	f06f 0003 	mvn.w	r0, #3
 8008be2:	e7fa      	b.n	8008bda <etharp_output+0x102>
 8008be4:	f06f 0003 	mvn.w	r0, #3
 8008be8:	e7f7      	b.n	8008bda <etharp_output+0x102>
 8008bea:	bf00      	nop
 8008bec:	20007298 	.word	0x20007298
 8008bf0:	200071d0 	.word	0x200071d0
 8008bf4:	2000aac4 	.word	0x2000aac4
 8008bf8:	08009024 	.word	0x08009024

08008bfc <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 8008bfc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008c00:	b082      	sub	sp, #8
 8008c02:	4604      	mov	r4, r0
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 8008c04:	8945      	ldrh	r5, [r0, #10]
 8008c06:	2d0e      	cmp	r5, #14
 8008c08:	d80d      	bhi.n	8008c26 <ethernet_input+0x2a>
    /* a packet with only an ethernet header (or less) is not valid for us */
    ETHARP_STATS_INC(etharp.proterr);
 8008c0a:	4b70      	ldr	r3, [pc, #448]	; (8008dcc <ethernet_input+0x1d0>)
 8008c0c:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8008c0e:	3201      	adds	r2, #1
 8008c10:	851a      	strh	r2, [r3, #40]	; 0x28
    ETHARP_STATS_INC(etharp.drop);
 8008c12:	8bda      	ldrh	r2, [r3, #30]
 8008c14:	3201      	adds	r2, #1
 8008c16:	83da      	strh	r2, [r3, #30]
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 8008c18:	4620      	mov	r0, r4
 8008c1a:	f7fc fd2c 	bl	8005676 <pbuf_free>
  return ERR_OK;
}
 8008c1e:	2000      	movs	r0, #0
 8008c20:	b002      	add	sp, #8
 8008c22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008c26:	460f      	mov	r7, r1
  ethhdr = (struct eth_hdr *)p->payload;
 8008c28:	6846      	ldr	r6, [r0, #4]
  type = ethhdr->type;
 8008c2a:	f8b6 800c 	ldrh.w	r8, [r6, #12]
  if (ethhdr->dest.addr[0] & 1) {
 8008c2e:	7833      	ldrb	r3, [r6, #0]
 8008c30:	f013 0f01 	tst.w	r3, #1
 8008c34:	d00b      	beq.n	8008c4e <ethernet_input+0x52>
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
 8008c36:	2b01      	cmp	r3, #1
 8008c38:	d017      	beq.n	8008c6a <ethernet_input+0x6e>
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 8008c3a:	2206      	movs	r2, #6
 8008c3c:	4964      	ldr	r1, [pc, #400]	; (8008dd0 <ethernet_input+0x1d4>)
 8008c3e:	4630      	mov	r0, r6
 8008c40:	f000 f916 	bl	8008e70 <memcmp>
 8008c44:	b918      	cbnz	r0, 8008c4e <ethernet_input+0x52>
      p->flags |= PBUF_FLAG_LLBCAST;
 8008c46:	7b63      	ldrb	r3, [r4, #13]
 8008c48:	f043 0308 	orr.w	r3, r3, #8
 8008c4c:	7363      	strb	r3, [r4, #13]
  switch (type) {
 8008c4e:	f1b8 0f08 	cmp.w	r8, #8
 8008c52:	d015      	beq.n	8008c80 <ethernet_input+0x84>
 8008c54:	f5b8 6fc1 	cmp.w	r8, #1544	; 0x608
 8008c58:	d023      	beq.n	8008ca2 <ethernet_input+0xa6>
      ETHARP_STATS_INC(etharp.proterr);
 8008c5a:	4b5c      	ldr	r3, [pc, #368]	; (8008dcc <ethernet_input+0x1d0>)
 8008c5c:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8008c5e:	3201      	adds	r2, #1
 8008c60:	851a      	strh	r2, [r3, #40]	; 0x28
      ETHARP_STATS_INC(etharp.drop);
 8008c62:	8bda      	ldrh	r2, [r3, #30]
 8008c64:	3201      	adds	r2, #1
 8008c66:	83da      	strh	r2, [r3, #30]
      goto free_and_return;
 8008c68:	e7d6      	b.n	8008c18 <ethernet_input+0x1c>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 8008c6a:	7873      	ldrb	r3, [r6, #1]
 8008c6c:	2b00      	cmp	r3, #0
 8008c6e:	d1ee      	bne.n	8008c4e <ethernet_input+0x52>
 8008c70:	78b3      	ldrb	r3, [r6, #2]
 8008c72:	2b5e      	cmp	r3, #94	; 0x5e
 8008c74:	d1eb      	bne.n	8008c4e <ethernet_input+0x52>
        p->flags |= PBUF_FLAG_LLMCAST;
 8008c76:	7b43      	ldrb	r3, [r0, #13]
 8008c78:	f043 0310 	orr.w	r3, r3, #16
 8008c7c:	7343      	strb	r3, [r0, #13]
 8008c7e:	e7e6      	b.n	8008c4e <ethernet_input+0x52>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 8008c80:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8008c84:	f013 0f20 	tst.w	r3, #32
 8008c88:	d0c6      	beq.n	8008c18 <ethernet_input+0x1c>
      if(pbuf_header(p, -ip_hdr_offset)) {
 8008c8a:	f06f 010d 	mvn.w	r1, #13
 8008c8e:	4620      	mov	r0, r4
 8008c90:	f7fc fcb3 	bl	80055fa <pbuf_header>
 8008c94:	2800      	cmp	r0, #0
 8008c96:	d1bf      	bne.n	8008c18 <ethernet_input+0x1c>
        ip_input(p, netif);
 8008c98:	4639      	mov	r1, r7
 8008c9a:	4620      	mov	r0, r4
 8008c9c:	f7fb fcaa 	bl	80045f4 <ip_input>
      break;
 8008ca0:	e7bd      	b.n	8008c1e <ethernet_input+0x22>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 8008ca2:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8008ca6:	f013 0f20 	tst.w	r3, #32
 8008caa:	d0b5      	beq.n	8008c18 <ethernet_input+0x1c>
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 8008cac:	2f00      	cmp	r7, #0
 8008cae:	d0b6      	beq.n	8008c1e <ethernet_input+0x22>
  if (p->len < SIZEOF_ETHARP_PACKET) {
 8008cb0:	2d29      	cmp	r5, #41	; 0x29
 8008cb2:	d90e      	bls.n	8008cd2 <ethernet_input+0xd6>
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 8008cb4:	89f3      	ldrh	r3, [r6, #14]
 8008cb6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008cba:	d015      	beq.n	8008ce8 <ethernet_input+0xec>
    ETHARP_STATS_INC(etharp.proterr);
 8008cbc:	4b43      	ldr	r3, [pc, #268]	; (8008dcc <ethernet_input+0x1d0>)
 8008cbe:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8008cc0:	3201      	adds	r2, #1
 8008cc2:	851a      	strh	r2, [r3, #40]	; 0x28
    ETHARP_STATS_INC(etharp.drop);
 8008cc4:	8bda      	ldrh	r2, [r3, #30]
 8008cc6:	3201      	adds	r2, #1
 8008cc8:	83da      	strh	r2, [r3, #30]
    pbuf_free(p);
 8008cca:	4620      	mov	r0, r4
 8008ccc:	f7fc fcd3 	bl	8005676 <pbuf_free>
 8008cd0:	e7a5      	b.n	8008c1e <ethernet_input+0x22>
    ETHARP_STATS_INC(etharp.lenerr);
 8008cd2:	4b3e      	ldr	r3, [pc, #248]	; (8008dcc <ethernet_input+0x1d0>)
 8008cd4:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 8008cd6:	3201      	adds	r2, #1
 8008cd8:	845a      	strh	r2, [r3, #34]	; 0x22
    ETHARP_STATS_INC(etharp.drop);
 8008cda:	8bda      	ldrh	r2, [r3, #30]
 8008cdc:	3201      	adds	r2, #1
 8008cde:	83da      	strh	r2, [r3, #30]
    pbuf_free(p);
 8008ce0:	4620      	mov	r0, r4
 8008ce2:	f7fc fcc8 	bl	8005676 <pbuf_free>
 8008ce6:	e79a      	b.n	8008c1e <ethernet_input+0x22>
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 8008ce8:	7cb3      	ldrb	r3, [r6, #18]
 8008cea:	2b06      	cmp	r3, #6
 8008cec:	d1e6      	bne.n	8008cbc <ethernet_input+0xc0>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 8008cee:	7cf3      	ldrb	r3, [r6, #19]
 8008cf0:	2b04      	cmp	r3, #4
 8008cf2:	d1e3      	bne.n	8008cbc <ethernet_input+0xc0>
      (hdr->protolen != sizeof(ip_addr_t)) ||
 8008cf4:	8a33      	ldrh	r3, [r6, #16]
 8008cf6:	2b08      	cmp	r3, #8
 8008cf8:	d1e0      	bne.n	8008cbc <ethernet_input+0xc0>
  ETHARP_STATS_INC(etharp.recv);
 8008cfa:	4a34      	ldr	r2, [pc, #208]	; (8008dcc <ethernet_input+0x1d0>)
 8008cfc:	8b53      	ldrh	r3, [r2, #26]
 8008cfe:	3301      	adds	r3, #1
 8008d00:	8353      	strh	r3, [r2, #26]
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 8008d02:	69f3      	ldr	r3, [r6, #28]
 8008d04:	9301      	str	r3, [sp, #4]
  if (ip_addr_isany(&netif->ip_addr)) {
 8008d06:	f117 0f04 	cmn.w	r7, #4
 8008d0a:	d03a      	beq.n	8008d82 <ethernet_input+0x186>
 8008d0c:	687b      	ldr	r3, [r7, #4]
 8008d0e:	b3c3      	cbz	r3, 8008d82 <ethernet_input+0x186>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008d10:	f106 0516 	add.w	r5, r6, #22
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 8008d14:	f8d6 2026 	ldr.w	r2, [r6, #38]	; 0x26
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008d18:	429a      	cmp	r2, r3
 8008d1a:	d148      	bne.n	8008dae <ethernet_input+0x1b2>
 8008d1c:	2301      	movs	r3, #1
 8008d1e:	462a      	mov	r2, r5
 8008d20:	a901      	add	r1, sp, #4
 8008d22:	4638      	mov	r0, r7
 8008d24:	f7ff fd24 	bl	8008770 <etharp_update_arp_entry>
  switch (hdr->opcode) {
 8008d28:	8ab3      	ldrh	r3, [r6, #20]
 8008d2a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008d2e:	d003      	beq.n	8008d38 <ethernet_input+0x13c>
 8008d30:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008d34:	d037      	beq.n	8008da6 <ethernet_input+0x1aa>
 8008d36:	e032      	b.n	8008d9e <ethernet_input+0x1a2>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
 8008d38:	46b8      	mov	r8, r7
      hdr->opcode = htons(ARP_REPLY);
 8008d3a:	2002      	movs	r0, #2
 8008d3c:	f7fb fa20 	bl	8004180 <lwip_htons>
 8008d40:	82b0      	strh	r0, [r6, #20]
      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 8008d42:	69f3      	ldr	r3, [r6, #28]
 8008d44:	f8c6 3026 	str.w	r3, [r6, #38]	; 0x26
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
 8008d48:	687b      	ldr	r3, [r7, #4]
 8008d4a:	61f3      	str	r3, [r6, #28]
      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
 8008d4c:	682b      	ldr	r3, [r5, #0]
 8008d4e:	6233      	str	r3, [r6, #32]
 8008d50:	88ab      	ldrh	r3, [r5, #4]
 8008d52:	84b3      	strh	r3, [r6, #36]	; 0x24
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
 8008d54:	682b      	ldr	r3, [r5, #0]
 8008d56:	6033      	str	r3, [r6, #0]
 8008d58:	88ab      	ldrh	r3, [r5, #4]
 8008d5a:	80b3      	strh	r3, [r6, #4]
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
 8008d5c:	f858 3f23 	ldr.w	r3, [r8, #35]!
 8008d60:	f8c6 3016 	str.w	r3, [r6, #22]
 8008d64:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8008d68:	80ab      	strh	r3, [r5, #4]
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
 8008d6a:	f8d8 3000 	ldr.w	r3, [r8]
 8008d6e:	f8c6 3006 	str.w	r3, [r6, #6]
 8008d72:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8008d76:	8173      	strh	r3, [r6, #10]
      netif->linkoutput(netif, p);
 8008d78:	69bb      	ldr	r3, [r7, #24]
 8008d7a:	4621      	mov	r1, r4
 8008d7c:	4638      	mov	r0, r7
 8008d7e:	4798      	blx	r3
 8008d80:	e011      	b.n	8008da6 <ethernet_input+0x1aa>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008d82:	2302      	movs	r3, #2
 8008d84:	f106 0216 	add.w	r2, r6, #22
 8008d88:	a901      	add	r1, sp, #4
 8008d8a:	4638      	mov	r0, r7
 8008d8c:	f7ff fcf0 	bl	8008770 <etharp_update_arp_entry>
  switch (hdr->opcode) {
 8008d90:	8ab3      	ldrh	r3, [r6, #20]
 8008d92:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008d96:	d006      	beq.n	8008da6 <ethernet_input+0x1aa>
 8008d98:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008d9c:	d003      	beq.n	8008da6 <ethernet_input+0x1aa>
    ETHARP_STATS_INC(etharp.err);
 8008d9e:	4a0b      	ldr	r2, [pc, #44]	; (8008dcc <ethernet_input+0x1d0>)
 8008da0:	8d93      	ldrh	r3, [r2, #44]	; 0x2c
 8008da2:	3301      	adds	r3, #1
 8008da4:	8593      	strh	r3, [r2, #44]	; 0x2c
  pbuf_free(p);
 8008da6:	4620      	mov	r0, r4
 8008da8:	f7fc fc65 	bl	8005676 <pbuf_free>
 8008dac:	e737      	b.n	8008c1e <ethernet_input+0x22>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008dae:	2302      	movs	r3, #2
 8008db0:	462a      	mov	r2, r5
 8008db2:	a901      	add	r1, sp, #4
 8008db4:	4638      	mov	r0, r7
 8008db6:	f7ff fcdb 	bl	8008770 <etharp_update_arp_entry>
  switch (hdr->opcode) {
 8008dba:	8ab3      	ldrh	r3, [r6, #20]
 8008dbc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008dc0:	d0f1      	beq.n	8008da6 <ethernet_input+0x1aa>
 8008dc2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008dc6:	d0ee      	beq.n	8008da6 <ethernet_input+0x1aa>
 8008dc8:	e7e9      	b.n	8008d9e <ethernet_input+0x1a2>
 8008dca:	bf00      	nop
 8008dcc:	2000aac4 	.word	0x2000aac4
 8008dd0:	08009024 	.word	0x08009024

08008dd4 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 8008dd4:	f8df d034 	ldr.w	sp, [pc, #52]	; 8008e0c <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8008dd8:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8008dda:	e003      	b.n	8008de4 <LoopCopyDataInit>

08008ddc <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8008ddc:	4b0c      	ldr	r3, [pc, #48]	; (8008e10 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8008dde:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8008de0:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8008de2:	3104      	adds	r1, #4

08008de4 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8008de4:	480b      	ldr	r0, [pc, #44]	; (8008e14 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8008de6:	4b0c      	ldr	r3, [pc, #48]	; (8008e18 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8008de8:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8008dea:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8008dec:	d3f6      	bcc.n	8008ddc <CopyDataInit>
  ldr  r2, =_sbss
 8008dee:	4a0b      	ldr	r2, [pc, #44]	; (8008e1c <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8008df0:	e002      	b.n	8008df8 <LoopFillZerobss>

08008df2 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8008df2:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8008df4:	f842 3b04 	str.w	r3, [r2], #4

08008df8 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8008df8:	4b09      	ldr	r3, [pc, #36]	; (8008e20 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8008dfa:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8008dfc:	d3f9      	bcc.n	8008df2 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8008dfe:	f7fa fca3 	bl	8003748 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8008e02:	f000 f811 	bl	8008e28 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8008e06:	f7fa fbe5 	bl	80035d4 <main>
  bx  lr    
 8008e0a:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 8008e0c:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8008e10:	08009044 	.word	0x08009044
  ldr  r0, =_sdata
 8008e14:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8008e18:	20000150 	.word	0x20000150
  ldr  r2, =_sbss
 8008e1c:	20000150 	.word	0x20000150
  ldr  r3, = _ebss
 8008e20:	2000ac00 	.word	0x2000ac00

08008e24 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8008e24:	e7fe      	b.n	8008e24 <ADC_IRQHandler>
	...

08008e28 <__libc_init_array>:
 8008e28:	b570      	push	{r4, r5, r6, lr}
 8008e2a:	4e0d      	ldr	r6, [pc, #52]	; (8008e60 <__libc_init_array+0x38>)
 8008e2c:	4c0d      	ldr	r4, [pc, #52]	; (8008e64 <__libc_init_array+0x3c>)
 8008e2e:	1ba4      	subs	r4, r4, r6
 8008e30:	10a4      	asrs	r4, r4, #2
 8008e32:	2500      	movs	r5, #0
 8008e34:	42a5      	cmp	r5, r4
 8008e36:	d109      	bne.n	8008e4c <__libc_init_array+0x24>
 8008e38:	4e0b      	ldr	r6, [pc, #44]	; (8008e68 <__libc_init_array+0x40>)
 8008e3a:	4c0c      	ldr	r4, [pc, #48]	; (8008e6c <__libc_init_array+0x44>)
 8008e3c:	f000 f83a 	bl	8008eb4 <_init>
 8008e40:	1ba4      	subs	r4, r4, r6
 8008e42:	10a4      	asrs	r4, r4, #2
 8008e44:	2500      	movs	r5, #0
 8008e46:	42a5      	cmp	r5, r4
 8008e48:	d105      	bne.n	8008e56 <__libc_init_array+0x2e>
 8008e4a:	bd70      	pop	{r4, r5, r6, pc}
 8008e4c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8008e50:	4798      	blx	r3
 8008e52:	3501      	adds	r5, #1
 8008e54:	e7ee      	b.n	8008e34 <__libc_init_array+0xc>
 8008e56:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8008e5a:	4798      	blx	r3
 8008e5c:	3501      	adds	r5, #1
 8008e5e:	e7f2      	b.n	8008e46 <__libc_init_array+0x1e>
 8008e60:	0800903c 	.word	0x0800903c
 8008e64:	0800903c 	.word	0x0800903c
 8008e68:	0800903c 	.word	0x0800903c
 8008e6c:	08009040 	.word	0x08009040

08008e70 <memcmp>:
 8008e70:	b510      	push	{r4, lr}
 8008e72:	3901      	subs	r1, #1
 8008e74:	4402      	add	r2, r0
 8008e76:	4290      	cmp	r0, r2
 8008e78:	d101      	bne.n	8008e7e <memcmp+0xe>
 8008e7a:	2000      	movs	r0, #0
 8008e7c:	bd10      	pop	{r4, pc}
 8008e7e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8008e82:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8008e86:	42a3      	cmp	r3, r4
 8008e88:	d0f5      	beq.n	8008e76 <memcmp+0x6>
 8008e8a:	1b18      	subs	r0, r3, r4
 8008e8c:	bd10      	pop	{r4, pc}

08008e8e <memcpy>:
 8008e8e:	b510      	push	{r4, lr}
 8008e90:	1e43      	subs	r3, r0, #1
 8008e92:	440a      	add	r2, r1
 8008e94:	4291      	cmp	r1, r2
 8008e96:	d100      	bne.n	8008e9a <memcpy+0xc>
 8008e98:	bd10      	pop	{r4, pc}
 8008e9a:	f811 4b01 	ldrb.w	r4, [r1], #1
 8008e9e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8008ea2:	e7f7      	b.n	8008e94 <memcpy+0x6>

08008ea4 <memset>:
 8008ea4:	4402      	add	r2, r0
 8008ea6:	4603      	mov	r3, r0
 8008ea8:	4293      	cmp	r3, r2
 8008eaa:	d100      	bne.n	8008eae <memset+0xa>
 8008eac:	4770      	bx	lr
 8008eae:	f803 1b01 	strb.w	r1, [r3], #1
 8008eb2:	e7f9      	b.n	8008ea8 <memset+0x4>

08008eb4 <_init>:
 8008eb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008eb6:	bf00      	nop
 8008eb8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8008eba:	bc08      	pop	{r3}
 8008ebc:	469e      	mov	lr, r3
 8008ebe:	4770      	bx	lr

08008ec0 <_fini>:
 8008ec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008ec2:	bf00      	nop
 8008ec4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8008ec6:	bc08      	pop	{r3}
 8008ec8:	469e      	mov	lr, r3
 8008eca:	4770      	bx	lr

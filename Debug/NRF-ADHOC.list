
NRF-ADHOC.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00008d60  08000198  08000198  00010198  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000016c  08008ef8  08008ef8  00018ef8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08009064  08009064  00019064  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  0800906c  0800906c  0001906c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  08009070  08009070  00019070  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000154  20000000  08009074  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000b068  20000158  080091c8  00020158  2**3
                  ALLOC
  8 ._user_heap_stack 00000600  2000b1c0  080091c8  0002b1c0  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00020154  2**0
                  CONTENTS, READONLY
 10 .debug_info   00034f2e  00000000  00000000  00020184  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00006fcc  00000000  00000000  000550b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00010a9f  00000000  00000000  0005c07e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 000012d0  00000000  00000000  0006cb20  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00001500  00000000  00000000  0006ddf0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000bac6  00000000  00000000  0006f2f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000060f3  00000000  00000000  0007adb6  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  00080ea9  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00003348  00000000  00000000  00080f28  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	; (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	; (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	; (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000158 	.word	0x20000158
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08008ee0 	.word	0x08008ee0

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	; (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	; (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	; (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	2000015c 	.word	0x2000015c
 80001d4:	08008ee0 	.word	0x08008ee0

080001d8 <strlen>:
 80001d8:	4603      	mov	r3, r0
 80001da:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001de:	2a00      	cmp	r2, #0
 80001e0:	d1fb      	bne.n	80001da <strlen+0x2>
 80001e2:	1a18      	subs	r0, r3, r0
 80001e4:	3801      	subs	r0, #1
 80001e6:	4770      	bx	lr

080001e8 <__aeabi_ldivmod>:
 80001e8:	b97b      	cbnz	r3, 800020a <__aeabi_ldivmod+0x22>
 80001ea:	b972      	cbnz	r2, 800020a <__aeabi_ldivmod+0x22>
 80001ec:	2900      	cmp	r1, #0
 80001ee:	bfbe      	ittt	lt
 80001f0:	2000      	movlt	r0, #0
 80001f2:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 80001f6:	e006      	blt.n	8000206 <__aeabi_ldivmod+0x1e>
 80001f8:	bf08      	it	eq
 80001fa:	2800      	cmpeq	r0, #0
 80001fc:	bf1c      	itt	ne
 80001fe:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 8000202:	f04f 30ff 	movne.w	r0, #4294967295
 8000206:	f000 b9c5 	b.w	8000594 <__aeabi_idiv0>
 800020a:	f1ad 0c08 	sub.w	ip, sp, #8
 800020e:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000212:	2900      	cmp	r1, #0
 8000214:	db09      	blt.n	800022a <__aeabi_ldivmod+0x42>
 8000216:	2b00      	cmp	r3, #0
 8000218:	db1a      	blt.n	8000250 <__aeabi_ldivmod+0x68>
 800021a:	f000 f84d 	bl	80002b8 <__udivmoddi4>
 800021e:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000222:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000226:	b004      	add	sp, #16
 8000228:	4770      	bx	lr
 800022a:	4240      	negs	r0, r0
 800022c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000230:	2b00      	cmp	r3, #0
 8000232:	db1b      	blt.n	800026c <__aeabi_ldivmod+0x84>
 8000234:	f000 f840 	bl	80002b8 <__udivmoddi4>
 8000238:	f8dd e004 	ldr.w	lr, [sp, #4]
 800023c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000240:	b004      	add	sp, #16
 8000242:	4240      	negs	r0, r0
 8000244:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000248:	4252      	negs	r2, r2
 800024a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800024e:	4770      	bx	lr
 8000250:	4252      	negs	r2, r2
 8000252:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000256:	f000 f82f 	bl	80002b8 <__udivmoddi4>
 800025a:	f8dd e004 	ldr.w	lr, [sp, #4]
 800025e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000262:	b004      	add	sp, #16
 8000264:	4240      	negs	r0, r0
 8000266:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800026a:	4770      	bx	lr
 800026c:	4252      	negs	r2, r2
 800026e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000272:	f000 f821 	bl	80002b8 <__udivmoddi4>
 8000276:	f8dd e004 	ldr.w	lr, [sp, #4]
 800027a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800027e:	b004      	add	sp, #16
 8000280:	4252      	negs	r2, r2
 8000282:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000286:	4770      	bx	lr

08000288 <__aeabi_uldivmod>:
 8000288:	b953      	cbnz	r3, 80002a0 <__aeabi_uldivmod+0x18>
 800028a:	b94a      	cbnz	r2, 80002a0 <__aeabi_uldivmod+0x18>
 800028c:	2900      	cmp	r1, #0
 800028e:	bf08      	it	eq
 8000290:	2800      	cmpeq	r0, #0
 8000292:	bf1c      	itt	ne
 8000294:	f04f 31ff 	movne.w	r1, #4294967295
 8000298:	f04f 30ff 	movne.w	r0, #4294967295
 800029c:	f000 b97a 	b.w	8000594 <__aeabi_idiv0>
 80002a0:	f1ad 0c08 	sub.w	ip, sp, #8
 80002a4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002a8:	f000 f806 	bl	80002b8 <__udivmoddi4>
 80002ac:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002b0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002b4:	b004      	add	sp, #16
 80002b6:	4770      	bx	lr

080002b8 <__udivmoddi4>:
 80002b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002bc:	468c      	mov	ip, r1
 80002be:	460d      	mov	r5, r1
 80002c0:	4604      	mov	r4, r0
 80002c2:	9e08      	ldr	r6, [sp, #32]
 80002c4:	2b00      	cmp	r3, #0
 80002c6:	d151      	bne.n	800036c <__udivmoddi4+0xb4>
 80002c8:	428a      	cmp	r2, r1
 80002ca:	4617      	mov	r7, r2
 80002cc:	d96d      	bls.n	80003aa <__udivmoddi4+0xf2>
 80002ce:	fab2 fe82 	clz	lr, r2
 80002d2:	f1be 0f00 	cmp.w	lr, #0
 80002d6:	d00b      	beq.n	80002f0 <__udivmoddi4+0x38>
 80002d8:	f1ce 0c20 	rsb	ip, lr, #32
 80002dc:	fa01 f50e 	lsl.w	r5, r1, lr
 80002e0:	fa20 fc0c 	lsr.w	ip, r0, ip
 80002e4:	fa02 f70e 	lsl.w	r7, r2, lr
 80002e8:	ea4c 0c05 	orr.w	ip, ip, r5
 80002ec:	fa00 f40e 	lsl.w	r4, r0, lr
 80002f0:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 80002f4:	0c25      	lsrs	r5, r4, #16
 80002f6:	fbbc f8fa 	udiv	r8, ip, sl
 80002fa:	fa1f f987 	uxth.w	r9, r7
 80002fe:	fb0a cc18 	mls	ip, sl, r8, ip
 8000302:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 8000306:	fb08 f309 	mul.w	r3, r8, r9
 800030a:	42ab      	cmp	r3, r5
 800030c:	d90a      	bls.n	8000324 <__udivmoddi4+0x6c>
 800030e:	19ed      	adds	r5, r5, r7
 8000310:	f108 32ff 	add.w	r2, r8, #4294967295
 8000314:	f080 8123 	bcs.w	800055e <__udivmoddi4+0x2a6>
 8000318:	42ab      	cmp	r3, r5
 800031a:	f240 8120 	bls.w	800055e <__udivmoddi4+0x2a6>
 800031e:	f1a8 0802 	sub.w	r8, r8, #2
 8000322:	443d      	add	r5, r7
 8000324:	1aed      	subs	r5, r5, r3
 8000326:	b2a4      	uxth	r4, r4
 8000328:	fbb5 f0fa 	udiv	r0, r5, sl
 800032c:	fb0a 5510 	mls	r5, sl, r0, r5
 8000330:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000334:	fb00 f909 	mul.w	r9, r0, r9
 8000338:	45a1      	cmp	r9, r4
 800033a:	d909      	bls.n	8000350 <__udivmoddi4+0x98>
 800033c:	19e4      	adds	r4, r4, r7
 800033e:	f100 33ff 	add.w	r3, r0, #4294967295
 8000342:	f080 810a 	bcs.w	800055a <__udivmoddi4+0x2a2>
 8000346:	45a1      	cmp	r9, r4
 8000348:	f240 8107 	bls.w	800055a <__udivmoddi4+0x2a2>
 800034c:	3802      	subs	r0, #2
 800034e:	443c      	add	r4, r7
 8000350:	eba4 0409 	sub.w	r4, r4, r9
 8000354:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000358:	2100      	movs	r1, #0
 800035a:	2e00      	cmp	r6, #0
 800035c:	d061      	beq.n	8000422 <__udivmoddi4+0x16a>
 800035e:	fa24 f40e 	lsr.w	r4, r4, lr
 8000362:	2300      	movs	r3, #0
 8000364:	6034      	str	r4, [r6, #0]
 8000366:	6073      	str	r3, [r6, #4]
 8000368:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800036c:	428b      	cmp	r3, r1
 800036e:	d907      	bls.n	8000380 <__udivmoddi4+0xc8>
 8000370:	2e00      	cmp	r6, #0
 8000372:	d054      	beq.n	800041e <__udivmoddi4+0x166>
 8000374:	2100      	movs	r1, #0
 8000376:	e886 0021 	stmia.w	r6, {r0, r5}
 800037a:	4608      	mov	r0, r1
 800037c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000380:	fab3 f183 	clz	r1, r3
 8000384:	2900      	cmp	r1, #0
 8000386:	f040 808e 	bne.w	80004a6 <__udivmoddi4+0x1ee>
 800038a:	42ab      	cmp	r3, r5
 800038c:	d302      	bcc.n	8000394 <__udivmoddi4+0xdc>
 800038e:	4282      	cmp	r2, r0
 8000390:	f200 80fa 	bhi.w	8000588 <__udivmoddi4+0x2d0>
 8000394:	1a84      	subs	r4, r0, r2
 8000396:	eb65 0503 	sbc.w	r5, r5, r3
 800039a:	2001      	movs	r0, #1
 800039c:	46ac      	mov	ip, r5
 800039e:	2e00      	cmp	r6, #0
 80003a0:	d03f      	beq.n	8000422 <__udivmoddi4+0x16a>
 80003a2:	e886 1010 	stmia.w	r6, {r4, ip}
 80003a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003aa:	b912      	cbnz	r2, 80003b2 <__udivmoddi4+0xfa>
 80003ac:	2701      	movs	r7, #1
 80003ae:	fbb7 f7f2 	udiv	r7, r7, r2
 80003b2:	fab7 fe87 	clz	lr, r7
 80003b6:	f1be 0f00 	cmp.w	lr, #0
 80003ba:	d134      	bne.n	8000426 <__udivmoddi4+0x16e>
 80003bc:	1beb      	subs	r3, r5, r7
 80003be:	0c3a      	lsrs	r2, r7, #16
 80003c0:	fa1f fc87 	uxth.w	ip, r7
 80003c4:	2101      	movs	r1, #1
 80003c6:	fbb3 f8f2 	udiv	r8, r3, r2
 80003ca:	0c25      	lsrs	r5, r4, #16
 80003cc:	fb02 3318 	mls	r3, r2, r8, r3
 80003d0:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 80003d4:	fb0c f308 	mul.w	r3, ip, r8
 80003d8:	42ab      	cmp	r3, r5
 80003da:	d907      	bls.n	80003ec <__udivmoddi4+0x134>
 80003dc:	19ed      	adds	r5, r5, r7
 80003de:	f108 30ff 	add.w	r0, r8, #4294967295
 80003e2:	d202      	bcs.n	80003ea <__udivmoddi4+0x132>
 80003e4:	42ab      	cmp	r3, r5
 80003e6:	f200 80d1 	bhi.w	800058c <__udivmoddi4+0x2d4>
 80003ea:	4680      	mov	r8, r0
 80003ec:	1aed      	subs	r5, r5, r3
 80003ee:	b2a3      	uxth	r3, r4
 80003f0:	fbb5 f0f2 	udiv	r0, r5, r2
 80003f4:	fb02 5510 	mls	r5, r2, r0, r5
 80003f8:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 80003fc:	fb0c fc00 	mul.w	ip, ip, r0
 8000400:	45a4      	cmp	ip, r4
 8000402:	d907      	bls.n	8000414 <__udivmoddi4+0x15c>
 8000404:	19e4      	adds	r4, r4, r7
 8000406:	f100 33ff 	add.w	r3, r0, #4294967295
 800040a:	d202      	bcs.n	8000412 <__udivmoddi4+0x15a>
 800040c:	45a4      	cmp	ip, r4
 800040e:	f200 80b8 	bhi.w	8000582 <__udivmoddi4+0x2ca>
 8000412:	4618      	mov	r0, r3
 8000414:	eba4 040c 	sub.w	r4, r4, ip
 8000418:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 800041c:	e79d      	b.n	800035a <__udivmoddi4+0xa2>
 800041e:	4631      	mov	r1, r6
 8000420:	4630      	mov	r0, r6
 8000422:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000426:	f1ce 0420 	rsb	r4, lr, #32
 800042a:	fa05 f30e 	lsl.w	r3, r5, lr
 800042e:	fa07 f70e 	lsl.w	r7, r7, lr
 8000432:	fa20 f804 	lsr.w	r8, r0, r4
 8000436:	0c3a      	lsrs	r2, r7, #16
 8000438:	fa25 f404 	lsr.w	r4, r5, r4
 800043c:	ea48 0803 	orr.w	r8, r8, r3
 8000440:	fbb4 f1f2 	udiv	r1, r4, r2
 8000444:	ea4f 4518 	mov.w	r5, r8, lsr #16
 8000448:	fb02 4411 	mls	r4, r2, r1, r4
 800044c:	fa1f fc87 	uxth.w	ip, r7
 8000450:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 8000454:	fb01 f30c 	mul.w	r3, r1, ip
 8000458:	42ab      	cmp	r3, r5
 800045a:	fa00 f40e 	lsl.w	r4, r0, lr
 800045e:	d909      	bls.n	8000474 <__udivmoddi4+0x1bc>
 8000460:	19ed      	adds	r5, r5, r7
 8000462:	f101 30ff 	add.w	r0, r1, #4294967295
 8000466:	f080 808a 	bcs.w	800057e <__udivmoddi4+0x2c6>
 800046a:	42ab      	cmp	r3, r5
 800046c:	f240 8087 	bls.w	800057e <__udivmoddi4+0x2c6>
 8000470:	3902      	subs	r1, #2
 8000472:	443d      	add	r5, r7
 8000474:	1aeb      	subs	r3, r5, r3
 8000476:	fa1f f588 	uxth.w	r5, r8
 800047a:	fbb3 f0f2 	udiv	r0, r3, r2
 800047e:	fb02 3310 	mls	r3, r2, r0, r3
 8000482:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8000486:	fb00 f30c 	mul.w	r3, r0, ip
 800048a:	42ab      	cmp	r3, r5
 800048c:	d907      	bls.n	800049e <__udivmoddi4+0x1e6>
 800048e:	19ed      	adds	r5, r5, r7
 8000490:	f100 38ff 	add.w	r8, r0, #4294967295
 8000494:	d26f      	bcs.n	8000576 <__udivmoddi4+0x2be>
 8000496:	42ab      	cmp	r3, r5
 8000498:	d96d      	bls.n	8000576 <__udivmoddi4+0x2be>
 800049a:	3802      	subs	r0, #2
 800049c:	443d      	add	r5, r7
 800049e:	1aeb      	subs	r3, r5, r3
 80004a0:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80004a4:	e78f      	b.n	80003c6 <__udivmoddi4+0x10e>
 80004a6:	f1c1 0720 	rsb	r7, r1, #32
 80004aa:	fa22 f807 	lsr.w	r8, r2, r7
 80004ae:	408b      	lsls	r3, r1
 80004b0:	fa05 f401 	lsl.w	r4, r5, r1
 80004b4:	ea48 0303 	orr.w	r3, r8, r3
 80004b8:	fa20 fe07 	lsr.w	lr, r0, r7
 80004bc:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 80004c0:	40fd      	lsrs	r5, r7
 80004c2:	ea4e 0e04 	orr.w	lr, lr, r4
 80004c6:	fbb5 f9fc 	udiv	r9, r5, ip
 80004ca:	ea4f 441e 	mov.w	r4, lr, lsr #16
 80004ce:	fb0c 5519 	mls	r5, ip, r9, r5
 80004d2:	fa1f f883 	uxth.w	r8, r3
 80004d6:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 80004da:	fb09 f408 	mul.w	r4, r9, r8
 80004de:	42ac      	cmp	r4, r5
 80004e0:	fa02 f201 	lsl.w	r2, r2, r1
 80004e4:	fa00 fa01 	lsl.w	sl, r0, r1
 80004e8:	d908      	bls.n	80004fc <__udivmoddi4+0x244>
 80004ea:	18ed      	adds	r5, r5, r3
 80004ec:	f109 30ff 	add.w	r0, r9, #4294967295
 80004f0:	d243      	bcs.n	800057a <__udivmoddi4+0x2c2>
 80004f2:	42ac      	cmp	r4, r5
 80004f4:	d941      	bls.n	800057a <__udivmoddi4+0x2c2>
 80004f6:	f1a9 0902 	sub.w	r9, r9, #2
 80004fa:	441d      	add	r5, r3
 80004fc:	1b2d      	subs	r5, r5, r4
 80004fe:	fa1f fe8e 	uxth.w	lr, lr
 8000502:	fbb5 f0fc 	udiv	r0, r5, ip
 8000506:	fb0c 5510 	mls	r5, ip, r0, r5
 800050a:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 800050e:	fb00 f808 	mul.w	r8, r0, r8
 8000512:	45a0      	cmp	r8, r4
 8000514:	d907      	bls.n	8000526 <__udivmoddi4+0x26e>
 8000516:	18e4      	adds	r4, r4, r3
 8000518:	f100 35ff 	add.w	r5, r0, #4294967295
 800051c:	d229      	bcs.n	8000572 <__udivmoddi4+0x2ba>
 800051e:	45a0      	cmp	r8, r4
 8000520:	d927      	bls.n	8000572 <__udivmoddi4+0x2ba>
 8000522:	3802      	subs	r0, #2
 8000524:	441c      	add	r4, r3
 8000526:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800052a:	eba4 0408 	sub.w	r4, r4, r8
 800052e:	fba0 8902 	umull	r8, r9, r0, r2
 8000532:	454c      	cmp	r4, r9
 8000534:	46c6      	mov	lr, r8
 8000536:	464d      	mov	r5, r9
 8000538:	d315      	bcc.n	8000566 <__udivmoddi4+0x2ae>
 800053a:	d012      	beq.n	8000562 <__udivmoddi4+0x2aa>
 800053c:	b156      	cbz	r6, 8000554 <__udivmoddi4+0x29c>
 800053e:	ebba 030e 	subs.w	r3, sl, lr
 8000542:	eb64 0405 	sbc.w	r4, r4, r5
 8000546:	fa04 f707 	lsl.w	r7, r4, r7
 800054a:	40cb      	lsrs	r3, r1
 800054c:	431f      	orrs	r7, r3
 800054e:	40cc      	lsrs	r4, r1
 8000550:	6037      	str	r7, [r6, #0]
 8000552:	6074      	str	r4, [r6, #4]
 8000554:	2100      	movs	r1, #0
 8000556:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800055a:	4618      	mov	r0, r3
 800055c:	e6f8      	b.n	8000350 <__udivmoddi4+0x98>
 800055e:	4690      	mov	r8, r2
 8000560:	e6e0      	b.n	8000324 <__udivmoddi4+0x6c>
 8000562:	45c2      	cmp	sl, r8
 8000564:	d2ea      	bcs.n	800053c <__udivmoddi4+0x284>
 8000566:	ebb8 0e02 	subs.w	lr, r8, r2
 800056a:	eb69 0503 	sbc.w	r5, r9, r3
 800056e:	3801      	subs	r0, #1
 8000570:	e7e4      	b.n	800053c <__udivmoddi4+0x284>
 8000572:	4628      	mov	r0, r5
 8000574:	e7d7      	b.n	8000526 <__udivmoddi4+0x26e>
 8000576:	4640      	mov	r0, r8
 8000578:	e791      	b.n	800049e <__udivmoddi4+0x1e6>
 800057a:	4681      	mov	r9, r0
 800057c:	e7be      	b.n	80004fc <__udivmoddi4+0x244>
 800057e:	4601      	mov	r1, r0
 8000580:	e778      	b.n	8000474 <__udivmoddi4+0x1bc>
 8000582:	3802      	subs	r0, #2
 8000584:	443c      	add	r4, r7
 8000586:	e745      	b.n	8000414 <__udivmoddi4+0x15c>
 8000588:	4608      	mov	r0, r1
 800058a:	e708      	b.n	800039e <__udivmoddi4+0xe6>
 800058c:	f1a8 0802 	sub.w	r8, r8, #2
 8000590:	443d      	add	r5, r7
 8000592:	e72b      	b.n	80003ec <__udivmoddi4+0x134>

08000594 <__aeabi_idiv0>:
 8000594:	4770      	bx	lr
 8000596:	bf00      	nop

08000598 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000598:	b510      	push	{r4, lr}
 800059a:	4604      	mov	r4, r0
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800059c:	4b0e      	ldr	r3, [pc, #56]	; (80005d8 <HAL_InitTick+0x40>)
 800059e:	7818      	ldrb	r0, [r3, #0]
 80005a0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80005a4:	fbb3 f3f0 	udiv	r3, r3, r0
 80005a8:	4a0c      	ldr	r2, [pc, #48]	; (80005dc <HAL_InitTick+0x44>)
 80005aa:	6810      	ldr	r0, [r2, #0]
 80005ac:	fbb0 f0f3 	udiv	r0, r0, r3
 80005b0:	f000 f8a6 	bl	8000700 <HAL_SYSTICK_Config>
 80005b4:	b968      	cbnz	r0, 80005d2 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80005b6:	2c0f      	cmp	r4, #15
 80005b8:	d901      	bls.n	80005be <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 80005ba:	2001      	movs	r0, #1
  }

  /* Return function status */
  return HAL_OK;
}
 80005bc:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 80005be:	2200      	movs	r2, #0
 80005c0:	4621      	mov	r1, r4
 80005c2:	f04f 30ff 	mov.w	r0, #4294967295
 80005c6:	f000 f85f 	bl	8000688 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 80005ca:	4b05      	ldr	r3, [pc, #20]	; (80005e0 <HAL_InitTick+0x48>)
 80005cc:	601c      	str	r4, [r3, #0]
  return HAL_OK;
 80005ce:	2000      	movs	r0, #0
 80005d0:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80005d2:	2001      	movs	r0, #1
 80005d4:	bd10      	pop	{r4, pc}
 80005d6:	bf00      	nop
 80005d8:	20000000 	.word	0x20000000
 80005dc:	20000100 	.word	0x20000100
 80005e0:	20000004 	.word	0x20000004

080005e4 <HAL_Init>:
{
 80005e4:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80005e6:	4b0b      	ldr	r3, [pc, #44]	; (8000614 <HAL_Init+0x30>)
 80005e8:	681a      	ldr	r2, [r3, #0]
 80005ea:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80005ee:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 80005f0:	681a      	ldr	r2, [r3, #0]
 80005f2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80005f6:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80005f8:	681a      	ldr	r2, [r3, #0]
 80005fa:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80005fe:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000600:	2003      	movs	r0, #3
 8000602:	f000 f82f 	bl	8000664 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8000606:	2000      	movs	r0, #0
 8000608:	f7ff ffc6 	bl	8000598 <HAL_InitTick>
  HAL_MspInit();
 800060c:	f003 f99f 	bl	800394e <HAL_MspInit>
}
 8000610:	2000      	movs	r0, #0
 8000612:	bd08      	pop	{r3, pc}
 8000614:	40023c00 	.word	0x40023c00

08000618 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8000618:	4a03      	ldr	r2, [pc, #12]	; (8000628 <HAL_IncTick+0x10>)
 800061a:	6811      	ldr	r1, [r2, #0]
 800061c:	4b03      	ldr	r3, [pc, #12]	; (800062c <HAL_IncTick+0x14>)
 800061e:	781b      	ldrb	r3, [r3, #0]
 8000620:	440b      	add	r3, r1
 8000622:	6013      	str	r3, [r2, #0]
 8000624:	4770      	bx	lr
 8000626:	bf00      	nop
 8000628:	20007800 	.word	0x20007800
 800062c:	20000000 	.word	0x20000000

08000630 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000630:	4b01      	ldr	r3, [pc, #4]	; (8000638 <HAL_GetTick+0x8>)
 8000632:	6818      	ldr	r0, [r3, #0]
}
 8000634:	4770      	bx	lr
 8000636:	bf00      	nop
 8000638:	20007800 	.word	0x20007800

0800063c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800063c:	b538      	push	{r3, r4, r5, lr}
 800063e:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000640:	f7ff fff6 	bl	8000630 <HAL_GetTick>
 8000644:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000646:	f1b4 3fff 	cmp.w	r4, #4294967295
 800064a:	d002      	beq.n	8000652 <HAL_Delay+0x16>
  {
    wait += (uint32_t)(uwTickFreq);
 800064c:	4b04      	ldr	r3, [pc, #16]	; (8000660 <HAL_Delay+0x24>)
 800064e:	781b      	ldrb	r3, [r3, #0]
 8000650:	441c      	add	r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 8000652:	f7ff ffed 	bl	8000630 <HAL_GetTick>
 8000656:	1b40      	subs	r0, r0, r5
 8000658:	4284      	cmp	r4, r0
 800065a:	d8fa      	bhi.n	8000652 <HAL_Delay+0x16>
  {
  }
}
 800065c:	bd38      	pop	{r3, r4, r5, pc}
 800065e:	bf00      	nop
 8000660:	20000000 	.word	0x20000000

08000664 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000664:	4a07      	ldr	r2, [pc, #28]	; (8000684 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8000666:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000668:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 800066c:	041b      	lsls	r3, r3, #16
 800066e:	0c1b      	lsrs	r3, r3, #16
 8000670:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000674:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8000678:	0200      	lsls	r0, r0, #8
 800067a:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 800067e:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8000680:	60d3      	str	r3, [r2, #12]
 8000682:	4770      	bx	lr
 8000684:	e000ed00 	.word	0xe000ed00

08000688 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000688:	b430      	push	{r4, r5}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800068a:	4b15      	ldr	r3, [pc, #84]	; (80006e0 <HAL_NVIC_SetPriority+0x58>)
 800068c:	68dc      	ldr	r4, [r3, #12]
 800068e:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000692:	f1c4 0307 	rsb	r3, r4, #7
 8000696:	2b04      	cmp	r3, #4
 8000698:	bf28      	it	cs
 800069a:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800069c:	1d25      	adds	r5, r4, #4
 800069e:	2d06      	cmp	r5, #6
 80006a0:	bf8c      	ite	hi
 80006a2:	1ee5      	subhi	r5, r4, #3
 80006a4:	2500      	movls	r5, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80006a6:	2401      	movs	r4, #1
 80006a8:	fa04 f303 	lsl.w	r3, r4, r3
 80006ac:	3b01      	subs	r3, #1
 80006ae:	4019      	ands	r1, r3
 80006b0:	40a9      	lsls	r1, r5
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80006b2:	40ac      	lsls	r4, r5
 80006b4:	3c01      	subs	r4, #1
 80006b6:	4022      	ands	r2, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80006b8:	4311      	orrs	r1, r2
  if ((int32_t)(IRQn) < 0)
 80006ba:	2800      	cmp	r0, #0
 80006bc:	db09      	blt.n	80006d2 <HAL_NVIC_SetPriority+0x4a>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006be:	0109      	lsls	r1, r1, #4
 80006c0:	b2c9      	uxtb	r1, r1
 80006c2:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80006c6:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 80006ca:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80006ce:	bc30      	pop	{r4, r5}
 80006d0:	4770      	bx	lr
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006d2:	f000 000f 	and.w	r0, r0, #15
 80006d6:	0109      	lsls	r1, r1, #4
 80006d8:	b2c9      	uxtb	r1, r1
 80006da:	4b02      	ldr	r3, [pc, #8]	; (80006e4 <HAL_NVIC_SetPriority+0x5c>)
 80006dc:	5419      	strb	r1, [r3, r0]
 80006de:	e7f6      	b.n	80006ce <HAL_NVIC_SetPriority+0x46>
 80006e0:	e000ed00 	.word	0xe000ed00
 80006e4:	e000ed14 	.word	0xe000ed14

080006e8 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80006e8:	0942      	lsrs	r2, r0, #5
 80006ea:	f000 001f 	and.w	r0, r0, #31
 80006ee:	2301      	movs	r3, #1
 80006f0:	fa03 f000 	lsl.w	r0, r3, r0
 80006f4:	4b01      	ldr	r3, [pc, #4]	; (80006fc <HAL_NVIC_EnableIRQ+0x14>)
 80006f6:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 80006fa:	4770      	bx	lr
 80006fc:	e000e100 	.word	0xe000e100

08000700 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000700:	3801      	subs	r0, #1
 8000702:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000706:	d20a      	bcs.n	800071e <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000708:	4b06      	ldr	r3, [pc, #24]	; (8000724 <HAL_SYSTICK_Config+0x24>)
 800070a:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800070c:	21f0      	movs	r1, #240	; 0xf0
 800070e:	4a06      	ldr	r2, [pc, #24]	; (8000728 <HAL_SYSTICK_Config+0x28>)
 8000710:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000714:	2000      	movs	r0, #0
 8000716:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000718:	2207      	movs	r2, #7
 800071a:	601a      	str	r2, [r3, #0]
 800071c:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 800071e:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000720:	4770      	bx	lr
 8000722:	bf00      	nop
 8000724:	e000e010 	.word	0xe000e010
 8000728:	e000ed00 	.word	0xe000ed00

0800072c <HAL_SYSTICK_CLKSourceConfig>:
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 800072c:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 800072e:	4a04      	ldr	r2, [pc, #16]	; (8000740 <HAL_SYSTICK_CLKSourceConfig+0x14>)
 8000730:	6813      	ldr	r3, [r2, #0]
 8000732:	bf0c      	ite	eq
 8000734:	f043 0304 	orreq.w	r3, r3, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000738:	f023 0304 	bicne.w	r3, r3, #4
 800073c:	6013      	str	r3, [r2, #0]
 800073e:	4770      	bx	lr
 8000740:	e000e010 	.word	0xe000e010

08000744 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8000744:	4770      	bx	lr

08000746 <HAL_SYSTICK_IRQHandler>:
{
 8000746:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8000748:	f7ff fffc 	bl	8000744 <HAL_SYSTICK_Callback>
 800074c:	bd08      	pop	{r3, pc}
	...

08000750 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000750:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000754:	b083      	sub	sp, #12
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000756:	2600      	movs	r6, #0
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 8000758:	f04f 0e01 	mov.w	lr, #1
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800075c:	f04f 0903 	mov.w	r9, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000760:	f8df c180 	ldr.w	ip, [pc, #384]	; 80008e4 <HAL_GPIO_Init+0x194>

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000764:	f8df a180 	ldr.w	sl, [pc, #384]	; 80008e8 <HAL_GPIO_Init+0x198>
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000768:	4f5c      	ldr	r7, [pc, #368]	; (80008dc <HAL_GPIO_Init+0x18c>)
 800076a:	e052      	b.n	8000812 <HAL_GPIO_Init+0xc2>
        temp = GPIOx->AFR[position >> 3U];
 800076c:	08f4      	lsrs	r4, r6, #3
 800076e:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8000772:	6a25      	ldr	r5, [r4, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8000774:	f006 0207 	and.w	r2, r6, #7
 8000778:	ea4f 0b82 	mov.w	fp, r2, lsl #2
 800077c:	220f      	movs	r2, #15
 800077e:	fa02 f20b 	lsl.w	r2, r2, fp
 8000782:	ea25 0502 	bic.w	r5, r5, r2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8000786:	690a      	ldr	r2, [r1, #16]
 8000788:	fa02 f20b 	lsl.w	r2, r2, fp
 800078c:	432a      	orrs	r2, r5
        GPIOx->AFR[position >> 3U] = temp;
 800078e:	6222      	str	r2, [r4, #32]
 8000790:	e04b      	b.n	800082a <HAL_GPIO_Init+0xda>
        temp = GPIOx->OSPEEDR; 
 8000792:	6882      	ldr	r2, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8000794:	ea04 0b02 	and.w	fp, r4, r2
        temp |= (GPIO_Init->Speed << (position * 2U));
 8000798:	68ca      	ldr	r2, [r1, #12]
 800079a:	40aa      	lsls	r2, r5
 800079c:	ea42 020b 	orr.w	r2, r2, fp
        GPIOx->OSPEEDR = temp;
 80007a0:	6082      	str	r2, [r0, #8]
        temp = GPIOx->OTYPER;
 80007a2:	6842      	ldr	r2, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80007a4:	ea22 0b03 	bic.w	fp, r2, r3
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80007a8:	684a      	ldr	r2, [r1, #4]
 80007aa:	f3c2 1300 	ubfx	r3, r2, #4, #1
 80007ae:	40b3      	lsls	r3, r6
 80007b0:	ea43 030b 	orr.w	r3, r3, fp
        GPIOx->OTYPER = temp;
 80007b4:	6043      	str	r3, [r0, #4]
 80007b6:	e04c      	b.n	8000852 <HAL_GPIO_Init+0x102>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80007b8:	2200      	movs	r2, #0
 80007ba:	40a2      	lsls	r2, r4
 80007bc:	432a      	orrs	r2, r5
        SYSCFG->EXTICR[position >> 2U] = temp;
 80007be:	609a      	str	r2, [r3, #8]
        temp = EXTI->IMR;
 80007c0:	683b      	ldr	r3, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 80007c2:	ea6f 0408 	mvn.w	r4, r8
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80007c6:	684a      	ldr	r2, [r1, #4]
 80007c8:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 80007cc:	bf0c      	ite	eq
 80007ce:	4023      	andeq	r3, r4
        {
          temp |= iocurrent;
 80007d0:	ea48 0303 	orrne.w	r3, r8, r3
        }
        EXTI->IMR = temp;
 80007d4:	603b      	str	r3, [r7, #0]

        temp = EXTI->EMR;
 80007d6:	687a      	ldr	r2, [r7, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80007d8:	684b      	ldr	r3, [r1, #4]
 80007da:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 80007de:	bf0c      	ite	eq
 80007e0:	4022      	andeq	r2, r4
        {
          temp |= iocurrent;
 80007e2:	ea48 0202 	orrne.w	r2, r8, r2
        }
        EXTI->EMR = temp;
 80007e6:	607a      	str	r2, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 80007e8:	68ba      	ldr	r2, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80007ea:	684b      	ldr	r3, [r1, #4]
 80007ec:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 80007f0:	bf0c      	ite	eq
 80007f2:	4022      	andeq	r2, r4
        {
          temp |= iocurrent;
 80007f4:	ea48 0202 	orrne.w	r2, r8, r2
        }
        EXTI->RTSR = temp;
 80007f8:	60ba      	str	r2, [r7, #8]

        temp = EXTI->FTSR;
 80007fa:	68fb      	ldr	r3, [r7, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80007fc:	684a      	ldr	r2, [r1, #4]
 80007fe:	f412 1f00 	tst.w	r2, #2097152	; 0x200000
        temp &= ~((uint32_t)iocurrent);
 8000802:	bf0c      	ite	eq
 8000804:	4023      	andeq	r3, r4
        {
          temp |= iocurrent;
 8000806:	ea48 0303 	orrne.w	r3, r8, r3
        }
        EXTI->FTSR = temp;
 800080a:	60fb      	str	r3, [r7, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800080c:	3601      	adds	r6, #1
 800080e:	2e10      	cmp	r6, #16
 8000810:	d060      	beq.n	80008d4 <HAL_GPIO_Init+0x184>
    ioposition = 0x01U << position;
 8000812:	fa0e f306 	lsl.w	r3, lr, r6
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000816:	680a      	ldr	r2, [r1, #0]
 8000818:	ea03 0802 	and.w	r8, r3, r2
    if(iocurrent == ioposition)
 800081c:	4543      	cmp	r3, r8
 800081e:	d1f5      	bne.n	800080c <HAL_GPIO_Init+0xbc>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000820:	684a      	ldr	r2, [r1, #4]
 8000822:	f022 0210 	bic.w	r2, r2, #16
 8000826:	2a02      	cmp	r2, #2
 8000828:	d0a0      	beq.n	800076c <HAL_GPIO_Init+0x1c>
      temp = GPIOx->MODER;
 800082a:	6802      	ldr	r2, [r0, #0]
 800082c:	0075      	lsls	r5, r6, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800082e:	fa09 f405 	lsl.w	r4, r9, r5
 8000832:	43e4      	mvns	r4, r4
 8000834:	ea02 0b04 	and.w	fp, r2, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000838:	684a      	ldr	r2, [r1, #4]
 800083a:	f002 0203 	and.w	r2, r2, #3
 800083e:	40aa      	lsls	r2, r5
 8000840:	ea42 020b 	orr.w	r2, r2, fp
      GPIOx->MODER = temp;
 8000844:	6002      	str	r2, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000846:	684a      	ldr	r2, [r1, #4]
 8000848:	f022 0210 	bic.w	r2, r2, #16
 800084c:	3a01      	subs	r2, #1
 800084e:	2a01      	cmp	r2, #1
 8000850:	d99f      	bls.n	8000792 <HAL_GPIO_Init+0x42>
      temp = GPIOx->PUPDR;
 8000852:	68c3      	ldr	r3, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8000854:	401c      	ands	r4, r3
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8000856:	688b      	ldr	r3, [r1, #8]
 8000858:	fa03 f505 	lsl.w	r5, r3, r5
 800085c:	4325      	orrs	r5, r4
      GPIOx->PUPDR = temp;
 800085e:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000860:	684b      	ldr	r3, [r1, #4]
 8000862:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8000866:	d0d1      	beq.n	800080c <HAL_GPIO_Init+0xbc>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000868:	2300      	movs	r3, #0
 800086a:	9301      	str	r3, [sp, #4]
 800086c:	f8dc 3044 	ldr.w	r3, [ip, #68]	; 0x44
 8000870:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000874:	f8cc 3044 	str.w	r3, [ip, #68]	; 0x44
 8000878:	f8dc 3044 	ldr.w	r3, [ip, #68]	; 0x44
 800087c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000880:	9301      	str	r3, [sp, #4]
 8000882:	9b01      	ldr	r3, [sp, #4]
 8000884:	f026 0303 	bic.w	r3, r6, #3
 8000888:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800088c:	f503 339c 	add.w	r3, r3, #79872	; 0x13800
        temp = SYSCFG->EXTICR[position >> 2U];
 8000890:	689d      	ldr	r5, [r3, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8000892:	f006 0203 	and.w	r2, r6, #3
 8000896:	0094      	lsls	r4, r2, #2
 8000898:	220f      	movs	r2, #15
 800089a:	40a2      	lsls	r2, r4
 800089c:	ea25 0502 	bic.w	r5, r5, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80008a0:	4550      	cmp	r0, sl
 80008a2:	d089      	beq.n	80007b8 <HAL_GPIO_Init+0x68>
 80008a4:	4a0e      	ldr	r2, [pc, #56]	; (80008e0 <HAL_GPIO_Init+0x190>)
 80008a6:	4290      	cmp	r0, r2
 80008a8:	d00e      	beq.n	80008c8 <HAL_GPIO_Init+0x178>
 80008aa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80008ae:	4290      	cmp	r0, r2
 80008b0:	d00c      	beq.n	80008cc <HAL_GPIO_Init+0x17c>
 80008b2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80008b6:	4290      	cmp	r0, r2
 80008b8:	d00a      	beq.n	80008d0 <HAL_GPIO_Init+0x180>
 80008ba:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80008be:	4290      	cmp	r0, r2
 80008c0:	bf0c      	ite	eq
 80008c2:	2204      	moveq	r2, #4
 80008c4:	2207      	movne	r2, #7
 80008c6:	e778      	b.n	80007ba <HAL_GPIO_Init+0x6a>
 80008c8:	4672      	mov	r2, lr
 80008ca:	e776      	b.n	80007ba <HAL_GPIO_Init+0x6a>
 80008cc:	2202      	movs	r2, #2
 80008ce:	e774      	b.n	80007ba <HAL_GPIO_Init+0x6a>
 80008d0:	464a      	mov	r2, r9
 80008d2:	e772      	b.n	80007ba <HAL_GPIO_Init+0x6a>
      }
    }
  }
}
 80008d4:	b003      	add	sp, #12
 80008d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80008da:	bf00      	nop
 80008dc:	40013c00 	.word	0x40013c00
 80008e0:	40020400 	.word	0x40020400
 80008e4:	40023800 	.word	0x40023800
 80008e8:	40020000 	.word	0x40020000

080008ec <HAL_PCD_Init>:
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 80008ec:	2800      	cmp	r0, #0
 80008ee:	d065      	beq.n	80009bc <HAL_PCD_Init+0xd0>
{ 
 80008f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80008f2:	b08b      	sub	sp, #44	; 0x2c
 80008f4:	4605      	mov	r5, r0
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 80008f6:	2303      	movs	r3, #3
 80008f8:	f880 33b9 	strb.w	r3, [r0, #953]	; 0x3b9
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);
 80008fc:	f003 f8be 	bl	8003a7c <HAL_PCD_MspInit>

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 8000900:	6828      	ldr	r0, [r5, #0]
 8000902:	f001 f972 	bl	8001bea <USB_DisableGlobalInt>
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 8000906:	462c      	mov	r4, r5
 8000908:	f854 7b10 	ldr.w	r7, [r4], #16
 800090c:	466e      	mov	r6, sp
 800090e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000910:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000912:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000914:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000916:	e894 0003 	ldmia.w	r4, {r0, r1}
 800091a:	e886 0003 	stmia.w	r6, {r0, r1}
 800091e:	1d2b      	adds	r3, r5, #4
 8000920:	cb0e      	ldmia	r3, {r1, r2, r3}
 8000922:	4638      	mov	r0, r7
 8000924:	f001 f91d 	bl	8001b62 <USB_CoreInit>
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8000928:	2100      	movs	r1, #0
 800092a:	6828      	ldr	r0, [r5, #0]
 800092c:	f001 f963 	bl	8001bf6 <USB_SetCurrentMode>
 8000930:	462b      	mov	r3, r5
 8000932:	462a      	mov	r2, r5
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8000934:	2100      	movs	r1, #0
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 8000936:	2001      	movs	r0, #1
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000938:	460c      	mov	r4, r1
   hpcd->IN_ep[i].is_in = 1U;
 800093a:	f882 0039 	strb.w	r0, [r2, #57]	; 0x39
   hpcd->IN_ep[i].num = i;
 800093e:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
   hpcd->IN_ep[i].tx_fifo_num = i;
 8000942:	87d1      	strh	r1, [r2, #62]	; 0x3e
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000944:	f882 403b 	strb.w	r4, [r2, #59]	; 0x3b
   hpcd->IN_ep[i].maxpacket = 0U;
 8000948:	6414      	str	r4, [r2, #64]	; 0x40
   hpcd->IN_ep[i].xfer_buff = 0U;
 800094a:	6454      	str	r4, [r2, #68]	; 0x44
   hpcd->IN_ep[i].xfer_len = 0U;
 800094c:	64d4      	str	r4, [r2, #76]	; 0x4c
 for (i = 0U; i < 15U; i++)
 800094e:	3101      	adds	r1, #1
 8000950:	321c      	adds	r2, #28
 8000952:	290f      	cmp	r1, #15
 8000954:	d1f1      	bne.n	800093a <HAL_PCD_Init+0x4e>
 8000956:	2100      	movs	r1, #0
 }
 
 for (i = 0U; i < 15U; i++)
 {
   hpcd->OUT_ep[i].is_in = 0U;
 8000958:	460a      	mov	r2, r1
 800095a:	f883 21f9 	strb.w	r2, [r3, #505]	; 0x1f9
   hpcd->OUT_ep[i].num = i;
 800095e:	f883 11f8 	strb.w	r1, [r3, #504]	; 0x1f8
   hpcd->IN_ep[i].tx_fifo_num = i;
 8000962:	87d9      	strh	r1, [r3, #62]	; 0x3e
   /* Control until ep is activated */
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8000964:	f883 21fb 	strb.w	r2, [r3, #507]	; 0x1fb
   hpcd->OUT_ep[i].maxpacket = 0U;
 8000968:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
   hpcd->OUT_ep[i].xfer_buff = 0U;
 800096c:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
   hpcd->OUT_ep[i].xfer_len = 0U;
 8000970:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000974:	682c      	ldr	r4, [r5, #0]
 8000976:	f101 0040 	add.w	r0, r1, #64	; 0x40
 800097a:	eb04 0480 	add.w	r4, r4, r0, lsl #2
 800097e:	6062      	str	r2, [r4, #4]
 for (i = 0U; i < 15U; i++)
 8000980:	3101      	adds	r1, #1
 8000982:	331c      	adds	r3, #28
 8000984:	290f      	cmp	r1, #15
 8000986:	d1e8      	bne.n	800095a <HAL_PCD_Init+0x6e>
 }
 
 /* Init Device */
 USB_DevInit(hpcd->Instance, hpcd->Init);
 8000988:	462c      	mov	r4, r5
 800098a:	f854 7b10 	ldr.w	r7, [r4], #16
 800098e:	466e      	mov	r6, sp
 8000990:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000992:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000994:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000996:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8000998:	e894 0003 	ldmia.w	r4, {r0, r1}
 800099c:	e886 0003 	stmia.w	r6, {r0, r1}
 80009a0:	1d2b      	adds	r3, r5, #4
 80009a2:	cb0e      	ldmia	r3, {r1, r2, r3}
 80009a4:	4638      	mov	r0, r7
 80009a6:	f001 f93d 	bl	8001c24 <USB_DevInit>
 
 hpcd->State= HAL_PCD_STATE_READY;
 80009aa:	2301      	movs	r3, #1
 80009ac:	f885 33b9 	strb.w	r3, [r5, #953]	; 0x3b9
 {
   HAL_PCDEx_ActivateBCD(hpcd);
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 80009b0:	6828      	ldr	r0, [r5, #0]
 80009b2:	f001 fd15 	bl	80023e0 <USB_DevDisconnect>
 return HAL_OK;
 80009b6:	2000      	movs	r0, #0
}
 80009b8:	b00b      	add	sp, #44	; 0x2c
 80009ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_ERROR;
 80009bc:	2001      	movs	r0, #1
 80009be:	4770      	bx	lr

080009c0 <HAL_PCD_Start>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 80009c0:	f890 33b8 	ldrb.w	r3, [r0, #952]	; 0x3b8
 80009c4:	2b01      	cmp	r3, #1
 80009c6:	d101      	bne.n	80009cc <HAL_PCD_Start+0xc>
 80009c8:	2002      	movs	r0, #2
 80009ca:	4770      	bx	lr
{ 
 80009cc:	b510      	push	{r4, lr}
 80009ce:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 80009d0:	2301      	movs	r3, #1
 80009d2:	f880 33b8 	strb.w	r3, [r0, #952]	; 0x3b8
  USB_DevConnect (hpcd->Instance);  
 80009d6:	6800      	ldr	r0, [r0, #0]
 80009d8:	f001 fcf6 	bl	80023c8 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 80009dc:	6820      	ldr	r0, [r4, #0]
 80009de:	f001 f8fe 	bl	8001bde <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd); 
 80009e2:	2000      	movs	r0, #0
 80009e4:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 80009e8:	bd10      	pop	{r4, pc}
	...

080009ec <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 80009ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80009f0:	b089      	sub	sp, #36	; 0x24
 80009f2:	4604      	mov	r4, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80009f4:	f8d0 8000 	ldr.w	r8, [r0]
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000U;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 80009f8:	4640      	mov	r0, r8
 80009fa:	f001 fd2d 	bl	8002458 <USB_GetMode>
 80009fe:	b110      	cbz	r0, 8000a06 <HAL_PCD_IRQHandler+0x1a>
        HAL_PCD_DisconnectCallback(hpcd);
      }
      hpcd->Instance->GOTGINT |= temp;
    }
  }
}
 8000a00:	b009      	add	sp, #36	; 0x24
 8000a02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000a06:	4681      	mov	r9, r0
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
 8000a08:	6820      	ldr	r0, [r4, #0]
 8000a0a:	f001 fcf5 	bl	80023f8 <USB_ReadInterrupts>
 8000a0e:	2800      	cmp	r0, #0
 8000a10:	d0f6      	beq.n	8000a00 <HAL_PCD_IRQHandler+0x14>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8000a12:	6820      	ldr	r0, [r4, #0]
 8000a14:	f001 fcf0 	bl	80023f8 <USB_ReadInterrupts>
 8000a18:	f010 0f02 	tst.w	r0, #2
 8000a1c:	d004      	beq.n	8000a28 <HAL_PCD_IRQHandler+0x3c>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8000a1e:	6822      	ldr	r2, [r4, #0]
 8000a20:	6953      	ldr	r3, [r2, #20]
 8000a22:	f003 0302 	and.w	r3, r3, #2
 8000a26:	6153      	str	r3, [r2, #20]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8000a28:	6820      	ldr	r0, [r4, #0]
 8000a2a:	f001 fce5 	bl	80023f8 <USB_ReadInterrupts>
 8000a2e:	f410 2f00 	tst.w	r0, #524288	; 0x80000
 8000a32:	d176      	bne.n	8000b22 <HAL_PCD_IRQHandler+0x136>
  uint32_t i = 0U, ep_intr = 0U, epint = 0U, epnum = 0U;
 8000a34:	46ca      	mov	sl, r9
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8000a36:	6820      	ldr	r0, [r4, #0]
 8000a38:	f001 fcde 	bl	80023f8 <USB_ReadInterrupts>
 8000a3c:	f410 2f80 	tst.w	r0, #262144	; 0x40000
 8000a40:	f040 80ca 	bne.w	8000bd8 <HAL_PCD_IRQHandler+0x1ec>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8000a44:	6820      	ldr	r0, [r4, #0]
 8000a46:	f001 fcd7 	bl	80023f8 <USB_ReadInterrupts>
 8000a4a:	2800      	cmp	r0, #0
 8000a4c:	f2c0 8181 	blt.w	8000d52 <HAL_PCD_IRQHandler+0x366>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 8000a50:	6820      	ldr	r0, [r4, #0]
 8000a52:	f001 fcd1 	bl	80023f8 <USB_ReadInterrupts>
 8000a56:	f410 6f00 	tst.w	r0, #2048	; 0x800
 8000a5a:	d00a      	beq.n	8000a72 <HAL_PCD_IRQHandler+0x86>
      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8000a5c:	f8d8 3808 	ldr.w	r3, [r8, #2056]	; 0x808
 8000a60:	f013 0f01 	tst.w	r3, #1
 8000a64:	f040 8184 	bne.w	8000d70 <HAL_PCD_IRQHandler+0x384>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8000a68:	6822      	ldr	r2, [r4, #0]
 8000a6a:	6953      	ldr	r3, [r2, #20]
 8000a6c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8000a70:	6153      	str	r3, [r2, #20]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8000a72:	6820      	ldr	r0, [r4, #0]
 8000a74:	f001 fcc0 	bl	80023f8 <USB_ReadInterrupts>
 8000a78:	f410 5f80 	tst.w	r0, #4096	; 0x1000
 8000a7c:	f040 817c 	bne.w	8000d78 <HAL_PCD_IRQHandler+0x38c>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8000a80:	6820      	ldr	r0, [r4, #0]
 8000a82:	f001 fcb9 	bl	80023f8 <USB_ReadInterrupts>
 8000a86:	f410 5f00 	tst.w	r0, #8192	; 0x2000
 8000a8a:	f040 81bb 	bne.w	8000e04 <HAL_PCD_IRQHandler+0x418>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8000a8e:	6820      	ldr	r0, [r4, #0]
 8000a90:	f001 fcb2 	bl	80023f8 <USB_ReadInterrupts>
 8000a94:	f010 0f10 	tst.w	r0, #16
 8000a98:	d015      	beq.n	8000ac6 <HAL_PCD_IRQHandler+0xda>
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000a9a:	6822      	ldr	r2, [r4, #0]
 8000a9c:	6993      	ldr	r3, [r2, #24]
 8000a9e:	f023 0310 	bic.w	r3, r3, #16
 8000aa2:	6193      	str	r3, [r2, #24]
      temp = USBx->GRXSTSP;
 8000aa4:	f8d8 5020 	ldr.w	r5, [r8, #32]
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8000aa8:	f005 060f 	and.w	r6, r5, #15
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 8000aac:	f3c5 4343 	ubfx	r3, r5, #17, #4
 8000ab0:	2b02      	cmp	r3, #2
 8000ab2:	f000 8237 	beq.w	8000f24 <HAL_PCD_IRQHandler+0x538>
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_SETUP_UPDT)
 8000ab6:	2b06      	cmp	r3, #6
 8000ab8:	f000 8254 	beq.w	8000f64 <HAL_PCD_IRQHandler+0x578>
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000abc:	6822      	ldr	r2, [r4, #0]
 8000abe:	6993      	ldr	r3, [r2, #24]
 8000ac0:	f043 0310 	orr.w	r3, r3, #16
 8000ac4:	6193      	str	r3, [r2, #24]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8000ac6:	6820      	ldr	r0, [r4, #0]
 8000ac8:	f001 fc96 	bl	80023f8 <USB_ReadInterrupts>
 8000acc:	f010 0f08 	tst.w	r0, #8
 8000ad0:	f040 825a 	bne.w	8000f88 <HAL_PCD_IRQHandler+0x59c>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8000ad4:	6820      	ldr	r0, [r4, #0]
 8000ad6:	f001 fc8f 	bl	80023f8 <USB_ReadInterrupts>
 8000ada:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
 8000ade:	f040 825c 	bne.w	8000f9a <HAL_PCD_IRQHandler+0x5ae>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8000ae2:	6820      	ldr	r0, [r4, #0]
 8000ae4:	f001 fc88 	bl	80023f8 <USB_ReadInterrupts>
 8000ae8:	f410 1f00 	tst.w	r0, #2097152	; 0x200000
 8000aec:	f040 8260 	bne.w	8000fb0 <HAL_PCD_IRQHandler+0x5c4>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8000af0:	6820      	ldr	r0, [r4, #0]
 8000af2:	f001 fc81 	bl	80023f8 <USB_ReadInterrupts>
 8000af6:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 8000afa:	f040 8264 	bne.w	8000fc6 <HAL_PCD_IRQHandler+0x5da>
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8000afe:	6820      	ldr	r0, [r4, #0]
 8000b00:	f001 fc7a 	bl	80023f8 <USB_ReadInterrupts>
 8000b04:	f010 0f04 	tst.w	r0, #4
 8000b08:	f43f af7a 	beq.w	8000a00 <HAL_PCD_IRQHandler+0x14>
      temp = hpcd->Instance->GOTGINT;
 8000b0c:	6823      	ldr	r3, [r4, #0]
 8000b0e:	685d      	ldr	r5, [r3, #4]
      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8000b10:	f015 0f04 	tst.w	r5, #4
 8000b14:	f040 8260 	bne.w	8000fd8 <HAL_PCD_IRQHandler+0x5ec>
      hpcd->Instance->GOTGINT |= temp;
 8000b18:	6823      	ldr	r3, [r4, #0]
 8000b1a:	685a      	ldr	r2, [r3, #4]
 8000b1c:	4315      	orrs	r5, r2
 8000b1e:	605d      	str	r5, [r3, #4]
 8000b20:	e76e      	b.n	8000a00 <HAL_PCD_IRQHandler+0x14>
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8000b22:	6820      	ldr	r0, [r4, #0]
 8000b24:	f001 fc6c 	bl	8002400 <USB_ReadDevAllOutEpInterrupt>
      while ( ep_intr )
 8000b28:	4605      	mov	r5, r0
 8000b2a:	2800      	cmp	r0, #0
 8000b2c:	d052      	beq.n	8000bd4 <HAL_PCD_IRQHandler+0x1e8>
 8000b2e:	f508 6630 	add.w	r6, r8, #2816	; 0xb00
 8000b32:	4627      	mov	r7, r4
 8000b34:	46ca      	mov	sl, r9
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8000b36:	f8cd 8008 	str.w	r8, [sp, #8]
 8000b3a:	e01b      	b.n	8000b74 <HAL_PCD_IRQHandler+0x188>
              hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
 8000b3c:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 8000b40:	6933      	ldr	r3, [r6, #16]
 8000b42:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8000b46:	1ad3      	subs	r3, r2, r3
 8000b48:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
              hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
 8000b4c:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 8000b50:	4413      	add	r3, r2
 8000b52:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
 8000b56:	e01f      	b.n	8000b98 <HAL_PCD_IRQHandler+0x1ac>
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8000b58:	f018 0f08 	tst.w	r8, #8
 8000b5c:	d131      	bne.n	8000bc2 <HAL_PCD_IRQHandler+0x1d6>
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8000b5e:	f018 0f10 	tst.w	r8, #16
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8000b62:	bf1c      	itt	ne
 8000b64:	2310      	movne	r3, #16
 8000b66:	60b3      	strne	r3, [r6, #8]
        epnum++;
 8000b68:	f10a 0a01 	add.w	sl, sl, #1
 8000b6c:	3620      	adds	r6, #32
 8000b6e:	371c      	adds	r7, #28
      while ( ep_intr )
 8000b70:	086d      	lsrs	r5, r5, #1
 8000b72:	d02c      	beq.n	8000bce <HAL_PCD_IRQHandler+0x1e2>
        if (ep_intr & 0x1U)
 8000b74:	f015 0f01 	tst.w	r5, #1
 8000b78:	d0f6      	beq.n	8000b68 <HAL_PCD_IRQHandler+0x17c>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8000b7a:	fa5f fb8a 	uxtb.w	fp, sl
 8000b7e:	4659      	mov	r1, fp
 8000b80:	6820      	ldr	r0, [r4, #0]
 8000b82:	f001 fc4d 	bl	8002420 <USB_ReadDevOutEPInterrupt>
 8000b86:	4680      	mov	r8, r0
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8000b88:	f010 0f01 	tst.w	r0, #1
 8000b8c:	d0e4      	beq.n	8000b58 <HAL_PCD_IRQHandler+0x16c>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8000b8e:	2301      	movs	r3, #1
 8000b90:	60b3      	str	r3, [r6, #8]
            if(hpcd->Init.dma_enable == 1U)
 8000b92:	6923      	ldr	r3, [r4, #16]
 8000b94:	2b01      	cmp	r3, #1
 8000b96:	d0d1      	beq.n	8000b3c <HAL_PCD_IRQHandler+0x150>
            HAL_PCD_DataOutStageCallback(hpcd, epnum);
 8000b98:	4659      	mov	r1, fp
 8000b9a:	4620      	mov	r0, r4
 8000b9c:	f002 ffb4 	bl	8003b08 <HAL_PCD_DataOutStageCallback>
            if(hpcd->Init.dma_enable == 1U)
 8000ba0:	6923      	ldr	r3, [r4, #16]
 8000ba2:	2b01      	cmp	r3, #1
 8000ba4:	d1d8      	bne.n	8000b58 <HAL_PCD_IRQHandler+0x16c>
              if((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8000ba6:	f1ba 0f00 	cmp.w	sl, #0
 8000baa:	d1d5      	bne.n	8000b58 <HAL_PCD_IRQHandler+0x16c>
 8000bac:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
 8000bb0:	2b00      	cmp	r3, #0
 8000bb2:	d1d1      	bne.n	8000b58 <HAL_PCD_IRQHandler+0x16c>
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8000bb4:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 8000bb8:	2101      	movs	r1, #1
 8000bba:	6820      	ldr	r0, [r4, #0]
 8000bbc:	f001 fc6c 	bl	8002498 <USB_EP0_OutStart>
 8000bc0:	e7ca      	b.n	8000b58 <HAL_PCD_IRQHandler+0x16c>
            HAL_PCD_SetupStageCallback(hpcd);
 8000bc2:	4620      	mov	r0, r4
 8000bc4:	f002 ff98 	bl	8003af8 <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8000bc8:	2308      	movs	r3, #8
 8000bca:	60b3      	str	r3, [r6, #8]
 8000bcc:	e7c7      	b.n	8000b5e <HAL_PCD_IRQHandler+0x172>
 8000bce:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8000bd2:	e730      	b.n	8000a36 <HAL_PCD_IRQHandler+0x4a>
      epnum = 0U;
 8000bd4:	4682      	mov	sl, r0
 8000bd6:	e72e      	b.n	8000a36 <HAL_PCD_IRQHandler+0x4a>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8000bd8:	6820      	ldr	r0, [r4, #0]
 8000bda:	f001 fc19 	bl	8002410 <USB_ReadDevAllInEpInterrupt>
      while ( ep_intr )
 8000bde:	4683      	mov	fp, r0
 8000be0:	2800      	cmp	r0, #0
 8000be2:	f000 80b4 	beq.w	8000d4e <HAL_PCD_IRQHandler+0x362>
 8000be6:	f8cd 8014 	str.w	r8, [sp, #20]
 8000bea:	f508 6710 	add.w	r7, r8, #2304	; 0x900
 8000bee:	46ca      	mov	sl, r9
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8000bf0:	f8cd 8018 	str.w	r8, [sp, #24]
 8000bf4:	46a0      	mov	r8, r4
 8000bf6:	f8cd 901c 	str.w	r9, [sp, #28]
 8000bfa:	e026      	b.n	8000c4a <HAL_PCD_IRQHandler+0x25e>
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
 8000bfc:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 8000c00:	f8d8 2040 	ldr.w	r2, [r8, #64]	; 0x40
 8000c04:	4413      	add	r3, r2
 8000c06:	f8c8 3044 	str.w	r3, [r8, #68]	; 0x44
 8000c0a:	e03c      	b.n	8000c86 <HAL_PCD_IRQHandler+0x29a>
           if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8000c0c:	f015 0f08 	tst.w	r5, #8
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8000c10:	bf1c      	itt	ne
 8000c12:	2308      	movne	r3, #8
 8000c14:	60bb      	strne	r3, [r7, #8]
          if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8000c16:	f015 0f10 	tst.w	r5, #16
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8000c1a:	bf1c      	itt	ne
 8000c1c:	2310      	movne	r3, #16
 8000c1e:	60bb      	strne	r3, [r7, #8]
          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8000c20:	f015 0f40 	tst.w	r5, #64	; 0x40
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8000c24:	bf1c      	itt	ne
 8000c26:	2340      	movne	r3, #64	; 0x40
 8000c28:	60bb      	strne	r3, [r7, #8]
          if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8000c2a:	f015 0f02 	tst.w	r5, #2
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8000c2e:	bf1c      	itt	ne
 8000c30:	2302      	movne	r3, #2
 8000c32:	60bb      	strne	r3, [r7, #8]
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8000c34:	f015 0f80 	tst.w	r5, #128	; 0x80
 8000c38:	d139      	bne.n	8000cae <HAL_PCD_IRQHandler+0x2c2>
        epnum++;
 8000c3a:	f10a 0a01 	add.w	sl, sl, #1
 8000c3e:	f108 081c 	add.w	r8, r8, #28
 8000c42:	3720      	adds	r7, #32
      while ( ep_intr )
 8000c44:	ea5f 0b5b 	movs.w	fp, fp, lsr #1
 8000c48:	d07c      	beq.n	8000d44 <HAL_PCD_IRQHandler+0x358>
        if (ep_intr & 0x1U) /* In ITR */
 8000c4a:	f01b 0f01 	tst.w	fp, #1
 8000c4e:	d0f4      	beq.n	8000c3a <HAL_PCD_IRQHandler+0x24e>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 8000c50:	fa5f f38a 	uxtb.w	r3, sl
 8000c54:	9302      	str	r3, [sp, #8]
 8000c56:	4619      	mov	r1, r3
 8000c58:	6820      	ldr	r0, [r4, #0]
 8000c5a:	f001 fbeb 	bl	8002434 <USB_ReadDevInEPInterrupt>
 8000c5e:	4605      	mov	r5, r0
           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8000c60:	f010 0f01 	tst.w	r0, #1
 8000c64:	d0d2      	beq.n	8000c0c <HAL_PCD_IRQHandler+0x220>
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000c66:	9b05      	ldr	r3, [sp, #20]
 8000c68:	f503 6200 	add.w	r2, r3, #2048	; 0x800
 8000c6c:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
            fifoemptymsk = 0x1U << epnum;
 8000c70:	2101      	movs	r1, #1
 8000c72:	fa01 f10a 	lsl.w	r1, r1, sl
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000c76:	ea23 0301 	bic.w	r3, r3, r1
 8000c7a:	6353      	str	r3, [r2, #52]	; 0x34
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8000c7c:	2301      	movs	r3, #1
 8000c7e:	60bb      	str	r3, [r7, #8]
            if (hpcd->Init.dma_enable == 1U)
 8000c80:	6923      	ldr	r3, [r4, #16]
 8000c82:	2b01      	cmp	r3, #1
 8000c84:	d0ba      	beq.n	8000bfc <HAL_PCD_IRQHandler+0x210>
            HAL_PCD_DataInStageCallback(hpcd, epnum);
 8000c86:	9902      	ldr	r1, [sp, #8]
 8000c88:	4620      	mov	r0, r4
 8000c8a:	f002 ff49 	bl	8003b20 <HAL_PCD_DataInStageCallback>
            if (hpcd->Init.dma_enable == 1U)
 8000c8e:	6923      	ldr	r3, [r4, #16]
 8000c90:	2b01      	cmp	r3, #1
 8000c92:	d1bb      	bne.n	8000c0c <HAL_PCD_IRQHandler+0x220>
              if((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8000c94:	f1ba 0f00 	cmp.w	sl, #0
 8000c98:	d1b8      	bne.n	8000c0c <HAL_PCD_IRQHandler+0x220>
 8000c9a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8000c9c:	2b00      	cmp	r3, #0
 8000c9e:	d1b5      	bne.n	8000c0c <HAL_PCD_IRQHandler+0x220>
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8000ca0:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 8000ca4:	2101      	movs	r1, #1
 8000ca6:	6820      	ldr	r0, [r4, #0]
 8000ca8:	f001 fbf6 	bl	8002498 <USB_EP0_OutStart>
 8000cac:	e7ae      	b.n	8000c0c <HAL_PCD_IRQHandler+0x220>
  * @param  epnum  endpoint number   
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 8000cae:	6823      	ldr	r3, [r4, #0]
 8000cb0:	4618      	mov	r0, r3
 8000cb2:	9304      	str	r3, [sp, #16]
 8000cb4:	4646      	mov	r6, r8
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 8000cb6:	f8d8 504c 	ldr.w	r5, [r8, #76]	; 0x4c
 8000cba:	f8d8 2050 	ldr.w	r2, [r8, #80]	; 0x50
 8000cbe:	1aab      	subs	r3, r5, r2
 8000cc0:	f8d8 1040 	ldr.w	r1, [r8, #64]	; 0x40
 8000cc4:	428b      	cmp	r3, r1
 8000cc6:	bf28      	it	cs
 8000cc8:	460b      	movcs	r3, r1
 8000cca:	9303      	str	r3, [sp, #12]
  }
  
  
  len32b = (len + 3U) / 4U;
 
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000ccc:	f500 6910 	add.w	r9, r0, #2304	; 0x900
 8000cd0:	eb09 194a 	add.w	r9, r9, sl, lsl #5
 8000cd4:	f8d9 1018 	ldr.w	r1, [r9, #24]
  len32b = (len + 3U) / 4U;
 8000cd8:	3303      	adds	r3, #3
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000cda:	b289      	uxth	r1, r1
 8000cdc:	ebb1 0f93 	cmp.w	r1, r3, lsr #2
 8000ce0:	d922      	bls.n	8000d28 <HAL_PCD_IRQHandler+0x33c>
 8000ce2:	4295      	cmp	r5, r2
 8000ce4:	d920      	bls.n	8000d28 <HAL_PCD_IRQHandler+0x33c>
          (ep->xfer_count < ep->xfer_len) &&
 8000ce6:	b1fd      	cbz	r5, 8000d28 <HAL_PCD_IRQHandler+0x33c>
            (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 8000ce8:	1aad      	subs	r5, r5, r2
 8000cea:	6c33      	ldr	r3, [r6, #64]	; 0x40
 8000cec:	429d      	cmp	r5, r3
 8000cee:	bf28      	it	cs
 8000cf0:	461d      	movcs	r5, r3
 8000cf2:	9503      	str	r5, [sp, #12]
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 8000cf4:	7c23      	ldrb	r3, [r4, #16]
 8000cf6:	9300      	str	r3, [sp, #0]
 8000cf8:	b2ab      	uxth	r3, r5
 8000cfa:	9a02      	ldr	r2, [sp, #8]
 8000cfc:	6c71      	ldr	r1, [r6, #68]	; 0x44
 8000cfe:	9804      	ldr	r0, [sp, #16]
 8000d00:	f001 fad2 	bl	80022a8 <USB_WritePacket>
    
    ep->xfer_buff  += len;
 8000d04:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8000d06:	442b      	add	r3, r5
 8000d08:	6473      	str	r3, [r6, #68]	; 0x44
    ep->xfer_count += len;
 8000d0a:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8000d0c:	442a      	add	r2, r5
 8000d0e:	6532      	str	r2, [r6, #80]	; 0x50
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000d10:	f8d9 3018 	ldr.w	r3, [r9, #24]
    len32b = (len + 3U) / 4U;
 8000d14:	3503      	adds	r5, #3
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000d16:	b29b      	uxth	r3, r3
 8000d18:	ebb3 0f95 	cmp.w	r3, r5, lsr #2
 8000d1c:	d904      	bls.n	8000d28 <HAL_PCD_IRQHandler+0x33c>
          (ep->xfer_count < ep->xfer_len) &&
 8000d1e:	6cf5      	ldr	r5, [r6, #76]	; 0x4c
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 8000d20:	4295      	cmp	r5, r2
 8000d22:	d901      	bls.n	8000d28 <HAL_PCD_IRQHandler+0x33c>
          (ep->xfer_count < ep->xfer_len) &&
 8000d24:	2d00      	cmp	r5, #0
 8000d26:	d1df      	bne.n	8000ce8 <HAL_PCD_IRQHandler+0x2fc>
  }
  
  if(len <= 0U)
 8000d28:	9b03      	ldr	r3, [sp, #12]
 8000d2a:	2b00      	cmp	r3, #0
 8000d2c:	d185      	bne.n	8000c3a <HAL_PCD_IRQHandler+0x24e>
  {
    fifoemptymsk = 0x1U << epnum;
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000d2e:	9b04      	ldr	r3, [sp, #16]
 8000d30:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
    fifoemptymsk = 0x1U << epnum;
 8000d34:	2101      	movs	r1, #1
 8000d36:	fa01 f10a 	lsl.w	r1, r1, sl
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000d3a:	ea22 0201 	bic.w	r2, r2, r1
 8000d3e:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
 8000d42:	e77a      	b.n	8000c3a <HAL_PCD_IRQHandler+0x24e>
 8000d44:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8000d48:	f8dd 901c 	ldr.w	r9, [sp, #28]
 8000d4c:	e67a      	b.n	8000a44 <HAL_PCD_IRQHandler+0x58>
      epnum = 0U;
 8000d4e:	4682      	mov	sl, r0
 8000d50:	e678      	b.n	8000a44 <HAL_PCD_IRQHandler+0x58>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8000d52:	f8d8 3804 	ldr.w	r3, [r8, #2052]	; 0x804
 8000d56:	f023 0301 	bic.w	r3, r3, #1
 8000d5a:	f8c8 3804 	str.w	r3, [r8, #2052]	; 0x804
        HAL_PCD_ResumeCallback(hpcd);
 8000d5e:	4620      	mov	r0, r4
 8000d60:	f002 ff16 	bl	8003b90 <HAL_PCD_ResumeCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8000d64:	6822      	ldr	r2, [r4, #0]
 8000d66:	6953      	ldr	r3, [r2, #20]
 8000d68:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8000d6c:	6153      	str	r3, [r2, #20]
 8000d6e:	e66f      	b.n	8000a50 <HAL_PCD_IRQHandler+0x64>
        HAL_PCD_SuspendCallback(hpcd);
 8000d70:	4620      	mov	r0, r4
 8000d72:	f002 fef5 	bl	8003b60 <HAL_PCD_SuspendCallback>
 8000d76:	e677      	b.n	8000a68 <HAL_PCD_IRQHandler+0x7c>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 8000d78:	f508 6500 	add.w	r5, r8, #2048	; 0x800
 8000d7c:	686b      	ldr	r3, [r5, #4]
 8000d7e:	f023 0301 	bic.w	r3, r3, #1
 8000d82:	606b      	str	r3, [r5, #4]
      USB_FlushTxFifo(hpcd->Instance , 0x10U);
 8000d84:	2110      	movs	r1, #16
 8000d86:	6820      	ldr	r0, [r4, #0]
 8000d88:	f000 fffa 	bl	8001d80 <USB_FlushTxFifo>
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000d8c:	6863      	ldr	r3, [r4, #4]
 8000d8e:	b15b      	cbz	r3, 8000da8 <HAL_PCD_IRQHandler+0x3bc>
 8000d90:	f508 6310 	add.w	r3, r8, #2304	; 0x900
        USBx_INEP(i)->DIEPINT = 0xFFU;
 8000d94:	22ff      	movs	r2, #255	; 0xff
 8000d96:	609a      	str	r2, [r3, #8]
        USBx_OUTEP(i)->DOEPINT = 0xFFU;
 8000d98:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000d9c:	f109 0901 	add.w	r9, r9, #1
 8000da0:	3320      	adds	r3, #32
 8000da2:	6861      	ldr	r1, [r4, #4]
 8000da4:	4549      	cmp	r1, r9
 8000da6:	d8f6      	bhi.n	8000d96 <HAL_PCD_IRQHandler+0x3aa>
      USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8000da8:	f04f 33ff 	mov.w	r3, #4294967295
 8000dac:	61ab      	str	r3, [r5, #24]
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8000dae:	69eb      	ldr	r3, [r5, #28]
 8000db0:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8000db4:	61eb      	str	r3, [r5, #28]
      if(hpcd->Init.use_dedicated_ep1)
 8000db6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000db8:	b1db      	cbz	r3, 8000df2 <HAL_PCD_IRQHandler+0x406>
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
 8000dba:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 8000dbe:	f043 030b 	orr.w	r3, r3, #11
 8000dc2:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
 8000dc6:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8000dc8:	f043 030b 	orr.w	r3, r3, #11
 8000dcc:	646b      	str	r3, [r5, #68]	; 0x44
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8000dce:	f8d8 3800 	ldr.w	r3, [r8, #2048]	; 0x800
 8000dd2:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8000dd6:	f8c8 3800 	str.w	r3, [r8, #2048]	; 0x800
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8000dda:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 8000dde:	7c21      	ldrb	r1, [r4, #16]
 8000de0:	6820      	ldr	r0, [r4, #0]
 8000de2:	f001 fb59 	bl	8002498 <USB_EP0_OutStart>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8000de6:	6822      	ldr	r2, [r4, #0]
 8000de8:	6953      	ldr	r3, [r2, #20]
 8000dea:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000dee:	6153      	str	r3, [r2, #20]
 8000df0:	e646      	b.n	8000a80 <HAL_PCD_IRQHandler+0x94>
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 8000df2:	696b      	ldr	r3, [r5, #20]
 8000df4:	f043 030b 	orr.w	r3, r3, #11
 8000df8:	616b      	str	r3, [r5, #20]
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 8000dfa:	692b      	ldr	r3, [r5, #16]
 8000dfc:	f043 030b 	orr.w	r3, r3, #11
 8000e00:	612b      	str	r3, [r5, #16]
 8000e02:	e7e4      	b.n	8000dce <HAL_PCD_IRQHandler+0x3e2>
      USB_ActivateSetup(hpcd->Instance);
 8000e04:	6820      	ldr	r0, [r4, #0]
 8000e06:	f001 fb2b 	bl	8002460 <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8000e0a:	6822      	ldr	r2, [r4, #0]
 8000e0c:	68d3      	ldr	r3, [r2, #12]
 8000e0e:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8000e12:	60d3      	str	r3, [r2, #12]
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
 8000e14:	6820      	ldr	r0, [r4, #0]
 8000e16:	f000 ffdc 	bl	8001dd2 <USB_GetDevSpeed>
 8000e1a:	b990      	cbnz	r0, 8000e42 <HAL_PCD_IRQHandler+0x456>
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
 8000e1c:	2300      	movs	r3, #0
 8000e1e:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8000e20:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000e24:	6163      	str	r3, [r4, #20]
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000e26:	6822      	ldr	r2, [r4, #0]
 8000e28:	68d3      	ldr	r3, [r2, #12]
 8000e2a:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 8000e2e:	60d3      	str	r3, [r2, #12]
      HAL_PCD_ResetCallback(hpcd);
 8000e30:	4620      	mov	r0, r4
 8000e32:	f002 fe86 	bl	8003b42 <HAL_PCD_ResetCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8000e36:	6822      	ldr	r2, [r4, #0]
 8000e38:	6953      	ldr	r3, [r2, #20]
 8000e3a:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8000e3e:	6153      	str	r3, [r2, #20]
 8000e40:	e625      	b.n	8000a8e <HAL_PCD_IRQHandler+0xa2>
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 8000e42:	2303      	movs	r3, #3
 8000e44:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8000e46:	2340      	movs	r3, #64	; 0x40
 8000e48:	6163      	str	r3, [r4, #20]
        hclk = HAL_RCC_GetHCLKFreq();
 8000e4a:	f000 fd33 	bl	80018b4 <HAL_RCC_GetHCLKFreq>
        if((hclk >= 14200000U)&&(hclk < 15000000U))
 8000e4e:	4b64      	ldr	r3, [pc, #400]	; (8000fe0 <HAL_PCD_IRQHandler+0x5f4>)
 8000e50:	4403      	add	r3, r0
 8000e52:	4a64      	ldr	r2, [pc, #400]	; (8000fe4 <HAL_PCD_IRQHandler+0x5f8>)
 8000e54:	4293      	cmp	r3, r2
 8000e56:	d805      	bhi.n	8000e64 <HAL_PCD_IRQHandler+0x478>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xFU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000e58:	6822      	ldr	r2, [r4, #0]
 8000e5a:	68d3      	ldr	r3, [r2, #12]
 8000e5c:	f443 5370 	orr.w	r3, r3, #15360	; 0x3c00
 8000e60:	60d3      	str	r3, [r2, #12]
 8000e62:	e7e5      	b.n	8000e30 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 15000000U)&&(hclk < 16000000U))
 8000e64:	4b60      	ldr	r3, [pc, #384]	; (8000fe8 <HAL_PCD_IRQHandler+0x5fc>)
 8000e66:	4403      	add	r3, r0
 8000e68:	4a60      	ldr	r2, [pc, #384]	; (8000fec <HAL_PCD_IRQHandler+0x600>)
 8000e6a:	4293      	cmp	r3, r2
 8000e6c:	d805      	bhi.n	8000e7a <HAL_PCD_IRQHandler+0x48e>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xEU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000e6e:	6822      	ldr	r2, [r4, #0]
 8000e70:	68d3      	ldr	r3, [r2, #12]
 8000e72:	f443 5360 	orr.w	r3, r3, #14336	; 0x3800
 8000e76:	60d3      	str	r3, [r2, #12]
 8000e78:	e7da      	b.n	8000e30 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 16000000U)&&(hclk < 17200000U))
 8000e7a:	f5a0 0374 	sub.w	r3, r0, #15990784	; 0xf40000
 8000e7e:	f5a3 5310 	sub.w	r3, r3, #9216	; 0x2400
 8000e82:	4a5b      	ldr	r2, [pc, #364]	; (8000ff0 <HAL_PCD_IRQHandler+0x604>)
 8000e84:	4293      	cmp	r3, r2
 8000e86:	d805      	bhi.n	8000e94 <HAL_PCD_IRQHandler+0x4a8>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xDU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000e88:	6822      	ldr	r2, [r4, #0]
 8000e8a:	68d3      	ldr	r3, [r2, #12]
 8000e8c:	f443 5350 	orr.w	r3, r3, #13312	; 0x3400
 8000e90:	60d3      	str	r3, [r2, #12]
 8000e92:	e7cd      	b.n	8000e30 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 17200000U)&&(hclk < 18500000U))
 8000e94:	f1a0 7383 	sub.w	r3, r0, #17170432	; 0x1060000
 8000e98:	f5a3 43e7 	sub.w	r3, r3, #29568	; 0x7380
 8000e9c:	4a55      	ldr	r2, [pc, #340]	; (8000ff4 <HAL_PCD_IRQHandler+0x608>)
 8000e9e:	4293      	cmp	r3, r2
 8000ea0:	d805      	bhi.n	8000eae <HAL_PCD_IRQHandler+0x4c2>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xCU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000ea2:	6822      	ldr	r2, [r4, #0]
 8000ea4:	68d3      	ldr	r3, [r2, #12]
 8000ea6:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 8000eaa:	60d3      	str	r3, [r2, #12]
 8000eac:	e7c0      	b.n	8000e30 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 18500000U)&&(hclk < 20000000U))
 8000eae:	4b52      	ldr	r3, [pc, #328]	; (8000ff8 <HAL_PCD_IRQHandler+0x60c>)
 8000eb0:	4403      	add	r3, r0
 8000eb2:	4a52      	ldr	r2, [pc, #328]	; (8000ffc <HAL_PCD_IRQHandler+0x610>)
 8000eb4:	4293      	cmp	r3, r2
 8000eb6:	d805      	bhi.n	8000ec4 <HAL_PCD_IRQHandler+0x4d8>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xBU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000eb8:	6822      	ldr	r2, [r4, #0]
 8000eba:	68d3      	ldr	r3, [r2, #12]
 8000ebc:	f443 5330 	orr.w	r3, r3, #11264	; 0x2c00
 8000ec0:	60d3      	str	r3, [r2, #12]
 8000ec2:	e7b5      	b.n	8000e30 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 20000000U)&&(hclk < 21800000U))
 8000ec4:	4b4e      	ldr	r3, [pc, #312]	; (8001000 <HAL_PCD_IRQHandler+0x614>)
 8000ec6:	4403      	add	r3, r0
 8000ec8:	4a4e      	ldr	r2, [pc, #312]	; (8001004 <HAL_PCD_IRQHandler+0x618>)
 8000eca:	4293      	cmp	r3, r2
 8000ecc:	d805      	bhi.n	8000eda <HAL_PCD_IRQHandler+0x4ee>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xAU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000ece:	6822      	ldr	r2, [r4, #0]
 8000ed0:	68d3      	ldr	r3, [r2, #12]
 8000ed2:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
 8000ed6:	60d3      	str	r3, [r2, #12]
 8000ed8:	e7aa      	b.n	8000e30 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 21800000U)&&(hclk < 24000000U))
 8000eda:	4b4b      	ldr	r3, [pc, #300]	; (8001008 <HAL_PCD_IRQHandler+0x61c>)
 8000edc:	4403      	add	r3, r0
 8000ede:	4a4b      	ldr	r2, [pc, #300]	; (800100c <HAL_PCD_IRQHandler+0x620>)
 8000ee0:	4293      	cmp	r3, r2
 8000ee2:	d805      	bhi.n	8000ef0 <HAL_PCD_IRQHandler+0x504>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x9U << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000ee4:	6822      	ldr	r2, [r4, #0]
 8000ee6:	68d3      	ldr	r3, [r2, #12]
 8000ee8:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 8000eec:	60d3      	str	r3, [r2, #12]
 8000eee:	e79f      	b.n	8000e30 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 24000000U)&&(hclk < 27700000U))
 8000ef0:	f1a0 73b7 	sub.w	r3, r0, #23986176	; 0x16e0000
 8000ef4:	f5a3 5358 	sub.w	r3, r3, #13824	; 0x3600
 8000ef8:	4a45      	ldr	r2, [pc, #276]	; (8001010 <HAL_PCD_IRQHandler+0x624>)
 8000efa:	4293      	cmp	r3, r2
 8000efc:	d805      	bhi.n	8000f0a <HAL_PCD_IRQHandler+0x51e>
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x8U << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000efe:	6822      	ldr	r2, [r4, #0]
 8000f00:	68d3      	ldr	r3, [r2, #12]
 8000f02:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000f06:	60d3      	str	r3, [r2, #12]
 8000f08:	e792      	b.n	8000e30 <HAL_PCD_IRQHandler+0x444>
        else if((hclk >= 27700000U)&&(hclk < 32000000U))
 8000f0a:	4b42      	ldr	r3, [pc, #264]	; (8001014 <HAL_PCD_IRQHandler+0x628>)
 8000f0c:	4403      	add	r3, r0
 8000f0e:	4a42      	ldr	r2, [pc, #264]	; (8001018 <HAL_PCD_IRQHandler+0x62c>)
 8000f10:	4293      	cmp	r3, r2
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x7U << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000f12:	6822      	ldr	r2, [r4, #0]
 8000f14:	68d3      	ldr	r3, [r2, #12]
 8000f16:	bf94      	ite	ls
 8000f18:	f443 53e0 	orrls.w	r3, r3, #7168	; 0x1c00
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x6U << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000f1c:	f443 53c0 	orrhi.w	r3, r3, #6144	; 0x1800
 8000f20:	60d3      	str	r3, [r2, #12]
 8000f22:	e785      	b.n	8000e30 <HAL_PCD_IRQHandler+0x444>
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 8000f24:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8000f28:	421d      	tst	r5, r3
 8000f2a:	f43f adc7 	beq.w	8000abc <HAL_PCD_IRQHandler+0xd0>
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4U);
 8000f2e:	092d      	lsrs	r5, r5, #4
 8000f30:	ea4f 09c6 	mov.w	r9, r6, lsl #3
 8000f34:	eba9 0706 	sub.w	r7, r9, r6
 8000f38:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 8000f3c:	f3c5 020a 	ubfx	r2, r5, #0, #11
 8000f40:	f8d7 1204 	ldr.w	r1, [r7, #516]	; 0x204
 8000f44:	4640      	mov	r0, r8
 8000f46:	f001 f9c5 	bl	80022d4 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8000f4a:	f3c5 050a 	ubfx	r5, r5, #0, #11
 8000f4e:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 8000f52:	442b      	add	r3, r5
 8000f54:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8000f58:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 8000f5c:	441d      	add	r5, r3
 8000f5e:	f8c7 5210 	str.w	r5, [r7, #528]	; 0x210
 8000f62:	e5ab      	b.n	8000abc <HAL_PCD_IRQHandler+0xd0>
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8000f64:	2208      	movs	r2, #8
 8000f66:	f504 716f 	add.w	r1, r4, #956	; 0x3bc
 8000f6a:	4640      	mov	r0, r8
 8000f6c:	f001 f9b2 	bl	80022d4 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8000f70:	00f2      	lsls	r2, r6, #3
 8000f72:	1b91      	subs	r1, r2, r6
 8000f74:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8000f78:	f3c5 130a 	ubfx	r3, r5, #4, #11
 8000f7c:	f8d1 2210 	ldr.w	r2, [r1, #528]	; 0x210
 8000f80:	4413      	add	r3, r2
 8000f82:	f8c1 3210 	str.w	r3, [r1, #528]	; 0x210
 8000f86:	e599      	b.n	8000abc <HAL_PCD_IRQHandler+0xd0>
      HAL_PCD_SOFCallback(hpcd);
 8000f88:	4620      	mov	r0, r4
 8000f8a:	f002 fdd4 	bl	8003b36 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8000f8e:	6822      	ldr	r2, [r4, #0]
 8000f90:	6953      	ldr	r3, [r2, #20]
 8000f92:	f003 0308 	and.w	r3, r3, #8
 8000f96:	6153      	str	r3, [r2, #20]
 8000f98:	e59c      	b.n	8000ad4 <HAL_PCD_IRQHandler+0xe8>
      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
 8000f9a:	fa5f f18a 	uxtb.w	r1, sl
 8000f9e:	4620      	mov	r0, r4
 8000fa0:	f002 fe02 	bl	8003ba8 <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8000fa4:	6822      	ldr	r2, [r4, #0]
 8000fa6:	6953      	ldr	r3, [r2, #20]
 8000fa8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8000fac:	6153      	str	r3, [r2, #20]
 8000fae:	e598      	b.n	8000ae2 <HAL_PCD_IRQHandler+0xf6>
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
 8000fb0:	fa5f f18a 	uxtb.w	r1, sl
 8000fb4:	4620      	mov	r0, r4
 8000fb6:	f002 fdf1 	bl	8003b9c <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8000fba:	6822      	ldr	r2, [r4, #0]
 8000fbc:	6953      	ldr	r3, [r2, #20]
 8000fbe:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8000fc2:	6153      	str	r3, [r2, #20]
 8000fc4:	e594      	b.n	8000af0 <HAL_PCD_IRQHandler+0x104>
      HAL_PCD_ConnectCallback(hpcd);
 8000fc6:	4620      	mov	r0, r4
 8000fc8:	f002 fdf4 	bl	8003bb4 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8000fcc:	6822      	ldr	r2, [r4, #0]
 8000fce:	6953      	ldr	r3, [r2, #20]
 8000fd0:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8000fd4:	6153      	str	r3, [r2, #20]
 8000fd6:	e592      	b.n	8000afe <HAL_PCD_IRQHandler+0x112>
        HAL_PCD_DisconnectCallback(hpcd);
 8000fd8:	4620      	mov	r0, r4
 8000fda:	f002 fdf1 	bl	8003bc0 <HAL_PCD_DisconnectCallback>
 8000fde:	e59b      	b.n	8000b18 <HAL_PCD_IRQHandler+0x12c>
 8000fe0:	ff275340 	.word	0xff275340
 8000fe4:	000c34ff 	.word	0x000c34ff
 8000fe8:	ff1b1e40 	.word	0xff1b1e40
 8000fec:	000f423f 	.word	0x000f423f
 8000ff0:	00124f7f 	.word	0x00124f7f
 8000ff4:	0013d61f 	.word	0x0013d61f
 8000ff8:	fee5b660 	.word	0xfee5b660
 8000ffc:	0016e35f 	.word	0x0016e35f
 8001000:	feced300 	.word	0xfeced300
 8001004:	001b773f 	.word	0x001b773f
 8001008:	feb35bc0 	.word	0xfeb35bc0
 800100c:	002191bf 	.word	0x002191bf
 8001010:	0038751f 	.word	0x0038751f
 8001014:	fe5954e0 	.word	0xfe5954e0
 8001018:	00419cdf 	.word	0x00419cdf

0800101c <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd); 
 800101c:	f890 33b8 	ldrb.w	r3, [r0, #952]	; 0x3b8
 8001020:	2b01      	cmp	r3, #1
 8001022:	d101      	bne.n	8001028 <HAL_PCD_SetAddress+0xc>
 8001024:	2002      	movs	r0, #2
 8001026:	4770      	bx	lr
{
 8001028:	b510      	push	{r4, lr}
 800102a:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 800102c:	2301      	movs	r3, #1
 800102e:	f880 33b8 	strb.w	r3, [r0, #952]	; 0x3b8
  USB_SetDevAddress(hpcd->Instance, address);
 8001032:	6800      	ldr	r0, [r0, #0]
 8001034:	f001 f9b8 	bl	80023a8 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);   
 8001038:	2000      	movs	r0, #0
 800103a:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 800103e:	bd10      	pop	{r4, pc}

08001040 <HAL_PCD_EP_Open>:
{
 8001040:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((ep_addr & 0x80) == 0x80)
 8001042:	f011 0f80 	tst.w	r1, #128	; 0x80
 8001046:	d11d      	bne.n	8001084 <HAL_PCD_EP_Open+0x44>
 8001048:	f001 047f 	and.w	r4, r1, #127	; 0x7f
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 800104c:	00e5      	lsls	r5, r4, #3
 800104e:	1b29      	subs	r1, r5, r4
 8001050:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8001054:	f501 71fc 	add.w	r1, r1, #504	; 0x1f8
  ep->num   = ep_addr & 0x7F;
 8001058:	1b2e      	subs	r6, r5, r4
 800105a:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 800105e:	f886 41f8 	strb.w	r4, [r6, #504]	; 0x1f8
  ep->is_in = (0x80 & ep_addr) != 0;
 8001062:	2700      	movs	r7, #0
 8001064:	f886 71f9 	strb.w	r7, [r6, #505]	; 0x1f9
  ep->maxpacket = ep_mps;
 8001068:	f8c6 2200 	str.w	r2, [r6, #512]	; 0x200
  ep->type = ep_type;
 800106c:	f886 31fb 	strb.w	r3, [r6, #507]	; 0x1fb
  if (ep_type == EP_TYPE_BULK )
 8001070:	2b02      	cmp	r3, #2
    ep->data_pid_start = 0U;
 8001072:	bf04      	itt	eq
 8001074:	2300      	moveq	r3, #0
 8001076:	710b      	strbeq	r3, [r1, #4]
  __HAL_LOCK(hpcd); 
 8001078:	f890 33b8 	ldrb.w	r3, [r0, #952]	; 0x3b8
 800107c:	2b01      	cmp	r3, #1
 800107e:	d115      	bne.n	80010ac <HAL_PCD_EP_Open+0x6c>
 8001080:	2002      	movs	r0, #2
}
 8001082:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001084:	f001 047f 	and.w	r4, r1, #127	; 0x7f
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001088:	00e5      	lsls	r5, r4, #3
 800108a:	1b29      	subs	r1, r5, r4
 800108c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8001090:	3138      	adds	r1, #56	; 0x38
  ep->num   = ep_addr & 0x7F;
 8001092:	1b2e      	subs	r6, r5, r4
 8001094:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8001098:	f886 4038 	strb.w	r4, [r6, #56]	; 0x38
  ep->is_in = (0x80 & ep_addr) != 0;
 800109c:	2701      	movs	r7, #1
 800109e:	f886 7039 	strb.w	r7, [r6, #57]	; 0x39
  ep->maxpacket = ep_mps;
 80010a2:	6432      	str	r2, [r6, #64]	; 0x40
  ep->type = ep_type;
 80010a4:	f886 303b 	strb.w	r3, [r6, #59]	; 0x3b
    ep->tx_fifo_num = ep->num;
 80010a8:	87f4      	strh	r4, [r6, #62]	; 0x3e
 80010aa:	e7e1      	b.n	8001070 <HAL_PCD_EP_Open+0x30>
 80010ac:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 80010ae:	2301      	movs	r3, #1
 80010b0:	f880 33b8 	strb.w	r3, [r0, #952]	; 0x3b8
  USB_ActivateEndpoint(hpcd->Instance , ep);
 80010b4:	6800      	ldr	r0, [r0, #0]
 80010b6:	f000 feab 	bl	8001e10 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 80010ba:	2000      	movs	r0, #0
 80010bc:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return ret;
 80010c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080010c2 <HAL_PCD_EP_Close>:
  if ((ep_addr & 0x80) == 0x80)
 80010c2:	b24a      	sxtb	r2, r1
 80010c4:	2a00      	cmp	r2, #0
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 80010c6:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 80010ca:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80010ce:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80010d2:	bfb4      	ite	lt
 80010d4:	3338      	addlt	r3, #56	; 0x38
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 80010d6:	f503 73fc 	addge.w	r3, r3, #504	; 0x1f8
  ep->num   = ep_addr & 0x7F;
 80010da:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 80010de:	7019      	strb	r1, [r3, #0]
  ep->is_in = (0x80 & ep_addr) != 0;
 80010e0:	0fd2      	lsrs	r2, r2, #31
 80010e2:	705a      	strb	r2, [r3, #1]
  __HAL_LOCK(hpcd); 
 80010e4:	f890 23b8 	ldrb.w	r2, [r0, #952]	; 0x3b8
 80010e8:	2a01      	cmp	r2, #1
 80010ea:	d101      	bne.n	80010f0 <HAL_PCD_EP_Close+0x2e>
 80010ec:	2002      	movs	r0, #2
 80010ee:	4770      	bx	lr
{  
 80010f0:	b510      	push	{r4, lr}
 80010f2:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 80010f4:	2201      	movs	r2, #1
 80010f6:	f880 23b8 	strb.w	r2, [r0, #952]	; 0x3b8
  USB_DeactivateEndpoint(hpcd->Instance , ep);
 80010fa:	4619      	mov	r1, r3
 80010fc:	6800      	ldr	r0, [r0, #0]
 80010fe:	f000 fecd 	bl	8001e9c <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 8001102:	2000      	movs	r0, #0
 8001104:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 8001108:	bd10      	pop	{r4, pc}

0800110a <HAL_PCD_EP_Receive>:
{
 800110a:	b538      	push	{r3, r4, r5, lr}
 800110c:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001110:	00ec      	lsls	r4, r5, #3
 8001112:	1b61      	subs	r1, r4, r5
 8001114:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8001118:	f501 71fc 	add.w	r1, r1, #504	; 0x1f8
  ep->xfer_buff = pBuf;  
 800111c:	1b64      	subs	r4, r4, r5
 800111e:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8001122:	f8c4 2204 	str.w	r2, [r4, #516]	; 0x204
  ep->xfer_len = len;
 8001126:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
  ep->xfer_count = 0U;
 800112a:	2300      	movs	r3, #0
 800112c:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
  ep->is_in = 0U;
 8001130:	f884 31f9 	strb.w	r3, [r4, #505]	; 0x1f9
  ep->num = ep_addr & 0x7F;
 8001134:	f884 51f8 	strb.w	r5, [r4, #504]	; 0x1f8
  if (hpcd->Init.dma_enable == 1U)
 8001138:	6903      	ldr	r3, [r0, #16]
 800113a:	2b01      	cmp	r3, #1
 800113c:	d006      	beq.n	800114c <HAL_PCD_EP_Receive+0x42>
  if ((ep_addr & 0x7F) == 0)
 800113e:	b165      	cbz	r5, 800115a <HAL_PCD_EP_Receive+0x50>
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001140:	b2da      	uxtb	r2, r3
 8001142:	6800      	ldr	r0, [r0, #0]
 8001144:	f000 ff10 	bl	8001f68 <USB_EPStartXfer>
}
 8001148:	2000      	movs	r0, #0
 800114a:	bd38      	pop	{r3, r4, r5, pc}
    ep->dma_addr = (uint32_t)pBuf;  
 800114c:	ebc5 04c5 	rsb	r4, r5, r5, lsl #3
 8001150:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8001154:	f8c4 2208 	str.w	r2, [r4, #520]	; 0x208
 8001158:	e7f1      	b.n	800113e <HAL_PCD_EP_Receive+0x34>
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 800115a:	b2da      	uxtb	r2, r3
 800115c:	6800      	ldr	r0, [r0, #0]
 800115e:	f001 f809 	bl	8002174 <USB_EP0StartXfer>
 8001162:	e7f1      	b.n	8001148 <HAL_PCD_EP_Receive+0x3e>

08001164 <HAL_PCD_EP_GetRxCount>:
  return hpcd->OUT_ep[ep_addr & 0xF].xfer_count;
 8001164:	f001 010f 	and.w	r1, r1, #15
 8001168:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 800116c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
}
 8001170:	f8b1 0210 	ldrh.w	r0, [r1, #528]	; 0x210
 8001174:	4770      	bx	lr

08001176 <HAL_PCD_EP_Transmit>:
{
 8001176:	b538      	push	{r3, r4, r5, lr}
 8001178:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 800117c:	00ec      	lsls	r4, r5, #3
 800117e:	1b61      	subs	r1, r4, r5
 8001180:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8001184:	3138      	adds	r1, #56	; 0x38
  ep->xfer_buff = pBuf;  
 8001186:	1b64      	subs	r4, r4, r5
 8001188:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 800118c:	6462      	str	r2, [r4, #68]	; 0x44
  ep->xfer_len = len;
 800118e:	64e3      	str	r3, [r4, #76]	; 0x4c
  ep->xfer_count = 0U;
 8001190:	2300      	movs	r3, #0
 8001192:	6523      	str	r3, [r4, #80]	; 0x50
  ep->is_in = 1U;
 8001194:	2301      	movs	r3, #1
 8001196:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  ep->num = ep_addr & 0x7F;
 800119a:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
  if (hpcd->Init.dma_enable == 1U)
 800119e:	6903      	ldr	r3, [r0, #16]
 80011a0:	2b01      	cmp	r3, #1
 80011a2:	d006      	beq.n	80011b2 <HAL_PCD_EP_Transmit+0x3c>
  if ((ep_addr & 0x7F) == 0)
 80011a4:	b15d      	cbz	r5, 80011be <HAL_PCD_EP_Transmit+0x48>
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 80011a6:	b2da      	uxtb	r2, r3
 80011a8:	6800      	ldr	r0, [r0, #0]
 80011aa:	f000 fedd 	bl	8001f68 <USB_EPStartXfer>
}
 80011ae:	2000      	movs	r0, #0
 80011b0:	bd38      	pop	{r3, r4, r5, pc}
    ep->dma_addr = (uint32_t)pBuf;  
 80011b2:	ebc5 04c5 	rsb	r4, r5, r5, lsl #3
 80011b6:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 80011ba:	64a2      	str	r2, [r4, #72]	; 0x48
 80011bc:	e7f2      	b.n	80011a4 <HAL_PCD_EP_Transmit+0x2e>
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 80011be:	b2da      	uxtb	r2, r3
 80011c0:	6800      	ldr	r0, [r0, #0]
 80011c2:	f000 ffd7 	bl	8002174 <USB_EP0StartXfer>
 80011c6:	e7f2      	b.n	80011ae <HAL_PCD_EP_Transmit+0x38>

080011c8 <HAL_PCD_EP_SetStall>:
{
 80011c8:	b538      	push	{r3, r4, r5, lr}
  if ((0x80 & ep_addr) == 0x80)
 80011ca:	b24a      	sxtb	r2, r1
 80011cc:	2a00      	cmp	r2, #0
 80011ce:	db12      	blt.n	80011f6 <HAL_PCD_EP_SetStall+0x2e>
    ep = &hpcd->OUT_ep[ep_addr];
 80011d0:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 80011d4:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80011d8:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
  ep->is_stall = 1U;
 80011dc:	2401      	movs	r4, #1
 80011de:	709c      	strb	r4, [r3, #2]
  ep->num   = ep_addr & 0x7F;
 80011e0:	f001 047f 	and.w	r4, r1, #127	; 0x7f
 80011e4:	701c      	strb	r4, [r3, #0]
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 80011e6:	0fd2      	lsrs	r2, r2, #31
 80011e8:	705a      	strb	r2, [r3, #1]
  __HAL_LOCK(hpcd); 
 80011ea:	f890 23b8 	ldrb.w	r2, [r0, #952]	; 0x3b8
 80011ee:	2a01      	cmp	r2, #1
 80011f0:	d109      	bne.n	8001206 <HAL_PCD_EP_SetStall+0x3e>
 80011f2:	2002      	movs	r0, #2
}
 80011f4:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 80011f6:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 80011fa:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80011fe:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8001202:	3338      	adds	r3, #56	; 0x38
 8001204:	e7ea      	b.n	80011dc <HAL_PCD_EP_SetStall+0x14>
 8001206:	4605      	mov	r5, r0
  __HAL_LOCK(hpcd); 
 8001208:	2201      	movs	r2, #1
 800120a:	f880 23b8 	strb.w	r2, [r0, #952]	; 0x3b8
  USB_EPSetStall(hpcd->Instance , ep);
 800120e:	4619      	mov	r1, r3
 8001210:	6800      	ldr	r0, [r0, #0]
 8001212:	f001 f874 	bl	80022fe <USB_EPSetStall>
  if((ep_addr & 0x7F) == 0)
 8001216:	b11c      	cbz	r4, 8001220 <HAL_PCD_EP_SetStall+0x58>
  __HAL_UNLOCK(hpcd); 
 8001218:	2000      	movs	r0, #0
 800121a:	f885 03b8 	strb.w	r0, [r5, #952]	; 0x3b8
  return HAL_OK;
 800121e:	bd38      	pop	{r3, r4, r5, pc}
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8001220:	f505 726f 	add.w	r2, r5, #956	; 0x3bc
 8001224:	7c29      	ldrb	r1, [r5, #16]
 8001226:	6828      	ldr	r0, [r5, #0]
 8001228:	f001 f936 	bl	8002498 <USB_EP0_OutStart>
 800122c:	e7f4      	b.n	8001218 <HAL_PCD_EP_SetStall+0x50>

0800122e <HAL_PCD_EP_ClrStall>:
{
 800122e:	b510      	push	{r4, lr}
  if ((0x80 & ep_addr) == 0x80)
 8001230:	b24a      	sxtb	r2, r1
 8001232:	2a00      	cmp	r2, #0
 8001234:	db12      	blt.n	800125c <HAL_PCD_EP_ClrStall+0x2e>
    ep = &hpcd->OUT_ep[ep_addr];
 8001236:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 800123a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800123e:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
  ep->is_stall = 0U;
 8001242:	2400      	movs	r4, #0
 8001244:	709c      	strb	r4, [r3, #2]
  ep->num   = ep_addr & 0x7F;
 8001246:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 800124a:	7019      	strb	r1, [r3, #0]
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 800124c:	0fd2      	lsrs	r2, r2, #31
 800124e:	705a      	strb	r2, [r3, #1]
  __HAL_LOCK(hpcd); 
 8001250:	f890 23b8 	ldrb.w	r2, [r0, #952]	; 0x3b8
 8001254:	2a01      	cmp	r2, #1
 8001256:	d109      	bne.n	800126c <HAL_PCD_EP_ClrStall+0x3e>
 8001258:	2002      	movs	r0, #2
}
 800125a:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 800125c:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8001260:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8001264:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8001268:	3338      	adds	r3, #56	; 0x38
 800126a:	e7ea      	b.n	8001242 <HAL_PCD_EP_ClrStall+0x14>
 800126c:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 800126e:	2201      	movs	r2, #1
 8001270:	f880 23b8 	strb.w	r2, [r0, #952]	; 0x3b8
  USB_EPClearStall(hpcd->Instance , ep);
 8001274:	4619      	mov	r1, r3
 8001276:	6800      	ldr	r0, [r0, #0]
 8001278:	f001 f869 	bl	800234e <USB_EPClearStall>
  __HAL_UNLOCK(hpcd); 
 800127c:	2000      	movs	r0, #0
 800127e:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 8001282:	bd10      	pop	{r4, pc}

08001284 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8001284:	b430      	push	{r4, r5}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8001286:	6805      	ldr	r5, [r0, #0]
 8001288:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  
  if(fifo == 0)
 800128a:	b1e1      	cbz	r1, 80012c6 <HAL_PCDEx_SetTxFiFo+0x42>
 800128c:	460b      	mov	r3, r1
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
 800128e:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8001290:	eb04 4411 	add.w	r4, r4, r1, lsr #16
    for (i = 0; i < (fifo - 1); i++)
 8001294:	1e59      	subs	r1, r3, #1
 8001296:	2900      	cmp	r1, #0
 8001298:	dd0c      	ble.n	80012b4 <HAL_PCDEx_SetTxFiFo+0x30>
 800129a:	2300      	movs	r3, #0
 800129c:	4618      	mov	r0, r3
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16U);
 800129e:	3340      	adds	r3, #64	; 0x40
 80012a0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80012a4:	685b      	ldr	r3, [r3, #4]
 80012a6:	eb04 4413 	add.w	r4, r4, r3, lsr #16
    for (i = 0; i < (fifo - 1); i++)
 80012aa:	3001      	adds	r0, #1
 80012ac:	b2c0      	uxtb	r0, r0
 80012ae:	4603      	mov	r3, r0
 80012b0:	4288      	cmp	r0, r1
 80012b2:	dbf4      	blt.n	800129e <HAL_PCDEx_SetTxFiFo+0x1a>
    }
    
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1] = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);        
 80012b4:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80012b8:	3140      	adds	r1, #64	; 0x40
 80012ba:	eb05 0581 	add.w	r5, r5, r1, lsl #2
 80012be:	606c      	str	r4, [r5, #4]
  }
  
  return HAL_OK;
}
 80012c0:	2000      	movs	r0, #0
 80012c2:	bc30      	pop	{r4, r5}
 80012c4:	4770      	bx	lr
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
 80012c6:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80012ca:	62ac      	str	r4, [r5, #40]	; 0x28
 80012cc:	e7f8      	b.n	80012c0 <HAL_PCDEx_SetTxFiFo+0x3c>

080012ce <HAL_PCDEx_SetRxFiFo>:
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 80012ce:	6803      	ldr	r3, [r0, #0]
 80012d0:	6259      	str	r1, [r3, #36]	; 0x24
  
  return HAL_OK;
}
 80012d2:	2000      	movs	r0, #0
 80012d4:	4770      	bx	lr
	...

080012d8 <HAL_RCC_OscConfig>:
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80012d8:	2800      	cmp	r0, #0
 80012da:	f000 81bd 	beq.w	8001658 <HAL_RCC_OscConfig+0x380>
{
 80012de:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80012e2:	b082      	sub	sp, #8
 80012e4:	4604      	mov	r4, r0
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80012e6:	6803      	ldr	r3, [r0, #0]
 80012e8:	f013 0f01 	tst.w	r3, #1
 80012ec:	d03b      	beq.n	8001366 <HAL_RCC_OscConfig+0x8e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 80012ee:	4ba8      	ldr	r3, [pc, #672]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 80012f0:	689b      	ldr	r3, [r3, #8]
 80012f2:	f003 030c 	and.w	r3, r3, #12
 80012f6:	2b04      	cmp	r3, #4
 80012f8:	d02c      	beq.n	8001354 <HAL_RCC_OscConfig+0x7c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80012fa:	4ba5      	ldr	r3, [pc, #660]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 80012fc:	689b      	ldr	r3, [r3, #8]
 80012fe:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8001302:	2b08      	cmp	r3, #8
 8001304:	d021      	beq.n	800134a <HAL_RCC_OscConfig+0x72>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001306:	6863      	ldr	r3, [r4, #4]
 8001308:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800130c:	d04f      	beq.n	80013ae <HAL_RCC_OscConfig+0xd6>
 800130e:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8001312:	d052      	beq.n	80013ba <HAL_RCC_OscConfig+0xe2>
 8001314:	4b9e      	ldr	r3, [pc, #632]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 8001316:	681a      	ldr	r2, [r3, #0]
 8001318:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800131c:	601a      	str	r2, [r3, #0]
 800131e:	681a      	ldr	r2, [r3, #0]
 8001320:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001324:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8001326:	6863      	ldr	r3, [r4, #4]
 8001328:	2b00      	cmp	r3, #0
 800132a:	d050      	beq.n	80013ce <HAL_RCC_OscConfig+0xf6>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800132c:	f7ff f980 	bl	8000630 <HAL_GetTick>
 8001330:	4606      	mov	r6, r0

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001332:	4d97      	ldr	r5, [pc, #604]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 8001334:	682b      	ldr	r3, [r5, #0]
 8001336:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800133a:	d114      	bne.n	8001366 <HAL_RCC_OscConfig+0x8e>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800133c:	f7ff f978 	bl	8000630 <HAL_GetTick>
 8001340:	1b80      	subs	r0, r0, r6
 8001342:	2864      	cmp	r0, #100	; 0x64
 8001344:	d9f6      	bls.n	8001334 <HAL_RCC_OscConfig+0x5c>
          {
            return HAL_TIMEOUT;
 8001346:	2003      	movs	r0, #3
 8001348:	e18b      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800134a:	4b91      	ldr	r3, [pc, #580]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 800134c:	685b      	ldr	r3, [r3, #4]
 800134e:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8001352:	d0d8      	beq.n	8001306 <HAL_RCC_OscConfig+0x2e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001354:	4b8e      	ldr	r3, [pc, #568]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 8001356:	681b      	ldr	r3, [r3, #0]
 8001358:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800135c:	d003      	beq.n	8001366 <HAL_RCC_OscConfig+0x8e>
 800135e:	6863      	ldr	r3, [r4, #4]
 8001360:	2b00      	cmp	r3, #0
 8001362:	f000 817b 	beq.w	800165c <HAL_RCC_OscConfig+0x384>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001366:	6823      	ldr	r3, [r4, #0]
 8001368:	f013 0f02 	tst.w	r3, #2
 800136c:	d055      	beq.n	800141a <HAL_RCC_OscConfig+0x142>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800136e:	4b88      	ldr	r3, [pc, #544]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 8001370:	689b      	ldr	r3, [r3, #8]
 8001372:	f013 0f0c 	tst.w	r3, #12
 8001376:	d03e      	beq.n	80013f6 <HAL_RCC_OscConfig+0x11e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001378:	4b85      	ldr	r3, [pc, #532]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 800137a:	689b      	ldr	r3, [r3, #8]
 800137c:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8001380:	2b08      	cmp	r3, #8
 8001382:	d033      	beq.n	80013ec <HAL_RCC_OscConfig+0x114>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8001384:	68e3      	ldr	r3, [r4, #12]
 8001386:	2b00      	cmp	r3, #0
 8001388:	d068      	beq.n	800145c <HAL_RCC_OscConfig+0x184>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800138a:	2201      	movs	r2, #1
 800138c:	4b81      	ldr	r3, [pc, #516]	; (8001594 <HAL_RCC_OscConfig+0x2bc>)
 800138e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001390:	f7ff f94e 	bl	8000630 <HAL_GetTick>
 8001394:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001396:	4d7e      	ldr	r5, [pc, #504]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 8001398:	682b      	ldr	r3, [r5, #0]
 800139a:	f013 0f02 	tst.w	r3, #2
 800139e:	d154      	bne.n	800144a <HAL_RCC_OscConfig+0x172>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80013a0:	f7ff f946 	bl	8000630 <HAL_GetTick>
 80013a4:	1b80      	subs	r0, r0, r6
 80013a6:	2802      	cmp	r0, #2
 80013a8:	d9f6      	bls.n	8001398 <HAL_RCC_OscConfig+0xc0>
          {
            return HAL_TIMEOUT;
 80013aa:	2003      	movs	r0, #3
 80013ac:	e159      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80013ae:	4a78      	ldr	r2, [pc, #480]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 80013b0:	6813      	ldr	r3, [r2, #0]
 80013b2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80013b6:	6013      	str	r3, [r2, #0]
 80013b8:	e7b5      	b.n	8001326 <HAL_RCC_OscConfig+0x4e>
 80013ba:	4b75      	ldr	r3, [pc, #468]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 80013bc:	681a      	ldr	r2, [r3, #0]
 80013be:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80013c2:	601a      	str	r2, [r3, #0]
 80013c4:	681a      	ldr	r2, [r3, #0]
 80013c6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80013ca:	601a      	str	r2, [r3, #0]
 80013cc:	e7ab      	b.n	8001326 <HAL_RCC_OscConfig+0x4e>
        tickstart = HAL_GetTick();
 80013ce:	f7ff f92f 	bl	8000630 <HAL_GetTick>
 80013d2:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80013d4:	4d6e      	ldr	r5, [pc, #440]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 80013d6:	682b      	ldr	r3, [r5, #0]
 80013d8:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80013dc:	d0c3      	beq.n	8001366 <HAL_RCC_OscConfig+0x8e>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80013de:	f7ff f927 	bl	8000630 <HAL_GetTick>
 80013e2:	1b80      	subs	r0, r0, r6
 80013e4:	2864      	cmp	r0, #100	; 0x64
 80013e6:	d9f6      	bls.n	80013d6 <HAL_RCC_OscConfig+0xfe>
            return HAL_TIMEOUT;
 80013e8:	2003      	movs	r0, #3
 80013ea:	e13a      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80013ec:	4b68      	ldr	r3, [pc, #416]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 80013ee:	685b      	ldr	r3, [r3, #4]
 80013f0:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80013f4:	d1c6      	bne.n	8001384 <HAL_RCC_OscConfig+0xac>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80013f6:	4b66      	ldr	r3, [pc, #408]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 80013f8:	681b      	ldr	r3, [r3, #0]
 80013fa:	f013 0f02 	tst.w	r3, #2
 80013fe:	d004      	beq.n	800140a <HAL_RCC_OscConfig+0x132>
 8001400:	68e3      	ldr	r3, [r4, #12]
 8001402:	2b01      	cmp	r3, #1
 8001404:	d001      	beq.n	800140a <HAL_RCC_OscConfig+0x132>
        return HAL_ERROR;
 8001406:	2001      	movs	r0, #1
 8001408:	e12b      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800140a:	4a61      	ldr	r2, [pc, #388]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 800140c:	6813      	ldr	r3, [r2, #0]
 800140e:	6921      	ldr	r1, [r4, #16]
 8001410:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001414:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001418:	6013      	str	r3, [r2, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800141a:	6823      	ldr	r3, [r4, #0]
 800141c:	f013 0f08 	tst.w	r3, #8
 8001420:	d040      	beq.n	80014a4 <HAL_RCC_OscConfig+0x1cc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8001422:	6963      	ldr	r3, [r4, #20]
 8001424:	b363      	cbz	r3, 8001480 <HAL_RCC_OscConfig+0x1a8>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001426:	2201      	movs	r2, #1
 8001428:	4b5b      	ldr	r3, [pc, #364]	; (8001598 <HAL_RCC_OscConfig+0x2c0>)
 800142a:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800142c:	f7ff f900 	bl	8000630 <HAL_GetTick>
 8001430:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001432:	4d57      	ldr	r5, [pc, #348]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 8001434:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001436:	f013 0f02 	tst.w	r3, #2
 800143a:	d133      	bne.n	80014a4 <HAL_RCC_OscConfig+0x1cc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800143c:	f7ff f8f8 	bl	8000630 <HAL_GetTick>
 8001440:	1b80      	subs	r0, r0, r6
 8001442:	2802      	cmp	r0, #2
 8001444:	d9f6      	bls.n	8001434 <HAL_RCC_OscConfig+0x15c>
        {
          return HAL_TIMEOUT;
 8001446:	2003      	movs	r0, #3
 8001448:	e10b      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800144a:	4a51      	ldr	r2, [pc, #324]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 800144c:	6813      	ldr	r3, [r2, #0]
 800144e:	6921      	ldr	r1, [r4, #16]
 8001450:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001454:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001458:	6013      	str	r3, [r2, #0]
 800145a:	e7de      	b.n	800141a <HAL_RCC_OscConfig+0x142>
        __HAL_RCC_HSI_DISABLE();
 800145c:	2200      	movs	r2, #0
 800145e:	4b4d      	ldr	r3, [pc, #308]	; (8001594 <HAL_RCC_OscConfig+0x2bc>)
 8001460:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001462:	f7ff f8e5 	bl	8000630 <HAL_GetTick>
 8001466:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001468:	4d49      	ldr	r5, [pc, #292]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 800146a:	682b      	ldr	r3, [r5, #0]
 800146c:	f013 0f02 	tst.w	r3, #2
 8001470:	d0d3      	beq.n	800141a <HAL_RCC_OscConfig+0x142>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001472:	f7ff f8dd 	bl	8000630 <HAL_GetTick>
 8001476:	1b80      	subs	r0, r0, r6
 8001478:	2802      	cmp	r0, #2
 800147a:	d9f6      	bls.n	800146a <HAL_RCC_OscConfig+0x192>
            return HAL_TIMEOUT;
 800147c:	2003      	movs	r0, #3
 800147e:	e0f0      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001480:	2200      	movs	r2, #0
 8001482:	4b45      	ldr	r3, [pc, #276]	; (8001598 <HAL_RCC_OscConfig+0x2c0>)
 8001484:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8001486:	f7ff f8d3 	bl	8000630 <HAL_GetTick>
 800148a:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800148c:	4d40      	ldr	r5, [pc, #256]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 800148e:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001490:	f013 0f02 	tst.w	r3, #2
 8001494:	d006      	beq.n	80014a4 <HAL_RCC_OscConfig+0x1cc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001496:	f7ff f8cb 	bl	8000630 <HAL_GetTick>
 800149a:	1b80      	subs	r0, r0, r6
 800149c:	2802      	cmp	r0, #2
 800149e:	d9f6      	bls.n	800148e <HAL_RCC_OscConfig+0x1b6>
        {
          return HAL_TIMEOUT;
 80014a0:	2003      	movs	r0, #3
 80014a2:	e0de      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80014a4:	6823      	ldr	r3, [r4, #0]
 80014a6:	f013 0f04 	tst.w	r3, #4
 80014aa:	d07a      	beq.n	80015a2 <HAL_RCC_OscConfig+0x2ca>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80014ac:	4b38      	ldr	r3, [pc, #224]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 80014ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80014b0:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 80014b4:	d134      	bne.n	8001520 <HAL_RCC_OscConfig+0x248>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80014b6:	2300      	movs	r3, #0
 80014b8:	9301      	str	r3, [sp, #4]
 80014ba:	4b35      	ldr	r3, [pc, #212]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 80014bc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80014be:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80014c2:	641a      	str	r2, [r3, #64]	; 0x40
 80014c4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80014c6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80014ca:	9301      	str	r3, [sp, #4]
 80014cc:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80014ce:	2501      	movs	r5, #1
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80014d0:	4b32      	ldr	r3, [pc, #200]	; (800159c <HAL_RCC_OscConfig+0x2c4>)
 80014d2:	681b      	ldr	r3, [r3, #0]
 80014d4:	f413 7f80 	tst.w	r3, #256	; 0x100
 80014d8:	d024      	beq.n	8001524 <HAL_RCC_OscConfig+0x24c>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80014da:	68a3      	ldr	r3, [r4, #8]
 80014dc:	2b01      	cmp	r3, #1
 80014de:	d035      	beq.n	800154c <HAL_RCC_OscConfig+0x274>
 80014e0:	2b05      	cmp	r3, #5
 80014e2:	d039      	beq.n	8001558 <HAL_RCC_OscConfig+0x280>
 80014e4:	4b2a      	ldr	r3, [pc, #168]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 80014e6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80014e8:	f022 0201 	bic.w	r2, r2, #1
 80014ec:	671a      	str	r2, [r3, #112]	; 0x70
 80014ee:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80014f0:	f022 0204 	bic.w	r2, r2, #4
 80014f4:	671a      	str	r2, [r3, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80014f6:	68a3      	ldr	r3, [r4, #8]
 80014f8:	2b00      	cmp	r3, #0
 80014fa:	d037      	beq.n	800156c <HAL_RCC_OscConfig+0x294>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80014fc:	f7ff f898 	bl	8000630 <HAL_GetTick>
 8001500:	4680      	mov	r8, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001502:	4e23      	ldr	r6, [pc, #140]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001504:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001508:	6f33      	ldr	r3, [r6, #112]	; 0x70
 800150a:	f013 0f02 	tst.w	r3, #2
 800150e:	d147      	bne.n	80015a0 <HAL_RCC_OscConfig+0x2c8>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001510:	f7ff f88e 	bl	8000630 <HAL_GetTick>
 8001514:	eba0 0008 	sub.w	r0, r0, r8
 8001518:	42b8      	cmp	r0, r7
 800151a:	d9f5      	bls.n	8001508 <HAL_RCC_OscConfig+0x230>
        {
          return HAL_TIMEOUT;
 800151c:	2003      	movs	r0, #3
 800151e:	e0a0      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
    FlagStatus       pwrclkchanged = RESET;
 8001520:	2500      	movs	r5, #0
 8001522:	e7d5      	b.n	80014d0 <HAL_RCC_OscConfig+0x1f8>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8001524:	4a1d      	ldr	r2, [pc, #116]	; (800159c <HAL_RCC_OscConfig+0x2c4>)
 8001526:	6813      	ldr	r3, [r2, #0]
 8001528:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800152c:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 800152e:	f7ff f87f 	bl	8000630 <HAL_GetTick>
 8001532:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001534:	4e19      	ldr	r6, [pc, #100]	; (800159c <HAL_RCC_OscConfig+0x2c4>)
 8001536:	6833      	ldr	r3, [r6, #0]
 8001538:	f413 7f80 	tst.w	r3, #256	; 0x100
 800153c:	d1cd      	bne.n	80014da <HAL_RCC_OscConfig+0x202>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800153e:	f7ff f877 	bl	8000630 <HAL_GetTick>
 8001542:	1bc0      	subs	r0, r0, r7
 8001544:	2802      	cmp	r0, #2
 8001546:	d9f6      	bls.n	8001536 <HAL_RCC_OscConfig+0x25e>
          return HAL_TIMEOUT;
 8001548:	2003      	movs	r0, #3
 800154a:	e08a      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800154c:	4a10      	ldr	r2, [pc, #64]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 800154e:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8001550:	f043 0301 	orr.w	r3, r3, #1
 8001554:	6713      	str	r3, [r2, #112]	; 0x70
 8001556:	e7ce      	b.n	80014f6 <HAL_RCC_OscConfig+0x21e>
 8001558:	4b0d      	ldr	r3, [pc, #52]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
 800155a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800155c:	f042 0204 	orr.w	r2, r2, #4
 8001560:	671a      	str	r2, [r3, #112]	; 0x70
 8001562:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001564:	f042 0201 	orr.w	r2, r2, #1
 8001568:	671a      	str	r2, [r3, #112]	; 0x70
 800156a:	e7c4      	b.n	80014f6 <HAL_RCC_OscConfig+0x21e>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800156c:	f7ff f860 	bl	8000630 <HAL_GetTick>
 8001570:	4680      	mov	r8, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001572:	4e07      	ldr	r6, [pc, #28]	; (8001590 <HAL_RCC_OscConfig+0x2b8>)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001574:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001578:	6f33      	ldr	r3, [r6, #112]	; 0x70
 800157a:	f013 0f02 	tst.w	r3, #2
 800157e:	d00f      	beq.n	80015a0 <HAL_RCC_OscConfig+0x2c8>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001580:	f7ff f856 	bl	8000630 <HAL_GetTick>
 8001584:	eba0 0008 	sub.w	r0, r0, r8
 8001588:	42b8      	cmp	r0, r7
 800158a:	d9f5      	bls.n	8001578 <HAL_RCC_OscConfig+0x2a0>
        {
          return HAL_TIMEOUT;
 800158c:	2003      	movs	r0, #3
 800158e:	e068      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
 8001590:	40023800 	.word	0x40023800
 8001594:	42470000 	.word	0x42470000
 8001598:	42470e80 	.word	0x42470e80
 800159c:	40007000 	.word	0x40007000
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 80015a0:	b9e5      	cbnz	r5, 80015dc <HAL_RCC_OscConfig+0x304>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80015a2:	69a3      	ldr	r3, [r4, #24]
 80015a4:	2b00      	cmp	r3, #0
 80015a6:	d05b      	beq.n	8001660 <HAL_RCC_OscConfig+0x388>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80015a8:	4a30      	ldr	r2, [pc, #192]	; (800166c <HAL_RCC_OscConfig+0x394>)
 80015aa:	6892      	ldr	r2, [r2, #8]
 80015ac:	f002 020c 	and.w	r2, r2, #12
 80015b0:	2a08      	cmp	r2, #8
 80015b2:	d059      	beq.n	8001668 <HAL_RCC_OscConfig+0x390>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80015b4:	2b02      	cmp	r3, #2
 80015b6:	d017      	beq.n	80015e8 <HAL_RCC_OscConfig+0x310>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80015b8:	2200      	movs	r2, #0
 80015ba:	4b2d      	ldr	r3, [pc, #180]	; (8001670 <HAL_RCC_OscConfig+0x398>)
 80015bc:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80015be:	f7ff f837 	bl	8000630 <HAL_GetTick>
 80015c2:	4605      	mov	r5, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80015c4:	4c29      	ldr	r4, [pc, #164]	; (800166c <HAL_RCC_OscConfig+0x394>)
 80015c6:	6823      	ldr	r3, [r4, #0]
 80015c8:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80015cc:	d042      	beq.n	8001654 <HAL_RCC_OscConfig+0x37c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80015ce:	f7ff f82f 	bl	8000630 <HAL_GetTick>
 80015d2:	1b40      	subs	r0, r0, r5
 80015d4:	2802      	cmp	r0, #2
 80015d6:	d9f6      	bls.n	80015c6 <HAL_RCC_OscConfig+0x2ee>
          {
            return HAL_TIMEOUT;
 80015d8:	2003      	movs	r0, #3
 80015da:	e042      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
      __HAL_RCC_PWR_CLK_DISABLE();
 80015dc:	4a23      	ldr	r2, [pc, #140]	; (800166c <HAL_RCC_OscConfig+0x394>)
 80015de:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80015e0:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80015e4:	6413      	str	r3, [r2, #64]	; 0x40
 80015e6:	e7dc      	b.n	80015a2 <HAL_RCC_OscConfig+0x2ca>
        __HAL_RCC_PLL_DISABLE();
 80015e8:	2200      	movs	r2, #0
 80015ea:	4b21      	ldr	r3, [pc, #132]	; (8001670 <HAL_RCC_OscConfig+0x398>)
 80015ec:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80015ee:	f7ff f81f 	bl	8000630 <HAL_GetTick>
 80015f2:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80015f4:	4d1d      	ldr	r5, [pc, #116]	; (800166c <HAL_RCC_OscConfig+0x394>)
 80015f6:	682b      	ldr	r3, [r5, #0]
 80015f8:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80015fc:	d006      	beq.n	800160c <HAL_RCC_OscConfig+0x334>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80015fe:	f7ff f817 	bl	8000630 <HAL_GetTick>
 8001602:	1b80      	subs	r0, r0, r6
 8001604:	2802      	cmp	r0, #2
 8001606:	d9f6      	bls.n	80015f6 <HAL_RCC_OscConfig+0x31e>
            return HAL_TIMEOUT;
 8001608:	2003      	movs	r0, #3
 800160a:	e02a      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 800160c:	69e3      	ldr	r3, [r4, #28]
 800160e:	6a22      	ldr	r2, [r4, #32]
 8001610:	4313      	orrs	r3, r2
 8001612:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001614:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8001618:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800161a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800161e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001620:	0852      	lsrs	r2, r2, #1
 8001622:	3a01      	subs	r2, #1
 8001624:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001628:	4a10      	ldr	r2, [pc, #64]	; (800166c <HAL_RCC_OscConfig+0x394>)
 800162a:	6053      	str	r3, [r2, #4]
        __HAL_RCC_PLL_ENABLE();
 800162c:	2201      	movs	r2, #1
 800162e:	4b10      	ldr	r3, [pc, #64]	; (8001670 <HAL_RCC_OscConfig+0x398>)
 8001630:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001632:	f7fe fffd 	bl	8000630 <HAL_GetTick>
 8001636:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001638:	4c0c      	ldr	r4, [pc, #48]	; (800166c <HAL_RCC_OscConfig+0x394>)
 800163a:	6823      	ldr	r3, [r4, #0]
 800163c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001640:	d106      	bne.n	8001650 <HAL_RCC_OscConfig+0x378>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001642:	f7fe fff5 	bl	8000630 <HAL_GetTick>
 8001646:	1b40      	subs	r0, r0, r5
 8001648:	2802      	cmp	r0, #2
 800164a:	d9f6      	bls.n	800163a <HAL_RCC_OscConfig+0x362>
            return HAL_TIMEOUT;
 800164c:	2003      	movs	r0, #3
 800164e:	e008      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8001650:	2000      	movs	r0, #0
 8001652:	e006      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
 8001654:	2000      	movs	r0, #0
 8001656:	e004      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
    return HAL_ERROR;
 8001658:	2001      	movs	r0, #1
 800165a:	4770      	bx	lr
        return HAL_ERROR;
 800165c:	2001      	movs	r0, #1
 800165e:	e000      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
  return HAL_OK;
 8001660:	2000      	movs	r0, #0
}
 8001662:	b002      	add	sp, #8
 8001664:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return HAL_ERROR;
 8001668:	2001      	movs	r0, #1
 800166a:	e7fa      	b.n	8001662 <HAL_RCC_OscConfig+0x38a>
 800166c:	40023800 	.word	0x40023800
 8001670:	42470060 	.word	0x42470060

08001674 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8001674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001676:	4b31      	ldr	r3, [pc, #196]	; (800173c <HAL_RCC_GetSysClockFreq+0xc8>)
 8001678:	689b      	ldr	r3, [r3, #8]
 800167a:	f003 030c 	and.w	r3, r3, #12
 800167e:	2b04      	cmp	r3, #4
 8001680:	d003      	beq.n	800168a <HAL_RCC_GetSysClockFreq+0x16>
 8001682:	2b08      	cmp	r3, #8
 8001684:	d003      	beq.n	800168e <HAL_RCC_GetSysClockFreq+0x1a>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8001686:	482e      	ldr	r0, [pc, #184]	; (8001740 <HAL_RCC_GetSysClockFreq+0xcc>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8001688:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      sysclockfreq = HSE_VALUE;
 800168a:	482e      	ldr	r0, [pc, #184]	; (8001744 <HAL_RCC_GetSysClockFreq+0xd0>)
 800168c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800168e:	4b2b      	ldr	r3, [pc, #172]	; (800173c <HAL_RCC_GetSysClockFreq+0xc8>)
 8001690:	685a      	ldr	r2, [r3, #4]
 8001692:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001696:	685b      	ldr	r3, [r3, #4]
 8001698:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 800169c:	d02a      	beq.n	80016f4 <HAL_RCC_GetSysClockFreq+0x80>
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800169e:	4b27      	ldr	r3, [pc, #156]	; (800173c <HAL_RCC_GetSysClockFreq+0xc8>)
 80016a0:	685b      	ldr	r3, [r3, #4]
 80016a2:	f3c3 1388 	ubfx	r3, r3, #6, #9
 80016a6:	461e      	mov	r6, r3
 80016a8:	2700      	movs	r7, #0
 80016aa:	015c      	lsls	r4, r3, #5
 80016ac:	2500      	movs	r5, #0
 80016ae:	1ae4      	subs	r4, r4, r3
 80016b0:	eb65 0507 	sbc.w	r5, r5, r7
 80016b4:	01a9      	lsls	r1, r5, #6
 80016b6:	ea41 6194 	orr.w	r1, r1, r4, lsr #26
 80016ba:	01a0      	lsls	r0, r4, #6
 80016bc:	1b00      	subs	r0, r0, r4
 80016be:	eb61 0105 	sbc.w	r1, r1, r5
 80016c2:	00cb      	lsls	r3, r1, #3
 80016c4:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 80016c8:	00c4      	lsls	r4, r0, #3
 80016ca:	19a0      	adds	r0, r4, r6
 80016cc:	eb43 0107 	adc.w	r1, r3, r7
 80016d0:	024b      	lsls	r3, r1, #9
 80016d2:	ea43 53d0 	orr.w	r3, r3, r0, lsr #23
 80016d6:	0244      	lsls	r4, r0, #9
 80016d8:	4620      	mov	r0, r4
 80016da:	4619      	mov	r1, r3
 80016dc:	2300      	movs	r3, #0
 80016de:	f7fe fdd3 	bl	8000288 <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 80016e2:	4b16      	ldr	r3, [pc, #88]	; (800173c <HAL_RCC_GetSysClockFreq+0xc8>)
 80016e4:	685b      	ldr	r3, [r3, #4]
 80016e6:	f3c3 4301 	ubfx	r3, r3, #16, #2
 80016ea:	3301      	adds	r3, #1
 80016ec:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 80016ee:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
 80016f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80016f4:	4b11      	ldr	r3, [pc, #68]	; (800173c <HAL_RCC_GetSysClockFreq+0xc8>)
 80016f6:	685b      	ldr	r3, [r3, #4]
 80016f8:	f3c3 1388 	ubfx	r3, r3, #6, #9
 80016fc:	461e      	mov	r6, r3
 80016fe:	2700      	movs	r7, #0
 8001700:	015c      	lsls	r4, r3, #5
 8001702:	2500      	movs	r5, #0
 8001704:	1ae4      	subs	r4, r4, r3
 8001706:	eb65 0507 	sbc.w	r5, r5, r7
 800170a:	01a9      	lsls	r1, r5, #6
 800170c:	ea41 6194 	orr.w	r1, r1, r4, lsr #26
 8001710:	01a0      	lsls	r0, r4, #6
 8001712:	1b00      	subs	r0, r0, r4
 8001714:	eb61 0105 	sbc.w	r1, r1, r5
 8001718:	00cb      	lsls	r3, r1, #3
 800171a:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 800171e:	00c4      	lsls	r4, r0, #3
 8001720:	19a0      	adds	r0, r4, r6
 8001722:	eb43 0107 	adc.w	r1, r3, r7
 8001726:	028b      	lsls	r3, r1, #10
 8001728:	ea43 5390 	orr.w	r3, r3, r0, lsr #22
 800172c:	0284      	lsls	r4, r0, #10
 800172e:	4620      	mov	r0, r4
 8001730:	4619      	mov	r1, r3
 8001732:	2300      	movs	r3, #0
 8001734:	f7fe fda8 	bl	8000288 <__aeabi_uldivmod>
 8001738:	e7d3      	b.n	80016e2 <HAL_RCC_GetSysClockFreq+0x6e>
 800173a:	bf00      	nop
 800173c:	40023800 	.word	0x40023800
 8001740:	00f42400 	.word	0x00f42400
 8001744:	007a1200 	.word	0x007a1200

08001748 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 8001748:	2800      	cmp	r0, #0
 800174a:	f000 80a5 	beq.w	8001898 <HAL_RCC_ClockConfig+0x150>
{
 800174e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001752:	4604      	mov	r4, r0
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8001754:	4b53      	ldr	r3, [pc, #332]	; (80018a4 <HAL_RCC_ClockConfig+0x15c>)
 8001756:	681b      	ldr	r3, [r3, #0]
 8001758:	f003 030f 	and.w	r3, r3, #15
 800175c:	428b      	cmp	r3, r1
 800175e:	d20a      	bcs.n	8001776 <HAL_RCC_ClockConfig+0x2e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001760:	b2cb      	uxtb	r3, r1
 8001762:	4a50      	ldr	r2, [pc, #320]	; (80018a4 <HAL_RCC_ClockConfig+0x15c>)
 8001764:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8001766:	6813      	ldr	r3, [r2, #0]
 8001768:	f003 030f 	and.w	r3, r3, #15
 800176c:	4299      	cmp	r1, r3
 800176e:	d002      	beq.n	8001776 <HAL_RCC_ClockConfig+0x2e>
      return HAL_ERROR;
 8001770:	2001      	movs	r0, #1
 8001772:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001776:	6823      	ldr	r3, [r4, #0]
 8001778:	f013 0f02 	tst.w	r3, #2
 800177c:	d017      	beq.n	80017ae <HAL_RCC_ClockConfig+0x66>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800177e:	f013 0f04 	tst.w	r3, #4
 8001782:	d004      	beq.n	800178e <HAL_RCC_ClockConfig+0x46>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8001784:	4a48      	ldr	r2, [pc, #288]	; (80018a8 <HAL_RCC_ClockConfig+0x160>)
 8001786:	6893      	ldr	r3, [r2, #8]
 8001788:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 800178c:	6093      	str	r3, [r2, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800178e:	6823      	ldr	r3, [r4, #0]
 8001790:	f013 0f08 	tst.w	r3, #8
 8001794:	d004      	beq.n	80017a0 <HAL_RCC_ClockConfig+0x58>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8001796:	4a44      	ldr	r2, [pc, #272]	; (80018a8 <HAL_RCC_ClockConfig+0x160>)
 8001798:	6893      	ldr	r3, [r2, #8]
 800179a:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 800179e:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80017a0:	4a41      	ldr	r2, [pc, #260]	; (80018a8 <HAL_RCC_ClockConfig+0x160>)
 80017a2:	6893      	ldr	r3, [r2, #8]
 80017a4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80017a8:	68a0      	ldr	r0, [r4, #8]
 80017aa:	4303      	orrs	r3, r0
 80017ac:	6093      	str	r3, [r2, #8]
 80017ae:	460d      	mov	r5, r1
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80017b0:	6823      	ldr	r3, [r4, #0]
 80017b2:	f013 0f01 	tst.w	r3, #1
 80017b6:	d036      	beq.n	8001826 <HAL_RCC_ClockConfig+0xde>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80017b8:	6862      	ldr	r2, [r4, #4]
 80017ba:	2a01      	cmp	r2, #1
 80017bc:	d023      	beq.n	8001806 <HAL_RCC_ClockConfig+0xbe>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80017be:	1e93      	subs	r3, r2, #2
 80017c0:	2b01      	cmp	r3, #1
 80017c2:	d928      	bls.n	8001816 <HAL_RCC_ClockConfig+0xce>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80017c4:	4b38      	ldr	r3, [pc, #224]	; (80018a8 <HAL_RCC_ClockConfig+0x160>)
 80017c6:	681b      	ldr	r3, [r3, #0]
 80017c8:	f013 0f02 	tst.w	r3, #2
 80017cc:	d066      	beq.n	800189c <HAL_RCC_ClockConfig+0x154>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80017ce:	4936      	ldr	r1, [pc, #216]	; (80018a8 <HAL_RCC_ClockConfig+0x160>)
 80017d0:	688b      	ldr	r3, [r1, #8]
 80017d2:	f023 0303 	bic.w	r3, r3, #3
 80017d6:	4313      	orrs	r3, r2
 80017d8:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 80017da:	f7fe ff29 	bl	8000630 <HAL_GetTick>
 80017de:	4680      	mov	r8, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80017e0:	4e31      	ldr	r6, [pc, #196]	; (80018a8 <HAL_RCC_ClockConfig+0x160>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80017e2:	f241 3788 	movw	r7, #5000	; 0x1388
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80017e6:	68b3      	ldr	r3, [r6, #8]
 80017e8:	f003 030c 	and.w	r3, r3, #12
 80017ec:	6862      	ldr	r2, [r4, #4]
 80017ee:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80017f2:	d018      	beq.n	8001826 <HAL_RCC_ClockConfig+0xde>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80017f4:	f7fe ff1c 	bl	8000630 <HAL_GetTick>
 80017f8:	eba0 0008 	sub.w	r0, r0, r8
 80017fc:	42b8      	cmp	r0, r7
 80017fe:	d9f2      	bls.n	80017e6 <HAL_RCC_ClockConfig+0x9e>
        return HAL_TIMEOUT;
 8001800:	2003      	movs	r0, #3
 8001802:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001806:	4b28      	ldr	r3, [pc, #160]	; (80018a8 <HAL_RCC_ClockConfig+0x160>)
 8001808:	681b      	ldr	r3, [r3, #0]
 800180a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800180e:	d1de      	bne.n	80017ce <HAL_RCC_ClockConfig+0x86>
        return HAL_ERROR;
 8001810:	2001      	movs	r0, #1
 8001812:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001816:	4b24      	ldr	r3, [pc, #144]	; (80018a8 <HAL_RCC_ClockConfig+0x160>)
 8001818:	681b      	ldr	r3, [r3, #0]
 800181a:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 800181e:	d1d6      	bne.n	80017ce <HAL_RCC_ClockConfig+0x86>
        return HAL_ERROR;
 8001820:	2001      	movs	r0, #1
 8001822:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8001826:	4b1f      	ldr	r3, [pc, #124]	; (80018a4 <HAL_RCC_ClockConfig+0x15c>)
 8001828:	681b      	ldr	r3, [r3, #0]
 800182a:	f003 030f 	and.w	r3, r3, #15
 800182e:	429d      	cmp	r5, r3
 8001830:	d20a      	bcs.n	8001848 <HAL_RCC_ClockConfig+0x100>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001832:	b2ea      	uxtb	r2, r5
 8001834:	4b1b      	ldr	r3, [pc, #108]	; (80018a4 <HAL_RCC_ClockConfig+0x15c>)
 8001836:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8001838:	681b      	ldr	r3, [r3, #0]
 800183a:	f003 030f 	and.w	r3, r3, #15
 800183e:	429d      	cmp	r5, r3
 8001840:	d002      	beq.n	8001848 <HAL_RCC_ClockConfig+0x100>
      return HAL_ERROR;
 8001842:	2001      	movs	r0, #1
}
 8001844:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001848:	6823      	ldr	r3, [r4, #0]
 800184a:	f013 0f04 	tst.w	r3, #4
 800184e:	d006      	beq.n	800185e <HAL_RCC_ClockConfig+0x116>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001850:	4a15      	ldr	r2, [pc, #84]	; (80018a8 <HAL_RCC_ClockConfig+0x160>)
 8001852:	6893      	ldr	r3, [r2, #8]
 8001854:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8001858:	68e1      	ldr	r1, [r4, #12]
 800185a:	430b      	orrs	r3, r1
 800185c:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800185e:	6823      	ldr	r3, [r4, #0]
 8001860:	f013 0f08 	tst.w	r3, #8
 8001864:	d007      	beq.n	8001876 <HAL_RCC_ClockConfig+0x12e>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8001866:	4a10      	ldr	r2, [pc, #64]	; (80018a8 <HAL_RCC_ClockConfig+0x160>)
 8001868:	6893      	ldr	r3, [r2, #8]
 800186a:	6921      	ldr	r1, [r4, #16]
 800186c:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001870:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001874:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8001876:	f7ff fefd 	bl	8001674 <HAL_RCC_GetSysClockFreq>
 800187a:	4b0b      	ldr	r3, [pc, #44]	; (80018a8 <HAL_RCC_ClockConfig+0x160>)
 800187c:	689b      	ldr	r3, [r3, #8]
 800187e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8001882:	4a0a      	ldr	r2, [pc, #40]	; (80018ac <HAL_RCC_ClockConfig+0x164>)
 8001884:	5cd3      	ldrb	r3, [r2, r3]
 8001886:	40d8      	lsrs	r0, r3
 8001888:	4b09      	ldr	r3, [pc, #36]	; (80018b0 <HAL_RCC_ClockConfig+0x168>)
 800188a:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 800188c:	2000      	movs	r0, #0
 800188e:	f7fe fe83 	bl	8000598 <HAL_InitTick>
  return HAL_OK;
 8001892:	2000      	movs	r0, #0
 8001894:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return HAL_ERROR;
 8001898:	2001      	movs	r0, #1
 800189a:	4770      	bx	lr
        return HAL_ERROR;
 800189c:	2001      	movs	r0, #1
 800189e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80018a2:	bf00      	nop
 80018a4:	40023c00 	.word	0x40023c00
 80018a8:	40023800 	.word	0x40023800
 80018ac:	08008f88 	.word	0x08008f88
 80018b0:	20000100 	.word	0x20000100

080018b4 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 80018b4:	4b01      	ldr	r3, [pc, #4]	; (80018bc <HAL_RCC_GetHCLKFreq+0x8>)
 80018b6:	6818      	ldr	r0, [r3, #0]
 80018b8:	4770      	bx	lr
 80018ba:	bf00      	nop
 80018bc:	20000100 	.word	0x20000100

080018c0 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80018c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80018c2:	b083      	sub	sp, #12
 80018c4:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 80018c6:	6803      	ldr	r3, [r0, #0]
 80018c8:	f013 0f05 	tst.w	r3, #5
 80018cc:	d10e      	bne.n	80018ec <HAL_RCCEx_PeriphCLKConfig+0x2c>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 80018ce:	6823      	ldr	r3, [r4, #0]
 80018d0:	f013 0f02 	tst.w	r3, #2
 80018d4:	d138      	bne.n	8001948 <HAL_RCCEx_PeriphCLKConfig+0x88>
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }
#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 80018d6:	6823      	ldr	r3, [r4, #0]
 80018d8:	f013 0f08 	tst.w	r3, #8
 80018dc:	f000 809b 	beq.w	8001a16 <HAL_RCCEx_PeriphCLKConfig+0x156>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 80018e0:	7d22      	ldrb	r2, [r4, #20]
 80018e2:	4b4e      	ldr	r3, [pc, #312]	; (8001a1c <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 80018e4:	601a      	str	r2, [r3, #0]
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 80018e6:	2000      	movs	r0, #0
}
 80018e8:	b003      	add	sp, #12
 80018ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_PLLI2S_DISABLE();
 80018ec:	2200      	movs	r2, #0
 80018ee:	4b4c      	ldr	r3, [pc, #304]	; (8001a20 <HAL_RCCEx_PeriphCLKConfig+0x160>)
 80018f0:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80018f2:	f7fe fe9d 	bl	8000630 <HAL_GetTick>
 80018f6:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 80018f8:	4d4a      	ldr	r5, [pc, #296]	; (8001a24 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 80018fa:	682b      	ldr	r3, [r5, #0]
 80018fc:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8001900:	d006      	beq.n	8001910 <HAL_RCCEx_PeriphCLKConfig+0x50>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8001902:	f7fe fe95 	bl	8000630 <HAL_GetTick>
 8001906:	1b80      	subs	r0, r0, r6
 8001908:	2802      	cmp	r0, #2
 800190a:	d9f6      	bls.n	80018fa <HAL_RCCEx_PeriphCLKConfig+0x3a>
        return HAL_TIMEOUT;
 800190c:	2003      	movs	r0, #3
 800190e:	e7eb      	b.n	80018e8 <HAL_RCCEx_PeriphCLKConfig+0x28>
    __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
 8001910:	68a2      	ldr	r2, [r4, #8]
 8001912:	68e3      	ldr	r3, [r4, #12]
 8001914:	071b      	lsls	r3, r3, #28
 8001916:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 800191a:	6862      	ldr	r2, [r4, #4]
 800191c:	4313      	orrs	r3, r2
 800191e:	4a41      	ldr	r2, [pc, #260]	; (8001a24 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001920:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 8001924:	2201      	movs	r2, #1
 8001926:	4b3e      	ldr	r3, [pc, #248]	; (8001a20 <HAL_RCCEx_PeriphCLKConfig+0x160>)
 8001928:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 800192a:	f7fe fe81 	bl	8000630 <HAL_GetTick>
 800192e:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8001930:	4d3c      	ldr	r5, [pc, #240]	; (8001a24 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001932:	682b      	ldr	r3, [r5, #0]
 8001934:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8001938:	d1c9      	bne.n	80018ce <HAL_RCCEx_PeriphCLKConfig+0xe>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 800193a:	f7fe fe79 	bl	8000630 <HAL_GetTick>
 800193e:	1b80      	subs	r0, r0, r6
 8001940:	2802      	cmp	r0, #2
 8001942:	d9f6      	bls.n	8001932 <HAL_RCCEx_PeriphCLKConfig+0x72>
        return HAL_TIMEOUT;
 8001944:	2003      	movs	r0, #3
 8001946:	e7cf      	b.n	80018e8 <HAL_RCCEx_PeriphCLKConfig+0x28>
    __HAL_RCC_PWR_CLK_ENABLE();
 8001948:	2300      	movs	r3, #0
 800194a:	9301      	str	r3, [sp, #4]
 800194c:	4b35      	ldr	r3, [pc, #212]	; (8001a24 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800194e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001950:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001954:	641a      	str	r2, [r3, #64]	; 0x40
 8001956:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001958:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800195c:	9301      	str	r3, [sp, #4]
 800195e:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 8001960:	4a31      	ldr	r2, [pc, #196]	; (8001a28 <HAL_RCCEx_PeriphCLKConfig+0x168>)
 8001962:	6813      	ldr	r3, [r2, #0]
 8001964:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001968:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 800196a:	f7fe fe61 	bl	8000630 <HAL_GetTick>
 800196e:	4606      	mov	r6, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8001970:	4d2d      	ldr	r5, [pc, #180]	; (8001a28 <HAL_RCCEx_PeriphCLKConfig+0x168>)
 8001972:	682b      	ldr	r3, [r5, #0]
 8001974:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001978:	d106      	bne.n	8001988 <HAL_RCCEx_PeriphCLKConfig+0xc8>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800197a:	f7fe fe59 	bl	8000630 <HAL_GetTick>
 800197e:	1b80      	subs	r0, r0, r6
 8001980:	2802      	cmp	r0, #2
 8001982:	d9f6      	bls.n	8001972 <HAL_RCCEx_PeriphCLKConfig+0xb2>
        return HAL_TIMEOUT;
 8001984:	2003      	movs	r0, #3
 8001986:	e7af      	b.n	80018e8 <HAL_RCCEx_PeriphCLKConfig+0x28>
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8001988:	4b26      	ldr	r3, [pc, #152]	; (8001a24 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800198a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800198c:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8001990:	d012      	beq.n	80019b8 <HAL_RCCEx_PeriphCLKConfig+0xf8>
 8001992:	6922      	ldr	r2, [r4, #16]
 8001994:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8001998:	4293      	cmp	r3, r2
 800199a:	d00d      	beq.n	80019b8 <HAL_RCCEx_PeriphCLKConfig+0xf8>
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800199c:	4b21      	ldr	r3, [pc, #132]	; (8001a24 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800199e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80019a0:	f422 7240 	bic.w	r2, r2, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 80019a4:	4921      	ldr	r1, [pc, #132]	; (8001a2c <HAL_RCCEx_PeriphCLKConfig+0x16c>)
 80019a6:	2001      	movs	r0, #1
 80019a8:	6008      	str	r0, [r1, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 80019aa:	2000      	movs	r0, #0
 80019ac:	6008      	str	r0, [r1, #0]
      RCC->BDCR = tmpreg1;
 80019ae:	671a      	str	r2, [r3, #112]	; 0x70
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 80019b0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80019b2:	f013 0f01 	tst.w	r3, #1
 80019b6:	d112      	bne.n	80019de <HAL_RCCEx_PeriphCLKConfig+0x11e>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80019b8:	6923      	ldr	r3, [r4, #16]
 80019ba:	f403 7240 	and.w	r2, r3, #768	; 0x300
 80019be:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 80019c2:	d01d      	beq.n	8001a00 <HAL_RCCEx_PeriphCLKConfig+0x140>
 80019c4:	4a17      	ldr	r2, [pc, #92]	; (8001a24 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 80019c6:	6893      	ldr	r3, [r2, #8]
 80019c8:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 80019cc:	6093      	str	r3, [r2, #8]
 80019ce:	4a15      	ldr	r2, [pc, #84]	; (8001a24 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 80019d0:	6f11      	ldr	r1, [r2, #112]	; 0x70
 80019d2:	6923      	ldr	r3, [r4, #16]
 80019d4:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80019d8:	430b      	orrs	r3, r1
 80019da:	6713      	str	r3, [r2, #112]	; 0x70
 80019dc:	e77b      	b.n	80018d6 <HAL_RCCEx_PeriphCLKConfig+0x16>
        tickstart = HAL_GetTick();
 80019de:	f7fe fe27 	bl	8000630 <HAL_GetTick>
 80019e2:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80019e4:	4d0f      	ldr	r5, [pc, #60]	; (8001a24 <HAL_RCCEx_PeriphCLKConfig+0x164>)
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80019e6:	f241 3688 	movw	r6, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80019ea:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80019ec:	f013 0f02 	tst.w	r3, #2
 80019f0:	d1e2      	bne.n	80019b8 <HAL_RCCEx_PeriphCLKConfig+0xf8>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80019f2:	f7fe fe1d 	bl	8000630 <HAL_GetTick>
 80019f6:	1bc0      	subs	r0, r0, r7
 80019f8:	42b0      	cmp	r0, r6
 80019fa:	d9f6      	bls.n	80019ea <HAL_RCCEx_PeriphCLKConfig+0x12a>
            return HAL_TIMEOUT;
 80019fc:	2003      	movs	r0, #3
 80019fe:	e773      	b.n	80018e8 <HAL_RCCEx_PeriphCLKConfig+0x28>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8001a00:	4908      	ldr	r1, [pc, #32]	; (8001a24 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8001a02:	688a      	ldr	r2, [r1, #8]
 8001a04:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8001a08:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8001a0c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001a10:	4313      	orrs	r3, r2
 8001a12:	608b      	str	r3, [r1, #8]
 8001a14:	e7db      	b.n	80019ce <HAL_RCCEx_PeriphCLKConfig+0x10e>
  return HAL_OK;
 8001a16:	2000      	movs	r0, #0
 8001a18:	e766      	b.n	80018e8 <HAL_RCCEx_PeriphCLKConfig+0x28>
 8001a1a:	bf00      	nop
 8001a1c:	424711e0 	.word	0x424711e0
 8001a20:	42470068 	.word	0x42470068
 8001a24:	40023800 	.word	0x40023800
 8001a28:	40007000 	.word	0x40007000
 8001a2c:	42470e40 	.word	0x42470e40

08001a30 <HAL_RTC_WaitForSynchro>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
 8001a30:	b538      	push	{r3, r4, r5, lr}
 8001a32:	4604      	mov	r4, r0
  uint32_t tickstart = 0U;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8001a34:	6802      	ldr	r2, [r0, #0]
 8001a36:	68d3      	ldr	r3, [r2, #12]
 8001a38:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8001a3c:	60d3      	str	r3, [r2, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 8001a3e:	f7fe fdf7 	bl	8000630 <HAL_GetTick>
 8001a42:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8001a44:	6823      	ldr	r3, [r4, #0]
 8001a46:	68db      	ldr	r3, [r3, #12]
 8001a48:	f013 0f20 	tst.w	r3, #32
 8001a4c:	d107      	bne.n	8001a5e <HAL_RTC_WaitForSynchro+0x2e>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8001a4e:	f7fe fdef 	bl	8000630 <HAL_GetTick>
 8001a52:	1b40      	subs	r0, r0, r5
 8001a54:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001a58:	d9f4      	bls.n	8001a44 <HAL_RTC_WaitForSynchro+0x14>
    {       
      return HAL_TIMEOUT;
 8001a5a:	2003      	movs	r0, #3
    } 
  }

  return HAL_OK;
}
 8001a5c:	bd38      	pop	{r3, r4, r5, pc}
  return HAL_OK;
 8001a5e:	2000      	movs	r0, #0
 8001a60:	bd38      	pop	{r3, r4, r5, pc}

08001a62 <RTC_EnterInitMode>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 8001a62:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0U; 
  
  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8001a64:	6803      	ldr	r3, [r0, #0]
 8001a66:	68da      	ldr	r2, [r3, #12]
 8001a68:	f012 0f40 	tst.w	r2, #64	; 0x40
 8001a6c:	d001      	beq.n	8001a72 <RTC_EnterInitMode+0x10>
        return HAL_TIMEOUT;
      } 
    }
  }
  
  return HAL_OK;  
 8001a6e:	2000      	movs	r0, #0
 8001a70:	bd38      	pop	{r3, r4, r5, pc}
 8001a72:	4604      	mov	r4, r0
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8001a74:	f04f 32ff 	mov.w	r2, #4294967295
 8001a78:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 8001a7a:	f7fe fdd9 	bl	8000630 <HAL_GetTick>
 8001a7e:	4605      	mov	r5, r0
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8001a80:	6823      	ldr	r3, [r4, #0]
 8001a82:	68db      	ldr	r3, [r3, #12]
 8001a84:	f013 0f40 	tst.w	r3, #64	; 0x40
 8001a88:	d107      	bne.n	8001a9a <RTC_EnterInitMode+0x38>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8001a8a:	f7fe fdd1 	bl	8000630 <HAL_GetTick>
 8001a8e:	1b40      	subs	r0, r0, r5
 8001a90:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001a94:	d9f4      	bls.n	8001a80 <RTC_EnterInitMode+0x1e>
        return HAL_TIMEOUT;
 8001a96:	2003      	movs	r0, #3
}
 8001a98:	bd38      	pop	{r3, r4, r5, pc}
  return HAL_OK;  
 8001a9a:	2000      	movs	r0, #0
 8001a9c:	bd38      	pop	{r3, r4, r5, pc}

08001a9e <HAL_RTC_Init>:
{
 8001a9e:	b538      	push	{r3, r4, r5, lr}
  if(hrtc == NULL)
 8001aa0:	2800      	cmp	r0, #0
 8001aa2:	d05c      	beq.n	8001b5e <HAL_RTC_Init+0xc0>
 8001aa4:	4604      	mov	r4, r0
  if(hrtc->State == HAL_RTC_STATE_RESET)
 8001aa6:	7f43      	ldrb	r3, [r0, #29]
 8001aa8:	2b00      	cmp	r3, #0
 8001aaa:	d041      	beq.n	8001b30 <HAL_RTC_Init+0x92>
  hrtc->State = HAL_RTC_STATE_BUSY;  
 8001aac:	2302      	movs	r3, #2
 8001aae:	7763      	strb	r3, [r4, #29]
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8001ab0:	6823      	ldr	r3, [r4, #0]
 8001ab2:	22ca      	movs	r2, #202	; 0xca
 8001ab4:	625a      	str	r2, [r3, #36]	; 0x24
 8001ab6:	6823      	ldr	r3, [r4, #0]
 8001ab8:	2253      	movs	r2, #83	; 0x53
 8001aba:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8001abc:	4620      	mov	r0, r4
 8001abe:	f7ff ffd0 	bl	8001a62 <RTC_EnterInitMode>
 8001ac2:	4605      	mov	r5, r0
 8001ac4:	2800      	cmp	r0, #0
 8001ac6:	d137      	bne.n	8001b38 <HAL_RTC_Init+0x9a>
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8001ac8:	6822      	ldr	r2, [r4, #0]
 8001aca:	6893      	ldr	r3, [r2, #8]
 8001acc:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 8001ad0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001ad4:	6093      	str	r3, [r2, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8001ad6:	6822      	ldr	r2, [r4, #0]
 8001ad8:	6891      	ldr	r1, [r2, #8]
 8001ada:	6863      	ldr	r3, [r4, #4]
 8001adc:	6920      	ldr	r0, [r4, #16]
 8001ade:	4303      	orrs	r3, r0
 8001ae0:	6960      	ldr	r0, [r4, #20]
 8001ae2:	4303      	orrs	r3, r0
 8001ae4:	430b      	orrs	r3, r1
 8001ae6:	6093      	str	r3, [r2, #8]
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8001ae8:	6823      	ldr	r3, [r4, #0]
 8001aea:	68e2      	ldr	r2, [r4, #12]
 8001aec:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 8001aee:	6822      	ldr	r2, [r4, #0]
 8001af0:	6913      	ldr	r3, [r2, #16]
 8001af2:	68a1      	ldr	r1, [r4, #8]
 8001af4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8001af8:	6113      	str	r3, [r2, #16]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT; 
 8001afa:	6822      	ldr	r2, [r4, #0]
 8001afc:	68d3      	ldr	r3, [r2, #12]
 8001afe:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001b02:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8001b04:	6823      	ldr	r3, [r4, #0]
 8001b06:	689b      	ldr	r3, [r3, #8]
 8001b08:	f013 0f20 	tst.w	r3, #32
 8001b0c:	d01b      	beq.n	8001b46 <HAL_RTC_Init+0xa8>
    hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
 8001b0e:	6822      	ldr	r2, [r4, #0]
 8001b10:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8001b12:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001b16:	6413      	str	r3, [r2, #64]	; 0x40
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType); 
 8001b18:	6822      	ldr	r2, [r4, #0]
 8001b1a:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8001b1c:	69a1      	ldr	r1, [r4, #24]
 8001b1e:	430b      	orrs	r3, r1
 8001b20:	6413      	str	r3, [r2, #64]	; 0x40
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8001b22:	6823      	ldr	r3, [r4, #0]
 8001b24:	22ff      	movs	r2, #255	; 0xff
 8001b26:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY;
 8001b28:	2301      	movs	r3, #1
 8001b2a:	7763      	strb	r3, [r4, #29]
}
 8001b2c:	4628      	mov	r0, r5
 8001b2e:	bd38      	pop	{r3, r4, r5, pc}
    hrtc->Lock = HAL_UNLOCKED;
 8001b30:	7703      	strb	r3, [r0, #28]
    HAL_RTC_MspInit(hrtc);
 8001b32:	f001 ff3b 	bl	80039ac <HAL_RTC_MspInit>
 8001b36:	e7b9      	b.n	8001aac <HAL_RTC_Init+0xe>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8001b38:	6823      	ldr	r3, [r4, #0]
 8001b3a:	22ff      	movs	r2, #255	; 0xff
 8001b3c:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8001b3e:	2304      	movs	r3, #4
 8001b40:	7763      	strb	r3, [r4, #29]
    return HAL_ERROR;
 8001b42:	2501      	movs	r5, #1
 8001b44:	e7f2      	b.n	8001b2c <HAL_RTC_Init+0x8e>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8001b46:	4620      	mov	r0, r4
 8001b48:	f7ff ff72 	bl	8001a30 <HAL_RTC_WaitForSynchro>
 8001b4c:	2800      	cmp	r0, #0
 8001b4e:	d0de      	beq.n	8001b0e <HAL_RTC_Init+0x70>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8001b50:	6823      	ldr	r3, [r4, #0]
 8001b52:	22ff      	movs	r2, #255	; 0xff
 8001b54:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8001b56:	2304      	movs	r3, #4
 8001b58:	7763      	strb	r3, [r4, #29]
        return HAL_ERROR;
 8001b5a:	2501      	movs	r5, #1
 8001b5c:	e7e6      	b.n	8001b2c <HAL_RTC_Init+0x8e>
     return HAL_ERROR;
 8001b5e:	2501      	movs	r5, #1
 8001b60:	e7e4      	b.n	8001b2c <HAL_RTC_Init+0x8e>

08001b62 <USB_CoreInit>:
  * @param  cfg  pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8001b62:	b084      	sub	sp, #16
 8001b64:	b510      	push	{r4, lr}
 8001b66:	4604      	mov	r4, r0
 8001b68:	a803      	add	r0, sp, #12
 8001b6a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001b6e:	9b08      	ldr	r3, [sp, #32]
 8001b70:	2b01      	cmp	r3, #1
 8001b72:	d011      	beq.n	8001b98 <USB_CoreInit+0x36>
    USB_CoreReset(USBx); 
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8001b74:	68e3      	ldr	r3, [r4, #12]
 8001b76:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001b7a:	60e3      	str	r3, [r4, #12]
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
 8001b7c:	4620      	mov	r0, r4
 8001b7e:	f000 fcaf 	bl	80024e0 <USB_CoreReset>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 8001b82:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001b86:	63a3      	str	r3, [r4, #56]	; 0x38
  }
 
  if(cfg.dma_enable == ENABLE)
 8001b88:	9b06      	ldr	r3, [sp, #24]
 8001b8a:	2b01      	cmp	r3, #1
 8001b8c:	d01e      	beq.n	8001bcc <USB_CoreInit+0x6a>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  }  

  return HAL_OK;
}
 8001b8e:	2000      	movs	r0, #0
 8001b90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8001b94:	b004      	add	sp, #16
 8001b96:	4770      	bx	lr
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8001b98:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001b9a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001b9e:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8001ba0:	68e3      	ldr	r3, [r4, #12]
 8001ba2:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 8001ba6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001baa:	60e3      	str	r3, [r4, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8001bac:	68e3      	ldr	r3, [r4, #12]
 8001bae:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8001bb2:	60e3      	str	r3, [r4, #12]
    if(cfg.use_external_vbus == 1U)
 8001bb4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8001bb6:	2b01      	cmp	r3, #1
 8001bb8:	d003      	beq.n	8001bc2 <USB_CoreInit+0x60>
    USB_CoreReset(USBx); 
 8001bba:	4620      	mov	r0, r4
 8001bbc:	f000 fc90 	bl	80024e0 <USB_CoreReset>
 8001bc0:	e7e2      	b.n	8001b88 <USB_CoreInit+0x26>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8001bc2:	68e3      	ldr	r3, [r4, #12]
 8001bc4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001bc8:	60e3      	str	r3, [r4, #12]
 8001bca:	e7f6      	b.n	8001bba <USB_CoreInit+0x58>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8001bcc:	68a3      	ldr	r3, [r4, #8]
 8001bce:	f043 0306 	orr.w	r3, r3, #6
 8001bd2:	60a3      	str	r3, [r4, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8001bd4:	68a3      	ldr	r3, [r4, #8]
 8001bd6:	f043 0320 	orr.w	r3, r3, #32
 8001bda:	60a3      	str	r3, [r4, #8]
 8001bdc:	e7d7      	b.n	8001b8e <USB_CoreInit+0x2c>

08001bde <USB_EnableGlobalInt>:
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8001bde:	6883      	ldr	r3, [r0, #8]
 8001be0:	f043 0301 	orr.w	r3, r3, #1
 8001be4:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 8001be6:	2000      	movs	r0, #0
 8001be8:	4770      	bx	lr

08001bea <USB_DisableGlobalInt>:
  * @param  USBx  Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8001bea:	6883      	ldr	r3, [r0, #8]
 8001bec:	f023 0301 	bic.w	r3, r3, #1
 8001bf0:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 8001bf2:	2000      	movs	r0, #0
 8001bf4:	4770      	bx	lr

08001bf6 <USB_SetCurrentMode>:
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
 8001bf6:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 8001bf8:	68c3      	ldr	r3, [r0, #12]
 8001bfa:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8001bfe:	60c3      	str	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 8001c00:	2901      	cmp	r1, #1
 8001c02:	d009      	beq.n	8001c18 <USB_SetCurrentMode+0x22>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
 8001c04:	b919      	cbnz	r1, 8001c0e <USB_SetCurrentMode+0x18>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
 8001c06:	68c3      	ldr	r3, [r0, #12]
 8001c08:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8001c0c:	60c3      	str	r3, [r0, #12]
  }
  HAL_Delay(50U);
 8001c0e:	2032      	movs	r0, #50	; 0x32
 8001c10:	f7fe fd14 	bl	800063c <HAL_Delay>
  
  return HAL_OK;
}
 8001c14:	2000      	movs	r0, #0
 8001c16:	bd08      	pop	{r3, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
 8001c18:	68c3      	ldr	r3, [r0, #12]
 8001c1a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8001c1e:	60c3      	str	r3, [r0, #12]
 8001c20:	e7f5      	b.n	8001c0e <USB_SetCurrentMode+0x18>
	...

08001c24 <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8001c24:	b084      	sub	sp, #16
 8001c26:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001c2a:	4604      	mov	r4, r0
 8001c2c:	a80b      	add	r0, sp, #44	; 0x2c
 8001c2e:	e880 000e 	stmia.w	r0, {r1, r2, r3}
 8001c32:	4688      	mov	r8, r1
 8001c34:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
 8001c38:	f8dd b054 	ldr.w	fp, [sp, #84]	; 0x54
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  if (cfg.vbus_sensing_enable == 0U)
 8001c3c:	f1bb 0f00 	cmp.w	fp, #0
 8001c40:	d172      	bne.n	8001d28 <USB_DevInit+0x104>
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 8001c42:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001c44:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001c48:	63a3      	str	r3, [r4, #56]	; 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx || STM32F413xx || STM32F423xx  */
  
  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 8001c4a:	2300      	movs	r3, #0
 8001c4c:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
  
  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8001c50:	f504 6500 	add.w	r5, r4, #2048	; 0x800
 8001c54:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 8001c58:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 8001c5c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8001c5e:	2b01      	cmp	r3, #1
 8001c60:	d067      	beq.n	8001d32 <USB_DevInit+0x10e>
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 8001c62:	2103      	movs	r1, #3
 8001c64:	4620      	mov	r0, r4
 8001c66:	f000 f8ad 	bl	8001dc4 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 8001c6a:	2110      	movs	r1, #16
 8001c6c:	4620      	mov	r0, r4
 8001c6e:	f000 f887 	bl	8001d80 <USB_FlushTxFifo>
  USB_FlushRxFifo(USBx);
 8001c72:	4620      	mov	r0, r4
 8001c74:	f000 f896 	bl	8001da4 <USB_FlushRxFifo>
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 8001c78:	2300      	movs	r3, #0
 8001c7a:	612b      	str	r3, [r5, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 8001c7c:	616b      	str	r3, [r5, #20]
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8001c7e:	f04f 32ff 	mov.w	r2, #4294967295
 8001c82:	61aa      	str	r2, [r5, #24]
  USBx_DEVICE->DAINTMSK = 0U;
 8001c84:	61eb      	str	r3, [r5, #28]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001c86:	f1b8 0f00 	cmp.w	r8, #0
 8001c8a:	d028      	beq.n	8001cde <USB_DevInit+0xba>
 8001c8c:	f504 6310 	add.w	r3, r4, #2304	; 0x900
 8001c90:	2200      	movs	r2, #0
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 8001c92:	4616      	mov	r6, r2
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8001c94:	f04f 4990 	mov.w	r9, #1207959552	; 0x48000000
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 8001c98:	27ff      	movs	r7, #255	; 0xff
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8001c9a:	6818      	ldr	r0, [r3, #0]
 8001c9c:	2800      	cmp	r0, #0
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8001c9e:	bfb4      	ite	lt
 8001ca0:	f8c3 9000 	strlt.w	r9, [r3]
      USBx_INEP(i)->DIEPCTL = 0U;
 8001ca4:	601e      	strge	r6, [r3, #0]
    USBx_INEP(i)->DIEPTSIZ = 0U;
 8001ca6:	611e      	str	r6, [r3, #16]
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 8001ca8:	609f      	str	r7, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001caa:	3201      	adds	r2, #1
 8001cac:	3320      	adds	r3, #32
 8001cae:	4542      	cmp	r2, r8
 8001cb0:	d1f3      	bne.n	8001c9a <USB_DevInit+0x76>
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001cb2:	b1a2      	cbz	r2, 8001cde <USB_DevInit+0xba>
 8001cb4:	f504 6330 	add.w	r3, r4, #2816	; 0xb00
 8001cb8:	2100      	movs	r1, #0
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8001cba:	460f      	mov	r7, r1
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8001cbc:	f04f 4990 	mov.w	r9, #1207959552	; 0x48000000
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 8001cc0:	f04f 08ff 	mov.w	r8, #255	; 0xff
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8001cc4:	681e      	ldr	r6, [r3, #0]
 8001cc6:	2e00      	cmp	r6, #0
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8001cc8:	bfb4      	ite	lt
 8001cca:	f8c3 9000 	strlt.w	r9, [r3]
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8001cce:	601f      	strge	r7, [r3, #0]
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8001cd0:	611f      	str	r7, [r3, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 8001cd2:	f8c3 8008 	str.w	r8, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001cd6:	3101      	adds	r1, #1
 8001cd8:	3320      	adds	r3, #32
 8001cda:	428a      	cmp	r2, r1
 8001cdc:	d1f2      	bne.n	8001cc4 <USB_DevInit+0xa0>
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8001cde:	692b      	ldr	r3, [r5, #16]
 8001ce0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001ce4:	612b      	str	r3, [r5, #16]
  
  if (cfg.dma_enable == 1U)
 8001ce6:	f1ba 0f01 	cmp.w	sl, #1
 8001cea:	d02e      	beq.n	8001d4a <USB_DevInit+0x126>
    
    i= USBx_DEVICE->DTHRCTL;
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 8001cec:	2300      	movs	r3, #0
 8001cee:	61a3      	str	r3, [r4, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 8001cf0:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 8001cf4:	6163      	str	r3, [r4, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 8001cf6:	f1ba 0f00 	cmp.w	sl, #0
 8001cfa:	d103      	bne.n	8001d04 <USB_DevInit+0xe0>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 8001cfc:	69a3      	ldr	r3, [r4, #24]
 8001cfe:	f043 0310 	orr.w	r3, r3, #16
 8001d02:	61a3      	str	r3, [r4, #24]
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 8001d04:	69a2      	ldr	r2, [r4, #24]
 8001d06:	4b1c      	ldr	r3, [pc, #112]	; (8001d78 <USB_DevInit+0x154>)
 8001d08:	4313      	orrs	r3, r2
 8001d0a:	61a3      	str	r3, [r4, #24]
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 8001d0c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8001d0e:	b11b      	cbz	r3, 8001d18 <USB_DevInit+0xf4>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8001d10:	69a3      	ldr	r3, [r4, #24]
 8001d12:	f043 0308 	orr.w	r3, r3, #8
 8001d16:	61a3      	str	r3, [r4, #24]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 8001d18:	f1bb 0f01 	cmp.w	fp, #1
 8001d1c:	d024      	beq.n	8001d68 <USB_DevInit+0x144>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
  }
  
  return HAL_OK;
}
 8001d1e:	2000      	movs	r0, #0
 8001d20:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001d24:	b004      	add	sp, #16
 8001d26:	4770      	bx	lr
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 8001d28:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001d2a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8001d2e:	63a3      	str	r3, [r4, #56]	; 0x38
 8001d30:	e78b      	b.n	8001c4a <USB_DevInit+0x26>
    if(cfg.speed == USB_OTG_SPEED_HIGH)
 8001d32:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001d34:	b923      	cbnz	r3, 8001d40 <USB_DevInit+0x11c>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
 8001d36:	2100      	movs	r1, #0
 8001d38:	4620      	mov	r0, r4
 8001d3a:	f000 f843 	bl	8001dc4 <USB_SetDevSpeed>
 8001d3e:	e794      	b.n	8001c6a <USB_DevInit+0x46>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
 8001d40:	2101      	movs	r1, #1
 8001d42:	4620      	mov	r0, r4
 8001d44:	f000 f83e 	bl	8001dc4 <USB_SetDevSpeed>
 8001d48:	e78f      	b.n	8001c6a <USB_DevInit+0x46>
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 8001d4a:	4b0c      	ldr	r3, [pc, #48]	; (8001d7c <USB_DevInit+0x158>)
 8001d4c:	632b      	str	r3, [r5, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 8001d4e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8001d50:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001d54:	f043 0303 	orr.w	r3, r3, #3
 8001d58:	632b      	str	r3, [r5, #48]	; 0x30
    i= USBx_DEVICE->DTHRCTL;
 8001d5a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  USBx->GINTMSK = 0U;
 8001d5c:	2300      	movs	r3, #0
 8001d5e:	61a3      	str	r3, [r4, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 8001d60:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 8001d64:	6163      	str	r3, [r4, #20]
 8001d66:	e7cd      	b.n	8001d04 <USB_DevInit+0xe0>
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 8001d68:	69a3      	ldr	r3, [r4, #24]
 8001d6a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8001d6e:	f043 0304 	orr.w	r3, r3, #4
 8001d72:	61a3      	str	r3, [r4, #24]
 8001d74:	e7d3      	b.n	8001d1e <USB_DevInit+0xfa>
 8001d76:	bf00      	nop
 8001d78:	803c3800 	.word	0x803c3800
 8001d7c:	00800100 	.word	0x00800100

08001d80 <USB_FlushTxFifo>:
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 8001d80:	0189      	lsls	r1, r1, #6
 8001d82:	f041 0120 	orr.w	r1, r1, #32
 8001d86:	6101      	str	r1, [r0, #16]
 8001d88:	4b05      	ldr	r3, [pc, #20]	; (8001da0 <USB_FlushTxFifo+0x20>)
    if (++count > 200000)
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8001d8a:	6902      	ldr	r2, [r0, #16]
 8001d8c:	f012 0f20 	tst.w	r2, #32
 8001d90:	d003      	beq.n	8001d9a <USB_FlushTxFifo+0x1a>
    if (++count > 200000)
 8001d92:	3b01      	subs	r3, #1
 8001d94:	d1f9      	bne.n	8001d8a <USB_FlushTxFifo+0xa>
      return HAL_TIMEOUT;
 8001d96:	2003      	movs	r0, #3
  
  return HAL_OK;
}
 8001d98:	4770      	bx	lr
  return HAL_OK;
 8001d9a:	2000      	movs	r0, #0
 8001d9c:	4770      	bx	lr
 8001d9e:	bf00      	nop
 8001da0:	00030d40 	.word	0x00030d40

08001da4 <USB_FlushRxFifo>:
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8001da4:	2310      	movs	r3, #16
 8001da6:	6103      	str	r3, [r0, #16]
 8001da8:	4b05      	ldr	r3, [pc, #20]	; (8001dc0 <USB_FlushRxFifo+0x1c>)
    if (++count > 200000)
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8001daa:	6902      	ldr	r2, [r0, #16]
 8001dac:	f012 0f10 	tst.w	r2, #16
 8001db0:	d003      	beq.n	8001dba <USB_FlushRxFifo+0x16>
    if (++count > 200000)
 8001db2:	3b01      	subs	r3, #1
 8001db4:	d1f9      	bne.n	8001daa <USB_FlushRxFifo+0x6>
      return HAL_TIMEOUT;
 8001db6:	2003      	movs	r0, #3
  
  return HAL_OK;
}
 8001db8:	4770      	bx	lr
  return HAL_OK;
 8001dba:	2000      	movs	r0, #0
 8001dbc:	4770      	bx	lr
 8001dbe:	bf00      	nop
 8001dc0:	00030d40 	.word	0x00030d40

08001dc4 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 8001dc4:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8001dc8:	4319      	orrs	r1, r3
 8001dca:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  return HAL_OK;
}
 8001dce:	2000      	movs	r0, #0
 8001dd0:	4770      	bx	lr

08001dd2 <USB_GetDevSpeed>:
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
  uint8_t speed = 0U;
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 8001dd2:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8001dd6:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 8001dda:	f013 0f06 	tst.w	r3, #6
 8001dde:	d011      	beq.n	8001e04 <USB_GetDevSpeed+0x32>
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8001de0:	6883      	ldr	r3, [r0, #8]
 8001de2:	f003 0306 	and.w	r3, r3, #6
 8001de6:	2b02      	cmp	r3, #2
 8001de8:	d00e      	beq.n	8001e08 <USB_GetDevSpeed+0x36>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
 8001dea:	6883      	ldr	r3, [r0, #8]
 8001dec:	f003 0306 	and.w	r3, r3, #6
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8001df0:	2b06      	cmp	r3, #6
 8001df2:	d00b      	beq.n	8001e0c <USB_GetDevSpeed+0x3a>
  {
    speed = USB_OTG_SPEED_FULL;
  }
  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8001df4:	6883      	ldr	r3, [r0, #8]
 8001df6:	f003 0306 	and.w	r3, r3, #6
  {
    speed = USB_OTG_SPEED_LOW;
 8001dfa:	2b04      	cmp	r3, #4
 8001dfc:	bf14      	ite	ne
 8001dfe:	2000      	movne	r0, #0
 8001e00:	2002      	moveq	r0, #2
 8001e02:	4770      	bx	lr
    speed = USB_OTG_SPEED_HIGH;
 8001e04:	2000      	movs	r0, #0
 8001e06:	4770      	bx	lr
    speed = USB_OTG_SPEED_FULL;
 8001e08:	2003      	movs	r0, #3
 8001e0a:	4770      	bx	lr
 8001e0c:	2003      	movs	r0, #3
  }
  
  return speed;
}
 8001e0e:	4770      	bx	lr

08001e10 <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8001e10:	b430      	push	{r4, r5}
  if (ep->is_in == 1U)
 8001e12:	784b      	ldrb	r3, [r1, #1]
 8001e14:	2b01      	cmp	r3, #1
 8001e16:	d020      	beq.n	8001e5a <USB_ActivateEndpoint+0x4a>
        ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
    } 
  }
  else
  {
     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U);
 8001e18:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 8001e1c:	780d      	ldrb	r5, [r1, #0]
 8001e1e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001e22:	40ab      	lsls	r3, r5
 8001e24:	4323      	orrs	r3, r4
 8001e26:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
     
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8001e2a:	780a      	ldrb	r2, [r1, #0]
 8001e2c:	0152      	lsls	r2, r2, #5
 8001e2e:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
 8001e32:	5813      	ldr	r3, [r2, r0]
 8001e34:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8001e38:	d10c      	bne.n	8001e54 <USB_ActivateEndpoint+0x44>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\
 8001e3a:	5814      	ldr	r4, [r2, r0]
 8001e3c:	688b      	ldr	r3, [r1, #8]
 8001e3e:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8001e42:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001e46:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001e4a:	78c9      	ldrb	r1, [r1, #3]
 8001e4c:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 8001e50:	4323      	orrs	r3, r4
 8001e52:	5013      	str	r3, [r2, r0]
       (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
    } 
  }
  return HAL_OK;
}
 8001e54:	2000      	movs	r0, #0
 8001e56:	bc30      	pop	{r4, r5}
 8001e58:	4770      	bx	lr
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
 8001e5a:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
 8001e5e:	780d      	ldrb	r5, [r1, #0]
 8001e60:	40ab      	lsls	r3, r5
 8001e62:	b29b      	uxth	r3, r3
 8001e64:	4323      	orrs	r3, r4
 8001e66:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8001e6a:	780c      	ldrb	r4, [r1, #0]
 8001e6c:	0162      	lsls	r2, r4, #5
 8001e6e:	f500 6010 	add.w	r0, r0, #2304	; 0x900
 8001e72:	5813      	ldr	r3, [r2, r0]
 8001e74:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8001e78:	d1ec      	bne.n	8001e54 <USB_ActivateEndpoint+0x44>
      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\
 8001e7a:	5815      	ldr	r5, [r2, r0]
 8001e7c:	688b      	ldr	r3, [r1, #8]
 8001e7e:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8001e82:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001e86:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001e8a:	78c9      	ldrb	r1, [r1, #3]
 8001e8c:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 8001e90:	ea43 5384 	orr.w	r3, r3, r4, lsl #22
 8001e94:	432b      	orrs	r3, r5
 8001e96:	5013      	str	r3, [r2, r0]
 8001e98:	e7dc      	b.n	8001e54 <USB_ActivateEndpoint+0x44>
	...

08001e9c <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8001e9c:	b538      	push	{r3, r4, r5, lr}
  uint32_t count = 0U;
  
  /* Disable the IN endpoint */
  if (ep->is_in == 1U)
 8001e9e:	784b      	ldrb	r3, [r1, #1]
 8001ea0:	2b01      	cmp	r3, #1
 8001ea2:	d01d      	beq.n	8001ee0 <USB_DeactivateEndpoint+0x44>
 8001ea4:	f500 6430 	add.w	r4, r0, #2816	; 0xb00
  
  }
  else /* Disable the OUT endpoint */
  {
    
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;  
 8001ea8:	780b      	ldrb	r3, [r1, #0]
 8001eaa:	015b      	lsls	r3, r3, #5
 8001eac:	591a      	ldr	r2, [r3, r4]
 8001eae:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001eb2:	511a      	str	r2, [r3, r4]
    
    /* sets the NAK bit for the OUT endpoint */
    USBx_OUTEP(ep->num)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8001eb4:	780b      	ldrb	r3, [r1, #0]
 8001eb6:	015b      	lsls	r3, r3, #5
 8001eb8:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001ebc:	511a      	str	r2, [r3, r4]
    
    /* Disable OUT endpoint */
    USBx_OUTEP(ep->num)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS;
 8001ebe:	780b      	ldrb	r3, [r1, #0]
 8001ec0:	015b      	lsls	r3, r3, #5
 8001ec2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001ec6:	511a      	str	r2, [r3, r4]
        return HAL_TIMEOUT;
      }
    }
    
    /*Wait for  EPDISD endpoint disabled interrupt*/ 
    while ((USBx_OUTEP(ep->num)->DOEPINT & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS);
 8001ec8:	780b      	ldrb	r3, [r1, #0]
 8001eca:	eb04 1443 	add.w	r4, r4, r3, lsl #5
 8001ece:	4b25      	ldr	r3, [pc, #148]	; (8001f64 <USB_DeactivateEndpoint+0xc8>)
 8001ed0:	68a2      	ldr	r2, [r4, #8]
 8001ed2:	f012 0f10 	tst.w	r2, #16
 8001ed6:	d032      	beq.n	8001f3e <USB_DeactivateEndpoint+0xa2>
      if (++count > 200000U)
 8001ed8:	3b01      	subs	r3, #1
 8001eda:	d1f9      	bne.n	8001ed0 <USB_DeactivateEndpoint+0x34>
        return HAL_TIMEOUT;
 8001edc:	2003      	movs	r0, #3
    
    /* Disable endpoint interrupts */
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));         
  }
  return HAL_OK;
}
 8001ede:	bd38      	pop	{r3, r4, r5, pc}
 8001ee0:	f500 6410 	add.w	r4, r0, #2304	; 0x900
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_USBAEP;  
 8001ee4:	780b      	ldrb	r3, [r1, #0]
 8001ee6:	015b      	lsls	r3, r3, #5
 8001ee8:	591a      	ldr	r2, [r3, r4]
 8001eea:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001eee:	511a      	str	r2, [r3, r4]
    USBx_INEP(ep->num)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8001ef0:	780b      	ldrb	r3, [r1, #0]
 8001ef2:	015b      	lsls	r3, r3, #5
 8001ef4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001ef8:	511a      	str	r2, [r3, r4]
    USBx_INEP(ep->num)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS;
 8001efa:	780b      	ldrb	r3, [r1, #0]
 8001efc:	015b      	lsls	r3, r3, #5
 8001efe:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001f02:	511a      	str	r2, [r3, r4]
    while ((USBx_INEP(ep->num)->DIEPINT & USB_OTG_DIEPCTL_EPDIS) == USB_OTG_DIEPCTL_EPDIS);
 8001f04:	780b      	ldrb	r3, [r1, #0]
 8001f06:	eb04 1443 	add.w	r4, r4, r3, lsl #5
 8001f0a:	4b16      	ldr	r3, [pc, #88]	; (8001f64 <USB_DeactivateEndpoint+0xc8>)
 8001f0c:	68a2      	ldr	r2, [r4, #8]
 8001f0e:	f012 4f80 	tst.w	r2, #1073741824	; 0x40000000
 8001f12:	d003      	beq.n	8001f1c <USB_DeactivateEndpoint+0x80>
      if (++count > 200000U)
 8001f14:	3b01      	subs	r3, #1
 8001f16:	d1f9      	bne.n	8001f0c <USB_DeactivateEndpoint+0x70>
        return HAL_TIMEOUT;
 8001f18:	2003      	movs	r0, #3
 8001f1a:	bd38      	pop	{r3, r4, r5, pc}
 8001f1c:	460d      	mov	r5, r1
 8001f1e:	4604      	mov	r4, r0
    USB_FlushTxFifo(USBx , 0x10U);
 8001f20:	2110      	movs	r1, #16
 8001f22:	f7ff ff2d 	bl	8001d80 <USB_FlushTxFifo>
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));   
 8001f26:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
 8001f2a:	7829      	ldrb	r1, [r5, #0]
 8001f2c:	2301      	movs	r3, #1
 8001f2e:	408b      	lsls	r3, r1
 8001f30:	b29b      	uxth	r3, r3
 8001f32:	ea22 0303 	bic.w	r3, r2, r3
 8001f36:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
  return HAL_OK;
 8001f3a:	2000      	movs	r0, #0
 8001f3c:	bd38      	pop	{r3, r4, r5, pc}
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 8001f3e:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8001f42:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001f46:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));         
 8001f4a:	f8d0 381c 	ldr.w	r3, [r0, #2076]	; 0x81c
 8001f4e:	7809      	ldrb	r1, [r1, #0]
 8001f50:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001f54:	408a      	lsls	r2, r1
 8001f56:	ea23 0302 	bic.w	r3, r3, r2
 8001f5a:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
  return HAL_OK;
 8001f5e:	2000      	movs	r0, #0
 8001f60:	bd38      	pop	{r3, r4, r5, pc}
 8001f62:	bf00      	nop
 8001f64:	00030d40 	.word	0x00030d40

08001f68 <USB_EPStartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8001f68:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001f6a:	b083      	sub	sp, #12
  uint16_t pktcnt = 0U;
  
  /* IN endpoint */
  if (ep->is_in == 1U)
 8001f6c:	784b      	ldrb	r3, [r1, #1]
 8001f6e:	2b01      	cmp	r3, #1
 8001f70:	d035      	beq.n	8001fde <USB_EPStartXfer+0x76>
 8001f72:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */  
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8001f76:	780d      	ldrb	r5, [r1, #0]
 8001f78:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8001f7c:	692c      	ldr	r4, [r5, #16]
 8001f7e:	0ce4      	lsrs	r4, r4, #19
 8001f80:	04e4      	lsls	r4, r4, #19
 8001f82:	612c      	str	r4, [r5, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 8001f84:	780d      	ldrb	r5, [r1, #0]
 8001f86:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8001f8a:	692c      	ldr	r4, [r5, #16]
 8001f8c:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 8001f90:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 8001f94:	612c      	str	r4, [r5, #16]

    if (ep->xfer_len == 0U)
 8001f96:	694c      	ldr	r4, [r1, #20]
 8001f98:	2c00      	cmp	r4, #0
 8001f9a:	f040 80b8 	bne.w	800210e <USB_EPStartXfer+0x1a6>
    {
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8001f9e:	780d      	ldrb	r5, [r1, #0]
 8001fa0:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8001fa4:	692e      	ldr	r6, [r5, #16]
 8001fa6:	688c      	ldr	r4, [r1, #8]
 8001fa8:	f3c4 0412 	ubfx	r4, r4, #0, #19
 8001fac:	4334      	orrs	r4, r6
 8001fae:	612c      	str	r4, [r5, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8001fb0:	780c      	ldrb	r4, [r1, #0]
 8001fb2:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8001fb6:	6925      	ldr	r5, [r4, #16]
 8001fb8:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 8001fbc:	6125      	str	r5, [r4, #16]
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));
    }

    if (dma == 1U)
 8001fbe:	2a01      	cmp	r2, #1
 8001fc0:	f000 80c0 	beq.w	8002144 <USB_EPStartXfer+0x1dc>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
    }
    
    if (ep->type == EP_TYPE_ISOC)
 8001fc4:	78ca      	ldrb	r2, [r1, #3]
 8001fc6:	2a01      	cmp	r2, #1
 8001fc8:	f000 80c2 	beq.w	8002150 <USB_EPStartXfer+0x1e8>
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
      }
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8001fcc:	780a      	ldrb	r2, [r1, #0]
 8001fce:	0152      	lsls	r2, r2, #5
 8001fd0:	58d1      	ldr	r1, [r2, r3]
 8001fd2:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 8001fd6:	50d1      	str	r1, [r2, r3]
  }
  return HAL_OK;
}
 8001fd8:	2000      	movs	r0, #0
 8001fda:	b003      	add	sp, #12
 8001fdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (ep->xfer_len == 0U)
 8001fde:	694b      	ldr	r3, [r1, #20]
 8001fe0:	bb4b      	cbnz	r3, 8002036 <USB_EPStartXfer+0xce>
 8001fe2:	f500 6310 	add.w	r3, r0, #2304	; 0x900
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001fe6:	780d      	ldrb	r5, [r1, #0]
 8001fe8:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8001fec:	692c      	ldr	r4, [r5, #16]
 8001fee:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 8001ff2:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 8001ff6:	612c      	str	r4, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8001ff8:	780c      	ldrb	r4, [r1, #0]
 8001ffa:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8001ffe:	6925      	ldr	r5, [r4, #16]
 8002000:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 8002004:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 8002006:	780c      	ldrb	r4, [r1, #0]
 8002008:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 800200c:	691c      	ldr	r4, [r3, #16]
 800200e:	0ce4      	lsrs	r4, r4, #19
 8002010:	04e4      	lsls	r4, r4, #19
 8002012:	611c      	str	r4, [r3, #16]
    if (dma == 1U)
 8002014:	2a01      	cmp	r2, #1
 8002016:	d03d      	beq.n	8002094 <USB_EPStartXfer+0x12c>
      if (ep->type != EP_TYPE_ISOC)
 8002018:	78cb      	ldrb	r3, [r1, #3]
 800201a:	2b01      	cmp	r3, #1
 800201c:	d066      	beq.n	80020ec <USB_EPStartXfer+0x184>
        if (ep->xfer_len > 0U)
 800201e:	694b      	ldr	r3, [r1, #20]
 8002020:	2b00      	cmp	r3, #0
 8002022:	d041      	beq.n	80020a8 <USB_EPStartXfer+0x140>
          USBx_DEVICE->DIEPEMPMSK |= 1U << ep->num;
 8002024:	f8d0 5834 	ldr.w	r5, [r0, #2100]	; 0x834
 8002028:	780e      	ldrb	r6, [r1, #0]
 800202a:	2301      	movs	r3, #1
 800202c:	40b3      	lsls	r3, r6
 800202e:	432b      	orrs	r3, r5
 8002030:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
 8002034:	e035      	b.n	80020a2 <USB_EPStartXfer+0x13a>
 8002036:	f500 6410 	add.w	r4, r0, #2304	; 0x900
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800203a:	780d      	ldrb	r5, [r1, #0]
 800203c:	eb04 1545 	add.w	r5, r4, r5, lsl #5
 8002040:	692b      	ldr	r3, [r5, #16]
 8002042:	0cdb      	lsrs	r3, r3, #19
 8002044:	04db      	lsls	r3, r3, #19
 8002046:	612b      	str	r3, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8002048:	780d      	ldrb	r5, [r1, #0]
 800204a:	eb04 1545 	add.w	r5, r4, r5, lsl #5
 800204e:	692b      	ldr	r3, [r5, #16]
 8002050:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 8002054:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 8002058:	612b      	str	r3, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;
 800205a:	780e      	ldrb	r6, [r1, #0]
 800205c:	eb04 1646 	add.w	r6, r4, r6, lsl #5
 8002060:	6937      	ldr	r7, [r6, #16]
 8002062:	688d      	ldr	r5, [r1, #8]
 8002064:	694b      	ldr	r3, [r1, #20]
 8002066:	442b      	add	r3, r5
 8002068:	3b01      	subs	r3, #1
 800206a:	fbb3 f3f5 	udiv	r3, r3, r5
 800206e:	4d40      	ldr	r5, [pc, #256]	; (8002170 <USB_EPStartXfer+0x208>)
 8002070:	ea05 43c3 	and.w	r3, r5, r3, lsl #19
 8002074:	433b      	orrs	r3, r7
 8002076:	6133      	str	r3, [r6, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8002078:	780d      	ldrb	r5, [r1, #0]
 800207a:	eb04 1545 	add.w	r5, r4, r5, lsl #5
 800207e:	692e      	ldr	r6, [r5, #16]
 8002080:	694b      	ldr	r3, [r1, #20]
 8002082:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002086:	4333      	orrs	r3, r6
 8002088:	612b      	str	r3, [r5, #16]
      if (ep->type == EP_TYPE_ISOC)
 800208a:	78cb      	ldrb	r3, [r1, #3]
 800208c:	2b01      	cmp	r3, #1
 800208e:	d01e      	beq.n	80020ce <USB_EPStartXfer+0x166>
    if (dma == 1U)
 8002090:	2a01      	cmp	r2, #1
 8002092:	d1c4      	bne.n	800201e <USB_EPStartXfer+0xb6>
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8002094:	780c      	ldrb	r4, [r1, #0]
 8002096:	f500 6310 	add.w	r3, r0, #2304	; 0x900
 800209a:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 800209e:	690c      	ldr	r4, [r1, #16]
 80020a0:	615c      	str	r4, [r3, #20]
    if (ep->type == EP_TYPE_ISOC)
 80020a2:	78cb      	ldrb	r3, [r1, #3]
 80020a4:	2b01      	cmp	r3, #1
 80020a6:	d021      	beq.n	80020ec <USB_EPStartXfer+0x184>
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80020a8:	780b      	ldrb	r3, [r1, #0]
 80020aa:	015b      	lsls	r3, r3, #5
 80020ac:	f500 6510 	add.w	r5, r0, #2304	; 0x900
 80020b0:	595c      	ldr	r4, [r3, r5]
 80020b2:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80020b6:	515c      	str	r4, [r3, r5]
    if (ep->type == EP_TYPE_ISOC)
 80020b8:	78cb      	ldrb	r3, [r1, #3]
 80020ba:	2b01      	cmp	r3, #1
 80020bc:	d18c      	bne.n	8001fd8 <USB_EPStartXfer+0x70>
 80020be:	4614      	mov	r4, r2
      USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
 80020c0:	8a8b      	ldrh	r3, [r1, #20]
 80020c2:	780a      	ldrb	r2, [r1, #0]
 80020c4:	68c9      	ldr	r1, [r1, #12]
 80020c6:	9400      	str	r4, [sp, #0]
 80020c8:	f000 f8ee 	bl	80022a8 <USB_WritePacket>
 80020cc:	e784      	b.n	8001fd8 <USB_EPStartXfer+0x70>
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
 80020ce:	780b      	ldrb	r3, [r1, #0]
 80020d0:	eb04 1343 	add.w	r3, r4, r3, lsl #5
 80020d4:	691d      	ldr	r5, [r3, #16]
 80020d6:	f025 45c0 	bic.w	r5, r5, #1610612736	; 0x60000000
 80020da:	611d      	str	r5, [r3, #16]
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); 
 80020dc:	780b      	ldrb	r3, [r1, #0]
 80020de:	eb04 1443 	add.w	r4, r4, r3, lsl #5
 80020e2:	6923      	ldr	r3, [r4, #16]
 80020e4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80020e8:	6123      	str	r3, [r4, #16]
 80020ea:	e793      	b.n	8002014 <USB_EPStartXfer+0xac>
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 80020ec:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 80020f0:	f413 7f80 	tst.w	r3, #256	; 0x100
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 80020f4:	780b      	ldrb	r3, [r1, #0]
 80020f6:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80020fa:	f500 6510 	add.w	r5, r0, #2304	; 0x900
 80020fe:	595c      	ldr	r4, [r3, r5]
 8002100:	bf0c      	ite	eq
 8002102:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8002106:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
 800210a:	515c      	str	r4, [r3, r5]
 800210c:	e7cc      	b.n	80020a8 <USB_EPStartXfer+0x140>
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
 800210e:	688d      	ldr	r5, [r1, #8]
 8002110:	442c      	add	r4, r5
 8002112:	3c01      	subs	r4, #1
 8002114:	fbb4 f4f5 	udiv	r4, r4, r5
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 8002118:	780e      	ldrb	r6, [r1, #0]
 800211a:	eb03 1646 	add.w	r6, r3, r6, lsl #5
 800211e:	6937      	ldr	r7, [r6, #16]
 8002120:	4d13      	ldr	r5, [pc, #76]	; (8002170 <USB_EPStartXfer+0x208>)
 8002122:	ea05 45c4 	and.w	r5, r5, r4, lsl #19
 8002126:	433d      	orrs	r5, r7
 8002128:	6135      	str	r5, [r6, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));
 800212a:	780e      	ldrb	r6, [r1, #0]
 800212c:	eb03 1646 	add.w	r6, r3, r6, lsl #5
 8002130:	6937      	ldr	r7, [r6, #16]
 8002132:	b2a4      	uxth	r4, r4
 8002134:	688d      	ldr	r5, [r1, #8]
 8002136:	fb05 f404 	mul.w	r4, r5, r4
 800213a:	f3c4 0412 	ubfx	r4, r4, #0, #19
 800213e:	433c      	orrs	r4, r7
 8002140:	6134      	str	r4, [r6, #16]
 8002142:	e73c      	b.n	8001fbe <USB_EPStartXfer+0x56>
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
 8002144:	780a      	ldrb	r2, [r1, #0]
 8002146:	eb03 1242 	add.w	r2, r3, r2, lsl #5
 800214a:	68cc      	ldr	r4, [r1, #12]
 800214c:	6154      	str	r4, [r2, #20]
 800214e:	e739      	b.n	8001fc4 <USB_EPStartXfer+0x5c>
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 8002150:	f8d0 2808 	ldr.w	r2, [r0, #2056]	; 0x808
 8002154:	f412 7f80 	tst.w	r2, #256	; 0x100
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 8002158:	780a      	ldrb	r2, [r1, #0]
 800215a:	ea4f 1242 	mov.w	r2, r2, lsl #5
 800215e:	58d0      	ldr	r0, [r2, r3]
 8002160:	bf0c      	ite	eq
 8002162:	f040 5000 	orreq.w	r0, r0, #536870912	; 0x20000000
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 8002166:	f040 5080 	orrne.w	r0, r0, #268435456	; 0x10000000
 800216a:	50d0      	str	r0, [r2, r3]
 800216c:	e72e      	b.n	8001fcc <USB_EPStartXfer+0x64>
 800216e:	bf00      	nop
 8002170:	1ff80000 	.word	0x1ff80000

08002174 <USB_EP0StartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8002174:	b430      	push	{r4, r5}
  /* IN endpoint */
  if (ep->is_in == 1U)
 8002176:	784b      	ldrb	r3, [r1, #1]
 8002178:	2b01      	cmp	r3, #1
 800217a:	d030      	beq.n	80021de <USB_EP0StartXfer+0x6a>
 800217c:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8002180:	780c      	ldrb	r4, [r1, #0]
 8002182:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 8002186:	6923      	ldr	r3, [r4, #16]
 8002188:	0cdb      	lsrs	r3, r3, #19
 800218a:	04db      	lsls	r3, r3, #19
 800218c:	6123      	str	r3, [r4, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 800218e:	780c      	ldrb	r4, [r1, #0]
 8002190:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 8002194:	6923      	ldr	r3, [r4, #16]
 8002196:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 800219a:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 800219e:	6123      	str	r3, [r4, #16]
      
    if (ep->xfer_len > 0U)
 80021a0:	694b      	ldr	r3, [r1, #20]
 80021a2:	b10b      	cbz	r3, 80021a8 <USB_EP0StartXfer+0x34>
    {
      ep->xfer_len = ep->maxpacket;
 80021a4:	688b      	ldr	r3, [r1, #8]
 80021a6:	614b      	str	r3, [r1, #20]
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 80021a8:	780b      	ldrb	r3, [r1, #0]
 80021aa:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 80021ae:	691c      	ldr	r4, [r3, #16]
 80021b0:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 80021b4:	611c      	str	r4, [r3, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 80021b6:	780c      	ldrb	r4, [r1, #0]
 80021b8:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 80021bc:	6925      	ldr	r5, [r4, #16]
 80021be:	688b      	ldr	r3, [r1, #8]
 80021c0:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80021c4:	432b      	orrs	r3, r5
 80021c6:	6123      	str	r3, [r4, #16]
    

    if (dma == 1U)
 80021c8:	2a01      	cmp	r2, #1
 80021ca:	d067      	beq.n	800229c <USB_EP0StartXfer+0x128>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
    }
    
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
 80021cc:	780b      	ldrb	r3, [r1, #0]
 80021ce:	015b      	lsls	r3, r3, #5
 80021d0:	581a      	ldr	r2, [r3, r0]
 80021d2:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80021d6:	501a      	str	r2, [r3, r0]
  }
  return HAL_OK;
}
 80021d8:	2000      	movs	r0, #0
 80021da:	bc30      	pop	{r4, r5}
 80021dc:	4770      	bx	lr
    if (ep->xfer_len == 0U)
 80021de:	694b      	ldr	r3, [r1, #20]
 80021e0:	bb73      	cbnz	r3, 8002240 <USB_EP0StartXfer+0xcc>
 80021e2:	f500 6310 	add.w	r3, r0, #2304	; 0x900
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 80021e6:	780d      	ldrb	r5, [r1, #0]
 80021e8:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 80021ec:	692c      	ldr	r4, [r5, #16]
 80021ee:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 80021f2:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 80021f6:	612c      	str	r4, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 80021f8:	780c      	ldrb	r4, [r1, #0]
 80021fa:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 80021fe:	6925      	ldr	r5, [r4, #16]
 8002200:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 8002204:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 8002206:	780c      	ldrb	r4, [r1, #0]
 8002208:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 800220c:	691c      	ldr	r4, [r3, #16]
 800220e:	0ce4      	lsrs	r4, r4, #19
 8002210:	04e4      	lsls	r4, r4, #19
 8002212:	611c      	str	r4, [r3, #16]
 8002214:	f500 6510 	add.w	r5, r0, #2304	; 0x900
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);     
 8002218:	780b      	ldrb	r3, [r1, #0]
 800221a:	015b      	lsls	r3, r3, #5
 800221c:	595c      	ldr	r4, [r3, r5]
 800221e:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 8002222:	515c      	str	r4, [r3, r5]
    if (dma == 1)
 8002224:	2a01      	cmp	r2, #1
 8002226:	d033      	beq.n	8002290 <USB_EP0StartXfer+0x11c>
      if (ep->xfer_len > 0U)
 8002228:	694b      	ldr	r3, [r1, #20]
 800222a:	2b00      	cmp	r3, #0
 800222c:	d0d4      	beq.n	80021d8 <USB_EP0StartXfer+0x64>
        USBx_DEVICE->DIEPEMPMSK |= 1U << (ep->num);
 800222e:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 8002232:	7809      	ldrb	r1, [r1, #0]
 8002234:	2301      	movs	r3, #1
 8002236:	408b      	lsls	r3, r1
 8002238:	4313      	orrs	r3, r2
 800223a:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
 800223e:	e7cb      	b.n	80021d8 <USB_EP0StartXfer+0x64>
 8002240:	f500 6310 	add.w	r3, r0, #2304	; 0x900
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8002244:	780d      	ldrb	r5, [r1, #0]
 8002246:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 800224a:	692c      	ldr	r4, [r5, #16]
 800224c:	0ce4      	lsrs	r4, r4, #19
 800224e:	04e4      	lsls	r4, r4, #19
 8002250:	612c      	str	r4, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8002252:	780d      	ldrb	r5, [r1, #0]
 8002254:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 8002258:	692c      	ldr	r4, [r5, #16]
 800225a:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 800225e:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 8002262:	612c      	str	r4, [r5, #16]
      if(ep->xfer_len > ep->maxpacket)
 8002264:	688c      	ldr	r4, [r1, #8]
 8002266:	694d      	ldr	r5, [r1, #20]
 8002268:	42a5      	cmp	r5, r4
        ep->xfer_len = ep->maxpacket;
 800226a:	bf88      	it	hi
 800226c:	614c      	strhi	r4, [r1, #20]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 800226e:	780c      	ldrb	r4, [r1, #0]
 8002270:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8002274:	6925      	ldr	r5, [r4, #16]
 8002276:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800227a:	6125      	str	r5, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 800227c:	780c      	ldrb	r4, [r1, #0]
 800227e:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8002282:	691d      	ldr	r5, [r3, #16]
 8002284:	694c      	ldr	r4, [r1, #20]
 8002286:	f3c4 0412 	ubfx	r4, r4, #0, #19
 800228a:	432c      	orrs	r4, r5
 800228c:	611c      	str	r4, [r3, #16]
 800228e:	e7c1      	b.n	8002214 <USB_EP0StartXfer+0xa0>
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8002290:	780b      	ldrb	r3, [r1, #0]
 8002292:	eb05 1543 	add.w	r5, r5, r3, lsl #5
 8002296:	690b      	ldr	r3, [r1, #16]
 8002298:	616b      	str	r3, [r5, #20]
 800229a:	e79d      	b.n	80021d8 <USB_EP0StartXfer+0x64>
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 800229c:	780b      	ldrb	r3, [r1, #0]
 800229e:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 80022a2:	68ca      	ldr	r2, [r1, #12]
 80022a4:	615a      	str	r2, [r3, #20]
 80022a6:	e791      	b.n	80021cc <USB_EP0StartXfer+0x58>

080022a8 <USB_WritePacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 80022a8:	b410      	push	{r4}
 80022aa:	f89d 4004 	ldrb.w	r4, [sp, #4]
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
 80022ae:	b96c      	cbnz	r4, 80022cc <USB_WritePacket+0x24>
  {
    count32b =  (len + 3U) / 4U;
 80022b0:	1cdc      	adds	r4, r3, #3
    for (i = 0U; i < count32b; i++, src += 4U)
 80022b2:	08a4      	lsrs	r4, r4, #2
 80022b4:	d00a      	beq.n	80022cc <USB_WritePacket+0x24>
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 80022b6:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 80022ba:	eb00 3202 	add.w	r2, r0, r2, lsl #12
 80022be:	2300      	movs	r3, #0
 80022c0:	f851 0b04 	ldr.w	r0, [r1], #4
 80022c4:	6010      	str	r0, [r2, #0]
    for (i = 0U; i < count32b; i++, src += 4U)
 80022c6:	3301      	adds	r3, #1
 80022c8:	429c      	cmp	r4, r3
 80022ca:	d1f9      	bne.n	80022c0 <USB_WritePacket+0x18>
    }
  }
  return HAL_OK;
}
 80022cc:	2000      	movs	r0, #0
 80022ce:	f85d 4b04 	ldr.w	r4, [sp], #4
 80022d2:	4770      	bx	lr

080022d4 <USB_ReadPacket>:
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
  uint32_t i=0U;
  uint32_t count32b = (len + 3U) / 4U;
 80022d4:	3203      	adds	r2, #3
  
  for ( i = 0U; i < count32b; i++, dest += 4U )
 80022d6:	0892      	lsrs	r2, r2, #2
 80022d8:	d00f      	beq.n	80022fa <USB_ReadPacket+0x26>
{
 80022da:	b470      	push	{r4, r5, r6}
  for ( i = 0U; i < count32b; i++, dest += 4U )
 80022dc:	460c      	mov	r4, r1
 80022de:	2300      	movs	r3, #0
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0U);
 80022e0:	f500 5680 	add.w	r6, r0, #4096	; 0x1000
 80022e4:	6835      	ldr	r5, [r6, #0]
 80022e6:	f844 5b04 	str.w	r5, [r4], #4
  for ( i = 0U; i < count32b; i++, dest += 4U )
 80022ea:	3301      	adds	r3, #1
 80022ec:	429a      	cmp	r2, r3
 80022ee:	d1f9      	bne.n	80022e4 <USB_ReadPacket+0x10>
 80022f0:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    
  }
  return ((void *)dest);
}
 80022f4:	4608      	mov	r0, r1
 80022f6:	bc70      	pop	{r4, r5, r6}
 80022f8:	4770      	bx	lr
 80022fa:	4608      	mov	r0, r1
 80022fc:	4770      	bx	lr

080022fe <USB_EPSetStall>:
  * @param  ep pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 80022fe:	784b      	ldrb	r3, [r1, #1]
 8002300:	2b01      	cmp	r3, #1
 8002302:	d012      	beq.n	800232a <USB_EPSetStall+0x2c>
 8002304:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
    } 
    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0U)
 8002308:	780b      	ldrb	r3, [r1, #0]
 800230a:	015b      	lsls	r3, r3, #5
 800230c:	581a      	ldr	r2, [r3, r0]
 800230e:	2a00      	cmp	r2, #0
 8002310:	db03      	blt.n	800231a <USB_EPSetStall+0x1c>
    {
      USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
 8002312:	581a      	ldr	r2, [r3, r0]
 8002314:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8002318:	501a      	str	r2, [r3, r0]
    } 
    USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 800231a:	780b      	ldrb	r3, [r1, #0]
 800231c:	015b      	lsls	r3, r3, #5
 800231e:	581a      	ldr	r2, [r3, r0]
 8002320:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8002324:	501a      	str	r2, [r3, r0]
  }
  return HAL_OK;
}
 8002326:	2000      	movs	r0, #0
 8002328:	4770      	bx	lr
 800232a:	f500 6010 	add.w	r0, r0, #2304	; 0x900
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0U)
 800232e:	780b      	ldrb	r3, [r1, #0]
 8002330:	015b      	lsls	r3, r3, #5
 8002332:	581a      	ldr	r2, [r3, r0]
 8002334:	2a00      	cmp	r2, #0
 8002336:	db03      	blt.n	8002340 <USB_EPSetStall+0x42>
      USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); 
 8002338:	581a      	ldr	r2, [r3, r0]
 800233a:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 800233e:	501a      	str	r2, [r3, r0]
    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8002340:	780b      	ldrb	r3, [r1, #0]
 8002342:	015b      	lsls	r3, r3, #5
 8002344:	581a      	ldr	r2, [r3, r0]
 8002346:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800234a:	501a      	str	r2, [r3, r0]
 800234c:	e7eb      	b.n	8002326 <USB_EPSetStall+0x28>

0800234e <USB_EPClearStall>:
  * @param  ep pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 800234e:	784b      	ldrb	r3, [r1, #1]
 8002350:	2b01      	cmp	r3, #1
 8002352:	d00e      	beq.n	8002372 <USB_EPClearStall+0x24>
 8002354:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }    
  }
  else
  {
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8002358:	780b      	ldrb	r3, [r1, #0]
 800235a:	015b      	lsls	r3, r3, #5
 800235c:	581a      	ldr	r2, [r3, r0]
 800235e:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002362:	501a      	str	r2, [r3, r0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8002364:	78cb      	ldrb	r3, [r1, #3]
 8002366:	3b02      	subs	r3, #2
 8002368:	b2db      	uxtb	r3, r3
 800236a:	2b01      	cmp	r3, #1
 800236c:	d915      	bls.n	800239a <USB_EPClearStall+0x4c>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }    
  }
  return HAL_OK;
}
 800236e:	2000      	movs	r0, #0
 8002370:	4770      	bx	lr
 8002372:	f500 6010 	add.w	r0, r0, #2304	; 0x900
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8002376:	780b      	ldrb	r3, [r1, #0]
 8002378:	015b      	lsls	r3, r3, #5
 800237a:	581a      	ldr	r2, [r3, r0]
 800237c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8002380:	501a      	str	r2, [r3, r0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8002382:	78cb      	ldrb	r3, [r1, #3]
 8002384:	3b02      	subs	r3, #2
 8002386:	b2db      	uxtb	r3, r3
 8002388:	2b01      	cmp	r3, #1
 800238a:	d8f0      	bhi.n	800236e <USB_EPClearStall+0x20>
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 800238c:	780b      	ldrb	r3, [r1, #0]
 800238e:	015b      	lsls	r3, r3, #5
 8002390:	581a      	ldr	r2, [r3, r0]
 8002392:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002396:	501a      	str	r2, [r3, r0]
 8002398:	e7e9      	b.n	800236e <USB_EPClearStall+0x20>
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 800239a:	780b      	ldrb	r3, [r1, #0]
 800239c:	015b      	lsls	r3, r3, #5
 800239e:	581a      	ldr	r2, [r3, r0]
 80023a0:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80023a4:	501a      	str	r2, [r3, r0]
 80023a6:	e7e2      	b.n	800236e <USB_EPClearStall+0x20>

080023a8 <USB_SetDevAddress>:
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
  USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
 80023a8:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80023ac:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80023b0:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= (address << 4U) & USB_OTG_DCFG_DAD ;
 80023b4:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80023b8:	0109      	lsls	r1, r1, #4
 80023ba:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 80023be:	4319      	orrs	r1, r3
 80023c0:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  
  return HAL_OK;  
}
 80023c4:	2000      	movs	r0, #0
 80023c6:	4770      	bx	lr

080023c8 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
{
 80023c8:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
 80023ca:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80023ce:	f023 0302 	bic.w	r3, r3, #2
 80023d2:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 80023d6:	2003      	movs	r0, #3
 80023d8:	f7fe f930 	bl	800063c <HAL_Delay>
  
  return HAL_OK;  
}
 80023dc:	2000      	movs	r0, #0
 80023de:	bd08      	pop	{r3, pc}

080023e0 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
 80023e0:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
 80023e2:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80023e6:	f043 0302 	orr.w	r3, r3, #2
 80023ea:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 80023ee:	2003      	movs	r0, #3
 80023f0:	f7fe f924 	bl	800063c <HAL_Delay>
  
  return HAL_OK;  
}
 80023f4:	2000      	movs	r0, #0
 80023f6:	bd08      	pop	{r3, pc}

080023f8 <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v = 0U;
  
  v = USBx->GINTSTS;
 80023f8:	6942      	ldr	r2, [r0, #20]
  v &= USBx->GINTMSK;
 80023fa:	6980      	ldr	r0, [r0, #24]
  return v;  
}
 80023fc:	4010      	ands	r0, r2
 80023fe:	4770      	bx	lr

08002400 <USB_ReadDevAllOutEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 8002400:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8002404:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  v &= USBx_DEVICE->DAINTMSK;
 8002408:	69c0      	ldr	r0, [r0, #28]
 800240a:	4018      	ands	r0, r3
  return ((v & 0xffff0000U) >> 16U);
}
 800240c:	0c00      	lsrs	r0, r0, #16
 800240e:	4770      	bx	lr

08002410 <USB_ReadDevAllInEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 8002410:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8002414:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  v &= USBx_DEVICE->DAINTMSK;
 8002418:	69c0      	ldr	r0, [r0, #28]
 800241a:	4018      	ands	r0, r3
  return ((v & 0xFFFFU));
}
 800241c:	b280      	uxth	r0, r0
 800241e:	4770      	bx	lr

08002420 <USB_ReadDevOutEPInterrupt>:
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 8002420:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 8002424:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 8002428:	688a      	ldr	r2, [r1, #8]
  v &= USBx_DEVICE->DOEPMSK;
 800242a:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 800242e:	6940      	ldr	r0, [r0, #20]
  return v;
}
 8002430:	4010      	ands	r0, r2
 8002432:	4770      	bx	lr

08002434 <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
 8002434:	b410      	push	{r4}
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
 8002436:	f8d0 4810 	ldr.w	r4, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 800243a:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  msk |= ((emp >> epnum) & 0x1U) << 7U;
  v = USBx_INEP(epnum)->DIEPINT & msk;
 800243e:	eb00 1041 	add.w	r0, r0, r1, lsl #5
 8002442:	f500 6010 	add.w	r0, r0, #2304	; 0x900
 8002446:	6880      	ldr	r0, [r0, #8]
  msk |= ((emp >> epnum) & 0x1U) << 7U;
 8002448:	40cb      	lsrs	r3, r1
 800244a:	01db      	lsls	r3, r3, #7
 800244c:	b2db      	uxtb	r3, r3
 800244e:	4323      	orrs	r3, r4
  return v;
}
 8002450:	4018      	ands	r0, r3
 8002452:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002456:	4770      	bx	lr

08002458 <USB_GetMode>:
  *           0 : Host 
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
  return ((USBx->GINTSTS ) & 0x1U);
 8002458:	6940      	ldr	r0, [r0, #20]
}
 800245a:	f000 0001 	and.w	r0, r0, #1
 800245e:	4770      	bx	lr

08002460 <USB_ActivateSetup>:
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
{
  /* Set the MPS of the IN EP based on the enumeration speed */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8002460:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8002464:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8002468:	f023 0307 	bic.w	r3, r3, #7
 800246c:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8002470:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8002474:	689a      	ldr	r2, [r3, #8]
 8002476:	f002 0206 	and.w	r2, r2, #6
 800247a:	2a04      	cmp	r2, #4
 800247c:	d005      	beq.n	800248a <USB_ActivateSetup+0x2a>
  {
    USBx_INEP(0U)->DIEPCTL |= 3U;
  }
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 800247e:	685a      	ldr	r2, [r3, #4]
 8002480:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002484:	605a      	str	r2, [r3, #4]

  return HAL_OK;
}
 8002486:	2000      	movs	r0, #0
 8002488:	4770      	bx	lr
    USBx_INEP(0U)->DIEPCTL |= 3U;
 800248a:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 800248e:	f042 0203 	orr.w	r2, r2, #3
 8002492:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
 8002496:	e7f2      	b.n	800247e <USB_ActivateSetup+0x1e>

08002498 <USB_EP0_OutStart>:
  *           1 : DMA feature used  
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
 8002498:	b410      	push	{r4}
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 800249a:	2400      	movs	r4, #0
 800249c:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
 80024a0:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 80024a4:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 80024a8:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 80024ac:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 80024b0:	f044 0418 	orr.w	r4, r4, #24
 80024b4:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 80024b8:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 80024bc:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
 80024c0:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1U)
 80024c4:	2901      	cmp	r1, #1
 80024c6:	d003      	beq.n	80024d0 <USB_EP0_OutStart+0x38>
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
  }
  
  return HAL_OK;  
}
 80024c8:	2000      	movs	r0, #0
 80024ca:	f85d 4b04 	ldr.w	r4, [sp], #4
 80024ce:	4770      	bx	lr
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 80024d0:	f8c0 2b14 	str.w	r2, [r0, #2836]	; 0xb14
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
 80024d4:	f04f 2380 	mov.w	r3, #2147516416	; 0x80008000
 80024d8:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 80024dc:	e7f4      	b.n	80024c8 <USB_EP0_OutStart+0x30>
	...

080024e0 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 80024e0:	4b0b      	ldr	r3, [pc, #44]	; (8002510 <USB_CoreReset+0x30>)
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80024e2:	6902      	ldr	r2, [r0, #16]
 80024e4:	2a00      	cmp	r2, #0
 80024e6:	db03      	blt.n	80024f0 <USB_CoreReset+0x10>
    if (++count > 200000U)
 80024e8:	3b01      	subs	r3, #1
 80024ea:	d1fa      	bne.n	80024e2 <USB_CoreReset+0x2>
      return HAL_TIMEOUT;
 80024ec:	2003      	movs	r0, #3
 80024ee:	4770      	bx	lr
  
  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 80024f0:	6903      	ldr	r3, [r0, #16]
 80024f2:	f043 0301 	orr.w	r3, r3, #1
 80024f6:	6103      	str	r3, [r0, #16]
 80024f8:	4b05      	ldr	r3, [pc, #20]	; (8002510 <USB_CoreReset+0x30>)
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 80024fa:	6902      	ldr	r2, [r0, #16]
 80024fc:	f012 0f01 	tst.w	r2, #1
 8002500:	d003      	beq.n	800250a <USB_CoreReset+0x2a>
    if (++count > 200000U)
 8002502:	3b01      	subs	r3, #1
 8002504:	d1f9      	bne.n	80024fa <USB_CoreReset+0x1a>
      return HAL_TIMEOUT;
 8002506:	2003      	movs	r0, #3
  
  return HAL_OK;
}
 8002508:	4770      	bx	lr
  return HAL_OK;
 800250a:	2000      	movs	r0, #0
 800250c:	4770      	bx	lr
 800250e:	bf00      	nop
 8002510:	00030d40 	.word	0x00030d40

08002514 <USBD_CDC_GetFSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetFSCfgDesc (uint16_t *length)
{
    *length = sizeof(USBD_CDC_CfgFSDesc);
 8002514:	234b      	movs	r3, #75	; 0x4b
 8002516:	8003      	strh	r3, [r0, #0]
    USBD_CDC_CfgFSDesc[2] = sizeof(USBD_CDC_CfgFSDesc) & 0xFF;
 8002518:	4802      	ldr	r0, [pc, #8]	; (8002524 <USBD_CDC_GetFSCfgDesc+0x10>)
 800251a:	7083      	strb	r3, [r0, #2]
    USBD_CDC_CfgFSDesc[3] = (sizeof(USBD_CDC_CfgFSDesc) >> 8) & 0xFF;
 800251c:	2300      	movs	r3, #0
 800251e:	70c3      	strb	r3, [r0, #3]
    return USBD_CDC_CfgFSDesc;
}
 8002520:	4770      	bx	lr
 8002522:	bf00      	nop
 8002524:	20000040 	.word	0x20000040

08002528 <rndis_iso_out_incomplete>:
{
 8002528:	b508      	push	{r3, lr}
	USBD_LL_PrepareReceive(pdev, RNDIS_DATA_OUT_EP, (uint8_t*)usb_rx_buffer, RNDIS_DATA_OUT_SZ);
 800252a:	2340      	movs	r3, #64	; 0x40
 800252c:	4a02      	ldr	r2, [pc, #8]	; (8002538 <rndis_iso_out_incomplete+0x10>)
 800252e:	2103      	movs	r1, #3
 8002530:	f001 fbfb 	bl	8003d2a <USBD_LL_PrepareReceive>
}
 8002534:	2000      	movs	r0, #0
 8002536:	bd08      	pop	{r3, pc}
 8002538:	20007804 	.word	0x20007804

0800253c <USBD_CDC_DataIn>:
	if (epnum == (RNDIS_DATA_IN_EP & 0x0F))
 800253c:	f001 010f 	and.w	r1, r1, #15
 8002540:	2902      	cmp	r1, #2
 8002542:	d001      	beq.n	8002548 <USBD_CDC_DataIn+0xc>
}
 8002544:	2000      	movs	r0, #0
 8002546:	4770      	bx	lr
{
 8002548:	b570      	push	{r4, r5, r6, lr}
		rndis_first_tx = false;
 800254a:	2500      	movs	r5, #0
 800254c:	4b0f      	ldr	r3, [pc, #60]	; (800258c <USBD_CDC_DataIn+0x50>)
 800254e:	701d      	strb	r5, [r3, #0]
		rndis_sended += sended;
 8002550:	4c0f      	ldr	r4, [pc, #60]	; (8002590 <USBD_CDC_DataIn+0x54>)
 8002552:	6821      	ldr	r1, [r4, #0]
 8002554:	4a0f      	ldr	r2, [pc, #60]	; (8002594 <USBD_CDC_DataIn+0x58>)
 8002556:	6813      	ldr	r3, [r2, #0]
 8002558:	440b      	add	r3, r1
 800255a:	6013      	str	r3, [r2, #0]
		rndis_tx_size -= sended;
 800255c:	4a0e      	ldr	r2, [pc, #56]	; (8002598 <USBD_CDC_DataIn+0x5c>)
 800255e:	6813      	ldr	r3, [r2, #0]
 8002560:	1a5b      	subs	r3, r3, r1
 8002562:	6013      	str	r3, [r2, #0]
		rndis_tx_ptr += sended;
 8002564:	4e0d      	ldr	r6, [pc, #52]	; (800259c <USBD_CDC_DataIn+0x60>)
 8002566:	6832      	ldr	r2, [r6, #0]
 8002568:	440a      	add	r2, r1
 800256a:	6032      	str	r2, [r6, #0]
		sended = 0;
 800256c:	6025      	str	r5, [r4, #0]
	if (sended != 0 || rndis_tx_ptr == NULL || rndis_tx_size <= 0) return USBD_OK;
 800256e:	b15a      	cbz	r2, 8002588 <USBD_CDC_DataIn+0x4c>
 8002570:	42ab      	cmp	r3, r5
 8002572:	dd09      	ble.n	8002588 <USBD_CDC_DataIn+0x4c>
 8002574:	2b40      	cmp	r3, #64	; 0x40
 8002576:	bfa8      	it	ge
 8002578:	2340      	movge	r3, #64	; 0x40
 800257a:	461c      	mov	r4, r3
		USBD_LL_Transmit(pdev,
 800257c:	b29b      	uxth	r3, r3
 800257e:	2182      	movs	r1, #130	; 0x82
 8002580:	f001 fbc6 	bl	8003d10 <USBD_LL_Transmit>
		sended = n;
 8002584:	4b02      	ldr	r3, [pc, #8]	; (8002590 <USBD_CDC_DataIn+0x54>)
 8002586:	601c      	str	r4, [r3, #0]
}
 8002588:	2000      	movs	r0, #0
 800258a:	bd70      	pop	{r4, r5, r6, pc}
 800258c:	2000008b 	.word	0x2000008b
 8002590:	200001cc 	.word	0x200001cc
 8002594:	200001c0 	.word	0x200001c0
 8002598:	200001c8 	.word	0x200001c8
 800259c:	200001c4 	.word	0x200001c4

080025a0 <USBD_CDC_DataOut>:
{
 80025a0:	b570      	push	{r4, r5, r6, lr}
 80025a2:	4606      	mov	r6, r0
 80025a4:	460c      	mov	r4, r1
	 uint32_t receivedLenght = USBD_LL_GetRxDataSize (pdev, epnum);
 80025a6:	f001 fbcd 	bl	8003d44 <USBD_LL_GetRxDataSize>
		if (epnum == RNDIS_DATA_OUT_EP)
 80025aa:	2c03      	cmp	r4, #3
 80025ac:	d001      	beq.n	80025b2 <USBD_CDC_DataOut+0x12>
}
 80025ae:	2000      	movs	r0, #0
 80025b0:	bd70      	pop	{r4, r5, r6, pc}
 80025b2:	4605      	mov	r5, r0
			if (rndis_received + receivedLenght > RNDIS_RX_BUFFER_SIZE)
 80025b4:	4b22      	ldr	r3, [pc, #136]	; (8002640 <USBD_CDC_DataOut+0xa0>)
 80025b6:	681b      	ldr	r3, [r3, #0]
 80025b8:	18c4      	adds	r4, r0, r3
 80025ba:	f240 6216 	movw	r2, #1558	; 0x616
 80025be:	4294      	cmp	r4, r2
 80025c0:	d90d      	bls.n	80025de <USBD_CDC_DataOut+0x3e>
				usb_eth_stat.rxbad++;
 80025c2:	4a20      	ldr	r2, [pc, #128]	; (8002644 <USBD_CDC_DataOut+0xa4>)
 80025c4:	68d3      	ldr	r3, [r2, #12]
 80025c6:	3301      	adds	r3, #1
 80025c8:	60d3      	str	r3, [r2, #12]
				rndis_received = 0;
 80025ca:	2200      	movs	r2, #0
 80025cc:	4b1c      	ldr	r3, [pc, #112]	; (8002640 <USBD_CDC_DataOut+0xa0>)
 80025ce:	601a      	str	r2, [r3, #0]
			USBD_LL_PrepareReceive(pdev,
 80025d0:	2340      	movs	r3, #64	; 0x40
 80025d2:	4a1d      	ldr	r2, [pc, #116]	; (8002648 <USBD_CDC_DataOut+0xa8>)
 80025d4:	2103      	movs	r1, #3
 80025d6:	4630      	mov	r0, r6
 80025d8:	f001 fba7 	bl	8003d2a <USBD_LL_PrepareReceive>
 80025dc:	e7e7      	b.n	80025ae <USBD_CDC_DataOut+0xe>
					memcpy(&rndis_rx_buffer[rndis_received], usb_rx_buffer, receivedLenght);
 80025de:	4602      	mov	r2, r0
 80025e0:	4919      	ldr	r1, [pc, #100]	; (8002648 <USBD_CDC_DataOut+0xa8>)
 80025e2:	481a      	ldr	r0, [pc, #104]	; (800264c <USBD_CDC_DataOut+0xac>)
 80025e4:	4418      	add	r0, r3
 80025e6:	f006 fc68 	bl	8008eba <memcpy>
					rndis_received += receivedLenght;
 80025ea:	4b15      	ldr	r3, [pc, #84]	; (8002640 <USBD_CDC_DataOut+0xa0>)
 80025ec:	601c      	str	r4, [r3, #0]
					if (receivedLenght != RNDIS_DATA_OUT_SZ)
 80025ee:	2d40      	cmp	r5, #64	; 0x40
 80025f0:	d0ee      	beq.n	80025d0 <USBD_CDC_DataOut+0x30>
	if (size < sizeof(rndis_data_packet_t)) return;
 80025f2:	2c2b      	cmp	r4, #43	; 0x2b
 80025f4:	d903      	bls.n	80025fe <USBD_CDC_DataOut+0x5e>
	if (p->MessageType != REMOTE_NDIS_PACKET_MSG || p->MessageLength != size) return;
 80025f6:	4b15      	ldr	r3, [pc, #84]	; (800264c <USBD_CDC_DataOut+0xac>)
 80025f8:	681b      	ldr	r3, [r3, #0]
 80025fa:	2b01      	cmp	r3, #1
 80025fc:	d003      	beq.n	8002606 <USBD_CDC_DataOut+0x66>
						rndis_received = 0;
 80025fe:	2200      	movs	r2, #0
 8002600:	4b0f      	ldr	r3, [pc, #60]	; (8002640 <USBD_CDC_DataOut+0xa0>)
 8002602:	601a      	str	r2, [r3, #0]
 8002604:	e7e4      	b.n	80025d0 <USBD_CDC_DataOut+0x30>
	if (p->MessageType != REMOTE_NDIS_PACKET_MSG || p->MessageLength != size) return;
 8002606:	4b11      	ldr	r3, [pc, #68]	; (800264c <USBD_CDC_DataOut+0xac>)
 8002608:	685b      	ldr	r3, [r3, #4]
 800260a:	429c      	cmp	r4, r3
 800260c:	d1f7      	bne.n	80025fe <USBD_CDC_DataOut+0x5e>
	if (p->DataOffset + offsetof(rndis_data_packet_t, DataOffset) + p->DataLength != size)
 800260e:	4b0f      	ldr	r3, [pc, #60]	; (800264c <USBD_CDC_DataOut+0xac>)
 8002610:	689a      	ldr	r2, [r3, #8]
 8002612:	68d9      	ldr	r1, [r3, #12]
 8002614:	1853      	adds	r3, r2, r1
 8002616:	3308      	adds	r3, #8
 8002618:	429c      	cmp	r4, r3
 800261a:	d004      	beq.n	8002626 <USBD_CDC_DataOut+0x86>
		usb_eth_stat.rxbad++;
 800261c:	4a09      	ldr	r2, [pc, #36]	; (8002644 <USBD_CDC_DataOut+0xa4>)
 800261e:	68d3      	ldr	r3, [r2, #12]
 8002620:	3301      	adds	r3, #1
 8002622:	60d3      	str	r3, [r2, #12]
 8002624:	e7eb      	b.n	80025fe <USBD_CDC_DataOut+0x5e>
	usb_eth_stat.rxok++;
 8002626:	4807      	ldr	r0, [pc, #28]	; (8002644 <USBD_CDC_DataOut+0xa4>)
 8002628:	6843      	ldr	r3, [r0, #4]
 800262a:	3301      	adds	r3, #1
 800262c:	6043      	str	r3, [r0, #4]
	if (rndis_rxproc != NULL)
 800262e:	4b08      	ldr	r3, [pc, #32]	; (8002650 <USBD_CDC_DataOut+0xb0>)
 8002630:	681b      	ldr	r3, [r3, #0]
 8002632:	2b00      	cmp	r3, #0
 8002634:	d0e3      	beq.n	80025fe <USBD_CDC_DataOut+0x5e>
		rndis_rxproc(&rndis_rx_buffer[p->DataOffset + offsetof(rndis_data_packet_t, DataOffset)], p->DataLength);
 8002636:	4807      	ldr	r0, [pc, #28]	; (8002654 <USBD_CDC_DataOut+0xb4>)
 8002638:	4410      	add	r0, r2
 800263a:	4798      	blx	r3
 800263c:	e7df      	b.n	80025fe <USBD_CDC_DataOut+0x5e>
 800263e:	bf00      	nop
 8002640:	200001b8 	.word	0x200001b8
 8002644:	200001d0 	.word	0x200001d0
 8002648:	20007804 	.word	0x20007804
 800264c:	20007844 	.word	0x20007844
 8002650:	200001bc 	.word	0x200001bc
 8002654:	2000784c 	.word	0x2000784c

08002658 <USBD_CDC_Setup>:
{
 8002658:	b508      	push	{r3, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800265a:	780b      	ldrb	r3, [r1, #0]
 800265c:	f003 0260 	and.w	r2, r3, #96	; 0x60
 8002660:	2a20      	cmp	r2, #32
 8002662:	d107      	bne.n	8002674 <USBD_CDC_Setup+0x1c>
    if (req->wLength)
 8002664:	88ca      	ldrh	r2, [r1, #6]
 8002666:	b12a      	cbz	r2, 8002674 <USBD_CDC_Setup+0x1c>
      if (req->bmRequest & 0x80)
 8002668:	f013 0f80 	tst.w	r3, #128	; 0x80
 800266c:	d104      	bne.n	8002678 <USBD_CDC_Setup+0x20>
        USBD_CtlPrepareRx(pdev, encapsulated_buffer, req->wLength);
 800266e:	4905      	ldr	r1, [pc, #20]	; (8002684 <USBD_CDC_Setup+0x2c>)
 8002670:	f000 ff38 	bl	80034e4 <USBD_CtlPrepareRx>
}
 8002674:	2000      	movs	r0, #0
 8002676:	bd08      	pop	{r3, pc}
			USBD_CtlSendData(pdev, encapsulated_buffer, ((rndis_generic_msg_t *)encapsulated_buffer)->MessageLength);
 8002678:	4902      	ldr	r1, [pc, #8]	; (8002684 <USBD_CDC_Setup+0x2c>)
 800267a:	684a      	ldr	r2, [r1, #4]
 800267c:	b292      	uxth	r2, r2
 800267e:	f000 ff1c 	bl	80034ba <USBD_CtlSendData>
 8002682:	e7f7      	b.n	8002674 <USBD_CDC_Setup+0x1c>
 8002684:	20007e5c 	.word	0x20007e5c

08002688 <USBD_CDC_DeInit>:
{
 8002688:	b510      	push	{r4, lr}
 800268a:	4604      	mov	r4, r0
  USBD_LL_CloseEP(pdev,
 800268c:	2181      	movs	r1, #129	; 0x81
 800268e:	f001 faf4 	bl	8003c7a <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev,
 8002692:	2182      	movs	r1, #130	; 0x82
 8002694:	4620      	mov	r0, r4
 8002696:	f001 faf0 	bl	8003c7a <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev,
 800269a:	2103      	movs	r1, #3
 800269c:	4620      	mov	r0, r4
 800269e:	f001 faec 	bl	8003c7a <USBD_LL_CloseEP>
}
 80026a2:	2000      	movs	r0, #0
 80026a4:	bd10      	pop	{r4, pc}
	...

080026a8 <USBD_CDC_Init>:
{
 80026a8:	b510      	push	{r4, lr}
 80026aa:	4604      	mov	r4, r0
    USBD_LL_OpenEP(pdev,
 80026ac:	2308      	movs	r3, #8
 80026ae:	2203      	movs	r2, #3
 80026b0:	2181      	movs	r1, #129	; 0x81
 80026b2:	f001 fad2 	bl	8003c5a <USBD_LL_OpenEP>
    USBD_LL_OpenEP(pdev,
 80026b6:	2340      	movs	r3, #64	; 0x40
 80026b8:	2202      	movs	r2, #2
 80026ba:	2182      	movs	r1, #130	; 0x82
 80026bc:	4620      	mov	r0, r4
 80026be:	f001 facc 	bl	8003c5a <USBD_LL_OpenEP>
    USBD_LL_OpenEP(pdev,
 80026c2:	2340      	movs	r3, #64	; 0x40
 80026c4:	2202      	movs	r2, #2
 80026c6:	2103      	movs	r1, #3
 80026c8:	4620      	mov	r0, r4
 80026ca:	f001 fac6 	bl	8003c5a <USBD_LL_OpenEP>
    USBD_LL_PrepareReceive(pdev,
 80026ce:	2340      	movs	r3, #64	; 0x40
 80026d0:	4a03      	ldr	r2, [pc, #12]	; (80026e0 <USBD_CDC_Init+0x38>)
 80026d2:	2103      	movs	r1, #3
 80026d4:	4620      	mov	r0, r4
 80026d6:	f001 fb28 	bl	8003d2a <USBD_LL_PrepareReceive>
}
 80026da:	2000      	movs	r0, #0
 80026dc:	bd10      	pop	{r4, pc}
 80026de:	bf00      	nop
 80026e0:	20007804 	.word	0x20007804

080026e4 <rndis_iso_in_incomplete>:
{
 80026e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (sended != 0 || rndis_tx_ptr == NULL || rndis_tx_size <= 0) return USBD_OK;
 80026e6:	4b21      	ldr	r3, [pc, #132]	; (800276c <rndis_iso_in_incomplete+0x88>)
 80026e8:	681b      	ldr	r3, [r3, #0]
 80026ea:	b9a3      	cbnz	r3, 8002716 <rndis_iso_in_incomplete+0x32>
 80026ec:	4b20      	ldr	r3, [pc, #128]	; (8002770 <rndis_iso_in_incomplete+0x8c>)
 80026ee:	681e      	ldr	r6, [r3, #0]
 80026f0:	b18e      	cbz	r6, 8002716 <rndis_iso_in_incomplete+0x32>
 80026f2:	4b20      	ldr	r3, [pc, #128]	; (8002774 <rndis_iso_in_incomplete+0x90>)
 80026f4:	681c      	ldr	r4, [r3, #0]
 80026f6:	2c00      	cmp	r4, #0
 80026f8:	dd0d      	ble.n	8002716 <rndis_iso_in_incomplete+0x32>
 80026fa:	4605      	mov	r5, r0
	if (rndis_first_tx)
 80026fc:	4b1e      	ldr	r3, [pc, #120]	; (8002778 <rndis_iso_in_incomplete+0x94>)
 80026fe:	781b      	ldrb	r3, [r3, #0]
 8002700:	b95b      	cbnz	r3, 800271a <rndis_iso_in_incomplete+0x36>
 8002702:	2c40      	cmp	r4, #64	; 0x40
 8002704:	bfa8      	it	ge
 8002706:	2440      	movge	r4, #64	; 0x40
		USBD_LL_Transmit(pdev,
 8002708:	b2a3      	uxth	r3, r4
 800270a:	4632      	mov	r2, r6
 800270c:	2182      	movs	r1, #130	; 0x82
 800270e:	f001 faff 	bl	8003d10 <USBD_LL_Transmit>
		sended = n;
 8002712:	4b16      	ldr	r3, [pc, #88]	; (800276c <rndis_iso_in_incomplete+0x88>)
 8002714:	601c      	str	r4, [r3, #0]
}
 8002716:	2000      	movs	r0, #0
 8002718:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		memset(hdr, 0, sizeof(rndis_data_packet_t));
 800271a:	4f18      	ldr	r7, [pc, #96]	; (800277c <rndis_iso_in_incomplete+0x98>)
 800271c:	222c      	movs	r2, #44	; 0x2c
 800271e:	2100      	movs	r1, #0
 8002720:	4638      	mov	r0, r7
 8002722:	f006 fbd5 	bl	8008ed0 <memset>
		hdr->MessageType = REMOTE_NDIS_PACKET_MSG;
 8002726:	2301      	movs	r3, #1
 8002728:	603b      	str	r3, [r7, #0]
		hdr->MessageLength = sizeof(rndis_data_packet_t) + rndis_tx_size;
 800272a:	f104 032c 	add.w	r3, r4, #44	; 0x2c
 800272e:	607b      	str	r3, [r7, #4]
		hdr->DataOffset = sizeof(rndis_data_packet_t) - offsetof(rndis_data_packet_t, DataOffset);
 8002730:	2324      	movs	r3, #36	; 0x24
 8002732:	60bb      	str	r3, [r7, #8]
		hdr->DataLength = rndis_tx_size;
 8002734:	60fc      	str	r4, [r7, #12]
		if (sended > rndis_tx_size) sended = rndis_tx_size;
 8002736:	2c13      	cmp	r4, #19
 8002738:	dc13      	bgt.n	8002762 <rndis_iso_in_incomplete+0x7e>
 800273a:	4b0c      	ldr	r3, [pc, #48]	; (800276c <rndis_iso_in_incomplete+0x88>)
 800273c:	601c      	str	r4, [r3, #0]
		memcpy(first + sizeof(rndis_data_packet_t), rndis_tx_ptr, sended);
 800273e:	4b0b      	ldr	r3, [pc, #44]	; (800276c <rndis_iso_in_incomplete+0x88>)
 8002740:	681c      	ldr	r4, [r3, #0]
 8002742:	4f0e      	ldr	r7, [pc, #56]	; (800277c <rndis_iso_in_incomplete+0x98>)
 8002744:	4622      	mov	r2, r4
 8002746:	4631      	mov	r1, r6
 8002748:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 800274c:	f006 fbb5 	bl	8008eba <memcpy>
		USBD_LL_Transmit(pdev,
 8002750:	f104 032c 	add.w	r3, r4, #44	; 0x2c
 8002754:	b29b      	uxth	r3, r3
 8002756:	463a      	mov	r2, r7
 8002758:	2182      	movs	r1, #130	; 0x82
 800275a:	4628      	mov	r0, r5
 800275c:	f001 fad8 	bl	8003d10 <USBD_LL_Transmit>
 8002760:	e7d9      	b.n	8002716 <rndis_iso_in_incomplete+0x32>
		sended = RNDIS_DATA_IN_SZ - sizeof(rndis_data_packet_t);
 8002762:	2214      	movs	r2, #20
 8002764:	4b01      	ldr	r3, [pc, #4]	; (800276c <rndis_iso_in_incomplete+0x88>)
 8002766:	601a      	str	r2, [r3, #0]
 8002768:	e7e9      	b.n	800273e <rndis_iso_in_incomplete+0x5a>
 800276a:	bf00      	nop
 800276c:	200001cc 	.word	0x200001cc
 8002770:	200001c4 	.word	0x200001c4
 8002774:	200001c8 	.word	0x200001c8
 8002778:	2000008b 	.word	0x2000008b
 800277c:	20000174 	.word	0x20000174

08002780 <usbd_rndis_sof>:
{
 8002780:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (sended != 0 || rndis_tx_ptr == NULL || rndis_tx_size <= 0) return USBD_OK;
 8002782:	4b21      	ldr	r3, [pc, #132]	; (8002808 <usbd_rndis_sof+0x88>)
 8002784:	681b      	ldr	r3, [r3, #0]
 8002786:	b9a3      	cbnz	r3, 80027b2 <usbd_rndis_sof+0x32>
 8002788:	4b20      	ldr	r3, [pc, #128]	; (800280c <usbd_rndis_sof+0x8c>)
 800278a:	681e      	ldr	r6, [r3, #0]
 800278c:	b18e      	cbz	r6, 80027b2 <usbd_rndis_sof+0x32>
 800278e:	4b20      	ldr	r3, [pc, #128]	; (8002810 <usbd_rndis_sof+0x90>)
 8002790:	681c      	ldr	r4, [r3, #0]
 8002792:	2c00      	cmp	r4, #0
 8002794:	dd0d      	ble.n	80027b2 <usbd_rndis_sof+0x32>
 8002796:	4605      	mov	r5, r0
	if (rndis_first_tx)
 8002798:	4b1e      	ldr	r3, [pc, #120]	; (8002814 <usbd_rndis_sof+0x94>)
 800279a:	781b      	ldrb	r3, [r3, #0]
 800279c:	b95b      	cbnz	r3, 80027b6 <usbd_rndis_sof+0x36>
 800279e:	2c40      	cmp	r4, #64	; 0x40
 80027a0:	bfa8      	it	ge
 80027a2:	2440      	movge	r4, #64	; 0x40
		USBD_LL_Transmit(pdev,
 80027a4:	b2a3      	uxth	r3, r4
 80027a6:	4632      	mov	r2, r6
 80027a8:	2182      	movs	r1, #130	; 0x82
 80027aa:	f001 fab1 	bl	8003d10 <USBD_LL_Transmit>
		sended = n;
 80027ae:	4b16      	ldr	r3, [pc, #88]	; (8002808 <usbd_rndis_sof+0x88>)
 80027b0:	601c      	str	r4, [r3, #0]
}
 80027b2:	2000      	movs	r0, #0
 80027b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		memset(hdr, 0, sizeof(rndis_data_packet_t));
 80027b6:	4f18      	ldr	r7, [pc, #96]	; (8002818 <usbd_rndis_sof+0x98>)
 80027b8:	222c      	movs	r2, #44	; 0x2c
 80027ba:	2100      	movs	r1, #0
 80027bc:	4638      	mov	r0, r7
 80027be:	f006 fb87 	bl	8008ed0 <memset>
		hdr->MessageType = REMOTE_NDIS_PACKET_MSG;
 80027c2:	2301      	movs	r3, #1
 80027c4:	603b      	str	r3, [r7, #0]
		hdr->MessageLength = sizeof(rndis_data_packet_t) + rndis_tx_size;
 80027c6:	f104 032c 	add.w	r3, r4, #44	; 0x2c
 80027ca:	607b      	str	r3, [r7, #4]
		hdr->DataOffset = sizeof(rndis_data_packet_t) - offsetof(rndis_data_packet_t, DataOffset);
 80027cc:	2324      	movs	r3, #36	; 0x24
 80027ce:	60bb      	str	r3, [r7, #8]
		hdr->DataLength = rndis_tx_size;
 80027d0:	60fc      	str	r4, [r7, #12]
		if (sended > rndis_tx_size) sended = rndis_tx_size;
 80027d2:	2c13      	cmp	r4, #19
 80027d4:	dc13      	bgt.n	80027fe <usbd_rndis_sof+0x7e>
 80027d6:	4b0c      	ldr	r3, [pc, #48]	; (8002808 <usbd_rndis_sof+0x88>)
 80027d8:	601c      	str	r4, [r3, #0]
		memcpy(first + sizeof(rndis_data_packet_t), rndis_tx_ptr, sended);
 80027da:	4b0b      	ldr	r3, [pc, #44]	; (8002808 <usbd_rndis_sof+0x88>)
 80027dc:	681c      	ldr	r4, [r3, #0]
 80027de:	4f0e      	ldr	r7, [pc, #56]	; (8002818 <usbd_rndis_sof+0x98>)
 80027e0:	4622      	mov	r2, r4
 80027e2:	4631      	mov	r1, r6
 80027e4:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 80027e8:	f006 fb67 	bl	8008eba <memcpy>
		USBD_LL_Transmit(pdev,
 80027ec:	f104 032c 	add.w	r3, r4, #44	; 0x2c
 80027f0:	b29b      	uxth	r3, r3
 80027f2:	463a      	mov	r2, r7
 80027f4:	2182      	movs	r1, #130	; 0x82
 80027f6:	4628      	mov	r0, r5
 80027f8:	f001 fa8a 	bl	8003d10 <USBD_LL_Transmit>
 80027fc:	e7d9      	b.n	80027b2 <usbd_rndis_sof+0x32>
		sended = RNDIS_DATA_IN_SZ - sizeof(rndis_data_packet_t);
 80027fe:	2214      	movs	r2, #20
 8002800:	4b01      	ldr	r3, [pc, #4]	; (8002808 <usbd_rndis_sof+0x88>)
 8002802:	601a      	str	r2, [r3, #0]
 8002804:	e7e9      	b.n	80027da <usbd_rndis_sof+0x5a>
 8002806:	bf00      	nop
 8002808:	200001cc 	.word	0x200001cc
 800280c:	200001c4 	.word	0x200001c4
 8002810:	200001c8 	.word	0x200001c8
 8002814:	2000008b 	.word	0x2000008b
 8002818:	20000174 	.word	0x20000174

0800281c <rndis_query_cmplt32>:
{
 800281c:	b538      	push	{r3, r4, r5, lr}
	c->MessageType = REMOTE_NDIS_QUERY_CMPLT;
 800281e:	4b10      	ldr	r3, [pc, #64]	; (8002860 <rndis_query_cmplt32+0x44>)
 8002820:	2200      	movs	r2, #0
 8002822:	2404      	movs	r4, #4
 8002824:	701c      	strb	r4, [r3, #0]
 8002826:	705a      	strb	r2, [r3, #1]
 8002828:	709a      	strb	r2, [r3, #2]
 800282a:	f06f 057f 	mvn.w	r5, #127	; 0x7f
 800282e:	70dd      	strb	r5, [r3, #3]
	c->MessageLength = sizeof(rndis_query_cmplt_t) + 4;
 8002830:	251c      	movs	r5, #28
 8002832:	711d      	strb	r5, [r3, #4]
 8002834:	715a      	strb	r2, [r3, #5]
 8002836:	719a      	strb	r2, [r3, #6]
 8002838:	71da      	strb	r2, [r3, #7]
	c->InformationBufferLength = 4;
 800283a:	741c      	strb	r4, [r3, #16]
 800283c:	745a      	strb	r2, [r3, #17]
 800283e:	749a      	strb	r2, [r3, #18]
 8002840:	74da      	strb	r2, [r3, #19]
	c->InformationBufferOffset = 16;
 8002842:	2410      	movs	r4, #16
 8002844:	751c      	strb	r4, [r3, #20]
 8002846:	755a      	strb	r2, [r3, #21]
 8002848:	759a      	strb	r2, [r3, #22]
 800284a:	75da      	strb	r2, [r3, #23]
	c->Status = status;
 800284c:	60d8      	str	r0, [r3, #12]
	*(uint32_t *)(c + 1) = data;
 800284e:	6199      	str	r1, [r3, #24]
	USBD_LL_Transmit(&hUsbDeviceFS,
 8002850:	2308      	movs	r3, #8
 8002852:	4a04      	ldr	r2, [pc, #16]	; (8002864 <rndis_query_cmplt32+0x48>)
 8002854:	2181      	movs	r1, #129	; 0x81
 8002856:	4804      	ldr	r0, [pc, #16]	; (8002868 <rndis_query_cmplt32+0x4c>)
 8002858:	f001 fa5a 	bl	8003d10 <USBD_LL_Transmit>
 800285c:	bd38      	pop	{r3, r4, r5, pc}
 800285e:	bf00      	nop
 8002860:	20007e5c 	.word	0x20007e5c
 8002864:	08008ef8 	.word	0x08008ef8
 8002868:	20007f2c 	.word	0x20007f2c

0800286c <rndis_query_cmplt>:
{
 800286c:	b570      	push	{r4, r5, r6, lr}
	c->MessageType = REMOTE_NDIS_QUERY_CMPLT;
 800286e:	4b0f      	ldr	r3, [pc, #60]	; (80028ac <rndis_query_cmplt+0x40>)
 8002870:	2400      	movs	r4, #0
 8002872:	2604      	movs	r6, #4
 8002874:	701e      	strb	r6, [r3, #0]
 8002876:	705c      	strb	r4, [r3, #1]
 8002878:	709c      	strb	r4, [r3, #2]
 800287a:	f06f 067f 	mvn.w	r6, #127	; 0x7f
 800287e:	70de      	strb	r6, [r3, #3]
	c->MessageLength = sizeof(rndis_query_cmplt_t) + size;
 8002880:	f102 0618 	add.w	r6, r2, #24
 8002884:	605e      	str	r6, [r3, #4]
	c->InformationBufferLength = size;
 8002886:	611a      	str	r2, [r3, #16]
	c->InformationBufferOffset = 16;
 8002888:	2510      	movs	r5, #16
 800288a:	751d      	strb	r5, [r3, #20]
 800288c:	755c      	strb	r4, [r3, #21]
 800288e:	759c      	strb	r4, [r3, #22]
 8002890:	75dc      	strb	r4, [r3, #23]
	c->Status = status;
 8002892:	60d8      	str	r0, [r3, #12]
	memcpy(c + 1, data, size);
 8002894:	f103 0018 	add.w	r0, r3, #24
 8002898:	f006 fb0f 	bl	8008eba <memcpy>
	USBD_LL_Transmit(&hUsbDeviceFS,
 800289c:	2308      	movs	r3, #8
 800289e:	4a04      	ldr	r2, [pc, #16]	; (80028b0 <rndis_query_cmplt+0x44>)
 80028a0:	2181      	movs	r1, #129	; 0x81
 80028a2:	4804      	ldr	r0, [pc, #16]	; (80028b4 <rndis_query_cmplt+0x48>)
 80028a4:	f001 fa34 	bl	8003d10 <USBD_LL_Transmit>
 80028a8:	bd70      	pop	{r4, r5, r6, pc}
 80028aa:	bf00      	nop
 80028ac:	20007e5c 	.word	0x20007e5c
 80028b0:	08008ef8 	.word	0x08008ef8
 80028b4:	20007f2c 	.word	0x20007f2c

080028b8 <rndis_query>:
{
 80028b8:	b508      	push	{r3, lr}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 80028ba:	4b87      	ldr	r3, [pc, #540]	; (8002ad8 <rndis_query+0x220>)
 80028bc:	68db      	ldr	r3, [r3, #12]
 80028be:	4a87      	ldr	r2, [pc, #540]	; (8002adc <rndis_query+0x224>)
 80028c0:	4293      	cmp	r3, r2
 80028c2:	f000 8090 	beq.w	80029e6 <rndis_query+0x12e>
 80028c6:	d919      	bls.n	80028fc <rndis_query+0x44>
 80028c8:	f1b3 3f01 	cmp.w	r3, #16843009	; 0x1010101
 80028cc:	f000 8091 	beq.w	80029f2 <rndis_query+0x13a>
 80028d0:	d867      	bhi.n	80029a2 <rndis_query+0xea>
 80028d2:	4a83      	ldr	r2, [pc, #524]	; (8002ae0 <rndis_query+0x228>)
 80028d4:	4293      	cmp	r3, r2
 80028d6:	f000 80ed 	beq.w	8002ab4 <rndis_query+0x1fc>
 80028da:	d854      	bhi.n	8002986 <rndis_query+0xce>
 80028dc:	4a81      	ldr	r2, [pc, #516]	; (8002ae4 <rndis_query+0x22c>)
 80028de:	4293      	cmp	r3, r2
 80028e0:	f000 80bf 	beq.w	8002a62 <rndis_query+0x1aa>
 80028e4:	4a80      	ldr	r2, [pc, #512]	; (8002ae8 <rndis_query+0x230>)
 80028e6:	4293      	cmp	r3, r2
 80028e8:	f000 80de 	beq.w	8002aa8 <rndis_query+0x1f0>
 80028ec:	4a7f      	ldr	r2, [pc, #508]	; (8002aec <rndis_query+0x234>)
 80028ee:	4293      	cmp	r3, r2
 80028f0:	d128      	bne.n	8002944 <rndis_query+0x8c>
		case OID_GEN_PHYSICAL_MEDIUM:        rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, NDIS_MEDIUM_802_3); return;
 80028f2:	2100      	movs	r1, #0
 80028f4:	4608      	mov	r0, r1
 80028f6:	f7ff ff91 	bl	800281c <rndis_query_cmplt32>
 80028fa:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 80028fc:	3a0c      	subs	r2, #12
 80028fe:	4293      	cmp	r3, r2
 8002900:	f000 80a4 	beq.w	8002a4c <rndis_query+0x194>
 8002904:	d910      	bls.n	8002928 <rndis_query+0x70>
 8002906:	4a7a      	ldr	r2, [pc, #488]	; (8002af0 <rndis_query+0x238>)
 8002908:	4293      	cmp	r3, r2
 800290a:	f000 8093 	beq.w	8002a34 <rndis_query+0x17c>
 800290e:	d82a      	bhi.n	8002966 <rndis_query+0xae>
 8002910:	3a02      	subs	r2, #2
 8002912:	4293      	cmp	r3, r2
 8002914:	f000 8082 	beq.w	8002a1c <rndis_query+0x164>
 8002918:	f200 8086 	bhi.w	8002a28 <rndis_query+0x170>
		case OID_GEN_RECEIVE_BLOCK_SIZE:     rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, ETH_MAX_PACKET_SIZE); return;
 800291c:	f240 51ea 	movw	r1, #1514	; 0x5ea
 8002920:	2000      	movs	r0, #0
 8002922:	f7ff ff7b 	bl	800281c <rndis_query_cmplt32>
 8002926:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 8002928:	3a07      	subs	r2, #7
 800292a:	4293      	cmp	r3, r2
 800292c:	d067      	beq.n	80029fe <rndis_query+0x146>
 800292e:	d90f      	bls.n	8002950 <rndis_query+0x98>
 8002930:	4a70      	ldr	r2, [pc, #448]	; (8002af4 <rndis_query+0x23c>)
 8002932:	4293      	cmp	r3, r2
 8002934:	f000 8084 	beq.w	8002a40 <rndis_query+0x188>
 8002938:	3201      	adds	r2, #1
 800293a:	4293      	cmp	r3, r2
 800293c:	d069      	beq.n	8002a12 <rndis_query+0x15a>
 800293e:	3a03      	subs	r2, #3
 8002940:	4293      	cmp	r3, r2
 8002942:	d061      	beq.n	8002a08 <rndis_query+0x150>
		default:                             rndis_query_cmplt(RNDIS_STATUS_FAILURE, NULL, 0); return;
 8002944:	2200      	movs	r2, #0
 8002946:	4611      	mov	r1, r2
 8002948:	486b      	ldr	r0, [pc, #428]	; (8002af8 <rndis_query+0x240>)
 800294a:	f7ff ff8f 	bl	800286c <rndis_query_cmplt>
 800294e:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 8002950:	3a02      	subs	r2, #2
 8002952:	4293      	cmp	r3, r2
 8002954:	d041      	beq.n	80029da <rndis_query+0x122>
 8002956:	3201      	adds	r2, #1
 8002958:	4293      	cmp	r3, r2
 800295a:	d1f3      	bne.n	8002944 <rndis_query+0x8c>
		case OID_GEN_HARDWARE_STATUS:        rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0); return;
 800295c:	2100      	movs	r1, #0
 800295e:	4608      	mov	r0, r1
 8002960:	f7ff ff5c 	bl	800281c <rndis_query_cmplt32>
 8002964:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 8002966:	4a65      	ldr	r2, [pc, #404]	; (8002afc <rndis_query+0x244>)
 8002968:	4293      	cmp	r3, r2
 800296a:	f000 808e 	beq.w	8002a8a <rndis_query+0x1d2>
 800296e:	3201      	adds	r2, #1
 8002970:	4293      	cmp	r3, r2
 8002972:	d071      	beq.n	8002a58 <rndis_query+0x1a0>
 8002974:	3a03      	subs	r2, #3
 8002976:	4293      	cmp	r3, r2
 8002978:	d1e4      	bne.n	8002944 <rndis_query+0x8c>
		case OID_GEN_MAXIMUM_TOTAL_SIZE:     rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, ETH_MAX_PACKET_SIZE); return;
 800297a:	f240 51ea 	movw	r1, #1514	; 0x5ea
 800297e:	2000      	movs	r0, #0
 8002980:	f7ff ff4c 	bl	800281c <rndis_query_cmplt32>
 8002984:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 8002986:	4a5e      	ldr	r2, [pc, #376]	; (8002b00 <rndis_query+0x248>)
 8002988:	4293      	cmp	r3, r2
 800298a:	f000 8099 	beq.w	8002ac0 <rndis_query+0x208>
 800298e:	f0c0 809d 	bcc.w	8002acc <rndis_query+0x214>
 8002992:	3201      	adds	r2, #1
 8002994:	4293      	cmp	r3, r2
 8002996:	d1d5      	bne.n	8002944 <rndis_query+0x8c>
		case OID_GEN_RCV_NO_BUFFER:          rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0); return;
 8002998:	2100      	movs	r1, #0
 800299a:	4608      	mov	r0, r1
 800299c:	f7ff ff3e 	bl	800281c <rndis_query_cmplt32>
 80029a0:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 80029a2:	4a58      	ldr	r2, [pc, #352]	; (8002b04 <rndis_query+0x24c>)
 80029a4:	4293      	cmp	r3, r2
 80029a6:	d06b      	beq.n	8002a80 <rndis_query+0x1c8>
 80029a8:	d809      	bhi.n	80029be <rndis_query+0x106>
 80029aa:	3a02      	subs	r2, #2
 80029ac:	4293      	cmp	r3, r2
 80029ae:	d062      	beq.n	8002a76 <rndis_query+0x1be>
 80029b0:	d85c      	bhi.n	8002a6c <rndis_query+0x1b4>
		case OID_802_3_CURRENT_ADDRESS:      rndis_query_cmplt(RNDIS_STATUS_SUCCESS, &station_hwaddr, 6); return;
 80029b2:	2206      	movs	r2, #6
 80029b4:	4954      	ldr	r1, [pc, #336]	; (8002b08 <rndis_query+0x250>)
 80029b6:	2000      	movs	r0, #0
 80029b8:	f7ff ff58 	bl	800286c <rndis_query_cmplt>
 80029bc:	bd08      	pop	{r3, pc}
	switch (((rndis_query_msg_t *)encapsulated_buffer)->Oid)
 80029be:	4a53      	ldr	r2, [pc, #332]	; (8002b0c <rndis_query+0x254>)
 80029c0:	4293      	cmp	r3, r2
 80029c2:	d067      	beq.n	8002a94 <rndis_query+0x1dc>
 80029c4:	3201      	adds	r2, #1
 80029c6:	4293      	cmp	r3, r2
 80029c8:	d069      	beq.n	8002a9e <rndis_query+0x1e6>
 80029ca:	3a02      	subs	r2, #2
 80029cc:	4293      	cmp	r3, r2
 80029ce:	d1b9      	bne.n	8002944 <rndis_query+0x8c>
		case OID_802_3_RCV_ERROR_ALIGNMENT:  rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0); return;
 80029d0:	2100      	movs	r1, #0
 80029d2:	4608      	mov	r0, r1
 80029d4:	f7ff ff22 	bl	800281c <rndis_query_cmplt32>
 80029d8:	bd08      	pop	{r3, pc}
		case OID_GEN_SUPPORTED_LIST:         rndis_query_cmplt(RNDIS_STATUS_SUCCESS, OIDSupportedList, 4 * OID_LIST_LENGTH); return;
 80029da:	2258      	movs	r2, #88	; 0x58
 80029dc:	494c      	ldr	r1, [pc, #304]	; (8002b10 <rndis_query+0x258>)
 80029de:	2000      	movs	r0, #0
 80029e0:	f7ff ff44 	bl	800286c <rndis_query_cmplt>
 80029e4:	bd08      	pop	{r3, pc}
		case OID_GEN_VENDOR_DRIVER_VERSION:  rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0x00001000);  return;
 80029e6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80029ea:	2000      	movs	r0, #0
 80029ec:	f7ff ff16 	bl	800281c <rndis_query_cmplt32>
 80029f0:	bd08      	pop	{r3, pc}
		case OID_802_3_PERMANENT_ADDRESS:    rndis_query_cmplt(RNDIS_STATUS_SUCCESS, &permanent_hwaddr, 6); return;
 80029f2:	2206      	movs	r2, #6
 80029f4:	4947      	ldr	r1, [pc, #284]	; (8002b14 <rndis_query+0x25c>)
 80029f6:	2000      	movs	r0, #0
 80029f8:	f7ff ff38 	bl	800286c <rndis_query_cmplt>
 80029fc:	bd08      	pop	{r3, pc}
		case OID_GEN_MEDIA_SUPPORTED:        rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, NDIS_MEDIUM_802_3); return;
 80029fe:	2100      	movs	r1, #0
 8002a00:	4608      	mov	r0, r1
 8002a02:	f7ff ff0b 	bl	800281c <rndis_query_cmplt32>
 8002a06:	bd08      	pop	{r3, pc}
		case OID_GEN_MEDIA_IN_USE:           rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, NDIS_MEDIUM_802_3); return;
 8002a08:	2100      	movs	r1, #0
 8002a0a:	4608      	mov	r0, r1
 8002a0c:	f7ff ff06 	bl	800281c <rndis_query_cmplt32>
 8002a10:	bd08      	pop	{r3, pc}
		case OID_GEN_LINK_SPEED:             rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, RNDIS_LINK_SPEED / 100); return;
 8002a12:	4941      	ldr	r1, [pc, #260]	; (8002b18 <rndis_query+0x260>)
 8002a14:	2000      	movs	r0, #0
 8002a16:	f7ff ff01 	bl	800281c <rndis_query_cmplt32>
 8002a1a:	bd08      	pop	{r3, pc}
		case OID_GEN_VENDOR_ID:              rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0x00FFFFFF); return;
 8002a1c:	f06f 417f 	mvn.w	r1, #4278190080	; 0xff000000
 8002a20:	2000      	movs	r0, #0
 8002a22:	f7ff fefb 	bl	800281c <rndis_query_cmplt32>
 8002a26:	bd08      	pop	{r3, pc}
		case OID_GEN_VENDOR_DESCRIPTION:     rndis_query_cmplt(RNDIS_STATUS_SUCCESS, rndis_vendor, strlen(rndis_vendor) + 1); return;
 8002a28:	2208      	movs	r2, #8
 8002a2a:	493c      	ldr	r1, [pc, #240]	; (8002b1c <rndis_query+0x264>)
 8002a2c:	2000      	movs	r0, #0
 8002a2e:	f7ff ff1d 	bl	800286c <rndis_query_cmplt>
 8002a32:	bd08      	pop	{r3, pc}
		case OID_GEN_CURRENT_PACKET_FILTER:  rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, oid_packet_filter); return;
 8002a34:	4b3a      	ldr	r3, [pc, #232]	; (8002b20 <rndis_query+0x268>)
 8002a36:	6819      	ldr	r1, [r3, #0]
 8002a38:	2000      	movs	r0, #0
 8002a3a:	f7ff feef 	bl	800281c <rndis_query_cmplt32>
 8002a3e:	bd08      	pop	{r3, pc}
		case OID_GEN_MAXIMUM_FRAME_SIZE:     rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, ETH_MAX_PACKET_SIZE - ETH_HEADER_SIZE); return;
 8002a40:	f240 51dc 	movw	r1, #1500	; 0x5dc
 8002a44:	2000      	movs	r0, #0
 8002a46:	f7ff fee9 	bl	800281c <rndis_query_cmplt32>
 8002a4a:	bd08      	pop	{r3, pc}
		case OID_GEN_TRANSMIT_BLOCK_SIZE:    rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, ETH_MAX_PACKET_SIZE); return;
 8002a4c:	f240 51ea 	movw	r1, #1514	; 0x5ea
 8002a50:	2000      	movs	r0, #0
 8002a52:	f7ff fee3 	bl	800281c <rndis_query_cmplt32>
 8002a56:	bd08      	pop	{r3, pc}
		case OID_GEN_MEDIA_CONNECT_STATUS:   rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, NDIS_MEDIA_STATE_CONNECTED); return;
 8002a58:	2100      	movs	r1, #0
 8002a5a:	4608      	mov	r0, r1
 8002a5c:	f7ff fede 	bl	800281c <rndis_query_cmplt32>
 8002a60:	bd08      	pop	{r3, pc}
		case OID_GEN_RNDIS_CONFIG_PARAMETER: rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0); return;
 8002a62:	2100      	movs	r1, #0
 8002a64:	4608      	mov	r0, r1
 8002a66:	f7ff fed9 	bl	800281c <rndis_query_cmplt32>
 8002a6a:	bd08      	pop	{r3, pc}
		case OID_802_3_MAXIMUM_LIST_SIZE:    rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 1); return;
 8002a6c:	2101      	movs	r1, #1
 8002a6e:	2000      	movs	r0, #0
 8002a70:	f7ff fed4 	bl	800281c <rndis_query_cmplt32>
 8002a74:	bd08      	pop	{r3, pc}
		case OID_802_3_MULTICAST_LIST:       rndis_query_cmplt32(RNDIS_STATUS_NOT_SUPPORTED, 0); return;
 8002a76:	2100      	movs	r1, #0
 8002a78:	482a      	ldr	r0, [pc, #168]	; (8002b24 <rndis_query+0x26c>)
 8002a7a:	f7ff fecf 	bl	800281c <rndis_query_cmplt32>
 8002a7e:	bd08      	pop	{r3, pc}
		case OID_802_3_MAC_OPTIONS:          rndis_query_cmplt32(RNDIS_STATUS_NOT_SUPPORTED, 0); return;
 8002a80:	2100      	movs	r1, #0
 8002a82:	4828      	ldr	r0, [pc, #160]	; (8002b24 <rndis_query+0x26c>)
 8002a84:	f7ff feca 	bl	800281c <rndis_query_cmplt32>
 8002a88:	bd08      	pop	{r3, pc}
		case OID_GEN_MAC_OPTIONS:            rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, /*MAC_OPT*/ 0); return;
 8002a8a:	2100      	movs	r1, #0
 8002a8c:	4608      	mov	r0, r1
 8002a8e:	f7ff fec5 	bl	800281c <rndis_query_cmplt32>
 8002a92:	bd08      	pop	{r3, pc}
		case OID_802_3_XMIT_ONE_COLLISION:   rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0); return;
 8002a94:	2100      	movs	r1, #0
 8002a96:	4608      	mov	r0, r1
 8002a98:	f7ff fec0 	bl	800281c <rndis_query_cmplt32>
 8002a9c:	bd08      	pop	{r3, pc}
		case OID_802_3_XMIT_MORE_COLLISIONS: rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, 0); return;
 8002a9e:	2100      	movs	r1, #0
 8002aa0:	4608      	mov	r0, r1
 8002aa2:	f7ff febb 	bl	800281c <rndis_query_cmplt32>
 8002aa6:	bd08      	pop	{r3, pc}
		case OID_GEN_XMIT_OK:                rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, usb_eth_stat.txok); return;
 8002aa8:	4b1f      	ldr	r3, [pc, #124]	; (8002b28 <rndis_query+0x270>)
 8002aaa:	6819      	ldr	r1, [r3, #0]
 8002aac:	2000      	movs	r0, #0
 8002aae:	f7ff feb5 	bl	800281c <rndis_query_cmplt32>
 8002ab2:	bd08      	pop	{r3, pc}
		case OID_GEN_RCV_OK:                 rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, usb_eth_stat.rxok); return;
 8002ab4:	4b1c      	ldr	r3, [pc, #112]	; (8002b28 <rndis_query+0x270>)
 8002ab6:	6859      	ldr	r1, [r3, #4]
 8002ab8:	2000      	movs	r0, #0
 8002aba:	f7ff feaf 	bl	800281c <rndis_query_cmplt32>
 8002abe:	bd08      	pop	{r3, pc}
		case OID_GEN_RCV_ERROR:              rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, usb_eth_stat.rxbad); return;
 8002ac0:	4b19      	ldr	r3, [pc, #100]	; (8002b28 <rndis_query+0x270>)
 8002ac2:	68d9      	ldr	r1, [r3, #12]
 8002ac4:	2000      	movs	r0, #0
 8002ac6:	f7ff fea9 	bl	800281c <rndis_query_cmplt32>
 8002aca:	bd08      	pop	{r3, pc}
		case OID_GEN_XMIT_ERROR:             rndis_query_cmplt32(RNDIS_STATUS_SUCCESS, usb_eth_stat.txbad); return;
 8002acc:	4b16      	ldr	r3, [pc, #88]	; (8002b28 <rndis_query+0x270>)
 8002ace:	6899      	ldr	r1, [r3, #8]
 8002ad0:	2000      	movs	r0, #0
 8002ad2:	f7ff fea3 	bl	800281c <rndis_query_cmplt32>
 8002ad6:	bd08      	pop	{r3, pc}
 8002ad8:	20007e5c 	.word	0x20007e5c
 8002adc:	00010116 	.word	0x00010116
 8002ae0:	00020102 	.word	0x00020102
 8002ae4:	0001021b 	.word	0x0001021b
 8002ae8:	00020101 	.word	0x00020101
 8002aec:	00010202 	.word	0x00010202
 8002af0:	0001010e 	.word	0x0001010e
 8002af4:	00010106 	.word	0x00010106
 8002af8:	c0000001 	.word	0xc0000001
 8002afc:	00010113 	.word	0x00010113
 8002b00:	00020104 	.word	0x00020104
 8002b04:	01010105 	.word	0x01010105
 8002b08:	08008f74 	.word	0x08008f74
 8002b0c:	01020102 	.word	0x01020102
 8002b10:	08008f0c 	.word	0x08008f0c
 8002b14:	08008f64 	.word	0x08008f64
 8002b18:	0001d4c0 	.word	0x0001d4c0
 8002b1c:	08008f6c 	.word	0x08008f6c
 8002b20:	200001b4 	.word	0x200001b4
 8002b24:	c00000bb 	.word	0xc00000bb
 8002b28:	200001d0 	.word	0x200001d0

08002b2c <rndis_handle_set_msg>:
{
 8002b2c:	b510      	push	{r4, lr}
	oid = m->Oid;
 8002b2e:	4b21      	ldr	r3, [pc, #132]	; (8002bb4 <rndis_handle_set_msg+0x88>)
 8002b30:	68d9      	ldr	r1, [r3, #12]
	c->MessageType = REMOTE_NDIS_SET_CMPLT;
 8002b32:	2200      	movs	r2, #0
 8002b34:	2405      	movs	r4, #5
 8002b36:	701c      	strb	r4, [r3, #0]
 8002b38:	705a      	strb	r2, [r3, #1]
 8002b3a:	709a      	strb	r2, [r3, #2]
 8002b3c:	f06f 047f 	mvn.w	r4, #127	; 0x7f
 8002b40:	70dc      	strb	r4, [r3, #3]
	c->MessageLength = sizeof(rndis_set_cmplt_t);
 8002b42:	2410      	movs	r4, #16
 8002b44:	711c      	strb	r4, [r3, #4]
 8002b46:	715a      	strb	r2, [r3, #5]
 8002b48:	719a      	strb	r2, [r3, #6]
 8002b4a:	71da      	strb	r2, [r3, #7]
	c->Status = RNDIS_STATUS_SUCCESS;
 8002b4c:	731a      	strb	r2, [r3, #12]
 8002b4e:	735a      	strb	r2, [r3, #13]
 8002b50:	739a      	strb	r2, [r3, #14]
 8002b52:	73da      	strb	r2, [r3, #15]
	switch (oid)
 8002b54:	4b18      	ldr	r3, [pc, #96]	; (8002bb8 <rndis_handle_set_msg+0x8c>)
 8002b56:	4299      	cmp	r1, r3
 8002b58:	d01a      	beq.n	8002b90 <rndis_handle_set_msg+0x64>
 8002b5a:	d81f      	bhi.n	8002b9c <rndis_handle_set_msg+0x70>
 8002b5c:	3b04      	subs	r3, #4
 8002b5e:	4299      	cmp	r1, r3
 8002b60:	d10a      	bne.n	8002b78 <rndis_handle_set_msg+0x4c>
			oid_packet_filter = *INFBUF;
 8002b62:	4b14      	ldr	r3, [pc, #80]	; (8002bb4 <rndis_handle_set_msg+0x88>)
 8002b64:	695a      	ldr	r2, [r3, #20]
 8002b66:	3308      	adds	r3, #8
 8002b68:	58d3      	ldr	r3, [r2, r3]
 8002b6a:	4a14      	ldr	r2, [pc, #80]	; (8002bbc <rndis_handle_set_msg+0x90>)
 8002b6c:	6013      	str	r3, [r2, #0]
			if (oid_packet_filter)
 8002b6e:	b1e3      	cbz	r3, 8002baa <rndis_handle_set_msg+0x7e>
				rndis_state = rndis_data_initialized;
 8002b70:	2202      	movs	r2, #2
 8002b72:	4b13      	ldr	r3, [pc, #76]	; (8002bc0 <rndis_handle_set_msg+0x94>)
 8002b74:	701a      	strb	r2, [r3, #0]
 8002b76:	e00b      	b.n	8002b90 <rndis_handle_set_msg+0x64>
	switch (oid)
 8002b78:	3301      	adds	r3, #1
 8002b7a:	4299      	cmp	r1, r3
 8002b7c:	d008      	beq.n	8002b90 <rndis_handle_set_msg+0x64>
			c->Status = RNDIS_STATUS_FAILURE;
 8002b7e:	4b0d      	ldr	r3, [pc, #52]	; (8002bb4 <rndis_handle_set_msg+0x88>)
 8002b80:	2200      	movs	r2, #0
 8002b82:	2101      	movs	r1, #1
 8002b84:	7319      	strb	r1, [r3, #12]
 8002b86:	735a      	strb	r2, [r3, #13]
 8002b88:	739a      	strb	r2, [r3, #14]
 8002b8a:	f06f 023f 	mvn.w	r2, #63	; 0x3f
 8002b8e:	73da      	strb	r2, [r3, #15]
	USBD_LL_Transmit(pdev,
 8002b90:	2308      	movs	r3, #8
 8002b92:	4a0c      	ldr	r2, [pc, #48]	; (8002bc4 <rndis_handle_set_msg+0x98>)
 8002b94:	2181      	movs	r1, #129	; 0x81
 8002b96:	f001 f8bb 	bl	8003d10 <USBD_LL_Transmit>
 8002b9a:	bd10      	pop	{r4, pc}
	switch (oid)
 8002b9c:	4b0a      	ldr	r3, [pc, #40]	; (8002bc8 <rndis_handle_set_msg+0x9c>)
 8002b9e:	4299      	cmp	r1, r3
 8002ba0:	d0f6      	beq.n	8002b90 <rndis_handle_set_msg+0x64>
 8002ba2:	4b0a      	ldr	r3, [pc, #40]	; (8002bcc <rndis_handle_set_msg+0xa0>)
 8002ba4:	4299      	cmp	r1, r3
 8002ba6:	d1ea      	bne.n	8002b7e <rndis_handle_set_msg+0x52>
 8002ba8:	e7f2      	b.n	8002b90 <rndis_handle_set_msg+0x64>
				rndis_state = rndis_initialized;
 8002baa:	2201      	movs	r2, #1
 8002bac:	4b04      	ldr	r3, [pc, #16]	; (8002bc0 <rndis_handle_set_msg+0x94>)
 8002bae:	701a      	strb	r2, [r3, #0]
 8002bb0:	e7ee      	b.n	8002b90 <rndis_handle_set_msg+0x64>
 8002bb2:	bf00      	nop
 8002bb4:	20007e5c 	.word	0x20007e5c
 8002bb8:	00010112 	.word	0x00010112
 8002bbc:	200001b4 	.word	0x200001b4
 8002bc0:	20007ed4 	.word	0x20007ed4
 8002bc4:	08008ef8 	.word	0x08008ef8
 8002bc8:	0001021b 	.word	0x0001021b
 8002bcc:	01010103 	.word	0x01010103

08002bd0 <USBD_CDC_EP0_RxReady>:
{
 8002bd0:	b508      	push	{r3, lr}
  switch (((rndis_generic_msg_t *)encapsulated_buffer)->MessageType)
 8002bd2:	4b4f      	ldr	r3, [pc, #316]	; (8002d10 <USBD_CDC_EP0_RxReady+0x140>)
 8002bd4:	681b      	ldr	r3, [r3, #0]
 8002bd6:	3b02      	subs	r3, #2
 8002bd8:	2b06      	cmp	r3, #6
 8002bda:	d85a      	bhi.n	8002c92 <USBD_CDC_EP0_RxReady+0xc2>
 8002bdc:	e8df f003 	tbb	[pc, r3]
 8002be0:	5e5b5904 	.word	0x5e5b5904
 8002be4:	5961      	.short	0x5961
 8002be6:	80          	.byte	0x80
 8002be7:	00          	.byte	0x00
  				m->MessageType = REMOTE_NDIS_INITIALIZE_CMPLT;
 8002be8:	4b49      	ldr	r3, [pc, #292]	; (8002d10 <USBD_CDC_EP0_RxReady+0x140>)
 8002bea:	2200      	movs	r2, #0
 8002bec:	2102      	movs	r1, #2
 8002bee:	7019      	strb	r1, [r3, #0]
 8002bf0:	705a      	strb	r2, [r3, #1]
 8002bf2:	709a      	strb	r2, [r3, #2]
 8002bf4:	f06f 017f 	mvn.w	r1, #127	; 0x7f
 8002bf8:	70d9      	strb	r1, [r3, #3]
  				m->MessageLength = sizeof(rndis_initialize_cmplt_t);
 8002bfa:	2134      	movs	r1, #52	; 0x34
 8002bfc:	7119      	strb	r1, [r3, #4]
 8002bfe:	715a      	strb	r2, [r3, #5]
 8002c00:	719a      	strb	r2, [r3, #6]
 8002c02:	71da      	strb	r2, [r3, #7]
  				m->MajorVersion = RNDIS_MAJOR_VERSION;
 8002c04:	2101      	movs	r1, #1
 8002c06:	7419      	strb	r1, [r3, #16]
 8002c08:	745a      	strb	r2, [r3, #17]
 8002c0a:	749a      	strb	r2, [r3, #18]
 8002c0c:	74da      	strb	r2, [r3, #19]
  				m->MinorVersion = RNDIS_MINOR_VERSION;
 8002c0e:	751a      	strb	r2, [r3, #20]
 8002c10:	755a      	strb	r2, [r3, #21]
 8002c12:	759a      	strb	r2, [r3, #22]
 8002c14:	75da      	strb	r2, [r3, #23]
  				m->Status = RNDIS_STATUS_SUCCESS;
 8002c16:	731a      	strb	r2, [r3, #12]
 8002c18:	735a      	strb	r2, [r3, #13]
 8002c1a:	739a      	strb	r2, [r3, #14]
 8002c1c:	73da      	strb	r2, [r3, #15]
  				m->DeviceFlags = RNDIS_DF_CONNECTIONLESS;
 8002c1e:	7619      	strb	r1, [r3, #24]
 8002c20:	765a      	strb	r2, [r3, #25]
 8002c22:	769a      	strb	r2, [r3, #26]
 8002c24:	76da      	strb	r2, [r3, #27]
  				m->Medium = RNDIS_MEDIUM_802_3;
 8002c26:	771a      	strb	r2, [r3, #28]
 8002c28:	775a      	strb	r2, [r3, #29]
 8002c2a:	779a      	strb	r2, [r3, #30]
 8002c2c:	77da      	strb	r2, [r3, #31]
  				m->MaxPacketsPerTransfer = 1;
 8002c2e:	f883 1020 	strb.w	r1, [r3, #32]
 8002c32:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 8002c36:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8002c3a:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
  				m->MaxTransferSize = RNDIS_RX_BUFFER_SIZE;
 8002c3e:	2116      	movs	r1, #22
 8002c40:	f883 1024 	strb.w	r1, [r3, #36]	; 0x24
 8002c44:	2106      	movs	r1, #6
 8002c46:	f883 1025 	strb.w	r1, [r3, #37]	; 0x25
 8002c4a:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
 8002c4e:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
  				m->PacketAlignmentFactor = 0;
 8002c52:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 8002c56:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
 8002c5a:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
 8002c5e:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
  				m->AfListOffset = 0;
 8002c62:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
 8002c66:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
 8002c6a:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
 8002c6e:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
  				m->AfListSize = 0;
 8002c72:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
 8002c76:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
 8002c7a:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
 8002c7e:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
  				rndis_state = rndis_initialized;
 8002c82:	2201      	movs	r2, #1
 8002c84:	4b23      	ldr	r3, [pc, #140]	; (8002d14 <USBD_CDC_EP0_RxReady+0x144>)
 8002c86:	701a      	strb	r2, [r3, #0]
  				USBD_LL_Transmit(pdev,
 8002c88:	2308      	movs	r3, #8
 8002c8a:	4a23      	ldr	r2, [pc, #140]	; (8002d18 <USBD_CDC_EP0_RxReady+0x148>)
 8002c8c:	2181      	movs	r1, #129	; 0x81
 8002c8e:	f001 f83f 	bl	8003d10 <USBD_LL_Transmit>
}
 8002c92:	2000      	movs	r0, #0
 8002c94:	bd08      	pop	{r3, pc}
  			rndis_query(pdev);
 8002c96:	f7ff fe0f 	bl	80028b8 <rndis_query>
  			break;
 8002c9a:	e7fa      	b.n	8002c92 <USBD_CDC_EP0_RxReady+0xc2>
  			rndis_handle_set_msg(pdev);
 8002c9c:	f7ff ff46 	bl	8002b2c <rndis_handle_set_msg>
  			break;
 8002ca0:	e7f7      	b.n	8002c92 <USBD_CDC_EP0_RxReady+0xc2>
  				rndis_state = rndis_uninitialized;
 8002ca2:	2200      	movs	r2, #0
 8002ca4:	4b1b      	ldr	r3, [pc, #108]	; (8002d14 <USBD_CDC_EP0_RxReady+0x144>)
 8002ca6:	701a      	strb	r2, [r3, #0]
  				m->MessageType = REMOTE_NDIS_RESET_CMPLT;
 8002ca8:	4b19      	ldr	r3, [pc, #100]	; (8002d10 <USBD_CDC_EP0_RxReady+0x140>)
 8002caa:	2106      	movs	r1, #6
 8002cac:	7019      	strb	r1, [r3, #0]
 8002cae:	705a      	strb	r2, [r3, #1]
 8002cb0:	709a      	strb	r2, [r3, #2]
 8002cb2:	f06f 017f 	mvn.w	r1, #127	; 0x7f
 8002cb6:	70d9      	strb	r1, [r3, #3]
  				m->MessageLength = sizeof(rndis_reset_cmplt_t);
 8002cb8:	2110      	movs	r1, #16
 8002cba:	7119      	strb	r1, [r3, #4]
 8002cbc:	715a      	strb	r2, [r3, #5]
 8002cbe:	719a      	strb	r2, [r3, #6]
 8002cc0:	71da      	strb	r2, [r3, #7]
  				m->Status = RNDIS_STATUS_SUCCESS;
 8002cc2:	721a      	strb	r2, [r3, #8]
 8002cc4:	725a      	strb	r2, [r3, #9]
 8002cc6:	729a      	strb	r2, [r3, #10]
 8002cc8:	72da      	strb	r2, [r3, #11]
  				m->AddressingReset = 1; /* Make it look like we did something */
 8002cca:	2101      	movs	r1, #1
 8002ccc:	7319      	strb	r1, [r3, #12]
 8002cce:	735a      	strb	r2, [r3, #13]
 8002cd0:	739a      	strb	r2, [r3, #14]
 8002cd2:	73da      	strb	r2, [r3, #15]
  				USBD_LL_Transmit(pdev,
 8002cd4:	2308      	movs	r3, #8
 8002cd6:	4a10      	ldr	r2, [pc, #64]	; (8002d18 <USBD_CDC_EP0_RxReady+0x148>)
 8002cd8:	2181      	movs	r1, #129	; 0x81
 8002cda:	f001 f819 	bl	8003d10 <USBD_LL_Transmit>
  			break;
 8002cde:	e7d8      	b.n	8002c92 <USBD_CDC_EP0_RxReady+0xc2>
  				m->MessageType = REMOTE_NDIS_KEEPALIVE_CMPLT;
 8002ce0:	4b0b      	ldr	r3, [pc, #44]	; (8002d10 <USBD_CDC_EP0_RxReady+0x140>)
 8002ce2:	2200      	movs	r2, #0
 8002ce4:	2108      	movs	r1, #8
 8002ce6:	7019      	strb	r1, [r3, #0]
 8002ce8:	705a      	strb	r2, [r3, #1]
 8002cea:	709a      	strb	r2, [r3, #2]
 8002cec:	f06f 017f 	mvn.w	r1, #127	; 0x7f
 8002cf0:	70d9      	strb	r1, [r3, #3]
  				m->MessageLength = sizeof(rndis_keepalive_cmplt_t);
 8002cf2:	2110      	movs	r1, #16
 8002cf4:	7119      	strb	r1, [r3, #4]
 8002cf6:	715a      	strb	r2, [r3, #5]
 8002cf8:	719a      	strb	r2, [r3, #6]
 8002cfa:	71da      	strb	r2, [r3, #7]
  				m->Status = RNDIS_STATUS_SUCCESS;
 8002cfc:	731a      	strb	r2, [r3, #12]
 8002cfe:	735a      	strb	r2, [r3, #13]
 8002d00:	739a      	strb	r2, [r3, #14]
 8002d02:	73da      	strb	r2, [r3, #15]
  			USBD_LL_Transmit(pdev,
 8002d04:	2308      	movs	r3, #8
 8002d06:	4a04      	ldr	r2, [pc, #16]	; (8002d18 <USBD_CDC_EP0_RxReady+0x148>)
 8002d08:	2181      	movs	r1, #129	; 0x81
 8002d0a:	f001 f801 	bl	8003d10 <USBD_LL_Transmit>
  			break;
 8002d0e:	e7c0      	b.n	8002c92 <USBD_CDC_EP0_RxReady+0xc2>
 8002d10:	20007e5c 	.word	0x20007e5c
 8002d14:	20007ed4 	.word	0x20007ed4
 8002d18:	08008ef8 	.word	0x08008ef8

08002d1c <rndis_can_send>:

bool rndis_can_send(void)
{
	return rndis_tx_size <= 0;
 8002d1c:	4b03      	ldr	r3, [pc, #12]	; (8002d2c <rndis_can_send+0x10>)
 8002d1e:	6818      	ldr	r0, [r3, #0]
}
 8002d20:	2800      	cmp	r0, #0
 8002d22:	bfcc      	ite	gt
 8002d24:	2000      	movgt	r0, #0
 8002d26:	2001      	movle	r0, #1
 8002d28:	4770      	bx	lr
 8002d2a:	bf00      	nop
 8002d2c:	200001c8 	.word	0x200001c8

08002d30 <rndis_send>:

bool rndis_send(const void *data, int size)
{
	if (size <= 0 ||
 8002d30:	1e4a      	subs	r2, r1, #1
 8002d32:	f240 53e9 	movw	r3, #1513	; 0x5e9
 8002d36:	429a      	cmp	r2, r3
 8002d38:	d813      	bhi.n	8002d62 <rndis_send+0x32>
		size > ETH_MAX_PACKET_SIZE ||
		rndis_tx_size > 0) return false;
 8002d3a:	4b0b      	ldr	r3, [pc, #44]	; (8002d68 <rndis_send+0x38>)
		size > ETH_MAX_PACKET_SIZE ||
 8002d3c:	681b      	ldr	r3, [r3, #0]
 8002d3e:	2b00      	cmp	r3, #0
 8002d40:	dd01      	ble.n	8002d46 <rndis_send+0x16>
		rndis_tx_size > 0) return false;
 8002d42:	2000      	movs	r0, #0
	rndis_tx_size = size;
	rndis_sended = 0;
	__enable_irq();

	return true;
}
 8002d44:	4770      	bx	lr
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002d46:	b672      	cpsid	i
	rndis_first_tx = true;
 8002d48:	2301      	movs	r3, #1
 8002d4a:	4a08      	ldr	r2, [pc, #32]	; (8002d6c <rndis_send+0x3c>)
 8002d4c:	7013      	strb	r3, [r2, #0]
	rndis_tx_ptr = (uint8_t *)data;
 8002d4e:	4a08      	ldr	r2, [pc, #32]	; (8002d70 <rndis_send+0x40>)
 8002d50:	6010      	str	r0, [r2, #0]
	rndis_tx_size = size;
 8002d52:	4a05      	ldr	r2, [pc, #20]	; (8002d68 <rndis_send+0x38>)
 8002d54:	6011      	str	r1, [r2, #0]
	rndis_sended = 0;
 8002d56:	2100      	movs	r1, #0
 8002d58:	4a06      	ldr	r2, [pc, #24]	; (8002d74 <rndis_send+0x44>)
 8002d5a:	6011      	str	r1, [r2, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8002d5c:	b662      	cpsie	i
	return true;
 8002d5e:	4618      	mov	r0, r3
 8002d60:	4770      	bx	lr
		rndis_tx_size > 0) return false;
 8002d62:	2000      	movs	r0, #0
 8002d64:	4770      	bx	lr
 8002d66:	bf00      	nop
 8002d68:	200001c8 	.word	0x200001c8
 8002d6c:	2000008b 	.word	0x2000008b
 8002d70:	200001c4 	.word	0x200001c4
 8002d74:	200001c0 	.word	0x200001c0

08002d78 <USBD_CDC_RegisterInterface>:
uint8_t  USBD_CDC_RegisterInterface  (USBD_HandleTypeDef   *pdev,
                                      USBD_CDC_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;

  if(fops != NULL)
 8002d78:	b119      	cbz	r1, 8002d82 <USBD_CDC_RegisterInterface+0xa>
  {
    pdev->pUserData= fops;
 8002d7a:	f8c0 121c 	str.w	r1, [r0, #540]	; 0x21c
    ret = USBD_OK;
 8002d7e:	2000      	movs	r0, #0
 8002d80:	4770      	bx	lr
  uint8_t  ret = USBD_FAIL;
 8002d82:	2002      	movs	r0, #2
  }

  return ret;
}
 8002d84:	4770      	bx	lr

08002d86 <USBD_Init>:
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 8002d86:	b198      	cbz	r0, 8002db0 <USBD_Init+0x2a>
{
 8002d88:	b508      	push	{r3, lr}
 8002d8a:	4603      	mov	r3, r0
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 8002d8c:	f8d0 0214 	ldr.w	r0, [r0, #532]	; 0x214
 8002d90:	b110      	cbz	r0, 8002d98 <USBD_Init+0x12>
  {
    pdev->pClass = NULL;
 8002d92:	2000      	movs	r0, #0
 8002d94:	f8c3 0214 	str.w	r0, [r3, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 8002d98:	b109      	cbz	r1, 8002d9e <USBD_Init+0x18>
  {
    pdev->pDesc = pdesc;
 8002d9a:	f8c3 1210 	str.w	r1, [r3, #528]	; 0x210
 8002d9e:	4618      	mov	r0, r3
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 8002da0:	2301      	movs	r3, #1
 8002da2:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  pdev->id = id;
 8002da6:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 8002da8:	f000 ff10 	bl	8003bcc <USBD_LL_Init>
  
  return USBD_OK; 
 8002dac:	2000      	movs	r0, #0
 8002dae:	bd08      	pop	{r3, pc}
    return USBD_FAIL; 
 8002db0:	2002      	movs	r0, #2
 8002db2:	4770      	bx	lr

08002db4 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 8002db4:	b119      	cbz	r1, 8002dbe <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 8002db6:	f8c0 1214 	str.w	r1, [r0, #532]	; 0x214
    status = USBD_OK;
 8002dba:	2000      	movs	r0, #0
 8002dbc:	4770      	bx	lr
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 8002dbe:	2002      	movs	r0, #2
  }
  
  return status;
}
 8002dc0:	4770      	bx	lr

08002dc2 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 8002dc2:	b508      	push	{r3, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 8002dc4:	f000 ff3c 	bl	8003c40 <USBD_LL_Start>
  
  return USBD_OK;  
}
 8002dc8:	2000      	movs	r0, #0
 8002dca:	bd08      	pop	{r3, pc}

08002dcc <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8002dcc:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
 8002dce:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002dd2:	b133      	cbz	r3, 8002de2 <USBD_SetClassConfig+0x16>
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 8002dd4:	681b      	ldr	r3, [r3, #0]
 8002dd6:	4798      	blx	r3
 8002dd8:	2800      	cmp	r0, #0
    {
      ret = USBD_OK;
 8002dda:	bf14      	ite	ne
 8002ddc:	2002      	movne	r0, #2
 8002dde:	2000      	moveq	r0, #0
 8002de0:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef   ret = USBD_FAIL;
 8002de2:	2002      	movs	r0, #2
    }
  }
  return ret; 
}
 8002de4:	bd08      	pop	{r3, pc}

08002de6 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8002de6:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 8002de8:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002dec:	685b      	ldr	r3, [r3, #4]
 8002dee:	4798      	blx	r3
  return USBD_OK;
}
 8002df0:	2000      	movs	r0, #0
 8002df2:	bd08      	pop	{r3, pc}

08002df4 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8002df4:	b538      	push	{r3, r4, r5, lr}
 8002df6:	4604      	mov	r4, r0

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8002df8:	f500 7502 	add.w	r5, r0, #520	; 0x208
 8002dfc:	4628      	mov	r0, r5
 8002dfe:	f000 f904 	bl	800300a <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 8002e02:	2301      	movs	r3, #1
 8002e04:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 8002e08:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
 8002e0c:	f8c4 31f8 	str.w	r3, [r4, #504]	; 0x1f8
  
  switch (pdev->request.bmRequest & 0x1F) 
 8002e10:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
 8002e14:	f001 031f 	and.w	r3, r1, #31
 8002e18:	2b01      	cmp	r3, #1
 8002e1a:	d00e      	beq.n	8002e3a <USBD_LL_SetupStage+0x46>
 8002e1c:	b13b      	cbz	r3, 8002e2e <USBD_LL_SetupStage+0x3a>
 8002e1e:	2b02      	cmp	r3, #2
 8002e20:	d010      	beq.n	8002e44 <USBD_LL_SetupStage+0x50>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 8002e22:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8002e26:	4620      	mov	r0, r4
 8002e28:	f000 ff34 	bl	8003c94 <USBD_LL_StallEP>
    break;
 8002e2c:	e003      	b.n	8002e36 <USBD_LL_SetupStage+0x42>
    USBD_StdDevReq (pdev, &pdev->request);
 8002e2e:	4629      	mov	r1, r5
 8002e30:	4620      	mov	r0, r4
 8002e32:	f000 f909 	bl	8003048 <USBD_StdDevReq>
  }  
  return USBD_OK;  
}
 8002e36:	2000      	movs	r0, #0
 8002e38:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdItfReq(pdev, &pdev->request);
 8002e3a:	4629      	mov	r1, r5
 8002e3c:	4620      	mov	r0, r4
 8002e3e:	f000 fa7b 	bl	8003338 <USBD_StdItfReq>
    break;
 8002e42:	e7f8      	b.n	8002e36 <USBD_LL_SetupStage+0x42>
    USBD_StdEPReq(pdev, &pdev->request);   
 8002e44:	4629      	mov	r1, r5
 8002e46:	4620      	mov	r0, r4
 8002e48:	f000 fa92 	bl	8003370 <USBD_StdEPReq>
    break;
 8002e4c:	e7f3      	b.n	8002e36 <USBD_LL_SetupStage+0x42>

08002e4e <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 8002e4e:	b510      	push	{r4, lr}
 8002e50:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 8002e52:	bb19      	cbnz	r1, 8002e9c <USBD_LL_DataOutStage+0x4e>
 8002e54:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 8002e56:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 8002e5a:	2a03      	cmp	r2, #3
 8002e5c:	d127      	bne.n	8002eae <USBD_LL_DataOutStage+0x60>
    {
      if(pep->rem_length > pep->maxpacket)
 8002e5e:	f8d0 110c 	ldr.w	r1, [r0, #268]	; 0x10c
 8002e62:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
 8002e66:	4291      	cmp	r1, r2
 8002e68:	d80b      	bhi.n	8002e82 <USBD_LL_DataOutStage+0x34>
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
      }
      else
      {
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8002e6a:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002e6e:	691b      	ldr	r3, [r3, #16]
 8002e70:	b11b      	cbz	r3, 8002e7a <USBD_LL_DataOutStage+0x2c>
 8002e72:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8002e76:	2a03      	cmp	r2, #3
 8002e78:	d00e      	beq.n	8002e98 <USBD_LL_DataOutStage+0x4a>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
        {
          pdev->pClass->EP0_RxReady(pdev); 
        }
        USBD_CtlSendStatus(pdev);
 8002e7a:	4620      	mov	r0, r4
 8002e7c:	f000 fb49 	bl	8003512 <USBD_CtlSendStatus>
 8002e80:	e015      	b.n	8002eae <USBD_LL_DataOutStage+0x60>
        pep->rem_length -=  pep->maxpacket;
 8002e82:	1a89      	subs	r1, r1, r2
 8002e84:	f8c0 110c 	str.w	r1, [r0, #268]	; 0x10c
                            MIN(pep->rem_length ,pep->maxpacket));
 8002e88:	428a      	cmp	r2, r1
 8002e8a:	bf28      	it	cs
 8002e8c:	460a      	movcs	r2, r1
        USBD_CtlContinueRx (pdev, 
 8002e8e:	b292      	uxth	r2, r2
 8002e90:	4619      	mov	r1, r3
 8002e92:	f000 fb36 	bl	8003502 <USBD_CtlContinueRx>
 8002e96:	e00a      	b.n	8002eae <USBD_LL_DataOutStage+0x60>
          pdev->pClass->EP0_RxReady(pdev); 
 8002e98:	4798      	blx	r3
 8002e9a:	e7ee      	b.n	8002e7a <USBD_LL_DataOutStage+0x2c>
 8002e9c:	460a      	mov	r2, r1
      }
    }
  }
  else if((pdev->pClass->DataOut != NULL)&&
 8002e9e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002ea2:	699b      	ldr	r3, [r3, #24]
 8002ea4:	b11b      	cbz	r3, 8002eae <USBD_LL_DataOutStage+0x60>
 8002ea6:	f890 11fc 	ldrb.w	r1, [r0, #508]	; 0x1fc
 8002eaa:	2903      	cmp	r1, #3
 8002eac:	d001      	beq.n	8002eb2 <USBD_LL_DataOutStage+0x64>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 8002eae:	2000      	movs	r0, #0
 8002eb0:	bd10      	pop	{r4, pc}
    pdev->pClass->DataOut(pdev, epnum); 
 8002eb2:	4611      	mov	r1, r2
 8002eb4:	4798      	blx	r3
 8002eb6:	e7fa      	b.n	8002eae <USBD_LL_DataOutStage+0x60>

08002eb8 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 8002eb8:	b510      	push	{r4, lr}
 8002eba:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 8002ebc:	2900      	cmp	r1, #0
 8002ebe:	d147      	bne.n	8002f50 <USBD_LL_DataInStage+0x98>
 8002ec0:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 8002ec2:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 8002ec6:	2a02      	cmp	r2, #2
 8002ec8:	d005      	beq.n	8002ed6 <USBD_LL_DataInStage+0x1e>
          }          
          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 8002eca:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8002ece:	2b01      	cmp	r3, #1
 8002ed0:	d03a      	beq.n	8002f48 <USBD_LL_DataInStage+0x90>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 8002ed2:	2000      	movs	r0, #0
 8002ed4:	bd10      	pop	{r4, pc}
      if(pep->rem_length > pep->maxpacket)
 8002ed6:	69c1      	ldr	r1, [r0, #28]
 8002ed8:	6a02      	ldr	r2, [r0, #32]
 8002eda:	4291      	cmp	r1, r2
 8002edc:	d817      	bhi.n	8002f0e <USBD_LL_DataInStage+0x56>
        if((pep->total_length % pep->maxpacket == 0) &&
 8002ede:	6981      	ldr	r1, [r0, #24]
 8002ee0:	fbb1 f3f2 	udiv	r3, r1, r2
 8002ee4:	fb02 1313 	mls	r3, r2, r3, r1
 8002ee8:	b92b      	cbnz	r3, 8002ef6 <USBD_LL_DataInStage+0x3e>
 8002eea:	428a      	cmp	r2, r1
 8002eec:	d803      	bhi.n	8002ef6 <USBD_LL_DataInStage+0x3e>
           (pep->total_length >= pep->maxpacket) &&
 8002eee:	f8d0 31f8 	ldr.w	r3, [r0, #504]	; 0x1f8
 8002ef2:	4299      	cmp	r1, r3
 8002ef4:	d318      	bcc.n	8002f28 <USBD_LL_DataInStage+0x70>
          if((pdev->pClass->EP0_TxSent != NULL)&&
 8002ef6:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8002efa:	68db      	ldr	r3, [r3, #12]
 8002efc:	b11b      	cbz	r3, 8002f06 <USBD_LL_DataInStage+0x4e>
 8002efe:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 8002f02:	2a03      	cmp	r2, #3
 8002f04:	d01d      	beq.n	8002f42 <USBD_LL_DataInStage+0x8a>
          USBD_CtlReceiveStatus(pdev);
 8002f06:	4620      	mov	r0, r4
 8002f08:	f000 fb0e 	bl	8003528 <USBD_CtlReceiveStatus>
 8002f0c:	e7dd      	b.n	8002eca <USBD_LL_DataInStage+0x12>
        pep->rem_length -=  pep->maxpacket;
 8002f0e:	1a8a      	subs	r2, r1, r2
 8002f10:	61c2      	str	r2, [r0, #28]
        USBD_CtlContinueSendData (pdev, 
 8002f12:	b292      	uxth	r2, r2
 8002f14:	4619      	mov	r1, r3
 8002f16:	f000 fadd 	bl	80034d4 <USBD_CtlContinueSendData>
        USBD_LL_PrepareReceive (pdev,
 8002f1a:	2300      	movs	r3, #0
 8002f1c:	461a      	mov	r2, r3
 8002f1e:	4619      	mov	r1, r3
 8002f20:	4620      	mov	r0, r4
 8002f22:	f000 ff02 	bl	8003d2a <USBD_LL_PrepareReceive>
 8002f26:	e7d0      	b.n	8002eca <USBD_LL_DataInStage+0x12>
          USBD_CtlContinueSendData(pdev , NULL, 0);
 8002f28:	2200      	movs	r2, #0
 8002f2a:	4611      	mov	r1, r2
 8002f2c:	f000 fad2 	bl	80034d4 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 8002f30:	2100      	movs	r1, #0
 8002f32:	f8c4 11f8 	str.w	r1, [r4, #504]	; 0x1f8
        USBD_LL_PrepareReceive (pdev,
 8002f36:	460b      	mov	r3, r1
 8002f38:	460a      	mov	r2, r1
 8002f3a:	4620      	mov	r0, r4
 8002f3c:	f000 fef5 	bl	8003d2a <USBD_LL_PrepareReceive>
 8002f40:	e7c3      	b.n	8002eca <USBD_LL_DataInStage+0x12>
            pdev->pClass->EP0_TxSent(pdev); 
 8002f42:	4620      	mov	r0, r4
 8002f44:	4798      	blx	r3
 8002f46:	e7de      	b.n	8002f06 <USBD_LL_DataInStage+0x4e>
      pdev->dev_test_mode = 0;
 8002f48:	2300      	movs	r3, #0
 8002f4a:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
 8002f4e:	e7c0      	b.n	8002ed2 <USBD_LL_DataInStage+0x1a>
 8002f50:	460a      	mov	r2, r1
  else if((pdev->pClass->DataIn != NULL)&& 
 8002f52:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002f56:	695b      	ldr	r3, [r3, #20]
 8002f58:	2b00      	cmp	r3, #0
 8002f5a:	d0ba      	beq.n	8002ed2 <USBD_LL_DataInStage+0x1a>
 8002f5c:	f890 11fc 	ldrb.w	r1, [r0, #508]	; 0x1fc
 8002f60:	2903      	cmp	r1, #3
 8002f62:	d1b6      	bne.n	8002ed2 <USBD_LL_DataInStage+0x1a>
    pdev->pClass->DataIn(pdev, epnum); 
 8002f64:	4611      	mov	r1, r2
 8002f66:	4798      	blx	r3
 8002f68:	e7b3      	b.n	8002ed2 <USBD_LL_DataInStage+0x1a>

08002f6a <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8002f6a:	b538      	push	{r3, r4, r5, lr}
 8002f6c:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 8002f6e:	2340      	movs	r3, #64	; 0x40
 8002f70:	2200      	movs	r2, #0
 8002f72:	4611      	mov	r1, r2
 8002f74:	f000 fe71 	bl	8003c5a <USBD_LL_OpenEP>
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8002f78:	2540      	movs	r5, #64	; 0x40
 8002f7a:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 8002f7e:	462b      	mov	r3, r5
 8002f80:	2200      	movs	r2, #0
 8002f82:	2180      	movs	r1, #128	; 0x80
 8002f84:	4620      	mov	r0, r4
 8002f86:	f000 fe68 	bl	8003c5a <USBD_LL_OpenEP>
              0x80,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8002f8a:	6225      	str	r5, [r4, #32]
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8002f8c:	2301      	movs	r3, #1
 8002f8e:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 8002f92:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 8002f96:	b12b      	cbz	r3, 8002fa4 <USBD_LL_Reset+0x3a>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8002f98:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8002f9c:	685b      	ldr	r3, [r3, #4]
 8002f9e:	7921      	ldrb	r1, [r4, #4]
 8002fa0:	4620      	mov	r0, r4
 8002fa2:	4798      	blx	r3
 
  
  return USBD_OK;
}
 8002fa4:	2000      	movs	r0, #0
 8002fa6:	bd38      	pop	{r3, r4, r5, pc}

08002fa8 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 8002fa8:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 8002faa:	2000      	movs	r0, #0
 8002fac:	4770      	bx	lr

08002fae <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8002fae:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002fb2:	f880 31fd 	strb.w	r3, [r0, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8002fb6:	2304      	movs	r3, #4
 8002fb8:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8002fbc:	2000      	movs	r0, #0
 8002fbe:	4770      	bx	lr

08002fc0 <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;  
 8002fc0:	f890 31fd 	ldrb.w	r3, [r0, #509]	; 0x1fd
 8002fc4:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8002fc8:	2000      	movs	r0, #0
 8002fca:	4770      	bx	lr

08002fcc <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 8002fcc:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8002fce:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002fd2:	2b03      	cmp	r3, #3
 8002fd4:	d001      	beq.n	8002fda <USBD_LL_SOF+0xe>
    {
      pdev->pClass->SOF(pdev);
    }
  }
  return USBD_OK;
}
 8002fd6:	2000      	movs	r0, #0
 8002fd8:	bd08      	pop	{r3, pc}
    if(pdev->pClass->SOF != NULL)
 8002fda:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002fde:	69db      	ldr	r3, [r3, #28]
 8002fe0:	2b00      	cmp	r3, #0
 8002fe2:	d0f8      	beq.n	8002fd6 <USBD_LL_SOF+0xa>
      pdev->pClass->SOF(pdev);
 8002fe4:	4798      	blx	r3
 8002fe6:	e7f6      	b.n	8002fd6 <USBD_LL_SOF+0xa>

08002fe8 <USBD_LL_IsoINIncomplete>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 8002fe8:	2000      	movs	r0, #0
 8002fea:	4770      	bx	lr

08002fec <USBD_LL_IsoOUTIncomplete>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 8002fec:	2000      	movs	r0, #0
 8002fee:	4770      	bx	lr

08002ff0 <USBD_LL_DevConnected>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev)
{
  return USBD_OK;
}
 8002ff0:	2000      	movs	r0, #0
 8002ff2:	4770      	bx	lr

08002ff4 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
 8002ff4:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8002ff6:	2201      	movs	r2, #1
 8002ff8:	f880 21fc 	strb.w	r2, [r0, #508]	; 0x1fc
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8002ffc:	f8d0 2214 	ldr.w	r2, [r0, #532]	; 0x214
 8003000:	6852      	ldr	r2, [r2, #4]
 8003002:	7901      	ldrb	r1, [r0, #4]
 8003004:	4790      	blx	r2
   
  return USBD_OK;
}
 8003006:	2000      	movs	r0, #0
 8003008:	bd08      	pop	{r3, pc}

0800300a <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
 800300a:	780b      	ldrb	r3, [r1, #0]
 800300c:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 800300e:	784b      	ldrb	r3, [r1, #1]
 8003010:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8003012:	78ca      	ldrb	r2, [r1, #3]
 8003014:	788b      	ldrb	r3, [r1, #2]
 8003016:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 800301a:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 800301c:	794a      	ldrb	r2, [r1, #5]
 800301e:	790b      	ldrb	r3, [r1, #4]
 8003020:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8003024:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 8003026:	79ca      	ldrb	r2, [r1, #7]
 8003028:	798b      	ldrb	r3, [r1, #6]
 800302a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 800302e:	80c3      	strh	r3, [r0, #6]
 8003030:	4770      	bx	lr

08003032 <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 8003032:	b510      	push	{r4, lr}
 8003034:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
 8003036:	2180      	movs	r1, #128	; 0x80
 8003038:	f000 fe2c 	bl	8003c94 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 800303c:	2100      	movs	r1, #0
 800303e:	4620      	mov	r0, r4
 8003040:	f000 fe28 	bl	8003c94 <USBD_LL_StallEP>
 8003044:	bd10      	pop	{r4, pc}
	...

08003048 <USBD_StdDevReq>:
{
 8003048:	b570      	push	{r4, r5, r6, lr}
 800304a:	b082      	sub	sp, #8
 800304c:	4605      	mov	r5, r0
 800304e:	460c      	mov	r4, r1
  switch (req->bRequest) 
 8003050:	784b      	ldrb	r3, [r1, #1]
 8003052:	2b09      	cmp	r3, #9
 8003054:	f200 8168 	bhi.w	8003328 <USBD_StdDevReq+0x2e0>
 8003058:	e8df f013 	tbh	[pc, r3, lsl #1]
 800305c:	0150012d 	.word	0x0150012d
 8003060:	01430166 	.word	0x01430166
 8003064:	00a00166 	.word	0x00a00166
 8003068:	0166000a 	.word	0x0166000a
 800306c:	00c40111 	.word	0x00c40111
  switch (req->wValue >> 8)
 8003070:	884a      	ldrh	r2, [r1, #2]
 8003072:	0a13      	lsrs	r3, r2, #8
 8003074:	3b01      	subs	r3, #1
 8003076:	2b06      	cmp	r3, #6
 8003078:	f200 808c 	bhi.w	8003194 <USBD_StdDevReq+0x14c>
 800307c:	e8df f003 	tbb	[pc, r3]
 8003080:	8a321e04 	.word	0x8a321e04
 8003084:	6e8a      	.short	0x6e8a
 8003086:	7b          	.byte	0x7b
 8003087:	00          	.byte	0x00
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8003088:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800308c:	681b      	ldr	r3, [r3, #0]
 800308e:	f10d 0106 	add.w	r1, sp, #6
 8003092:	7c00      	ldrb	r0, [r0, #16]
 8003094:	4798      	blx	r3
  if((len != 0)&& (req->wLength != 0))
 8003096:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 800309a:	2a00      	cmp	r2, #0
 800309c:	f000 8146 	beq.w	800332c <USBD_StdDevReq+0x2e4>
 80030a0:	88e3      	ldrh	r3, [r4, #6]
 80030a2:	2b00      	cmp	r3, #0
 80030a4:	f000 8142 	beq.w	800332c <USBD_StdDevReq+0x2e4>
    len = MIN(len , req->wLength);
 80030a8:	429a      	cmp	r2, r3
 80030aa:	bf28      	it	cs
 80030ac:	461a      	movcs	r2, r3
 80030ae:	f8ad 2006 	strh.w	r2, [sp, #6]
    USBD_CtlSendData (pdev, 
 80030b2:	4601      	mov	r1, r0
 80030b4:	4628      	mov	r0, r5
 80030b6:	f000 fa00 	bl	80034ba <USBD_CtlSendData>
 80030ba:	e137      	b.n	800332c <USBD_StdDevReq+0x2e4>
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 80030bc:	7c03      	ldrb	r3, [r0, #16]
 80030be:	b943      	cbnz	r3, 80030d2 <USBD_StdDevReq+0x8a>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 80030c0:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80030c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80030c6:	f10d 0006 	add.w	r0, sp, #6
 80030ca:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 80030cc:	2302      	movs	r3, #2
 80030ce:	7043      	strb	r3, [r0, #1]
 80030d0:	e7e1      	b.n	8003096 <USBD_StdDevReq+0x4e>
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 80030d2:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80030d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80030d8:	f10d 0006 	add.w	r0, sp, #6
 80030dc:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 80030de:	2302      	movs	r3, #2
 80030e0:	7043      	strb	r3, [r0, #1]
 80030e2:	e7d8      	b.n	8003096 <USBD_StdDevReq+0x4e>
    switch ((uint8_t)(req->wValue))
 80030e4:	b2d2      	uxtb	r2, r2
 80030e6:	2a05      	cmp	r2, #5
 80030e8:	d834      	bhi.n	8003154 <USBD_StdDevReq+0x10c>
 80030ea:	e8df f002 	tbb	[pc, r2]
 80030ee:	0b03      	.short	0x0b03
 80030f0:	2b231b13 	.word	0x2b231b13
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 80030f4:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 80030f8:	685b      	ldr	r3, [r3, #4]
 80030fa:	f10d 0106 	add.w	r1, sp, #6
 80030fe:	7c00      	ldrb	r0, [r0, #16]
 8003100:	4798      	blx	r3
 8003102:	e7c8      	b.n	8003096 <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8003104:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003108:	689b      	ldr	r3, [r3, #8]
 800310a:	f10d 0106 	add.w	r1, sp, #6
 800310e:	7c00      	ldrb	r0, [r0, #16]
 8003110:	4798      	blx	r3
 8003112:	e7c0      	b.n	8003096 <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8003114:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003118:	68db      	ldr	r3, [r3, #12]
 800311a:	f10d 0106 	add.w	r1, sp, #6
 800311e:	7c00      	ldrb	r0, [r0, #16]
 8003120:	4798      	blx	r3
 8003122:	e7b8      	b.n	8003096 <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8003124:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003128:	691b      	ldr	r3, [r3, #16]
 800312a:	f10d 0106 	add.w	r1, sp, #6
 800312e:	7c00      	ldrb	r0, [r0, #16]
 8003130:	4798      	blx	r3
 8003132:	e7b0      	b.n	8003096 <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8003134:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003138:	695b      	ldr	r3, [r3, #20]
 800313a:	f10d 0106 	add.w	r1, sp, #6
 800313e:	7c00      	ldrb	r0, [r0, #16]
 8003140:	4798      	blx	r3
 8003142:	e7a8      	b.n	8003096 <USBD_StdDevReq+0x4e>
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8003144:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003148:	699b      	ldr	r3, [r3, #24]
 800314a:	f10d 0106 	add.w	r1, sp, #6
 800314e:	7c00      	ldrb	r0, [r0, #16]
 8003150:	4798      	blx	r3
 8003152:	e7a0      	b.n	8003096 <USBD_StdDevReq+0x4e>
       USBD_CtlError(pdev , req);
 8003154:	4621      	mov	r1, r4
 8003156:	f7ff ff6c 	bl	8003032 <USBD_CtlError>
 800315a:	e0e7      	b.n	800332c <USBD_StdDevReq+0x2e4>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 800315c:	7c03      	ldrb	r3, [r0, #16]
 800315e:	b933      	cbnz	r3, 800316e <USBD_StdDevReq+0x126>
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8003160:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003164:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003166:	f10d 0006 	add.w	r0, sp, #6
 800316a:	4798      	blx	r3
 800316c:	e793      	b.n	8003096 <USBD_StdDevReq+0x4e>
      USBD_CtlError(pdev , req);
 800316e:	4621      	mov	r1, r4
 8003170:	f7ff ff5f 	bl	8003032 <USBD_CtlError>
 8003174:	e0da      	b.n	800332c <USBD_StdDevReq+0x2e4>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8003176:	7c03      	ldrb	r3, [r0, #16]
 8003178:	b943      	cbnz	r3, 800318c <USBD_StdDevReq+0x144>
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 800317a:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800317e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003180:	f10d 0006 	add.w	r0, sp, #6
 8003184:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8003186:	2307      	movs	r3, #7
 8003188:	7043      	strb	r3, [r0, #1]
 800318a:	e784      	b.n	8003096 <USBD_StdDevReq+0x4e>
      USBD_CtlError(pdev , req);
 800318c:	4621      	mov	r1, r4
 800318e:	f7ff ff50 	bl	8003032 <USBD_CtlError>
 8003192:	e0cb      	b.n	800332c <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);
 8003194:	4621      	mov	r1, r4
 8003196:	f7ff ff4c 	bl	8003032 <USBD_CtlError>
 800319a:	e0c7      	b.n	800332c <USBD_StdDevReq+0x2e4>
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 800319c:	888b      	ldrh	r3, [r1, #4]
 800319e:	b9e3      	cbnz	r3, 80031da <USBD_StdDevReq+0x192>
 80031a0:	88cb      	ldrh	r3, [r1, #6]
 80031a2:	b9d3      	cbnz	r3, 80031da <USBD_StdDevReq+0x192>
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 80031a4:	788e      	ldrb	r6, [r1, #2]
 80031a6:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 80031aa:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80031ae:	2b03      	cmp	r3, #3
 80031b0:	d00c      	beq.n	80031cc <USBD_StdDevReq+0x184>
      pdev->dev_address = dev_addr;
 80031b2:	f880 61fe 	strb.w	r6, [r0, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 80031b6:	4631      	mov	r1, r6
 80031b8:	f000 fd9d 	bl	8003cf6 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 80031bc:	4628      	mov	r0, r5
 80031be:	f000 f9a8 	bl	8003512 <USBD_CtlSendStatus>
      if (dev_addr != 0) 
 80031c2:	b136      	cbz	r6, 80031d2 <USBD_StdDevReq+0x18a>
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 80031c4:	2302      	movs	r3, #2
 80031c6:	f885 31fc 	strb.w	r3, [r5, #508]	; 0x1fc
 80031ca:	e0af      	b.n	800332c <USBD_StdDevReq+0x2e4>
      USBD_CtlError(pdev , req);
 80031cc:	f7ff ff31 	bl	8003032 <USBD_CtlError>
 80031d0:	e0ac      	b.n	800332c <USBD_StdDevReq+0x2e4>
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 80031d2:	2301      	movs	r3, #1
 80031d4:	f885 31fc 	strb.w	r3, [r5, #508]	; 0x1fc
 80031d8:	e0a8      	b.n	800332c <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);                        
 80031da:	4621      	mov	r1, r4
 80031dc:	4628      	mov	r0, r5
 80031de:	f7ff ff28 	bl	8003032 <USBD_CtlError>
 80031e2:	e0a3      	b.n	800332c <USBD_StdDevReq+0x2e4>
  cfgidx = (uint8_t)(req->wValue);                 
 80031e4:	7889      	ldrb	r1, [r1, #2]
 80031e6:	4b53      	ldr	r3, [pc, #332]	; (8003334 <USBD_StdDevReq+0x2ec>)
 80031e8:	7019      	strb	r1, [r3, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 80031ea:	2901      	cmp	r1, #1
 80031ec:	d809      	bhi.n	8003202 <USBD_StdDevReq+0x1ba>
    switch (pdev->dev_state) 
 80031ee:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80031f2:	2b02      	cmp	r3, #2
 80031f4:	d009      	beq.n	800320a <USBD_StdDevReq+0x1c2>
 80031f6:	2b03      	cmp	r3, #3
 80031f8:	d01c      	beq.n	8003234 <USBD_StdDevReq+0x1ec>
       USBD_CtlError(pdev , req);                     
 80031fa:	4621      	mov	r1, r4
 80031fc:	f7ff ff19 	bl	8003032 <USBD_CtlError>
 8003200:	e094      	b.n	800332c <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);                              
 8003202:	4621      	mov	r1, r4
 8003204:	f7ff ff15 	bl	8003032 <USBD_CtlError>
 8003208:	e090      	b.n	800332c <USBD_StdDevReq+0x2e4>
      if (cfgidx) 
 800320a:	b181      	cbz	r1, 800322e <USBD_StdDevReq+0x1e6>
        pdev->dev_config = cfgidx;
 800320c:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 800320e:	2303      	movs	r3, #3
 8003210:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8003214:	f7ff fdda 	bl	8002dcc <USBD_SetClassConfig>
 8003218:	2802      	cmp	r0, #2
 800321a:	d003      	beq.n	8003224 <USBD_StdDevReq+0x1dc>
        USBD_CtlSendStatus(pdev);
 800321c:	4628      	mov	r0, r5
 800321e:	f000 f978 	bl	8003512 <USBD_CtlSendStatus>
 8003222:	e083      	b.n	800332c <USBD_StdDevReq+0x2e4>
          USBD_CtlError(pdev , req);  
 8003224:	4621      	mov	r1, r4
 8003226:	4628      	mov	r0, r5
 8003228:	f7ff ff03 	bl	8003032 <USBD_CtlError>
 800322c:	e07e      	b.n	800332c <USBD_StdDevReq+0x2e4>
         USBD_CtlSendStatus(pdev);
 800322e:	f000 f970 	bl	8003512 <USBD_CtlSendStatus>
 8003232:	e07b      	b.n	800332c <USBD_StdDevReq+0x2e4>
      if (cfgidx == 0) 
 8003234:	b189      	cbz	r1, 800325a <USBD_StdDevReq+0x212>
      else  if (cfgidx != pdev->dev_config) 
 8003236:	6843      	ldr	r3, [r0, #4]
 8003238:	4299      	cmp	r1, r3
 800323a:	d01d      	beq.n	8003278 <USBD_StdDevReq+0x230>
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 800323c:	b2d9      	uxtb	r1, r3
 800323e:	f7ff fdd2 	bl	8002de6 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 8003242:	4b3c      	ldr	r3, [pc, #240]	; (8003334 <USBD_StdDevReq+0x2ec>)
 8003244:	7819      	ldrb	r1, [r3, #0]
 8003246:	6069      	str	r1, [r5, #4]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8003248:	4628      	mov	r0, r5
 800324a:	f7ff fdbf 	bl	8002dcc <USBD_SetClassConfig>
 800324e:	2802      	cmp	r0, #2
 8003250:	d00d      	beq.n	800326e <USBD_StdDevReq+0x226>
        USBD_CtlSendStatus(pdev);
 8003252:	4628      	mov	r0, r5
 8003254:	f000 f95d 	bl	8003512 <USBD_CtlSendStatus>
 8003258:	e068      	b.n	800332c <USBD_StdDevReq+0x2e4>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800325a:	2302      	movs	r3, #2
 800325c:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
 8003260:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
 8003262:	f7ff fdc0 	bl	8002de6 <USBD_ClrClassConfig>
        USBD_CtlSendStatus(pdev);
 8003266:	4628      	mov	r0, r5
 8003268:	f000 f953 	bl	8003512 <USBD_CtlSendStatus>
 800326c:	e05e      	b.n	800332c <USBD_StdDevReq+0x2e4>
          USBD_CtlError(pdev , req);  
 800326e:	4621      	mov	r1, r4
 8003270:	4628      	mov	r0, r5
 8003272:	f7ff fede 	bl	8003032 <USBD_CtlError>
 8003276:	e059      	b.n	800332c <USBD_StdDevReq+0x2e4>
        USBD_CtlSendStatus(pdev);
 8003278:	f000 f94b 	bl	8003512 <USBD_CtlSendStatus>
 800327c:	e056      	b.n	800332c <USBD_StdDevReq+0x2e4>
  if (req->wLength != 1) 
 800327e:	88cb      	ldrh	r3, [r1, #6]
 8003280:	2b01      	cmp	r3, #1
 8003282:	d108      	bne.n	8003296 <USBD_StdDevReq+0x24e>
    switch (pdev->dev_state )  
 8003284:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003288:	2b02      	cmp	r3, #2
 800328a:	d007      	beq.n	800329c <USBD_StdDevReq+0x254>
 800328c:	2b03      	cmp	r3, #3
 800328e:	d00d      	beq.n	80032ac <USBD_StdDevReq+0x264>
       USBD_CtlError(pdev , req);
 8003290:	f7ff fecf 	bl	8003032 <USBD_CtlError>
 8003294:	e04a      	b.n	800332c <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);
 8003296:	f7ff fecc 	bl	8003032 <USBD_CtlError>
 800329a:	e047      	b.n	800332c <USBD_StdDevReq+0x2e4>
      pdev->dev_default_config = 0;
 800329c:	4601      	mov	r1, r0
 800329e:	2300      	movs	r3, #0
 80032a0:	f841 3f08 	str.w	r3, [r1, #8]!
      USBD_CtlSendData (pdev, 
 80032a4:	2201      	movs	r2, #1
 80032a6:	f000 f908 	bl	80034ba <USBD_CtlSendData>
 80032aa:	e03f      	b.n	800332c <USBD_StdDevReq+0x2e4>
      USBD_CtlSendData (pdev, 
 80032ac:	2201      	movs	r2, #1
 80032ae:	1d01      	adds	r1, r0, #4
 80032b0:	f000 f903 	bl	80034ba <USBD_CtlSendData>
 80032b4:	e03a      	b.n	800332c <USBD_StdDevReq+0x2e4>
  switch (pdev->dev_state) 
 80032b6:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80032ba:	3b02      	subs	r3, #2
 80032bc:	2b01      	cmp	r3, #1
 80032be:	d80d      	bhi.n	80032dc <USBD_StdDevReq+0x294>
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 80032c0:	2301      	movs	r3, #1
 80032c2:	60c3      	str	r3, [r0, #12]
    if (pdev->dev_remote_wakeup) 
 80032c4:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
 80032c8:	b10b      	cbz	r3, 80032ce <USBD_StdDevReq+0x286>
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 80032ca:	2303      	movs	r3, #3
 80032cc:	60c3      	str	r3, [r0, #12]
    USBD_CtlSendData (pdev, 
 80032ce:	2202      	movs	r2, #2
 80032d0:	f105 010c 	add.w	r1, r5, #12
 80032d4:	4628      	mov	r0, r5
 80032d6:	f000 f8f0 	bl	80034ba <USBD_CtlSendData>
 80032da:	e027      	b.n	800332c <USBD_StdDevReq+0x2e4>
    USBD_CtlError(pdev , req);                        
 80032dc:	f7ff fea9 	bl	8003032 <USBD_CtlError>
 80032e0:	e024      	b.n	800332c <USBD_StdDevReq+0x2e4>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80032e2:	884b      	ldrh	r3, [r1, #2]
 80032e4:	2b01      	cmp	r3, #1
 80032e6:	d121      	bne.n	800332c <USBD_StdDevReq+0x2e4>
    pdev->dev_remote_wakeup = 1;  
 80032e8:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
    pdev->pClass->Setup (pdev, req);   
 80032ec:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80032f0:	689b      	ldr	r3, [r3, #8]
 80032f2:	4798      	blx	r3
    USBD_CtlSendStatus(pdev);
 80032f4:	4628      	mov	r0, r5
 80032f6:	f000 f90c 	bl	8003512 <USBD_CtlSendStatus>
 80032fa:	e017      	b.n	800332c <USBD_StdDevReq+0x2e4>
  switch (pdev->dev_state)
 80032fc:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003300:	3b02      	subs	r3, #2
 8003302:	2b01      	cmp	r3, #1
 8003304:	d80d      	bhi.n	8003322 <USBD_StdDevReq+0x2da>
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 8003306:	884b      	ldrh	r3, [r1, #2]
 8003308:	2b01      	cmp	r3, #1
 800330a:	d10f      	bne.n	800332c <USBD_StdDevReq+0x2e4>
      pdev->dev_remote_wakeup = 0; 
 800330c:	2300      	movs	r3, #0
 800330e:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 8003312:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003316:	689b      	ldr	r3, [r3, #8]
 8003318:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 800331a:	4628      	mov	r0, r5
 800331c:	f000 f8f9 	bl	8003512 <USBD_CtlSendStatus>
 8003320:	e004      	b.n	800332c <USBD_StdDevReq+0x2e4>
     USBD_CtlError(pdev , req);
 8003322:	f7ff fe86 	bl	8003032 <USBD_CtlError>
 8003326:	e001      	b.n	800332c <USBD_StdDevReq+0x2e4>
    USBD_CtlError(pdev , req);
 8003328:	f7ff fe83 	bl	8003032 <USBD_CtlError>
}
 800332c:	2000      	movs	r0, #0
 800332e:	b002      	add	sp, #8
 8003330:	bd70      	pop	{r4, r5, r6, pc}
 8003332:	bf00      	nop
 8003334:	200001e0 	.word	0x200001e0

08003338 <USBD_StdItfReq>:
{
 8003338:	b538      	push	{r3, r4, r5, lr}
 800333a:	4604      	mov	r4, r0
 800333c:	460d      	mov	r5, r1
  switch (pdev->dev_state) 
 800333e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003342:	2b03      	cmp	r3, #3
 8003344:	d111      	bne.n	800336a <USBD_StdItfReq+0x32>
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 8003346:	790b      	ldrb	r3, [r1, #4]
 8003348:	2b01      	cmp	r3, #1
 800334a:	d903      	bls.n	8003354 <USBD_StdItfReq+0x1c>
       USBD_CtlError(pdev , req);
 800334c:	f7ff fe71 	bl	8003032 <USBD_CtlError>
}
 8003350:	2000      	movs	r0, #0
 8003352:	bd38      	pop	{r3, r4, r5, pc}
      pdev->pClass->Setup (pdev, req); 
 8003354:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003358:	689b      	ldr	r3, [r3, #8]
 800335a:	4798      	blx	r3
      if((req->wLength == 0)&& (ret == USBD_OK))
 800335c:	88eb      	ldrh	r3, [r5, #6]
 800335e:	2b00      	cmp	r3, #0
 8003360:	d1f6      	bne.n	8003350 <USBD_StdItfReq+0x18>
         USBD_CtlSendStatus(pdev);
 8003362:	4620      	mov	r0, r4
 8003364:	f000 f8d5 	bl	8003512 <USBD_CtlSendStatus>
 8003368:	e7f2      	b.n	8003350 <USBD_StdItfReq+0x18>
     USBD_CtlError(pdev , req);
 800336a:	f7ff fe62 	bl	8003032 <USBD_CtlError>
    break;
 800336e:	e7ef      	b.n	8003350 <USBD_StdItfReq+0x18>

08003370 <USBD_StdEPReq>:
{
 8003370:	b538      	push	{r3, r4, r5, lr}
 8003372:	4605      	mov	r5, r0
 8003374:	460c      	mov	r4, r1
  ep_addr  = LOBYTE(req->wIndex);   
 8003376:	888a      	ldrh	r2, [r1, #4]
  if ((req->bmRequest & 0x60) == 0x20)
 8003378:	780b      	ldrb	r3, [r1, #0]
 800337a:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800337e:	2b20      	cmp	r3, #32
 8003380:	d011      	beq.n	80033a6 <USBD_StdEPReq+0x36>
 8003382:	b2d1      	uxtb	r1, r2
  switch (req->bRequest) 
 8003384:	7863      	ldrb	r3, [r4, #1]
 8003386:	2b01      	cmp	r3, #1
 8003388:	d02a      	beq.n	80033e0 <USBD_StdEPReq+0x70>
 800338a:	2b00      	cmp	r3, #0
 800338c:	d04b      	beq.n	8003426 <USBD_StdEPReq+0xb6>
 800338e:	2b03      	cmp	r3, #3
 8003390:	d10d      	bne.n	80033ae <USBD_StdEPReq+0x3e>
    switch (pdev->dev_state) 
 8003392:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003396:	2b02      	cmp	r3, #2
 8003398:	d00b      	beq.n	80033b2 <USBD_StdEPReq+0x42>
 800339a:	2b03      	cmp	r3, #3
 800339c:	d00f      	beq.n	80033be <USBD_StdEPReq+0x4e>
      USBD_CtlError(pdev , req);
 800339e:	4621      	mov	r1, r4
 80033a0:	f7ff fe47 	bl	8003032 <USBD_CtlError>
      break;    
 80033a4:	e003      	b.n	80033ae <USBD_StdEPReq+0x3e>
    pdev->pClass->Setup (pdev, req);
 80033a6:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80033aa:	689b      	ldr	r3, [r3, #8]
 80033ac:	4798      	blx	r3
}
 80033ae:	2000      	movs	r0, #0
 80033b0:	bd38      	pop	{r3, r4, r5, pc}
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80033b2:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 80033b6:	d0fa      	beq.n	80033ae <USBD_StdEPReq+0x3e>
        USBD_LL_StallEP(pdev , ep_addr);
 80033b8:	f000 fc6c 	bl	8003c94 <USBD_LL_StallEP>
 80033bc:	e7f7      	b.n	80033ae <USBD_StdEPReq+0x3e>
      if (req->wValue == USB_FEATURE_EP_HALT)
 80033be:	8863      	ldrh	r3, [r4, #2]
 80033c0:	b923      	cbnz	r3, 80033cc <USBD_StdEPReq+0x5c>
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80033c2:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 80033c6:	d001      	beq.n	80033cc <USBD_StdEPReq+0x5c>
          USBD_LL_StallEP(pdev , ep_addr);
 80033c8:	f000 fc64 	bl	8003c94 <USBD_LL_StallEP>
      pdev->pClass->Setup (pdev, req);   
 80033cc:	f8d5 3214 	ldr.w	r3, [r5, #532]	; 0x214
 80033d0:	689b      	ldr	r3, [r3, #8]
 80033d2:	4621      	mov	r1, r4
 80033d4:	4628      	mov	r0, r5
 80033d6:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 80033d8:	4628      	mov	r0, r5
 80033da:	f000 f89a 	bl	8003512 <USBD_CtlSendStatus>
      break;
 80033de:	e7e6      	b.n	80033ae <USBD_StdEPReq+0x3e>
    switch (pdev->dev_state) 
 80033e0:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80033e4:	2b02      	cmp	r3, #2
 80033e6:	d005      	beq.n	80033f4 <USBD_StdEPReq+0x84>
 80033e8:	2b03      	cmp	r3, #3
 80033ea:	d009      	beq.n	8003400 <USBD_StdEPReq+0x90>
      USBD_CtlError(pdev , req);
 80033ec:	4621      	mov	r1, r4
 80033ee:	f7ff fe20 	bl	8003032 <USBD_CtlError>
      break;    
 80033f2:	e7dc      	b.n	80033ae <USBD_StdEPReq+0x3e>
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80033f4:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 80033f8:	d0d9      	beq.n	80033ae <USBD_StdEPReq+0x3e>
        USBD_LL_StallEP(pdev , ep_addr);
 80033fa:	f000 fc4b 	bl	8003c94 <USBD_LL_StallEP>
 80033fe:	e7d6      	b.n	80033ae <USBD_StdEPReq+0x3e>
      if (req->wValue == USB_FEATURE_EP_HALT)
 8003400:	8863      	ldrh	r3, [r4, #2]
 8003402:	2b00      	cmp	r3, #0
 8003404:	d1d3      	bne.n	80033ae <USBD_StdEPReq+0x3e>
        if ((ep_addr & 0x7F) != 0x00) 
 8003406:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 800340a:	d103      	bne.n	8003414 <USBD_StdEPReq+0xa4>
        USBD_CtlSendStatus(pdev);
 800340c:	4628      	mov	r0, r5
 800340e:	f000 f880 	bl	8003512 <USBD_CtlSendStatus>
 8003412:	e7cc      	b.n	80033ae <USBD_StdEPReq+0x3e>
          USBD_LL_ClearStallEP(pdev , ep_addr);
 8003414:	f000 fc4b 	bl	8003cae <USBD_LL_ClearStallEP>
          pdev->pClass->Setup (pdev, req);
 8003418:	f8d5 3214 	ldr.w	r3, [r5, #532]	; 0x214
 800341c:	689b      	ldr	r3, [r3, #8]
 800341e:	4621      	mov	r1, r4
 8003420:	4628      	mov	r0, r5
 8003422:	4798      	blx	r3
 8003424:	e7f2      	b.n	800340c <USBD_StdEPReq+0x9c>
    switch (pdev->dev_state) 
 8003426:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800342a:	2b02      	cmp	r3, #2
 800342c:	d005      	beq.n	800343a <USBD_StdEPReq+0xca>
 800342e:	2b03      	cmp	r3, #3
 8003430:	d009      	beq.n	8003446 <USBD_StdEPReq+0xd6>
      USBD_CtlError(pdev , req);
 8003432:	4621      	mov	r1, r4
 8003434:	f7ff fdfd 	bl	8003032 <USBD_CtlError>
      break;
 8003438:	e7b9      	b.n	80033ae <USBD_StdEPReq+0x3e>
      if ((ep_addr & 0x7F) != 0x00) 
 800343a:	f011 0f7f 	tst.w	r1, #127	; 0x7f
 800343e:	d0b6      	beq.n	80033ae <USBD_StdEPReq+0x3e>
        USBD_LL_StallEP(pdev , ep_addr);
 8003440:	f000 fc28 	bl	8003c94 <USBD_LL_StallEP>
 8003444:	e7b3      	b.n	80033ae <USBD_StdEPReq+0x3e>
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8003446:	f012 0f80 	tst.w	r2, #128	; 0x80
 800344a:	f001 047f 	and.w	r4, r1, #127	; 0x7f
 800344e:	eb00 1404 	add.w	r4, r0, r4, lsl #4
 8003452:	bf14      	ite	ne
 8003454:	3414      	addne	r4, #20
 8003456:	f504 7482 	addeq.w	r4, r4, #260	; 0x104
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 800345a:	f000 fc35 	bl	8003cc8 <USBD_LL_IsStallEP>
 800345e:	b138      	cbz	r0, 8003470 <USBD_StdEPReq+0x100>
        pep->status = 0x0001;     
 8003460:	2301      	movs	r3, #1
 8003462:	6023      	str	r3, [r4, #0]
      USBD_CtlSendData (pdev,
 8003464:	2202      	movs	r2, #2
 8003466:	4621      	mov	r1, r4
 8003468:	4628      	mov	r0, r5
 800346a:	f000 f826 	bl	80034ba <USBD_CtlSendData>
      break;
 800346e:	e79e      	b.n	80033ae <USBD_StdEPReq+0x3e>
        pep->status = 0x0000;  
 8003470:	2300      	movs	r3, #0
 8003472:	6023      	str	r3, [r4, #0]
 8003474:	e7f6      	b.n	8003464 <USBD_StdEPReq+0xf4>

08003476 <USBD_GetString>:
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
 8003476:	b1f8      	cbz	r0, 80034b8 <USBD_GetString+0x42>
{
 8003478:	b430      	push	{r4, r5}
 800347a:	4604      	mov	r4, r0
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 800347c:	7803      	ldrb	r3, [r0, #0]
 800347e:	b133      	cbz	r3, 800348e <USBD_GetString+0x18>
 8003480:	2300      	movs	r3, #0
    {
        len++;
 8003482:	3301      	adds	r3, #1
 8003484:	b2db      	uxtb	r3, r3
    while (*buf != '\0') 
 8003486:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 800348a:	2d00      	cmp	r5, #0
 800348c:	d1f9      	bne.n	8003482 <USBD_GetString+0xc>
    *len =  USBD_GetLen(desc) * 2 + 2;    
 800348e:	005b      	lsls	r3, r3, #1
 8003490:	3302      	adds	r3, #2
 8003492:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
 8003494:	700b      	strb	r3, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8003496:	2303      	movs	r3, #3
 8003498:	704b      	strb	r3, [r1, #1]
    while (*desc != '\0') 
 800349a:	7820      	ldrb	r0, [r4, #0]
 800349c:	b158      	cbz	r0, 80034b6 <USBD_GetString+0x40>
 800349e:	2302      	movs	r3, #2
      unicode[idx++] =  0x00;
 80034a0:	2500      	movs	r5, #0
      unicode[idx++] = *desc++;
 80034a2:	1c5a      	adds	r2, r3, #1
 80034a4:	b2d2      	uxtb	r2, r2
 80034a6:	54c8      	strb	r0, [r1, r3]
      unicode[idx++] =  0x00;
 80034a8:	3302      	adds	r3, #2
 80034aa:	b2db      	uxtb	r3, r3
 80034ac:	548d      	strb	r5, [r1, r2]
    while (*desc != '\0') 
 80034ae:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 80034b2:	2800      	cmp	r0, #0
 80034b4:	d1f5      	bne.n	80034a2 <USBD_GetString+0x2c>
}
 80034b6:	bc30      	pop	{r4, r5}
 80034b8:	4770      	bx	lr

080034ba <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 80034ba:	b510      	push	{r4, lr}
 80034bc:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 80034be:	2202      	movs	r2, #2
 80034c0:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
 80034c4:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
 80034c6:	61c3      	str	r3, [r0, #28]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 80034c8:	460a      	mov	r2, r1
 80034ca:	2100      	movs	r1, #0
 80034cc:	f000 fc20 	bl	8003d10 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 80034d0:	2000      	movs	r0, #0
 80034d2:	bd10      	pop	{r4, pc}

080034d4 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 80034d4:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 80034d6:	4613      	mov	r3, r2
 80034d8:	460a      	mov	r2, r1
 80034da:	2100      	movs	r1, #0
 80034dc:	f000 fc18 	bl	8003d10 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 80034e0:	2000      	movs	r0, #0
 80034e2:	bd08      	pop	{r3, pc}

080034e4 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlPrepareRx (USBD_HandleTypeDef  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 80034e4:	b510      	push	{r4, lr}
 80034e6:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
 80034e8:	2203      	movs	r2, #3
 80034ea:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_out[0].total_length = len;
 80034ee:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  pdev->ep_out[0].rem_length   = len;
 80034f2:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev,
 80034f6:	460a      	mov	r2, r1
 80034f8:	2100      	movs	r1, #0
 80034fa:	f000 fc16 	bl	8003d2a <USBD_LL_PrepareReceive>
                          0,
                          pbuf,
                         len);
  
  return USBD_OK;
}
 80034fe:	2000      	movs	r0, #0
 8003500:	bd10      	pop	{r4, pc}

08003502 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8003502:	b508      	push	{r3, lr}

  USBD_LL_PrepareReceive (pdev,
 8003504:	4613      	mov	r3, r2
 8003506:	460a      	mov	r2, r1
 8003508:	2100      	movs	r1, #0
 800350a:	f000 fc0e 	bl	8003d2a <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
 800350e:	2000      	movs	r0, #0
 8003510:	bd08      	pop	{r3, pc}

08003512 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 8003512:	b508      	push	{r3, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8003514:	2304      	movs	r3, #4
 8003516:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 800351a:	2300      	movs	r3, #0
 800351c:	461a      	mov	r2, r3
 800351e:	4619      	mov	r1, r3
 8003520:	f000 fbf6 	bl	8003d10 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8003524:	2000      	movs	r0, #0
 8003526:	bd08      	pop	{r3, pc}

08003528 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 8003528:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 800352a:	2305      	movs	r3, #5
 800352c:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 8003530:	2300      	movs	r3, #0
 8003532:	461a      	mov	r2, r3
 8003534:	4619      	mov	r1, r3
 8003536:	f000 fbf8 	bl	8003d2a <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}
 800353a:	2000      	movs	r0, #0
 800353c:	bd08      	pop	{r3, pc}
	...

08003540 <netif_init_cb>:
    return ERR_OK;
}


err_t netif_init_cb(struct netif *netif)
{
 8003540:	4603      	mov	r3, r0
    LWIP_ASSERT("netif != NULL", (netif != NULL));
    netif->mtu = RNDIS_MTU;
 8003542:	f240 52dc 	movw	r2, #1500	; 0x5dc
 8003546:	8402      	strh	r2, [r0, #32]
    netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP | NETIF_FLAG_UP;
 8003548:	2233      	movs	r2, #51	; 0x33
 800354a:	f880 2029 	strb.w	r2, [r0, #41]	; 0x29
    netif->state = NULL;
 800354e:	2000      	movs	r0, #0
 8003550:	61d8      	str	r0, [r3, #28]
    netif->name[0] = 'E';
 8003552:	2245      	movs	r2, #69	; 0x45
 8003554:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
    netif->name[1] = 'X';
 8003558:	2258      	movs	r2, #88	; 0x58
 800355a:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
    netif->linkoutput = linkoutput_fn;
 800355e:	4a02      	ldr	r2, [pc, #8]	; (8003568 <netif_init_cb+0x28>)
 8003560:	619a      	str	r2, [r3, #24]
    netif->output = output_fn;
 8003562:	4a02      	ldr	r2, [pc, #8]	; (800356c <netif_init_cb+0x2c>)
 8003564:	615a      	str	r2, [r3, #20]
    return ERR_OK;
}
 8003566:	4770      	bx	lr
 8003568:	080036ad 	.word	0x080036ad
 800356c:	08003595 	.word	0x08003595

08003570 <tcp_timer_proc>:
{
 8003570:	b508      	push	{r3, lr}
    tcp_tmr();
 8003572:	f002 fe63 	bl	800623c <tcp_tmr>
 8003576:	bd08      	pop	{r3, pc}

08003578 <on_packet>:
{
 8003578:	b510      	push	{r4, lr}
 800357a:	460c      	mov	r4, r1
    memcpy(received, data, size);
 800357c:	460a      	mov	r2, r1
 800357e:	4601      	mov	r1, r0
 8003580:	4802      	ldr	r0, [pc, #8]	; (800358c <on_packet+0x14>)
 8003582:	f005 fc9a 	bl	8008eba <memcpy>
    recvSize = size;
 8003586:	4b02      	ldr	r3, [pc, #8]	; (8003590 <on_packet+0x18>)
 8003588:	601c      	str	r4, [r3, #0]
 800358a:	bd10      	pop	{r4, pc}
 800358c:	200007dc 	.word	0x200007dc
 8003590:	20000dc8 	.word	0x20000dc8

08003594 <output_fn>:
{
 8003594:	b508      	push	{r3, lr}
    return etharp_output(netif, p, ipaddr);
 8003596:	f005 fab5 	bl	8008b04 <etharp_output>
}
 800359a:	bd08      	pop	{r3, pc}

0800359c <usb_polling>:
  __ASM volatile ("cpsid i" : : : "memory");
 800359c:	b672      	cpsid	i
    if (recvSize == 0)
 800359e:	4b11      	ldr	r3, [pc, #68]	; (80035e4 <usb_polling+0x48>)
 80035a0:	6819      	ldr	r1, [r3, #0]
 80035a2:	b909      	cbnz	r1, 80035a8 <usb_polling+0xc>
  __ASM volatile ("cpsie i" : : : "memory");
 80035a4:	b662      	cpsie	i
 80035a6:	4770      	bx	lr
{
 80035a8:	b570      	push	{r4, r5, r6, lr}
    frame = pbuf_alloc(PBUF_RAW, recvSize, PBUF_POOL);
 80035aa:	2203      	movs	r2, #3
 80035ac:	b289      	uxth	r1, r1
 80035ae:	4610      	mov	r0, r2
 80035b0:	f002 f8a6 	bl	8005700 <pbuf_alloc>
    if (frame == NULL)
 80035b4:	4604      	mov	r4, r0
 80035b6:	b190      	cbz	r0, 80035de <usb_polling+0x42>
    memcpy(frame->payload, received, recvSize);
 80035b8:	4d0a      	ldr	r5, [pc, #40]	; (80035e4 <usb_polling+0x48>)
 80035ba:	682e      	ldr	r6, [r5, #0]
 80035bc:	4632      	mov	r2, r6
 80035be:	490a      	ldr	r1, [pc, #40]	; (80035e8 <usb_polling+0x4c>)
 80035c0:	6840      	ldr	r0, [r0, #4]
 80035c2:	f005 fc7a 	bl	8008eba <memcpy>
    frame->len = recvSize;
 80035c6:	8166      	strh	r6, [r4, #10]
    recvSize = 0;
 80035c8:	2300      	movs	r3, #0
 80035ca:	602b      	str	r3, [r5, #0]
 80035cc:	b662      	cpsie	i
    ethernet_input(frame, &netif_data);
 80035ce:	4907      	ldr	r1, [pc, #28]	; (80035ec <usb_polling+0x50>)
 80035d0:	4620      	mov	r0, r4
 80035d2:	f005 fb29 	bl	8008c28 <ethernet_input>
    pbuf_free(frame);
 80035d6:	4620      	mov	r0, r4
 80035d8:	f002 f863 	bl	80056a2 <pbuf_free>
 80035dc:	bd70      	pop	{r4, r5, r6, pc}
 80035de:	b662      	cpsie	i
 80035e0:	bd70      	pop	{r4, r5, r6, pc}
 80035e2:	bf00      	nop
 80035e4:	20000dc8 	.word	0x20000dc8
 80035e8:	200007dc 	.word	0x200007dc
 80035ec:	20007efc 	.word	0x20007efc

080035f0 <SysTick_Handler>:

    }
}

void SysTick_Handler(void)
{
 80035f0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80035f2:	f7fd f811 	bl	8000618 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
 80035f6:	f7fd f8a6 	bl	8000746 <HAL_SYSTICK_IRQHandler>
  /* USER CODE BEGIN SysTick_IRQn 1 */
  usAddition += 1000;
 80035fa:	4905      	ldr	r1, [pc, #20]	; (8003610 <SysTick_Handler+0x20>)
 80035fc:	e9d1 2300 	ldrd	r2, r3, [r1]
 8003600:	f512 727a 	adds.w	r2, r2, #1000	; 0x3e8
 8003604:	f143 0300 	adc.w	r3, r3, #0
 8003608:	e9c1 2300 	strd	r2, r3, [r1]
 800360c:	bd08      	pop	{r3, pc}
 800360e:	bf00      	nop
 8003610:	20000de0 	.word	0x20000de0

08003614 <utime>:
  /* USER CODE END SysTick_IRQn 1 */
}

int64_t utime(void)
{
 8003614:	b5d0      	push	{r4, r6, r7, lr}
    uint32_t ctrl;
    static int64_t res;
    uint32_t ticks;

    ctrl = SysTick->CTRL;
 8003616:	4b10      	ldr	r3, [pc, #64]	; (8003658 <utime+0x44>)
 8003618:	681b      	ldr	r3, [r3, #0]

read:
    ticks = SysTick->VAL;
    res = usAddition;
 800361a:	4b10      	ldr	r3, [pc, #64]	; (800365c <utime+0x48>)
 800361c:	e9d3 6700 	ldrd	r6, r7, [r3]
    ticks = SysTick->VAL;
 8003620:	4b0d      	ldr	r3, [pc, #52]	; (8003658 <utime+0x44>)
    res = usAddition;
 8003622:	490f      	ldr	r1, [pc, #60]	; (8003660 <utime+0x4c>)
    ticks = SysTick->VAL;
 8003624:	689c      	ldr	r4, [r3, #8]
    res = usAddition;
 8003626:	e9c1 6700 	strd	r6, r7, [r1]
    ctrl = SysTick->CTRL;
 800362a:	681a      	ldr	r2, [r3, #0]
    if (ctrl & SysTick_CTRL_COUNTFLAG_Msk)
 800362c:	f412 3f80 	tst.w	r2, #65536	; 0x10000
 8003630:	d1f8      	bne.n	8003624 <utime+0x10>
        goto read;

    #define ticksPerUs (HAL_RCC_GetHCLKFreq()/1000000)
    res += 1000 - ticks / ticksPerUs;
 8003632:	f7fe f93f 	bl	80018b4 <HAL_RCC_GetHCLKFreq>
 8003636:	4b0b      	ldr	r3, [pc, #44]	; (8003664 <utime+0x50>)
 8003638:	fba3 3000 	umull	r3, r0, r3, r0
 800363c:	0c80      	lsrs	r0, r0, #18
 800363e:	fbb4 f4f0 	udiv	r4, r4, r0
 8003642:	f5c4 747a 	rsb	r4, r4, #1000	; 0x3e8
 8003646:	4b06      	ldr	r3, [pc, #24]	; (8003660 <utime+0x4c>)
 8003648:	e9d3 0100 	ldrd	r0, r1, [r3]
 800364c:	1900      	adds	r0, r0, r4
 800364e:	f141 0100 	adc.w	r1, r1, #0
 8003652:	e9c3 0100 	strd	r0, r1, [r3]
    #undef usecPerTick

    return res;
}
 8003656:	bdd0      	pop	{r4, r6, r7, pc}
 8003658:	e000e010 	.word	0xe000e010
 800365c:	20000de0 	.word	0x20000de0
 8003660:	20000dd0 	.word	0x20000dd0
 8003664:	431bde83 	.word	0x431bde83

08003668 <mtime>:
    if (m != NULL) *m = time.Minutes;
    if (s != NULL) *s = time.Seconds;
}

int64_t mtime(void)
{
 8003668:	b508      	push	{r3, lr}
    return utime() / 1000;
 800366a:	f7ff ffd3 	bl	8003614 <utime>
 800366e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8003672:	2300      	movs	r3, #0
 8003674:	f7fc fdb8 	bl	80001e8 <__aeabi_ldivmod>
}
 8003678:	bd08      	pop	{r3, pc}

0800367a <sys_now>:
{
 800367a:	b508      	push	{r3, lr}
    return (uint32_t)mtime();
 800367c:	f7ff fff4 	bl	8003668 <mtime>
}
 8003680:	bd08      	pop	{r3, pc}

08003682 <usleep>:

void usleep(int us)
{
 8003682:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003684:	4606      	mov	r6, r0
    uint64_t t = utime();
 8003686:	f7ff ffc5 	bl	8003614 <utime>
 800368a:	4604      	mov	r4, r0
 800368c:	460d      	mov	r5, r1
    while (true)
    {
        uint64_t t1 = utime();
        if (t1 - t >= us) break;
 800368e:	17f7      	asrs	r7, r6, #31
        uint64_t t1 = utime();
 8003690:	f7ff ffc0 	bl	8003614 <utime>
        if (t1 - t >= us) break;
 8003694:	1b02      	subs	r2, r0, r4
 8003696:	eb61 0305 	sbc.w	r3, r1, r5
 800369a:	42bb      	cmp	r3, r7
 800369c:	bf08      	it	eq
 800369e:	42b2      	cmpeq	r2, r6
 80036a0:	d203      	bcs.n	80036aa <usleep+0x28>
        if (t1 < t) break; /* overflow */
 80036a2:	42a9      	cmp	r1, r5
 80036a4:	bf08      	it	eq
 80036a6:	42a0      	cmpeq	r0, r4
 80036a8:	d2f2      	bcs.n	8003690 <usleep+0xe>
 80036aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080036ac <linkoutput_fn>:
{
 80036ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80036ae:	460c      	mov	r4, r1
 80036b0:	25c8      	movs	r5, #200	; 0xc8
        msleep(1);
 80036b2:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
        if (rndis_can_send()) break;
 80036b6:	f7ff fb31 	bl	8002d1c <rndis_can_send>
 80036ba:	b920      	cbnz	r0, 80036c6 <linkoutput_fn+0x1a>
        msleep(1);
 80036bc:	4630      	mov	r0, r6
 80036be:	f7ff ffe0 	bl	8003682 <usleep>
    for (i = 0; i < 200; i++)
 80036c2:	3d01      	subs	r5, #1
 80036c4:	d1f7      	bne.n	80036b6 <linkoutput_fn+0xa>
    for(q = p; q != NULL; q = q->next)
 80036c6:	b1b4      	cbz	r4, 80036f6 <linkoutput_fn+0x4a>
        if (size + q->len > RNDIS_MTU + 14)
 80036c8:	8962      	ldrh	r2, [r4, #10]
 80036ca:	f240 53ea 	movw	r3, #1514	; 0x5ea
 80036ce:	429a      	cmp	r2, r3
 80036d0:	dc21      	bgt.n	8003716 <linkoutput_fn+0x6a>
 80036d2:	2500      	movs	r5, #0
        memcpy(data + size, (char *)q->payload, q->len);
 80036d4:	4e13      	ldr	r6, [pc, #76]	; (8003724 <linkoutput_fn+0x78>)
        if (size + q->len > RNDIS_MTU + 14)
 80036d6:	461f      	mov	r7, r3
        memcpy(data + size, (char *)q->payload, q->len);
 80036d8:	6861      	ldr	r1, [r4, #4]
 80036da:	1970      	adds	r0, r6, r5
 80036dc:	f005 fbed 	bl	8008eba <memcpy>
        size += q->len;
 80036e0:	8963      	ldrh	r3, [r4, #10]
 80036e2:	441d      	add	r5, r3
    for(q = p; q != NULL; q = q->next)
 80036e4:	6824      	ldr	r4, [r4, #0]
 80036e6:	b13c      	cbz	r4, 80036f8 <linkoutput_fn+0x4c>
        if (size + q->len > RNDIS_MTU + 14)
 80036e8:	8962      	ldrh	r2, [r4, #10]
 80036ea:	1953      	adds	r3, r2, r5
 80036ec:	42bb      	cmp	r3, r7
 80036ee:	ddf3      	ble.n	80036d8 <linkoutput_fn+0x2c>
            return ERR_ARG;
 80036f0:	f06f 000d 	mvn.w	r0, #13
 80036f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    for(q = p; q != NULL; q = q->next)
 80036f6:	2500      	movs	r5, #0
    buffStatus = rndis_can_send();
 80036f8:	f7ff fb10 	bl	8002d1c <rndis_can_send>
 80036fc:	4b0a      	ldr	r3, [pc, #40]	; (8003728 <linkoutput_fn+0x7c>)
 80036fe:	7018      	strb	r0, [r3, #0]
    if (!buffStatus)
 8003700:	b160      	cbz	r0, 800371c <linkoutput_fn+0x70>
    rndis_send(data, size);
 8003702:	4629      	mov	r1, r5
 8003704:	4807      	ldr	r0, [pc, #28]	; (8003724 <linkoutput_fn+0x78>)
 8003706:	f7ff fb13 	bl	8002d30 <rndis_send>
    outputs++;
 800370a:	4a08      	ldr	r2, [pc, #32]	; (800372c <linkoutput_fn+0x80>)
 800370c:	6813      	ldr	r3, [r2, #0]
 800370e:	3301      	adds	r3, #1
 8003710:	6013      	str	r3, [r2, #0]
    return ERR_OK;
 8003712:	2000      	movs	r0, #0
 8003714:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return ERR_ARG;
 8003716:	f06f 000d 	mvn.w	r0, #13
 800371a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return ERR_USE;
 800371c:	f06f 0007 	mvn.w	r0, #7
}
 8003720:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003722:	bf00      	nop
 8003724:	200001e4 	.word	0x200001e4
 8003728:	20007ed8 	.word	0x20007ed8
 800372c:	200007d8 	.word	0x200007d8

08003730 <stmr>:
    }
}

void stmr(void)
{
 8003730:	b570      	push	{r4, r5, r6, lr}
    stmr_t *tmr;
    uint32_t time;
    time = utime();
 8003732:	f7ff ff6f 	bl	8003614 <utime>
 8003736:	4606      	mov	r6, r0
    tmr = stmrs;
 8003738:	4b0b      	ldr	r3, [pc, #44]	; (8003768 <stmr+0x38>)
 800373a:	681c      	ldr	r4, [r3, #0]
    while (tmr != NULL)
 800373c:	b91c      	cbnz	r4, 8003746 <stmr+0x16>
 800373e:	bd70      	pop	{r4, r5, r6, pc}
 8003740:	462c      	mov	r4, r5
 8003742:	2d00      	cmp	r5, #0
 8003744:	d0fb      	beq.n	800373e <stmr+0xe>
    {
        stmr_t *t;
        uint32_t elapsed;
        t = tmr;
        tmr = tmr->next;
 8003746:	6965      	ldr	r5, [r4, #20]
        if ((t->flags & STMR_ACTIVE) == 0)
 8003748:	68a3      	ldr	r3, [r4, #8]
 800374a:	f013 0f01 	tst.w	r3, #1
 800374e:	d0f7      	beq.n	8003740 <stmr+0x10>
            continue;
        elapsed = time;
        elapsed -= t->event;
 8003750:	6863      	ldr	r3, [r4, #4]
 8003752:	1af3      	subs	r3, r6, r3
        if (elapsed < t->period)
 8003754:	6822      	ldr	r2, [r4, #0]
 8003756:	4293      	cmp	r3, r2
 8003758:	d3f2      	bcc.n	8003740 <stmr+0x10>
            continue;
        t->proc(t);
 800375a:	6923      	ldr	r3, [r4, #16]
 800375c:	4620      	mov	r0, r4
 800375e:	4798      	blx	r3
        t->event = utime();
 8003760:	f7ff ff58 	bl	8003614 <utime>
 8003764:	6060      	str	r0, [r4, #4]
 8003766:	e7eb      	b.n	8003740 <stmr+0x10>
 8003768:	20000dd8 	.word	0x20000dd8

0800376c <stmr_add>:
    stmrs = tmr;
}

void stmr_add(stmr_t *tmr)
{
    tmr->next = stmrs;
 800376c:	4b02      	ldr	r3, [pc, #8]	; (8003778 <stmr_add+0xc>)
 800376e:	681a      	ldr	r2, [r3, #0]
 8003770:	6142      	str	r2, [r0, #20]
    stmrs = tmr;
 8003772:	6018      	str	r0, [r3, #0]
 8003774:	4770      	bx	lr
 8003776:	bf00      	nop
 8003778:	20000dd8 	.word	0x20000dd8

0800377c <init_lwip>:
{
 800377c:	b510      	push	{r4, lr}
 800377e:	b084      	sub	sp, #16
    lwip_init();
 8003780:	f000 fd2e 	bl	80041e0 <lwip_init>
    netif->hwaddr_len = 6;
 8003784:	4c0e      	ldr	r4, [pc, #56]	; (80037c0 <init_lwip+0x44>)
 8003786:	2306      	movs	r3, #6
 8003788:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
    memcpy(netif->hwaddr, hwaddr, 6);
 800378c:	4b0d      	ldr	r3, [pc, #52]	; (80037c4 <init_lwip+0x48>)
 800378e:	6818      	ldr	r0, [r3, #0]
 8003790:	f8c4 0023 	str.w	r0, [r4, #35]	; 0x23
 8003794:	889b      	ldrh	r3, [r3, #4]
 8003796:	f8a4 3027 	strh.w	r3, [r4, #39]	; 0x27
    netif = netif_add(netif, PADDR(ipaddr), PADDR(netmask), PADDR(gateway), NULL, netif_init_cb, ip_input);
 800379a:	4b0b      	ldr	r3, [pc, #44]	; (80037c8 <init_lwip+0x4c>)
 800379c:	9302      	str	r3, [sp, #8]
 800379e:	4b0b      	ldr	r3, [pc, #44]	; (80037cc <init_lwip+0x50>)
 80037a0:	9301      	str	r3, [sp, #4]
 80037a2:	2300      	movs	r3, #0
 80037a4:	9300      	str	r3, [sp, #0]
 80037a6:	4b0a      	ldr	r3, [pc, #40]	; (80037d0 <init_lwip+0x54>)
 80037a8:	4a0a      	ldr	r2, [pc, #40]	; (80037d4 <init_lwip+0x58>)
 80037aa:	490b      	ldr	r1, [pc, #44]	; (80037d8 <init_lwip+0x5c>)
 80037ac:	4620      	mov	r0, r4
 80037ae:	f001 fee1 	bl	8005574 <netif_add>
    netif_set_default(netif);
 80037b2:	f001 ff03 	bl	80055bc <netif_set_default>
    stmr_add(&tcp_timer);
 80037b6:	4809      	ldr	r0, [pc, #36]	; (80037dc <init_lwip+0x60>)
 80037b8:	f7ff ffd8 	bl	800376c <stmr_add>
}
 80037bc:	b004      	add	sp, #16
 80037be:	bd10      	pop	{r4, pc}
 80037c0:	20007efc 	.word	0x20007efc
 80037c4:	08008f7c 	.word	0x08008f7c
 80037c8:	08004621 	.word	0x08004621
 80037cc:	08003541 	.word	0x08003541
 80037d0:	200007d4 	.word	0x200007d4
 80037d4:	200000e4 	.word	0x200000e4
 80037d8:	200000e0 	.word	0x200000e0
 80037dc:	200000e8 	.word	0x200000e8

080037e0 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80037e0:	b500      	push	{lr}
 80037e2:	b09b      	sub	sp, #108	; 0x6c
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;

    /**Configure the main internal regulator output voltage 
    */
  __HAL_RCC_PWR_CLK_ENABLE();
 80037e4:	2100      	movs	r1, #0
 80037e6:	9101      	str	r1, [sp, #4]
 80037e8:	4b2c      	ldr	r3, [pc, #176]	; (800389c <SystemClock_Config+0xbc>)
 80037ea:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80037ec:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80037f0:	641a      	str	r2, [r3, #64]	; 0x40
 80037f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80037f4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80037f8:	9301      	str	r3, [sp, #4]
 80037fa:	9b01      	ldr	r3, [sp, #4]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80037fc:	9102      	str	r1, [sp, #8]
 80037fe:	4b28      	ldr	r3, [pc, #160]	; (80038a0 <SystemClock_Config+0xc0>)
 8003800:	681a      	ldr	r2, [r3, #0]
 8003802:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8003806:	601a      	str	r2, [r3, #0]
 8003808:	681b      	ldr	r3, [r3, #0]
 800380a:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800380e:	9302      	str	r3, [sp, #8]
 8003810:	9b02      	ldr	r3, [sp, #8]

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 8003812:	2309      	movs	r3, #9
 8003814:	930e      	str	r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8003816:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800381a:	920f      	str	r2, [sp, #60]	; 0x3c
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 800381c:	2201      	movs	r2, #1
 800381e:	9213      	str	r2, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8003820:	2202      	movs	r2, #2
 8003822:	9214      	str	r2, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8003824:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8003828:	9215      	str	r2, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLM = 4;
 800382a:	2204      	movs	r2, #4
 800382c:	9216      	str	r2, [sp, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLN = 216;
 800382e:	22d8      	movs	r2, #216	; 0xd8
 8003830:	9217      	str	r2, [sp, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV6;
 8003832:	2206      	movs	r2, #6
 8003834:	9218      	str	r2, [sp, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLQ = 9;
 8003836:	9319      	str	r3, [sp, #100]	; 0x64
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8003838:	a80e      	add	r0, sp, #56	; 0x38
 800383a:	f7fd fd4d 	bl	80012d8 <HAL_RCC_OscConfig>
 800383e:	bb50      	cbnz	r0, 8003896 <SystemClock_Config+0xb6>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8003840:	230f      	movs	r3, #15
 8003842:	9309      	str	r3, [sp, #36]	; 0x24
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8003844:	2102      	movs	r1, #2
 8003846:	910a      	str	r1, [sp, #40]	; 0x28
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8003848:	2300      	movs	r3, #0
 800384a:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 800384c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8003850:	920c      	str	r2, [sp, #48]	; 0x30
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8003852:	930d      	str	r3, [sp, #52]	; 0x34

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8003854:	a809      	add	r0, sp, #36	; 0x24
 8003856:	f7fd ff77 	bl	8001748 <HAL_RCC_ClockConfig>
 800385a:	b9e8      	cbnz	r0, 8003898 <SystemClock_Config+0xb8>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 800385c:	2302      	movs	r3, #2
 800385e:	9303      	str	r3, [sp, #12]
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 8003860:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003864:	9307      	str	r3, [sp, #28]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8003866:	a803      	add	r0, sp, #12
 8003868:	f7fe f82a 	bl	80018c0 <HAL_RCCEx_PeriphCLKConfig>
 800386c:	b9a8      	cbnz	r0, 800389a <SystemClock_Config+0xba>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure the Systick interrupt time 
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 800386e:	f7fe f821 	bl	80018b4 <HAL_RCC_GetHCLKFreq>
 8003872:	4b0c      	ldr	r3, [pc, #48]	; (80038a4 <SystemClock_Config+0xc4>)
 8003874:	fba3 3000 	umull	r3, r0, r3, r0
 8003878:	0980      	lsrs	r0, r0, #6
 800387a:	f7fc ff41 	bl	8000700 <HAL_SYSTICK_Config>

    /**Configure the Systick 
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 800387e:	2004      	movs	r0, #4
 8003880:	f7fc ff54 	bl	800072c <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8003884:	2200      	movs	r2, #0
 8003886:	4611      	mov	r1, r2
 8003888:	f04f 30ff 	mov.w	r0, #4294967295
 800388c:	f7fc fefc 	bl	8000688 <HAL_NVIC_SetPriority>
}
 8003890:	b01b      	add	sp, #108	; 0x6c
 8003892:	f85d fb04 	ldr.w	pc, [sp], #4
 8003896:	e7fe      	b.n	8003896 <SystemClock_Config+0xb6>
 8003898:	e7fe      	b.n	8003898 <SystemClock_Config+0xb8>
 800389a:	e7fe      	b.n	800389a <SystemClock_Config+0xba>
 800389c:	40023800 	.word	0x40023800
 80038a0:	40007000 	.word	0x40007000
 80038a4:	10624dd3 	.word	0x10624dd3

080038a8 <main>:
{
 80038a8:	b500      	push	{lr}
 80038aa:	b083      	sub	sp, #12
  HAL_Init();
 80038ac:	f7fc fe9a 	bl	80005e4 <HAL_Init>
  SystemClock_Config();
 80038b0:	f7ff ff96 	bl	80037e0 <SystemClock_Config>
*/
static void MX_GPIO_Init(void)
{

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80038b4:	2400      	movs	r4, #0
 80038b6:	9400      	str	r4, [sp, #0]
 80038b8:	4b1d      	ldr	r3, [pc, #116]	; (8003930 <main+0x88>)
 80038ba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80038bc:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80038c0:	631a      	str	r2, [r3, #48]	; 0x30
 80038c2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80038c4:	f002 0280 	and.w	r2, r2, #128	; 0x80
 80038c8:	9200      	str	r2, [sp, #0]
 80038ca:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80038cc:	9401      	str	r4, [sp, #4]
 80038ce:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80038d0:	f042 0201 	orr.w	r2, r2, #1
 80038d4:	631a      	str	r2, [r3, #48]	; 0x30
 80038d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80038d8:	f003 0301 	and.w	r3, r3, #1
 80038dc:	9301      	str	r3, [sp, #4]
 80038de:	9b01      	ldr	r3, [sp, #4]
  MX_USB_DEVICE_Init();
 80038e0:	f000 f8a8 	bl	8003a34 <MX_USB_DEVICE_Init>
  hrtc.Instance = RTC;
 80038e4:	4813      	ldr	r0, [pc, #76]	; (8003934 <main+0x8c>)
 80038e6:	4b14      	ldr	r3, [pc, #80]	; (8003938 <main+0x90>)
 80038e8:	6003      	str	r3, [r0, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 80038ea:	6044      	str	r4, [r0, #4]
  hrtc.Init.AsynchPrediv = 127;
 80038ec:	237f      	movs	r3, #127	; 0x7f
 80038ee:	6083      	str	r3, [r0, #8]
  hrtc.Init.SynchPrediv = 255;
 80038f0:	23ff      	movs	r3, #255	; 0xff
 80038f2:	60c3      	str	r3, [r0, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 80038f4:	6104      	str	r4, [r0, #16]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 80038f6:	6144      	str	r4, [r0, #20]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 80038f8:	6184      	str	r4, [r0, #24]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 80038fa:	f7fe f8d0 	bl	8001a9e <HAL_RTC_Init>
 80038fe:	b9b0      	cbnz	r0, 800392e <main+0x86>
  rndis_rxproc = on_packet;
 8003900:	4a0e      	ldr	r2, [pc, #56]	; (800393c <main+0x94>)
 8003902:	4b0f      	ldr	r3, [pc, #60]	; (8003940 <main+0x98>)
 8003904:	601a      	str	r2, [r3, #0]
  init_lwip();
 8003906:	f7ff ff39 	bl	800377c <init_lwip>
	while (!netif_is_up(&netif_data)) ;
 800390a:	4b0e      	ldr	r3, [pc, #56]	; (8003944 <main+0x9c>)
 800390c:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8003910:	f003 0301 	and.w	r3, r3, #1
 8003914:	2b00      	cmp	r3, #0
 8003916:	d0fd      	beq.n	8003914 <main+0x6c>
	while (dhserv_init(&dhcp_config) != ERR_OK) ;
 8003918:	4c0b      	ldr	r4, [pc, #44]	; (8003948 <main+0xa0>)
 800391a:	4620      	mov	r0, r4
 800391c:	f000 fc1c 	bl	8004158 <dhserv_init>
 8003920:	2800      	cmp	r0, #0
 8003922:	d1fa      	bne.n	800391a <main+0x72>
  	  usb_polling();     /* usb device polling */
 8003924:	f7ff fe3a 	bl	800359c <usb_polling>
  	  stmr();            /* call software timers */
 8003928:	f7ff ff02 	bl	8003730 <stmr>
 800392c:	e7fa      	b.n	8003924 <main+0x7c>
 800392e:	e7fe      	b.n	800392e <main+0x86>
 8003930:	40023800 	.word	0x40023800
 8003934:	20007edc 	.word	0x20007edc
 8003938:	40002800 	.word	0x40002800
 800393c:	08003579 	.word	0x08003579
 8003940:	200001bc 	.word	0x200001bc
 8003944:	20007efc 	.word	0x20007efc
 8003948:	2000008c 	.word	0x2000008c

0800394c <_Error_Handler>:
  * @param  file: The file name as string.
  * @param  line: The line in file as a number.
  * @retval None
  */
void _Error_Handler(char *file, int line)
{
 800394c:	e7fe      	b.n	800394c <_Error_Handler>

0800394e <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800394e:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8003950:	2003      	movs	r0, #3
 8003952:	f7fc fe87 	bl	8000664 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 8003956:	2200      	movs	r2, #0
 8003958:	4611      	mov	r1, r2
 800395a:	f06f 000b 	mvn.w	r0, #11
 800395e:	f7fc fe93 	bl	8000688 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8003962:	2200      	movs	r2, #0
 8003964:	4611      	mov	r1, r2
 8003966:	f06f 000a 	mvn.w	r0, #10
 800396a:	f7fc fe8d 	bl	8000688 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 800396e:	2200      	movs	r2, #0
 8003970:	4611      	mov	r1, r2
 8003972:	f06f 0009 	mvn.w	r0, #9
 8003976:	f7fc fe87 	bl	8000688 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 800397a:	2200      	movs	r2, #0
 800397c:	4611      	mov	r1, r2
 800397e:	f06f 0004 	mvn.w	r0, #4
 8003982:	f7fc fe81 	bl	8000688 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 8003986:	2200      	movs	r2, #0
 8003988:	4611      	mov	r1, r2
 800398a:	f06f 0003 	mvn.w	r0, #3
 800398e:	f7fc fe7b 	bl	8000688 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 8003992:	2200      	movs	r2, #0
 8003994:	4611      	mov	r1, r2
 8003996:	f06f 0001 	mvn.w	r0, #1
 800399a:	f7fc fe75 	bl	8000688 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 800399e:	2200      	movs	r2, #0
 80039a0:	4611      	mov	r1, r2
 80039a2:	f04f 30ff 	mov.w	r0, #4294967295
 80039a6:	f7fc fe6f 	bl	8000688 <HAL_NVIC_SetPriority>
 80039aa:	bd08      	pop	{r3, pc}

080039ac <HAL_RTC_MspInit>:
}

void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{

  if(hrtc->Instance==RTC)
 80039ac:	6802      	ldr	r2, [r0, #0]
 80039ae:	4b04      	ldr	r3, [pc, #16]	; (80039c0 <HAL_RTC_MspInit+0x14>)
 80039b0:	429a      	cmp	r2, r3
 80039b2:	d000      	beq.n	80039b6 <HAL_RTC_MspInit+0xa>
 80039b4:	4770      	bx	lr
  {
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 80039b6:	2201      	movs	r2, #1
 80039b8:	4b02      	ldr	r3, [pc, #8]	; (80039c4 <HAL_RTC_MspInit+0x18>)
 80039ba:	601a      	str	r2, [r3, #0]
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }

}
 80039bc:	e7fa      	b.n	80039b4 <HAL_RTC_MspInit+0x8>
 80039be:	bf00      	nop
 80039c0:	40002800 	.word	0x40002800
 80039c4:	42470e3c 	.word	0x42470e3c

080039c8 <NMI_Handler>:

/**
* @brief This function handles Non maskable interrupt.
*/
void NMI_Handler(void)
{
 80039c8:	4770      	bx	lr

080039ca <HardFault_Handler>:

/**
* @brief This function handles Hard fault interrupt.
*/
void HardFault_Handler(void)
{
 80039ca:	e7fe      	b.n	80039ca <HardFault_Handler>

080039cc <MemManage_Handler>:

/**
* @brief This function handles Memory management fault.
*/
void MemManage_Handler(void)
{
 80039cc:	e7fe      	b.n	80039cc <MemManage_Handler>

080039ce <BusFault_Handler>:

/**
* @brief This function handles Pre-fetch fault, memory access fault.
*/
void BusFault_Handler(void)
{
 80039ce:	e7fe      	b.n	80039ce <BusFault_Handler>

080039d0 <UsageFault_Handler>:

/**
* @brief This function handles Undefined instruction or illegal state.
*/
void UsageFault_Handler(void)
{
 80039d0:	e7fe      	b.n	80039d0 <UsageFault_Handler>

080039d2 <SVC_Handler>:

/**
* @brief This function handles System service call via SWI instruction.
*/
void SVC_Handler(void)
{
 80039d2:	4770      	bx	lr

080039d4 <DebugMon_Handler>:

/**
* @brief This function handles Debug monitor.
*/
void DebugMon_Handler(void)
{
 80039d4:	4770      	bx	lr

080039d6 <PendSV_Handler>:

/**
* @brief This function handles Pendable request for system service.
*/
void PendSV_Handler(void)
{
 80039d6:	4770      	bx	lr

080039d8 <OTG_FS_IRQHandler>:

/**
* @brief This function handles USB On The Go FS global interrupt.
*/
void OTG_FS_IRQHandler(void)
{
 80039d8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 80039da:	4802      	ldr	r0, [pc, #8]	; (80039e4 <OTG_FS_IRQHandler+0xc>)
 80039dc:	f7fd f806 	bl	80009ec <HAL_PCD_IRQHandler>
 80039e0:	bd08      	pop	{r3, pc}
 80039e2:	bf00      	nop
 80039e4:	20008150 	.word	0x20008150

080039e8 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80039e8:	490f      	ldr	r1, [pc, #60]	; (8003a28 <SystemInit+0x40>)
 80039ea:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 80039ee:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80039f2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80039f6:	4b0d      	ldr	r3, [pc, #52]	; (8003a2c <SystemInit+0x44>)
 80039f8:	681a      	ldr	r2, [r3, #0]
 80039fa:	f042 0201 	orr.w	r2, r2, #1
 80039fe:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8003a00:	2000      	movs	r0, #0
 8003a02:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8003a04:	681a      	ldr	r2, [r3, #0]
 8003a06:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8003a0a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003a0e:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8003a10:	4a07      	ldr	r2, [pc, #28]	; (8003a30 <SystemInit+0x48>)
 8003a12:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003a14:	681a      	ldr	r2, [r3, #0]
 8003a16:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003a1a:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8003a1c:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8003a1e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003a22:	608b      	str	r3, [r1, #8]
 8003a24:	4770      	bx	lr
 8003a26:	bf00      	nop
 8003a28:	e000ed00 	.word	0xe000ed00
 8003a2c:	40023800 	.word	0x40023800
 8003a30:	24003010 	.word	0x24003010

08003a34 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 8003a34:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PreTreatment */
  
  /* Init Device Library, add supported class and start the library. */
  USBD_Init(&hUsbDeviceFS, &USR_desc, DEVICE_FS);
 8003a36:	4c09      	ldr	r4, [pc, #36]	; (8003a5c <MX_USB_DEVICE_Init+0x28>)
 8003a38:	2200      	movs	r2, #0
 8003a3a:	4909      	ldr	r1, [pc, #36]	; (8003a60 <MX_USB_DEVICE_Init+0x2c>)
 8003a3c:	4620      	mov	r0, r4
 8003a3e:	f7ff f9a2 	bl	8002d86 <USBD_Init>

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC);
 8003a42:	4908      	ldr	r1, [pc, #32]	; (8003a64 <MX_USB_DEVICE_Init+0x30>)
 8003a44:	4620      	mov	r0, r4
 8003a46:	f7ff f9b5 	bl	8002db4 <USBD_RegisterClass>

  USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS);
 8003a4a:	4907      	ldr	r1, [pc, #28]	; (8003a68 <MX_USB_DEVICE_Init+0x34>)
 8003a4c:	4620      	mov	r0, r4
 8003a4e:	f7ff f993 	bl	8002d78 <USBD_CDC_RegisterInterface>

  USBD_Start(&hUsbDeviceFS);
 8003a52:	4620      	mov	r0, r4
 8003a54:	f7ff f9b5 	bl	8002dc2 <USBD_Start>
 8003a58:	bd10      	pop	{r4, pc}
 8003a5a:	bf00      	nop
 8003a5c:	20007f2c 	.word	0x20007f2c
 8003a60:	2000012c 	.word	0x2000012c
 8003a64:	20000008 	.word	0x20000008
 8003a68:	20000104 	.word	0x20000104

08003a6c <CDC_Init_FS>:
{
  /* USER CODE BEGIN 3 */
  /* Set Application Buffers */
  /* USER CODE END 3 */
	return (USBD_OK);
}
 8003a6c:	2000      	movs	r0, #0
 8003a6e:	4770      	bx	lr

08003a70 <CDC_DeInit_FS>:
static int8_t CDC_DeInit_FS(void)
{
	  return (USBD_OK);


}
 8003a70:	2000      	movs	r0, #0
 8003a72:	4770      	bx	lr

08003a74 <CDC_Control_FS>:
  */
static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
	  return (USBD_OK);

}
 8003a74:	2000      	movs	r0, #0
 8003a76:	4770      	bx	lr

08003a78 <CDC_Receive_FS>:
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
  /* USER CODE END 6 */
	  return (USBD_OK);

}
 8003a78:	2000      	movs	r0, #0
 8003a7a:	4770      	bx	lr

08003a7c <HAL_PCD_MspInit>:
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 8003a7c:	6803      	ldr	r3, [r0, #0]
 8003a7e:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8003a82:	d000      	beq.n	8003a86 <HAL_PCD_MspInit+0xa>
 8003a84:	4770      	bx	lr
{
 8003a86:	b530      	push	{r4, r5, lr}
 8003a88:	b087      	sub	sp, #28
    PA8     ------> USB_OTG_FS_SOF
    PA9     ------> USB_OTG_FS_VBUS
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12;
 8003a8a:	f44f 53c8 	mov.w	r3, #6400	; 0x1900
 8003a8e:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8003a90:	2302      	movs	r3, #2
 8003a92:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003a94:	2400      	movs	r4, #0
 8003a96:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8003a98:	2303      	movs	r3, #3
 8003a9a:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8003a9c:	230a      	movs	r3, #10
 8003a9e:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003aa0:	4d13      	ldr	r5, [pc, #76]	; (8003af0 <HAL_PCD_MspInit+0x74>)
 8003aa2:	a901      	add	r1, sp, #4
 8003aa4:	4628      	mov	r0, r5
 8003aa6:	f7fc fe53 	bl	8000750 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9;
 8003aaa:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003aae:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8003ab0:	9402      	str	r4, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003ab2:	9403      	str	r4, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003ab4:	a901      	add	r1, sp, #4
 8003ab6:	4628      	mov	r0, r5
 8003ab8:	f7fc fe4a 	bl	8000750 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8003abc:	4b0d      	ldr	r3, [pc, #52]	; (8003af4 <HAL_PCD_MspInit+0x78>)
 8003abe:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003ac0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003ac4:	635a      	str	r2, [r3, #52]	; 0x34
 8003ac6:	9400      	str	r4, [sp, #0]
 8003ac8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003aca:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8003ace:	645a      	str	r2, [r3, #68]	; 0x44
 8003ad0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003ad2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8003ad6:	9300      	str	r3, [sp, #0]
 8003ad8:	9b00      	ldr	r3, [sp, #0]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 8003ada:	4622      	mov	r2, r4
 8003adc:	4621      	mov	r1, r4
 8003ade:	2043      	movs	r0, #67	; 0x43
 8003ae0:	f7fc fdd2 	bl	8000688 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8003ae4:	2043      	movs	r0, #67	; 0x43
 8003ae6:	f7fc fdff 	bl	80006e8 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8003aea:	b007      	add	sp, #28
 8003aec:	bd30      	pop	{r4, r5, pc}
 8003aee:	bf00      	nop
 8003af0:	40020000 	.word	0x40020000
 8003af4:	40023800 	.word	0x40023800

08003af8 <HAL_PCD_SetupStageCallback>:
  * @brief  Setup stage callback
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
 8003af8:	b508      	push	{r3, lr}
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8003afa:	f500 716f 	add.w	r1, r0, #956	; 0x3bc
 8003afe:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003b02:	f7ff f977 	bl	8002df4 <USBD_LL_SetupStage>
 8003b06:	bd08      	pop	{r3, pc}

08003b08 <HAL_PCD_DataOutStageCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8003b08:	b508      	push	{r3, lr}
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8003b0a:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8003b0e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8003b12:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8003b16:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003b1a:	f7ff f998 	bl	8002e4e <USBD_LL_DataOutStage>
 8003b1e:	bd08      	pop	{r3, pc}

08003b20 <HAL_PCD_DataInStageCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8003b20:	b508      	push	{r3, lr}
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8003b22:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8003b26:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8003b2a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003b2c:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003b30:	f7ff f9c2 	bl	8002eb8 <USBD_LL_DataInStage>
 8003b34:	bd08      	pop	{r3, pc}

08003b36 <HAL_PCD_SOFCallback>:
  * @brief  SOF callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
 8003b36:	b508      	push	{r3, lr}
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8003b38:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003b3c:	f7ff fa46 	bl	8002fcc <USBD_LL_SOF>
 8003b40:	bd08      	pop	{r3, pc}

08003b42 <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 8003b42:	b510      	push	{r4, lr}
 8003b44:	4604      	mov	r4, r0
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  /* Set USB current speed. */
  switch (hpcd->Init.speed)
 8003b46:	68c1      	ldr	r1, [r0, #12]
	
  default:
    speed = USBD_SPEED_FULL;
    break;    
  }
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8003b48:	3100      	adds	r1, #0
 8003b4a:	bf18      	it	ne
 8003b4c:	2101      	movne	r1, #1
 8003b4e:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003b52:	f7ff fa29 	bl	8002fa8 <USBD_LL_SetSpeed>
  
  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8003b56:	f8d4 03ec 	ldr.w	r0, [r4, #1004]	; 0x3ec
 8003b5a:	f7ff fa06 	bl	8002f6a <USBD_LL_Reset>
 8003b5e:	bd10      	pop	{r4, pc}

08003b60 <HAL_PCD_SuspendCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
 8003b60:	b510      	push	{r4, lr}
 8003b62:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8003b64:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003b68:	f7ff fa21 	bl	8002fae <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8003b6c:	6822      	ldr	r2, [r4, #0]
 8003b6e:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 8003b72:	f043 0301 	orr.w	r3, r3, #1
 8003b76:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8003b7a:	6a23      	ldr	r3, [r4, #32]
 8003b7c:	b123      	cbz	r3, 8003b88 <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8003b7e:	4a03      	ldr	r2, [pc, #12]	; (8003b8c <HAL_PCD_SuspendCallback+0x2c>)
 8003b80:	6913      	ldr	r3, [r2, #16]
 8003b82:	f043 0306 	orr.w	r3, r3, #6
 8003b86:	6113      	str	r3, [r2, #16]
 8003b88:	bd10      	pop	{r4, pc}
 8003b8a:	bf00      	nop
 8003b8c:	e000ed00 	.word	0xe000ed00

08003b90 <HAL_PCD_ResumeCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
 8003b90:	b508      	push	{r3, lr}
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8003b92:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003b96:	f7ff fa13 	bl	8002fc0 <USBD_LL_Resume>
 8003b9a:	bd08      	pop	{r3, pc}

08003b9c <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8003b9c:	b508      	push	{r3, lr}
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8003b9e:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003ba2:	f7ff fa23 	bl	8002fec <USBD_LL_IsoOUTIncomplete>
 8003ba6:	bd08      	pop	{r3, pc}

08003ba8 <HAL_PCD_ISOINIncompleteCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8003ba8:	b508      	push	{r3, lr}
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8003baa:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003bae:	f7ff fa1b 	bl	8002fe8 <USBD_LL_IsoINIncomplete>
 8003bb2:	bd08      	pop	{r3, pc}

08003bb4 <HAL_PCD_ConnectCallback>:
  * @brief  Connect callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
 8003bb4:	b508      	push	{r3, lr}
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 8003bb6:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003bba:	f7ff fa19 	bl	8002ff0 <USBD_LL_DevConnected>
 8003bbe:	bd08      	pop	{r3, pc}

08003bc0 <HAL_PCD_DisconnectCallback>:
  * @brief  Disconnect callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
 8003bc0:	b508      	push	{r3, lr}
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 8003bc2:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003bc6:	f7ff fa15 	bl	8002ff4 <USBD_LL_DevDisconnected>
 8003bca:	bd08      	pop	{r3, pc}

08003bcc <USBD_LL_Init>:
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 8003bcc:	7803      	ldrb	r3, [r0, #0]
 8003bce:	b10b      	cbz	r3, 8003bd4 <USBD_LL_Init+0x8>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
  }
  return USBD_OK;
}
 8003bd0:	2000      	movs	r0, #0
 8003bd2:	4770      	bx	lr
{
 8003bd4:	b510      	push	{r4, lr}
 8003bd6:	4603      	mov	r3, r0
  hpcd_USB_OTG_FS.pData = pdev;
 8003bd8:	4817      	ldr	r0, [pc, #92]	; (8003c38 <USBD_LL_Init+0x6c>)
 8003bda:	f8c0 33ec 	str.w	r3, [r0, #1004]	; 0x3ec
  pdev->pData = &hpcd_USB_OTG_FS;
 8003bde:	f8c3 0220 	str.w	r0, [r3, #544]	; 0x220
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8003be2:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8003be6:	6003      	str	r3, [r0, #0]
  hpcd_USB_OTG_FS.Init.dev_endpoints = 5;
 8003be8:	2305      	movs	r3, #5
 8003bea:	6043      	str	r3, [r0, #4]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8003bec:	2202      	movs	r2, #2
 8003bee:	60c2      	str	r2, [r0, #12]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 8003bf0:	2300      	movs	r3, #0
 8003bf2:	6103      	str	r3, [r0, #16]
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 8003bf4:	6143      	str	r3, [r0, #20]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8003bf6:	6182      	str	r2, [r0, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = ENABLE;
 8003bf8:	2201      	movs	r2, #1
 8003bfa:	61c2      	str	r2, [r0, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8003bfc:	6203      	str	r3, [r0, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8003bfe:	6243      	str	r3, [r0, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 8003c00:	62c2      	str	r2, [r0, #44]	; 0x2c
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 8003c02:	6303      	str	r3, [r0, #48]	; 0x30
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8003c04:	f7fc fe72 	bl	80008ec <HAL_PCD_Init>
 8003c08:	b980      	cbnz	r0, 8003c2c <USBD_LL_Init+0x60>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 8003c0a:	4c0b      	ldr	r4, [pc, #44]	; (8003c38 <USBD_LL_Init+0x6c>)
 8003c0c:	2180      	movs	r1, #128	; 0x80
 8003c0e:	4620      	mov	r0, r4
 8003c10:	f7fd fb5d 	bl	80012ce <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8003c14:	2240      	movs	r2, #64	; 0x40
 8003c16:	2100      	movs	r1, #0
 8003c18:	4620      	mov	r0, r4
 8003c1a:	f7fd fb33 	bl	8001284 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 8003c1e:	2280      	movs	r2, #128	; 0x80
 8003c20:	2101      	movs	r1, #1
 8003c22:	4620      	mov	r0, r4
 8003c24:	f7fd fb2e 	bl	8001284 <HAL_PCDEx_SetTxFiFo>
}
 8003c28:	2000      	movs	r0, #0
 8003c2a:	bd10      	pop	{r4, pc}
    _Error_Handler(__FILE__, __LINE__);
 8003c2c:	f240 1153 	movw	r1, #339	; 0x153
 8003c30:	4802      	ldr	r0, [pc, #8]	; (8003c3c <USBD_LL_Init+0x70>)
 8003c32:	f7ff fe8b 	bl	800394c <_Error_Handler>
 8003c36:	e7e8      	b.n	8003c0a <USBD_LL_Init+0x3e>
 8003c38:	20008150 	.word	0x20008150
 8003c3c:	08008f98 	.word	0x08008f98

08003c40 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver. 
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8003c40:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
 
  hal_status = HAL_PCD_Start(pdev->pData);
 8003c42:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003c46:	f7fc febb 	bl	80009c0 <HAL_PCD_Start>
     
  switch (hal_status) {
 8003c4a:	b120      	cbz	r0, 8003c56 <USBD_LL_Start+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003c4c:	2802      	cmp	r0, #2
 8003c4e:	bf0c      	ite	eq
 8003c50:	2001      	moveq	r0, #1
 8003c52:	2002      	movne	r0, #2
 8003c54:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003c56:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003c58:	bd08      	pop	{r3, pc}

08003c5a <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8003c5a:	b510      	push	{r4, lr}
 8003c5c:	461c      	mov	r4, r3
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8003c5e:	4613      	mov	r3, r2
 8003c60:	4622      	mov	r2, r4
 8003c62:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003c66:	f7fd f9eb 	bl	8001040 <HAL_PCD_EP_Open>

  switch (hal_status) {
 8003c6a:	b120      	cbz	r0, 8003c76 <USBD_LL_OpenEP+0x1c>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003c6c:	2802      	cmp	r0, #2
 8003c6e:	bf0c      	ite	eq
 8003c70:	2001      	moveq	r0, #1
 8003c72:	2002      	movne	r0, #2
 8003c74:	bd10      	pop	{r4, pc}
      usb_status = USBD_OK;
 8003c76:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003c78:	bd10      	pop	{r4, pc}

08003c7a <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003c7a:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8003c7c:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003c80:	f7fd fa1f 	bl	80010c2 <HAL_PCD_EP_Close>
      
  switch (hal_status) {
 8003c84:	b120      	cbz	r0, 8003c90 <USBD_LL_CloseEP+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003c86:	2802      	cmp	r0, #2
 8003c88:	bf0c      	ite	eq
 8003c8a:	2001      	moveq	r0, #1
 8003c8c:	2002      	movne	r0, #2
 8003c8e:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003c90:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 8003c92:	bd08      	pop	{r3, pc}

08003c94 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003c94:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8003c96:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003c9a:	f7fd fa95 	bl	80011c8 <HAL_PCD_EP_SetStall>

  switch (hal_status) {
 8003c9e:	b120      	cbz	r0, 8003caa <USBD_LL_StallEP+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003ca0:	2802      	cmp	r0, #2
 8003ca2:	bf0c      	ite	eq
 8003ca4:	2001      	moveq	r0, #1
 8003ca6:	2002      	movne	r0, #2
 8003ca8:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003caa:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 8003cac:	bd08      	pop	{r3, pc}

08003cae <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003cae:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 8003cb0:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003cb4:	f7fd fabb 	bl	800122e <HAL_PCD_EP_ClrStall>
     
  switch (hal_status) {
 8003cb8:	b120      	cbz	r0, 8003cc4 <USBD_LL_ClearStallEP+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003cba:	2802      	cmp	r0, #2
 8003cbc:	bf0c      	ite	eq
 8003cbe:	2001      	moveq	r0, #1
 8003cc0:	2002      	movne	r0, #2
 8003cc2:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003cc4:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status; 
}
 8003cc6:	bd08      	pop	{r3, pc}

08003cc8 <USBD_LL_IsStallEP>:
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8003cc8:	f8d0 2220 	ldr.w	r2, [r0, #544]	; 0x220
  
  if((ep_addr & 0x80) == 0x80)
 8003ccc:	f011 0f80 	tst.w	r1, #128	; 0x80
 8003cd0:	d108      	bne.n	8003ce4 <USBD_LL_IsStallEP+0x1c>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8003cd2:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8003cd6:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8003cda:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8003cde:	f891 01fa 	ldrb.w	r0, [r1, #506]	; 0x1fa
  }
}
 8003ce2:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8003ce4:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8003ce8:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8003cec:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8003cf0:	f893 003a 	ldrb.w	r0, [r3, #58]	; 0x3a
 8003cf4:	4770      	bx	lr

08003cf6 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8003cf6:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8003cf8:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003cfc:	f7fd f98e 	bl	800101c <HAL_PCD_SetAddress>
     
  switch (hal_status) {
 8003d00:	b120      	cbz	r0, 8003d0c <USBD_LL_SetUSBAddress+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003d02:	2802      	cmp	r0, #2
 8003d04:	bf0c      	ite	eq
 8003d06:	2001      	moveq	r0, #1
 8003d08:	2002      	movne	r0, #2
 8003d0a:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003d0c:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 8003d0e:	bd08      	pop	{r3, pc}

08003d10 <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size    
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8003d10:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8003d12:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003d16:	f7fd fa2e 	bl	8001176 <HAL_PCD_EP_Transmit>
     
  switch (hal_status) {
 8003d1a:	b120      	cbz	r0, 8003d26 <USBD_LL_Transmit+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003d1c:	2802      	cmp	r0, #2
 8003d1e:	bf0c      	ite	eq
 8003d20:	2001      	moveq	r0, #1
 8003d22:	2002      	movne	r0, #2
 8003d24:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003d26:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;    
}
 8003d28:	bd08      	pop	{r3, pc}

08003d2a <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8003d2a:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8003d2c:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003d30:	f7fd f9eb 	bl	800110a <HAL_PCD_EP_Receive>
     
  switch (hal_status) {
 8003d34:	b120      	cbz	r0, 8003d40 <USBD_LL_PrepareReceive+0x16>
    case HAL_OK :
      usb_status = USBD_OK;
    break;
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8003d36:	2802      	cmp	r0, #2
 8003d38:	bf0c      	ite	eq
 8003d3a:	2001      	moveq	r0, #1
 8003d3c:	2002      	movne	r0, #2
 8003d3e:	bd08      	pop	{r3, pc}
      usb_status = USBD_OK;
 8003d40:	2000      	movs	r0, #0
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status; 
}
 8003d42:	bd08      	pop	{r3, pc}

08003d44 <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003d44:	b508      	push	{r3, lr}
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 8003d46:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003d4a:	f7fd fa0b 	bl	8001164 <HAL_PCD_EP_GetRxCount>
}
 8003d4e:	bd08      	pop	{r3, pc}

08003d50 <USBD_USR_DeviceDescriptor>:
     HIBYTE(USBD_LANGID_STRING),
};

uint8_t *USBD_USR_DeviceDescriptor(uint8_t speed , uint16_t *length)
{
    *length = sizeof(USBD_DeviceDesc);
 8003d50:	2312      	movs	r3, #18
 8003d52:	800b      	strh	r3, [r1, #0]
    return USBD_DeviceDesc;
}
 8003d54:	4800      	ldr	r0, [pc, #0]	; (8003d58 <USBD_USR_DeviceDescriptor+0x8>)
 8003d56:	4770      	bx	lr
 8003d58:	20000114 	.word	0x20000114

08003d5c <USBD_USR_LangIDStrDescriptor>:

uint8_t *USBD_USR_LangIDStrDescriptor(uint8_t speed , uint16_t *length)
{
    *length =  sizeof(USBD_LangIDDesc);
 8003d5c:	2304      	movs	r3, #4
 8003d5e:	800b      	strh	r3, [r1, #0]
    return USBD_LangIDDesc;
}
 8003d60:	4800      	ldr	r0, [pc, #0]	; (8003d64 <USBD_USR_LangIDStrDescriptor+0x8>)
 8003d62:	4770      	bx	lr
 8003d64:	20000128 	.word	0x20000128

08003d68 <USBD_USR_ProductStrDescriptor>:

uint8_t *USBD_USR_ProductStrDescriptor(uint8_t speed , uint16_t *length)
{
 8003d68:	b508      	push	{r3, lr}
 8003d6a:	460a      	mov	r2, r1
    {
        USBD_GetString((uint8_t *)USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
    }
    else
    {
        USBD_GetString((uint8_t *)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);
 8003d6c:	4902      	ldr	r1, [pc, #8]	; (8003d78 <USBD_USR_ProductStrDescriptor+0x10>)
 8003d6e:	4803      	ldr	r0, [pc, #12]	; (8003d7c <USBD_USR_ProductStrDescriptor+0x14>)
 8003d70:	f7ff fb81 	bl	8003476 <USBD_GetString>
    }
    return USBD_StrDesc;
}
 8003d74:	4800      	ldr	r0, [pc, #0]	; (8003d78 <USBD_USR_ProductStrDescriptor+0x10>)
 8003d76:	bd08      	pop	{r3, pc}
 8003d78:	20008540 	.word	0x20008540
 8003d7c:	08008fdc 	.word	0x08008fdc

08003d80 <USBD_USR_ManufacturerStrDescriptor>:

uint8_t *USBD_USR_ManufacturerStrDescriptor( uint8_t speed , uint16_t *length)
{
 8003d80:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8003d82:	4c04      	ldr	r4, [pc, #16]	; (8003d94 <USBD_USR_ManufacturerStrDescriptor+0x14>)
 8003d84:	460a      	mov	r2, r1
 8003d86:	4621      	mov	r1, r4
 8003d88:	4803      	ldr	r0, [pc, #12]	; (8003d98 <USBD_USR_ManufacturerStrDescriptor+0x18>)
 8003d8a:	f7ff fb74 	bl	8003476 <USBD_GetString>
    return USBD_StrDesc;
}
 8003d8e:	4620      	mov	r0, r4
 8003d90:	bd10      	pop	{r4, pc}
 8003d92:	bf00      	nop
 8003d94:	20008540 	.word	0x20008540
 8003d98:	08008fcc 	.word	0x08008fcc

08003d9c <USBD_USR_SerialStrDescriptor>:

uint8_t *USBD_USR_SerialStrDescriptor( uint8_t speed , uint16_t *length)
{
 8003d9c:	b508      	push	{r3, lr}
 8003d9e:	460a      	mov	r2, r1
    if(speed  == USB_OTG_SPEED_HIGH)
 8003da0:	b128      	cbz	r0, 8003dae <USBD_USR_SerialStrDescriptor+0x12>
    {
        USBD_GetString((uint8_t *)USBD_SERIALNUMBER_HS_STRING, USBD_StrDesc, length);
    }
    else
    {
        USBD_GetString((uint8_t *)USBD_SERIALNUMBER_FS_STRING, USBD_StrDesc, length);
 8003da2:	4905      	ldr	r1, [pc, #20]	; (8003db8 <USBD_USR_SerialStrDescriptor+0x1c>)
 8003da4:	4805      	ldr	r0, [pc, #20]	; (8003dbc <USBD_USR_SerialStrDescriptor+0x20>)
 8003da6:	f7ff fb66 	bl	8003476 <USBD_GetString>
    }
    return USBD_StrDesc;
}
 8003daa:	4803      	ldr	r0, [pc, #12]	; (8003db8 <USBD_USR_SerialStrDescriptor+0x1c>)
 8003dac:	bd08      	pop	{r3, pc}
        USBD_GetString((uint8_t *)USBD_SERIALNUMBER_HS_STRING, USBD_StrDesc, length);
 8003dae:	4902      	ldr	r1, [pc, #8]	; (8003db8 <USBD_USR_SerialStrDescriptor+0x1c>)
 8003db0:	4803      	ldr	r0, [pc, #12]	; (8003dc0 <USBD_USR_SerialStrDescriptor+0x24>)
 8003db2:	f7ff fb60 	bl	8003476 <USBD_GetString>
 8003db6:	e7f8      	b.n	8003daa <USBD_USR_SerialStrDescriptor+0xe>
 8003db8:	20008540 	.word	0x20008540
 8003dbc:	08008ffc 	.word	0x08008ffc
 8003dc0:	08008fec 	.word	0x08008fec

08003dc4 <USBD_USR_ConfigStrDescriptor>:

uint8_t *USBD_USR_ConfigStrDescriptor( uint8_t speed , uint16_t *length)
{
 8003dc4:	b508      	push	{r3, lr}
 8003dc6:	460a      	mov	r2, r1
    {
        USBD_GetString((uint8_t *)USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
    }
    else
    {
        USBD_GetString((uint8_t *)USBD_CONFIGURATION_FS_STRING, USBD_StrDesc, length);
 8003dc8:	4902      	ldr	r1, [pc, #8]	; (8003dd4 <USBD_USR_ConfigStrDescriptor+0x10>)
 8003dca:	4803      	ldr	r0, [pc, #12]	; (8003dd8 <USBD_USR_ConfigStrDescriptor+0x14>)
 8003dcc:	f7ff fb53 	bl	8003476 <USBD_GetString>
    }
    return USBD_StrDesc;
}
 8003dd0:	4800      	ldr	r0, [pc, #0]	; (8003dd4 <USBD_USR_ConfigStrDescriptor+0x10>)
 8003dd2:	bd08      	pop	{r3, pc}
 8003dd4:	20008540 	.word	0x20008540
 8003dd8:	08008fac 	.word	0x08008fac

08003ddc <USBD_USR_InterfaceStrDescriptor>:

uint8_t *USBD_USR_InterfaceStrDescriptor( uint8_t speed , uint16_t *length)
{
 8003ddc:	b508      	push	{r3, lr}
 8003dde:	460a      	mov	r2, r1
    {
        USBD_GetString((uint8_t *)USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
    }
    else
    {
        USBD_GetString((uint8_t *)USBD_INTERFACE_FS_STRING, USBD_StrDesc, length);
 8003de0:	4902      	ldr	r1, [pc, #8]	; (8003dec <USBD_USR_InterfaceStrDescriptor+0x10>)
 8003de2:	4803      	ldr	r0, [pc, #12]	; (8003df0 <USBD_USR_InterfaceStrDescriptor+0x14>)
 8003de4:	f7ff fb47 	bl	8003476 <USBD_GetString>
    }
    return USBD_StrDesc;
}
 8003de8:	4800      	ldr	r0, [pc, #0]	; (8003dec <USBD_USR_InterfaceStrDescriptor+0x10>)
 8003dea:	bd08      	pop	{r3, pc}
 8003dec:	20008540 	.word	0x20008540
 8003df0:	08008fbc 	.word	0x08008fbc

08003df4 <entry_by_mac>:
			return &config->entries[i];
	return NULL;
}

static dhcp_entry_t *entry_by_mac(uint8_t *mac)
{
 8003df4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int i;
	for (i = 0; i < config->num_entry; i++)
 8003df8:	4b0e      	ldr	r3, [pc, #56]	; (8003e34 <entry_by_mac+0x40>)
 8003dfa:	681b      	ldr	r3, [r3, #0]
 8003dfc:	f8d3 8010 	ldr.w	r8, [r3, #16]
 8003e00:	f1b8 0f00 	cmp.w	r8, #0
 8003e04:	dd13      	ble.n	8003e2e <entry_by_mac+0x3a>
 8003e06:	4606      	mov	r6, r0
 8003e08:	695c      	ldr	r4, [r3, #20]
		if (memcmp(config->entries[i].mac, mac, 6) == 0)
 8003e0a:	2500      	movs	r5, #0
 8003e0c:	f04f 0906 	mov.w	r9, #6
 8003e10:	4627      	mov	r7, r4
 8003e12:	464a      	mov	r2, r9
 8003e14:	4631      	mov	r1, r6
 8003e16:	4620      	mov	r0, r4
 8003e18:	f005 f840 	bl	8008e9c <memcmp>
 8003e1c:	b120      	cbz	r0, 8003e28 <entry_by_mac+0x34>
	for (i = 0; i < config->num_entry; i++)
 8003e1e:	3501      	adds	r5, #1
 8003e20:	3414      	adds	r4, #20
 8003e22:	4545      	cmp	r5, r8
 8003e24:	d1f4      	bne.n	8003e10 <entry_by_mac+0x1c>
			return &config->entries[i];
	return NULL;
 8003e26:	2700      	movs	r7, #0
}
 8003e28:	4638      	mov	r0, r7
 8003e2a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return NULL;
 8003e2e:	2700      	movs	r7, #0
 8003e30:	e7fa      	b.n	8003e28 <entry_by_mac+0x34>
 8003e32:	bf00      	nop
 8003e34:	20000de8 	.word	0x20000de8

08003e38 <find_dhcp_option>:
{
	memset(entry->mac, 0, 6);
}

uint8_t *find_dhcp_option(uint8_t *attrs, int size, uint8_t attr)
{
 8003e38:	b430      	push	{r4, r5}
	int i = 0;
 8003e3a:	2300      	movs	r3, #0
	while ((i + 1) < size)
 8003e3c:	1c5c      	adds	r4, r3, #1
 8003e3e:	428c      	cmp	r4, r1
 8003e40:	da0b      	bge.n	8003e5a <find_dhcp_option+0x22>
	{
		int next = i + attrs[i + 1] + 2;
 8003e42:	461c      	mov	r4, r3
 8003e44:	18c5      	adds	r5, r0, r3
 8003e46:	786d      	ldrb	r5, [r5, #1]
 8003e48:	442b      	add	r3, r5
 8003e4a:	3302      	adds	r3, #2
		if (next > size) return NULL;
 8003e4c:	4299      	cmp	r1, r3
 8003e4e:	db08      	blt.n	8003e62 <find_dhcp_option+0x2a>
		if (attrs[i] == attr)
 8003e50:	1905      	adds	r5, r0, r4
 8003e52:	5d04      	ldrb	r4, [r0, r4]
 8003e54:	4294      	cmp	r4, r2
 8003e56:	d1f1      	bne.n	8003e3c <find_dhcp_option+0x4>
 8003e58:	e000      	b.n	8003e5c <find_dhcp_option+0x24>
			return attrs + i;
		i = next;
	}
	return NULL;
 8003e5a:	2500      	movs	r5, #0
}
 8003e5c:	4628      	mov	r0, r5
 8003e5e:	bc30      	pop	{r4, r5}
 8003e60:	4770      	bx	lr
		if (next > size) return NULL;
 8003e62:	2500      	movs	r5, #0
 8003e64:	e7fa      	b.n	8003e5c <find_dhcp_option+0x24>

08003e66 <fill_options>:
	uint32_t dns,
	int lease_time,
	uint32_t serverid,
	uint32_t router,
	uint32_t subnet)
{
 8003e66:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003e6a:	4604      	mov	r4, r0
 8003e6c:	4617      	mov	r7, r2
 8003e6e:	4698      	mov	r8, r3
 8003e70:	9b08      	ldr	r3, [sp, #32]
 8003e72:	9d0a      	ldr	r5, [sp, #40]	; 0x28
	uint8_t *ptr = (uint8_t *)dest;
	/* ACK message type */
	*ptr++ = 53;
 8003e74:	2235      	movs	r2, #53	; 0x35
 8003e76:	7002      	strb	r2, [r0, #0]
	*ptr++ = 1;
 8003e78:	2001      	movs	r0, #1
 8003e7a:	7060      	strb	r0, [r4, #1]
	*ptr++ = msg_type;
 8003e7c:	70a1      	strb	r1, [r4, #2]

	/* dhcp server identifier */
	*ptr++ = DHCP_SERVERID;
 8003e7e:	2236      	movs	r2, #54	; 0x36
 8003e80:	70e2      	strb	r2, [r4, #3]
	*ptr++ = 4;
 8003e82:	2204      	movs	r2, #4
 8003e84:	7122      	strb	r2, [r4, #4]
	*(uint32_t *)ptr = serverid;
 8003e86:	9909      	ldr	r1, [sp, #36]	; 0x24
 8003e88:	f8c4 1005 	str.w	r1, [r4, #5]
	ptr += 4;

	/* lease time */
	*ptr++ = DHCP_LEASETIME;
 8003e8c:	2133      	movs	r1, #51	; 0x33
 8003e8e:	7261      	strb	r1, [r4, #9]
	*ptr++ = 4;
 8003e90:	72a2      	strb	r2, [r4, #10]
	*ptr++ = (lease_time >> 24) & 0xFF;
 8003e92:	0e19      	lsrs	r1, r3, #24
 8003e94:	72e1      	strb	r1, [r4, #11]
	*ptr++ = (lease_time >> 16) & 0xFF;
 8003e96:	1419      	asrs	r1, r3, #16
 8003e98:	7321      	strb	r1, [r4, #12]
	*ptr++ = (lease_time >> 8) & 0xFF;
 8003e9a:	1219      	asrs	r1, r3, #8
 8003e9c:	7361      	strb	r1, [r4, #13]
	*ptr++ = (lease_time >> 0) & 0xFF;
 8003e9e:	73a3      	strb	r3, [r4, #14]

	/* subnet mask */
	*ptr++ = DHCP_SUBNETMASK;
 8003ea0:	73e0      	strb	r0, [r4, #15]
	*ptr++ = 4;
 8003ea2:	7422      	strb	r2, [r4, #16]
	*(uint32_t *)ptr = subnet;
 8003ea4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8003ea6:	f8c4 3011 	str.w	r3, [r4, #17]
	ptr += 4;

	/* router */
	if (router != 0)
 8003eaa:	bb15      	cbnz	r5, 8003ef2 <fill_options+0x8c>
	ptr += 4;
 8003eac:	f104 0515 	add.w	r5, r4, #21
		*(uint32_t *)ptr = router;
		ptr += 4;
	}

	/* domain name */
	if (domain != NULL)
 8003eb0:	b17f      	cbz	r7, 8003ed2 <fill_options+0x6c>
	{
		int len = strlen(domain);
 8003eb2:	4638      	mov	r0, r7
 8003eb4:	f7fc f990 	bl	80001d8 <strlen>
 8003eb8:	4681      	mov	r9, r0
		*ptr++ = DHCP_DNSDOMAIN;
 8003eba:	462e      	mov	r6, r5
 8003ebc:	230f      	movs	r3, #15
 8003ebe:	f806 3b02 	strb.w	r3, [r6], #2
		*ptr++ = len;
 8003ec2:	7068      	strb	r0, [r5, #1]
		memcpy(ptr, domain, len);
 8003ec4:	4602      	mov	r2, r0
 8003ec6:	4639      	mov	r1, r7
 8003ec8:	4630      	mov	r0, r6
 8003eca:	f004 fff6 	bl	8008eba <memcpy>
		ptr += len;
 8003ece:	eb06 0509 	add.w	r5, r6, r9
	}

	/* domain name server (DNS) */
	if (dns != 0)
 8003ed2:	f1b8 0f00 	cmp.w	r8, #0
 8003ed6:	d006      	beq.n	8003ee6 <fill_options+0x80>
	{
		*ptr++ = DHCP_DNSSERVER;
 8003ed8:	2306      	movs	r3, #6
 8003eda:	702b      	strb	r3, [r5, #0]
		*ptr++ = 4;
 8003edc:	2304      	movs	r3, #4
 8003ede:	706b      	strb	r3, [r5, #1]
		*(uint32_t *)ptr = dns;
 8003ee0:	f8c5 8002 	str.w	r8, [r5, #2]
		ptr += 4;
 8003ee4:	3506      	adds	r5, #6
	}

	/* end */
	*ptr++ = DHCP_END;
 8003ee6:	23ff      	movs	r3, #255	; 0xff
 8003ee8:	f805 3b01 	strb.w	r3, [r5], #1
	return ptr - (uint8_t *)dest;
}
 8003eec:	1b28      	subs	r0, r5, r4
 8003eee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		*ptr++ = DHCP_ROUTER;
 8003ef2:	2303      	movs	r3, #3
 8003ef4:	7563      	strb	r3, [r4, #21]
		*ptr++ = 4;
 8003ef6:	2304      	movs	r3, #4
 8003ef8:	75a3      	strb	r3, [r4, #22]
		*(uint32_t *)ptr = router;
 8003efa:	f8c4 5017 	str.w	r5, [r4, #23]
		ptr += 4;
 8003efe:	f104 051b 	add.w	r5, r4, #27
 8003f02:	e7d5      	b.n	8003eb0 <fill_options+0x4a>

08003f04 <udp_recv_proc>:

static void udp_recv_proc(void *arg, struct udp_pcb *upcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
 8003f04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003f08:	b087      	sub	sp, #28
 8003f0a:	460d      	mov	r5, r1
 8003f0c:	4614      	mov	r4, r2
 8003f0e:	f8bd 6040 	ldrh.w	r6, [sp, #64]	; 0x40
	dhcp_entry_t *entry;
	struct pbuf *pp;

	int n = p->len;
	if (n > sizeof(dhcp_data)) n = sizeof(dhcp_data);
	memcpy(&dhcp_data, p->payload, n);
 8003f12:	4f84      	ldr	r7, [pc, #528]	; (8004124 <udp_recv_proc+0x220>)
 8003f14:	8952      	ldrh	r2, [r2, #10]
 8003f16:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
 8003f1a:	bf28      	it	cs
 8003f1c:	f44f 7201 	movcs.w	r2, #516	; 0x204
 8003f20:	6861      	ldr	r1, [r4, #4]
 8003f22:	4638      	mov	r0, r7
 8003f24:	f004 ffc9 	bl	8008eba <memcpy>
	switch (dhcp_data.dp_options[2])
 8003f28:	f897 30f2 	ldrb.w	r3, [r7, #242]	; 0xf2
 8003f2c:	2b01      	cmp	r3, #1
 8003f2e:	d007      	beq.n	8003f40 <udp_recv_proc+0x3c>
 8003f30:	2b03      	cmp	r3, #3
 8003f32:	d070      	beq.n	8004016 <udp_recv_proc+0x112>
			break;

		default:
				break;
	}
	pbuf_free(p);
 8003f34:	4620      	mov	r0, r4
 8003f36:	f001 fbb4 	bl	80056a2 <pbuf_free>
}
 8003f3a:	b007      	add	sp, #28
 8003f3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			entry = entry_by_mac(dhcp_data.dp_chaddr);
 8003f40:	4879      	ldr	r0, [pc, #484]	; (8004128 <udp_recv_proc+0x224>)
 8003f42:	f7ff ff57 	bl	8003df4 <entry_by_mac>
			if (entry == NULL) entry = vacant_address();
 8003f46:	4681      	mov	r9, r0
 8003f48:	2800      	cmp	r0, #0
 8003f4a:	d043      	beq.n	8003fd4 <udp_recv_proc+0xd0>
			dhcp_data.dp_op = 2; /* reply */
 8003f4c:	4f75      	ldr	r7, [pc, #468]	; (8004124 <udp_recv_proc+0x220>)
 8003f4e:	f04f 0a02 	mov.w	sl, #2
 8003f52:	f887 a000 	strb.w	sl, [r7]
			dhcp_data.dp_secs = 0;
 8003f56:	f04f 0800 	mov.w	r8, #0
 8003f5a:	f8a7 8008 	strh.w	r8, [r7, #8]
			dhcp_data.dp_flags = 0;
 8003f5e:	f8a7 800a 	strh.w	r8, [r7, #10]
			*(uint32_t *)dhcp_data.dp_yiaddr = *(uint32_t *)entry->addr;
 8003f62:	f8d9 3006 	ldr.w	r3, [r9, #6]
 8003f66:	613b      	str	r3, [r7, #16]
			memcpy(dhcp_data.dp_magic, magic_cookie, 4);
 8003f68:	4b70      	ldr	r3, [pc, #448]	; (800412c <udp_recv_proc+0x228>)
 8003f6a:	681b      	ldr	r3, [r3, #0]
 8003f6c:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
			memset(dhcp_data.dp_options, 0, sizeof(dhcp_data.dp_options));
 8003f70:	37f0      	adds	r7, #240	; 0xf0
 8003f72:	f240 1213 	movw	r2, #275	; 0x113
 8003f76:	4641      	mov	r1, r8
 8003f78:	4638      	mov	r0, r7
 8003f7a:	f004 ffa9 	bl	8008ed0 <memset>
				config->domain,
 8003f7e:	4b6c      	ldr	r3, [pc, #432]	; (8004130 <udp_recv_proc+0x22c>)
 8003f80:	681a      	ldr	r2, [r3, #0]
			fill_options(dhcp_data.dp_options,
 8003f82:	6811      	ldr	r1, [r2, #0]
 8003f84:	f8d2 3006 	ldr.w	r3, [r2, #6]
 8003f88:	68d2      	ldr	r2, [r2, #12]
 8003f8a:	f8d9 000a 	ldr.w	r0, [r9, #10]
 8003f8e:	9003      	str	r0, [sp, #12]
 8003f90:	9102      	str	r1, [sp, #8]
 8003f92:	9101      	str	r1, [sp, #4]
 8003f94:	f8d9 1010 	ldr.w	r1, [r9, #16]
 8003f98:	9100      	str	r1, [sp, #0]
 8003f9a:	4651      	mov	r1, sl
 8003f9c:	4638      	mov	r0, r7
 8003f9e:	f7ff ff62 	bl	8003e66 <fill_options>
			pp = pbuf_alloc(PBUF_TRANSPORT, sizeof(dhcp_data), PBUF_POOL);
 8003fa2:	2203      	movs	r2, #3
 8003fa4:	f44f 7101 	mov.w	r1, #516	; 0x204
 8003fa8:	4640      	mov	r0, r8
 8003faa:	f001 fba9 	bl	8005700 <pbuf_alloc>
			if (pp == NULL) break;
 8003fae:	4607      	mov	r7, r0
 8003fb0:	2800      	cmp	r0, #0
 8003fb2:	d0bf      	beq.n	8003f34 <udp_recv_proc+0x30>
			memcpy(pp->payload, &dhcp_data, sizeof(dhcp_data));
 8003fb4:	f44f 7201 	mov.w	r2, #516	; 0x204
 8003fb8:	495a      	ldr	r1, [pc, #360]	; (8004124 <udp_recv_proc+0x220>)
 8003fba:	6840      	ldr	r0, [r0, #4]
 8003fbc:	f004 ff7d 	bl	8008eba <memcpy>
			udp_sendto(upcb, pp, IP_ADDR_BROADCAST, port);
 8003fc0:	4633      	mov	r3, r6
 8003fc2:	4a5c      	ldr	r2, [pc, #368]	; (8004134 <udp_recv_proc+0x230>)
 8003fc4:	4639      	mov	r1, r7
 8003fc6:	4628      	mov	r0, r5
 8003fc8:	f004 faec 	bl	80085a4 <udp_sendto>
			pbuf_free(pp);
 8003fcc:	4638      	mov	r0, r7
 8003fce:	f001 fb68 	bl	80056a2 <pbuf_free>
			break;
 8003fd2:	e7af      	b.n	8003f34 <udp_recv_proc+0x30>
	for (i = 0; i < config->num_entry; i++)
 8003fd4:	4b56      	ldr	r3, [pc, #344]	; (8004130 <udp_recv_proc+0x22c>)
 8003fd6:	681b      	ldr	r3, [r3, #0]
 8003fd8:	f8d3 9010 	ldr.w	r9, [r3, #16]
 8003fdc:	f1b9 0f00 	cmp.w	r9, #0
 8003fe0:	dda8      	ble.n	8003f34 <udp_recv_proc+0x30>
		if (is_vacant(config->entries + i))
 8003fe2:	695b      	ldr	r3, [r3, #20]
 8003fe4:	9305      	str	r3, [sp, #20]
 8003fe6:	461f      	mov	r7, r3
 8003fe8:	f04f 0800 	mov.w	r8, #0
	return memcmp("\0\0\0\0\0", entry->mac, 6) == 0;
 8003fec:	f8df b14c 	ldr.w	fp, [pc, #332]	; 800413c <udp_recv_proc+0x238>
 8003ff0:	f04f 0a06 	mov.w	sl, #6
 8003ff4:	4652      	mov	r2, sl
 8003ff6:	4639      	mov	r1, r7
 8003ff8:	4658      	mov	r0, fp
 8003ffa:	f004 ff4f 	bl	8008e9c <memcmp>
		if (is_vacant(config->entries + i))
 8003ffe:	b128      	cbz	r0, 800400c <udp_recv_proc+0x108>
	for (i = 0; i < config->num_entry; i++)
 8004000:	f108 0801 	add.w	r8, r8, #1
 8004004:	3714      	adds	r7, #20
 8004006:	45c1      	cmp	r9, r8
 8004008:	d1f4      	bne.n	8003ff4 <udp_recv_proc+0xf0>
 800400a:	e793      	b.n	8003f34 <udp_recv_proc+0x30>
			if (entry == NULL) break;
 800400c:	9b05      	ldr	r3, [sp, #20]
 800400e:	f113 0914 	adds.w	r9, r3, #20
 8004012:	d08f      	beq.n	8003f34 <udp_recv_proc+0x30>
 8004014:	e79a      	b.n	8003f4c <udp_recv_proc+0x48>
			ptr = find_dhcp_option(dhcp_data.dp_options, sizeof(dhcp_data.dp_options), DHCP_IPADDRESS);
 8004016:	2232      	movs	r2, #50	; 0x32
 8004018:	f240 1113 	movw	r1, #275	; 0x113
 800401c:	4846      	ldr	r0, [pc, #280]	; (8004138 <udp_recv_proc+0x234>)
 800401e:	f7ff ff0b 	bl	8003e38 <find_dhcp_option>
			if (ptr == NULL) break;
 8004022:	4607      	mov	r7, r0
 8004024:	2800      	cmp	r0, #0
 8004026:	d085      	beq.n	8003f34 <udp_recv_proc+0x30>
			if (ptr[1] != 4) break;
 8004028:	7843      	ldrb	r3, [r0, #1]
 800402a:	2b04      	cmp	r3, #4
 800402c:	d182      	bne.n	8003f34 <udp_recv_proc+0x30>
			entry = entry_by_mac(dhcp_data.dp_chaddr);
 800402e:	483e      	ldr	r0, [pc, #248]	; (8004128 <udp_recv_proc+0x224>)
 8004030:	f7ff fee0 	bl	8003df4 <entry_by_mac>
			if (entry != NULL) free_entry(entry);
 8004034:	b110      	cbz	r0, 800403c <udp_recv_proc+0x138>
	memset(entry->mac, 0, 6);
 8004036:	2200      	movs	r2, #0
 8004038:	6002      	str	r2, [r0, #0]
 800403a:	8082      	strh	r2, [r0, #4]
			entry = entry_by_ip(*(uint32_t *)ptr);
 800403c:	f8d7 8002 	ldr.w	r8, [r7, #2]
	for (i = 0; i < config->num_entry; i++)
 8004040:	4b3b      	ldr	r3, [pc, #236]	; (8004130 <udp_recv_proc+0x22c>)
 8004042:	f8d3 9000 	ldr.w	r9, [r3]
 8004046:	f8d9 0010 	ldr.w	r0, [r9, #16]
 800404a:	2800      	cmp	r0, #0
 800404c:	f77f af72 	ble.w	8003f34 <udp_recv_proc+0x30>
		if (*(uint32_t *)config->entries[i].addr == ip)
 8004050:	f8d9 7014 	ldr.w	r7, [r9, #20]
 8004054:	f8d7 3006 	ldr.w	r3, [r7, #6]
 8004058:	4598      	cmp	r8, r3
 800405a:	d00c      	beq.n	8004076 <udp_recv_proc+0x172>
 800405c:	f107 0314 	add.w	r3, r7, #20
 8004060:	2200      	movs	r2, #0
	for (i = 0; i < config->num_entry; i++)
 8004062:	3201      	adds	r2, #1
 8004064:	4282      	cmp	r2, r0
 8004066:	f43f af65 	beq.w	8003f34 <udp_recv_proc+0x30>
		if (*(uint32_t *)config->entries[i].addr == ip)
 800406a:	461f      	mov	r7, r3
 800406c:	3314      	adds	r3, #20
 800406e:	f853 1c0e 	ldr.w	r1, [r3, #-14]
 8004072:	4588      	cmp	r8, r1
 8004074:	d1f5      	bne.n	8004062 <udp_recv_proc+0x15e>
			if (entry == NULL) break;
 8004076:	2f00      	cmp	r7, #0
 8004078:	f43f af5c 	beq.w	8003f34 <udp_recv_proc+0x30>
	return memcmp("\0\0\0\0\0", entry->mac, 6) == 0;
 800407c:	46ba      	mov	sl, r7
 800407e:	2206      	movs	r2, #6
 8004080:	4639      	mov	r1, r7
 8004082:	482e      	ldr	r0, [pc, #184]	; (800413c <udp_recv_proc+0x238>)
 8004084:	f004 ff0a 	bl	8008e9c <memcmp>
			if (!is_vacant(entry)) break;
 8004088:	2800      	cmp	r0, #0
 800408a:	f47f af53 	bne.w	8003f34 <udp_recv_proc+0x30>
			memcpy(dhcp_data.dp_yiaddr, ptr, 4);
 800408e:	4825      	ldr	r0, [pc, #148]	; (8004124 <udp_recv_proc+0x220>)
 8004090:	f8c0 8010 	str.w	r8, [r0, #16]
			dhcp_data.dp_op = 2; /* reply */
 8004094:	2302      	movs	r3, #2
 8004096:	7003      	strb	r3, [r0, #0]
			dhcp_data.dp_secs = 0;
 8004098:	f04f 0800 	mov.w	r8, #0
 800409c:	f8a0 8008 	strh.w	r8, [r0, #8]
			dhcp_data.dp_flags = 0;
 80040a0:	f8a0 800a 	strh.w	r8, [r0, #10]
			memcpy(dhcp_data.dp_magic, magic_cookie, 4);
 80040a4:	4b21      	ldr	r3, [pc, #132]	; (800412c <udp_recv_proc+0x228>)
 80040a6:	681b      	ldr	r3, [r3, #0]
 80040a8:	f8c0 30ec 	str.w	r3, [r0, #236]	; 0xec
			memset(dhcp_data.dp_options, 0, sizeof(dhcp_data.dp_options));
 80040ac:	f100 0bf0 	add.w	fp, r0, #240	; 0xf0
 80040b0:	f240 1213 	movw	r2, #275	; 0x113
 80040b4:	4641      	mov	r1, r8
 80040b6:	4658      	mov	r0, fp
 80040b8:	f004 ff0a 	bl	8008ed0 <memset>
			fill_options(dhcp_data.dp_options,
 80040bc:	f8d9 1000 	ldr.w	r1, [r9]
 80040c0:	f8d9 3006 	ldr.w	r3, [r9, #6]
 80040c4:	f8d9 200c 	ldr.w	r2, [r9, #12]
 80040c8:	f8d7 000a 	ldr.w	r0, [r7, #10]
 80040cc:	9003      	str	r0, [sp, #12]
 80040ce:	9102      	str	r1, [sp, #8]
 80040d0:	9101      	str	r1, [sp, #4]
 80040d2:	6939      	ldr	r1, [r7, #16]
 80040d4:	9100      	str	r1, [sp, #0]
 80040d6:	2105      	movs	r1, #5
 80040d8:	4658      	mov	r0, fp
 80040da:	f7ff fec4 	bl	8003e66 <fill_options>
			pp = pbuf_alloc(PBUF_TRANSPORT, sizeof(dhcp_data), PBUF_POOL);
 80040de:	2203      	movs	r2, #3
 80040e0:	f44f 7101 	mov.w	r1, #516	; 0x204
 80040e4:	4640      	mov	r0, r8
 80040e6:	f001 fb0b 	bl	8005700 <pbuf_alloc>
			if (pp == NULL) break;
 80040ea:	4607      	mov	r7, r0
 80040ec:	2800      	cmp	r0, #0
 80040ee:	f43f af21 	beq.w	8003f34 <udp_recv_proc+0x30>
			memcpy(entry->mac, dhcp_data.dp_chaddr, 6);
 80040f2:	f1ab 01d4 	sub.w	r1, fp, #212	; 0xd4
 80040f6:	6808      	ldr	r0, [r1, #0]
 80040f8:	f8ca 0000 	str.w	r0, [sl]
 80040fc:	888b      	ldrh	r3, [r1, #4]
 80040fe:	f8aa 3004 	strh.w	r3, [sl, #4]
			memcpy(pp->payload, &dhcp_data, sizeof(dhcp_data));
 8004102:	f44f 7201 	mov.w	r2, #516	; 0x204
 8004106:	391c      	subs	r1, #28
 8004108:	6878      	ldr	r0, [r7, #4]
 800410a:	f004 fed6 	bl	8008eba <memcpy>
			udp_sendto(upcb, pp, IP_ADDR_BROADCAST, port);
 800410e:	4633      	mov	r3, r6
 8004110:	4a08      	ldr	r2, [pc, #32]	; (8004134 <udp_recv_proc+0x230>)
 8004112:	4639      	mov	r1, r7
 8004114:	4628      	mov	r0, r5
 8004116:	f004 fa45 	bl	80085a4 <udp_sendto>
			pbuf_free(pp);
 800411a:	4638      	mov	r0, r7
 800411c:	f001 fac1 	bl	80056a2 <pbuf_free>
			break;
 8004120:	e708      	b.n	8003f34 <udp_recv_proc+0x30>
 8004122:	bf00      	nop
 8004124:	20008740 	.word	0x20008740
 8004128:	2000875c 	.word	0x2000875c
 800412c:	20000148 	.word	0x20000148
 8004130:	20000de8 	.word	0x20000de8
 8004134:	08009010 	.word	0x08009010
 8004138:	20008830 	.word	0x20008830
 800413c:	08008f04 	.word	0x08008f04

08004140 <dhserv_free>:
	config = c;
	return ERR_OK;
}

void dhserv_free(void)
{
 8004140:	b508      	push	{r3, lr}
	if (pcb == NULL) return;
 8004142:	4b04      	ldr	r3, [pc, #16]	; (8004154 <dhserv_free+0x14>)
 8004144:	6818      	ldr	r0, [r3, #0]
 8004146:	b120      	cbz	r0, 8004152 <dhserv_free+0x12>
	udp_remove(pcb);
 8004148:	f004 fa4e 	bl	80085e8 <udp_remove>
	pcb = NULL;
 800414c:	2200      	movs	r2, #0
 800414e:	4b01      	ldr	r3, [pc, #4]	; (8004154 <dhserv_free+0x14>)
 8004150:	601a      	str	r2, [r3, #0]
 8004152:	bd08      	pop	{r3, pc}
 8004154:	20000dec 	.word	0x20000dec

08004158 <dhserv_init>:
{
 8004158:	b538      	push	{r3, r4, r5, lr}
 800415a:	4604      	mov	r4, r0
	udp_init();
 800415c:	f004 f82c 	bl	80081b8 <udp_init>
	dhserv_free();
 8004160:	f7ff ffee 	bl	8004140 <dhserv_free>
	pcb = udp_new();
 8004164:	f004 fa5c 	bl	8008620 <udp_new>
 8004168:	4b0c      	ldr	r3, [pc, #48]	; (800419c <dhserv_init+0x44>)
 800416a:	6018      	str	r0, [r3, #0]
	if (pcb == NULL)
 800416c:	b190      	cbz	r0, 8004194 <dhserv_init+0x3c>
	err = udp_bind(pcb, IP_ADDR_ANY, c->port);
 800416e:	88a2      	ldrh	r2, [r4, #4]
 8004170:	490b      	ldr	r1, [pc, #44]	; (80041a0 <dhserv_init+0x48>)
 8004172:	f004 f929 	bl	80083c8 <udp_bind>
	if (err != ERR_OK)
 8004176:	4605      	mov	r5, r0
 8004178:	b948      	cbnz	r0, 800418e <dhserv_init+0x36>
	udp_recv(pcb, udp_recv_proc, NULL);
 800417a:	2200      	movs	r2, #0
 800417c:	4909      	ldr	r1, [pc, #36]	; (80041a4 <dhserv_init+0x4c>)
 800417e:	4b07      	ldr	r3, [pc, #28]	; (800419c <dhserv_init+0x44>)
 8004180:	6818      	ldr	r0, [r3, #0]
 8004182:	f004 fa2d 	bl	80085e0 <udp_recv>
	config = c;
 8004186:	4b08      	ldr	r3, [pc, #32]	; (80041a8 <dhserv_init+0x50>)
 8004188:	601c      	str	r4, [r3, #0]
}
 800418a:	4628      	mov	r0, r5
 800418c:	bd38      	pop	{r3, r4, r5, pc}
		dhserv_free();
 800418e:	f7ff ffd7 	bl	8004140 <dhserv_free>
		return err;
 8004192:	e7fa      	b.n	800418a <dhserv_init+0x32>
		return ERR_MEM;
 8004194:	f04f 35ff 	mov.w	r5, #4294967295
 8004198:	e7f7      	b.n	800418a <dhserv_init+0x32>
 800419a:	bf00      	nop
 800419c:	20000dec 	.word	0x20000dec
 80041a0:	0800900c 	.word	0x0800900c
 80041a4:	08003f05 	.word	0x08003f05
 80041a8:	20000de8 	.word	0x20000de8

080041ac <lwip_htons>:
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
 80041ac:	0a03      	lsrs	r3, r0, #8
 80041ae:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
}
 80041b2:	b280      	uxth	r0, r0
 80041b4:	4770      	bx	lr

080041b6 <lwip_ntohs>:
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
 80041b6:	0a03      	lsrs	r3, r0, #8
 80041b8:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 */
u16_t
lwip_ntohs(u16_t n)
{
  return lwip_htons(n);
}
 80041bc:	b280      	uxth	r0, r0
 80041be:	4770      	bx	lr

080041c0 <lwip_htonl>:
lwip_htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
 80041c0:	0e03      	lsrs	r3, r0, #24
    ((n & 0xff0000UL) >> 8) |
 80041c2:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
    ((n & 0xff00) << 8) |
 80041c6:	0202      	lsls	r2, r0, #8
 80041c8:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    ((n & 0xff0000UL) >> 8) |
 80041cc:	4313      	orrs	r3, r2
 80041ce:	0a00      	lsrs	r0, r0, #8
 80041d0:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
}
 80041d4:	4318      	orrs	r0, r3
 80041d6:	4770      	bx	lr

080041d8 <lwip_ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
lwip_ntohl(u32_t n)
{
 80041d8:	b508      	push	{r3, lr}
  return lwip_htonl(n);
 80041da:	f7ff fff1 	bl	80041c0 <lwip_htonl>
}
 80041de:	bd08      	pop	{r3, pc}

080041e0 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
 80041e0:	b508      	push	{r3, lr}
  /* Modules initialization */
  stats_init();
 80041e2:	f001 fc61 	bl	8005aa8 <stats_init>
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
 80041e6:	f000 ff3d 	bl	8005064 <mem_init>
  memp_init();
 80041ea:	f001 f8dd 	bl	80053a8 <memp_init>
  pbuf_init();
  netif_init();
 80041ee:	f001 f97b 	bl	80054e8 <netif_init>
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 80041f2:	f003 ffe1 	bl	80081b8 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 80041f6:	f001 fc58 	bl	8005aaa <tcp_init>
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
 80041fa:	f003 ffad 	bl	8008158 <sys_timeouts_init>
 80041fe:	bd08      	pop	{r3, pc}

08004200 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 8004200:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004204:	b085      	sub	sp, #20
 8004206:	4680      	mov	r8, r0
 8004208:	4689      	mov	r9, r1
 800420a:	4615      	mov	r5, r2
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 800420c:	2200      	movs	r2, #0
 800420e:	2124      	movs	r1, #36	; 0x24
 8004210:	2001      	movs	r0, #1
 8004212:	f001 fa75 	bl	8005700 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 8004216:	2800      	cmp	r0, #0
 8004218:	d043      	beq.n	80042a2 <icmp_send_response+0xa2>
 800421a:	4606      	mov	r6, r0
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 800421c:	f8d8 7004 	ldr.w	r7, [r8, #4]
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 8004220:	6844      	ldr	r4, [r0, #4]
  icmphdr->type = type;
 8004222:	f884 9000 	strb.w	r9, [r4]
  icmphdr->code = code;
 8004226:	7065      	strb	r5, [r4, #1]
  icmphdr->id = 0;
 8004228:	2500      	movs	r5, #0
 800422a:	7125      	strb	r5, [r4, #4]
 800422c:	7165      	strb	r5, [r4, #5]
  icmphdr->seqno = 0;
 800422e:	71a5      	strb	r5, [r4, #6]
 8004230:	71e5      	strb	r5, [r4, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8004232:	f8d0 c004 	ldr.w	ip, [r0, #4]
 8004236:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800423a:	f8d3 e000 	ldr.w	lr, [r3]
 800423e:	6858      	ldr	r0, [r3, #4]
 8004240:	6899      	ldr	r1, [r3, #8]
 8004242:	f8d3 800c 	ldr.w	r8, [r3, #12]
 8004246:	f8cc e008 	str.w	lr, [ip, #8]
 800424a:	f8cc 000c 	str.w	r0, [ip, #12]
 800424e:	f8cc 1010 	str.w	r1, [ip, #16]
 8004252:	f8cc 8014 	str.w	r8, [ip, #20]
 8004256:	f8d3 e010 	ldr.w	lr, [r3, #16]
 800425a:	6958      	ldr	r0, [r3, #20]
 800425c:	6999      	ldr	r1, [r3, #24]
 800425e:	f8cc e018 	str.w	lr, [ip, #24]
 8004262:	f8cc 001c 	str.w	r0, [ip, #28]
 8004266:	f8cc 1020 	str.w	r1, [ip, #32]
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
 800426a:	70a5      	strb	r5, [r4, #2]
 800426c:	70e5      	strb	r5, [r4, #3]
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 800426e:	8971      	ldrh	r1, [r6, #10]
 8004270:	4620      	mov	r0, r4
 8004272:	f000 f97c 	bl	800456e <inet_chksum>
 8004276:	8060      	strh	r0, [r4, #2]
  ICMP_STATS_INC(icmp.xmit);
 8004278:	4a0b      	ldr	r2, [pc, #44]	; (80042a8 <icmp_send_response+0xa8>)
 800427a:	f8b2 3060 	ldrh.w	r3, [r2, #96]	; 0x60
 800427e:	3301      	adds	r3, #1
 8004280:	f8a2 3060 	strh.w	r3, [r2, #96]	; 0x60
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 8004284:	68fb      	ldr	r3, [r7, #12]
 8004286:	aa04      	add	r2, sp, #16
 8004288:	f842 3d04 	str.w	r3, [r2, #-4]!
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
 800428c:	2301      	movs	r3, #1
 800428e:	9301      	str	r3, [sp, #4]
 8004290:	9500      	str	r5, [sp, #0]
 8004292:	23ff      	movs	r3, #255	; 0xff
 8004294:	4629      	mov	r1, r5
 8004296:	4630      	mov	r0, r6
 8004298:	f000 fb60 	bl	800495c <ip_output>
  pbuf_free(q);
 800429c:	4630      	mov	r0, r6
 800429e:	f001 fa00 	bl	80056a2 <pbuf_free>
}
 80042a2:	b005      	add	sp, #20
 80042a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80042a8:	2000b084 	.word	0x2000b084

080042ac <icmp_input>:
{
 80042ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80042b0:	b085      	sub	sp, #20
 80042b2:	4606      	mov	r6, r0
 80042b4:	4688      	mov	r8, r1
  ICMP_STATS_INC(icmp.recv);
 80042b6:	4a62      	ldr	r2, [pc, #392]	; (8004440 <icmp_input+0x194>)
 80042b8:	f8b2 3062 	ldrh.w	r3, [r2, #98]	; 0x62
 80042bc:	3301      	adds	r3, #1
 80042be:	f8a2 3062 	strh.w	r3, [r2, #98]	; 0x62
  iphdr = (struct ip_hdr *)p->payload;
 80042c2:	6847      	ldr	r7, [r0, #4]
  hlen = IPH_HL(iphdr) * 4;
 80042c4:	783c      	ldrb	r4, [r7, #0]
 80042c6:	f004 040f 	and.w	r4, r4, #15
 80042ca:	00a4      	lsls	r4, r4, #2
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 80042cc:	4265      	negs	r5, r4
 80042ce:	b22d      	sxth	r5, r5
 80042d0:	4629      	mov	r1, r5
 80042d2:	f001 f9a8 	bl	8005626 <pbuf_header>
 80042d6:	b9c0      	cbnz	r0, 800430a <icmp_input+0x5e>
 80042d8:	8933      	ldrh	r3, [r6, #8]
 80042da:	2b03      	cmp	r3, #3
 80042dc:	d915      	bls.n	800430a <icmp_input+0x5e>
  type = *((u8_t *)p->payload);
 80042de:	6873      	ldr	r3, [r6, #4]
  switch (type) {
 80042e0:	781b      	ldrb	r3, [r3, #0]
 80042e2:	2b00      	cmp	r3, #0
 80042e4:	f000 80a8 	beq.w	8004438 <icmp_input+0x18c>
 80042e8:	2b08      	cmp	r3, #8
 80042ea:	f040 809a 	bne.w	8004422 <icmp_input+0x176>
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
 80042ee:	4b55      	ldr	r3, [pc, #340]	; (8004444 <icmp_input+0x198>)
 80042f0:	6818      	ldr	r0, [r3, #0]
 80042f2:	f000 09f0 	and.w	r9, r0, #240	; 0xf0
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
 80042f6:	4641      	mov	r1, r8
 80042f8:	f000 fb54 	bl	80049a4 <ip4_addr_isbroadcast>
 80042fc:	b988      	cbnz	r0, 8004322 <icmp_input+0x76>
      if (!accepted) {
 80042fe:	f1b9 0fe0 	cmp.w	r9, #224	; 0xe0
 8004302:	d00e      	beq.n	8004322 <icmp_input+0x76>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 8004304:	8933      	ldrh	r3, [r6, #8]
 8004306:	2b07      	cmp	r3, #7
 8004308:	d815      	bhi.n	8004336 <icmp_input+0x8a>
  pbuf_free(p);
 800430a:	4630      	mov	r0, r6
 800430c:	f001 f9c9 	bl	80056a2 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
 8004310:	4a4b      	ldr	r2, [pc, #300]	; (8004440 <icmp_input+0x194>)
 8004312:	f8b2 306a 	ldrh.w	r3, [r2, #106]	; 0x6a
 8004316:	3301      	adds	r3, #1
 8004318:	f8a2 306a 	strh.w	r3, [r2, #106]	; 0x6a
}
 800431c:	b005      	add	sp, #20
 800431e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ICMP_STATS_INC(icmp.err);
 8004322:	4a47      	ldr	r2, [pc, #284]	; (8004440 <icmp_input+0x194>)
 8004324:	f8b2 3074 	ldrh.w	r3, [r2, #116]	; 0x74
 8004328:	3301      	adds	r3, #1
 800432a:	f8a2 3074 	strh.w	r3, [r2, #116]	; 0x74
        pbuf_free(p);
 800432e:	4630      	mov	r0, r6
 8004330:	f001 f9b7 	bl	80056a2 <pbuf_free>
        return;
 8004334:	e7f2      	b.n	800431c <icmp_input+0x70>
    if (inet_chksum_pbuf(p) != 0) {
 8004336:	4630      	mov	r0, r6
 8004338:	f000 f91f 	bl	800457a <inet_chksum_pbuf>
 800433c:	b9a0      	cbnz	r0, 8004368 <icmp_input+0xbc>
  hlen = IPH_HL(iphdr) * 4;
 800433e:	b224      	sxth	r4, r4
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 8004340:	2122      	movs	r1, #34	; 0x22
 8004342:	4630      	mov	r0, r6
 8004344:	f001 f96f 	bl	8005626 <pbuf_header>
 8004348:	b390      	cbz	r0, 80043b0 <icmp_input+0x104>
      if (pbuf_header(p, hlen)) {
 800434a:	4621      	mov	r1, r4
 800434c:	4630      	mov	r0, r6
 800434e:	f001 f96a 	bl	8005626 <pbuf_header>
 8004352:	b198      	cbz	r0, 800437c <icmp_input+0xd0>
  pbuf_free(p);
 8004354:	4630      	mov	r0, r6
 8004356:	f001 f9a4 	bl	80056a2 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
 800435a:	4a39      	ldr	r2, [pc, #228]	; (8004440 <icmp_input+0x194>)
 800435c:	f8b2 3074 	ldrh.w	r3, [r2, #116]	; 0x74
 8004360:	3301      	adds	r3, #1
 8004362:	f8a2 3074 	strh.w	r3, [r2, #116]	; 0x74
  return;
 8004366:	e7d9      	b.n	800431c <icmp_input+0x70>
      pbuf_free(p);
 8004368:	4630      	mov	r0, r6
 800436a:	f001 f99a 	bl	80056a2 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
 800436e:	4a34      	ldr	r2, [pc, #208]	; (8004440 <icmp_input+0x194>)
 8004370:	f8b2 3068 	ldrh.w	r3, [r2, #104]	; 0x68
 8004374:	3301      	adds	r3, #1
 8004376:	f8a2 3068 	strh.w	r3, [r2, #104]	; 0x68
      return;
 800437a:	e7cf      	b.n	800431c <icmp_input+0x70>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 800437c:	2200      	movs	r2, #0
 800437e:	8931      	ldrh	r1, [r6, #8]
 8004380:	2002      	movs	r0, #2
 8004382:	f001 f9bd 	bl	8005700 <pbuf_alloc>
      if (r == NULL) {
 8004386:	4681      	mov	r9, r0
 8004388:	2800      	cmp	r0, #0
 800438a:	d0e3      	beq.n	8004354 <icmp_input+0xa8>
      if (pbuf_copy(r, p) != ERR_OK) {
 800438c:	4631      	mov	r1, r6
 800438e:	f001 faab 	bl	80058e8 <pbuf_copy>
 8004392:	2800      	cmp	r0, #0
 8004394:	d1de      	bne.n	8004354 <icmp_input+0xa8>
      iphdr = (struct ip_hdr *)r->payload;
 8004396:	f8d9 7004 	ldr.w	r7, [r9, #4]
      if (pbuf_header(r, -hlen)) {
 800439a:	4629      	mov	r1, r5
 800439c:	4648      	mov	r0, r9
 800439e:	f001 f942 	bl	8005626 <pbuf_header>
 80043a2:	2800      	cmp	r0, #0
 80043a4:	d1d6      	bne.n	8004354 <icmp_input+0xa8>
      pbuf_free(p);
 80043a6:	4630      	mov	r0, r6
 80043a8:	f001 f97b 	bl	80056a2 <pbuf_free>
      p = r;
 80043ac:	464e      	mov	r6, r9
 80043ae:	e006      	b.n	80043be <icmp_input+0x112>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 80043b0:	f06f 0121 	mvn.w	r1, #33	; 0x21
 80043b4:	4630      	mov	r0, r6
 80043b6:	f001 f936 	bl	8005626 <pbuf_header>
 80043ba:	2800      	cmp	r0, #0
 80043bc:	d1ca      	bne.n	8004354 <icmp_input+0xa8>
    iecho = (struct icmp_echo_hdr *)p->payload;
 80043be:	6872      	ldr	r2, [r6, #4]
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
 80043c0:	4b20      	ldr	r3, [pc, #128]	; (8004444 <icmp_input+0x198>)
 80043c2:	681b      	ldr	r3, [r3, #0]
 80043c4:	60fb      	str	r3, [r7, #12]
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 80043c6:	4b20      	ldr	r3, [pc, #128]	; (8004448 <icmp_input+0x19c>)
 80043c8:	681b      	ldr	r3, [r3, #0]
 80043ca:	613b      	str	r3, [r7, #16]
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 80043cc:	2300      	movs	r3, #0
 80043ce:	7013      	strb	r3, [r2, #0]
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 80043d0:	8853      	ldrh	r3, [r2, #2]
 80043d2:	f64f 71f6 	movw	r1, #65526	; 0xfff6
 80043d6:	428b      	cmp	r3, r1
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
 80043d8:	bf8c      	ite	hi
 80043da:	3309      	addhi	r3, #9
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
 80043dc:	3308      	addls	r3, #8
 80043de:	8053      	strh	r3, [r2, #2]
    IPH_TTL_SET(iphdr, ICMP_TTL);
 80043e0:	23ff      	movs	r3, #255	; 0xff
 80043e2:	723b      	strb	r3, [r7, #8]
    IPH_CHKSUM_SET(iphdr, 0);
 80043e4:	2300      	movs	r3, #0
 80043e6:	72bb      	strb	r3, [r7, #10]
 80043e8:	72fb      	strb	r3, [r7, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 80043ea:	2114      	movs	r1, #20
 80043ec:	4638      	mov	r0, r7
 80043ee:	f000 f8be 	bl	800456e <inet_chksum>
 80043f2:	8178      	strh	r0, [r7, #10]
    ICMP_STATS_INC(icmp.xmit);
 80043f4:	4a12      	ldr	r2, [pc, #72]	; (8004440 <icmp_input+0x194>)
 80043f6:	f8b2 3060 	ldrh.w	r3, [r2, #96]	; 0x60
 80043fa:	3301      	adds	r3, #1
 80043fc:	f8a2 3060 	strh.w	r3, [r2, #96]	; 0x60
    if(pbuf_header(p, hlen)) {
 8004400:	4621      	mov	r1, r4
 8004402:	4630      	mov	r0, r6
 8004404:	f001 f90f 	bl	8005626 <pbuf_header>
 8004408:	b9b0      	cbnz	r0, 8004438 <icmp_input+0x18c>
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
 800440a:	f8cd 8008 	str.w	r8, [sp, #8]
 800440e:	2301      	movs	r3, #1
 8004410:	9301      	str	r3, [sp, #4]
 8004412:	2200      	movs	r2, #0
 8004414:	9200      	str	r2, [sp, #0]
 8004416:	23ff      	movs	r3, #255	; 0xff
 8004418:	490a      	ldr	r1, [pc, #40]	; (8004444 <icmp_input+0x198>)
 800441a:	4630      	mov	r0, r6
 800441c:	f000 fa1c 	bl	8004858 <ip_output_if>
 8004420:	e00a      	b.n	8004438 <icmp_input+0x18c>
    ICMP_STATS_INC(icmp.proterr);
 8004422:	4b07      	ldr	r3, [pc, #28]	; (8004440 <icmp_input+0x194>)
 8004424:	f8b3 2070 	ldrh.w	r2, [r3, #112]	; 0x70
 8004428:	3201      	adds	r2, #1
 800442a:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
    ICMP_STATS_INC(icmp.drop);
 800442e:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
 8004432:	3201      	adds	r2, #1
 8004434:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
  pbuf_free(p);
 8004438:	4630      	mov	r0, r6
 800443a:	f001 f932 	bl	80056a2 <pbuf_free>
  return;
 800443e:	e76d      	b.n	800431c <icmp_input+0x70>
 8004440:	2000b084 	.word	0x2000b084
 8004444:	2000894c 	.word	0x2000894c
 8004448:	20008944 	.word	0x20008944

0800444c <icmp_dest_unreach>:
{
 800444c:	b508      	push	{r3, lr}
  icmp_send_response(p, ICMP_DUR, t);
 800444e:	460a      	mov	r2, r1
 8004450:	2103      	movs	r1, #3
 8004452:	f7ff fed5 	bl	8004200 <icmp_send_response>
 8004456:	bd08      	pop	{r3, pc}

08004458 <icmp_time_exceeded>:
{
 8004458:	b508      	push	{r3, lr}
  icmp_send_response(p, ICMP_TE, t);
 800445a:	460a      	mov	r2, r1
 800445c:	210b      	movs	r1, #11
 800445e:	f7ff fecf 	bl	8004200 <icmp_send_response>
 8004462:	bd08      	pop	{r3, pc}

08004464 <lwip_standard_chksum>:
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
 8004464:	b410      	push	{r4}
 8004466:	b083      	sub	sp, #12
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
 8004468:	2300      	movs	r3, #0
 800446a:	f8ad 3006 	strh.w	r3, [sp, #6]
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 800446e:	f010 0401 	ands.w	r4, r0, #1
 8004472:	d007      	beq.n	8004484 <lwip_standard_chksum+0x20>
 8004474:	4299      	cmp	r1, r3
 8004476:	dd2a      	ble.n	80044ce <lwip_standard_chksum+0x6a>
    ((u8_t *)&t)[1] = *pb++;
 8004478:	1c43      	adds	r3, r0, #1
 800447a:	7802      	ldrb	r2, [r0, #0]
 800447c:	f88d 2007 	strb.w	r2, [sp, #7]
    len--;
 8004480:	3901      	subs	r1, #1
 8004482:	e000      	b.n	8004486 <lwip_standard_chksum+0x22>
  u8_t *pb = (u8_t *)dataptr;
 8004484:	4603      	mov	r3, r0
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 8004486:	2901      	cmp	r1, #1
 8004488:	dd1f      	ble.n	80044ca <lwip_standard_chksum+0x66>
  u8_t *pb = (u8_t *)dataptr;
 800448a:	2200      	movs	r2, #0
    sum += *ps++;
 800448c:	f833 0b02 	ldrh.w	r0, [r3], #2
 8004490:	4402      	add	r2, r0
    len -= 2;
 8004492:	3902      	subs	r1, #2
  while (len > 1) {
 8004494:	2901      	cmp	r1, #1
 8004496:	dcf9      	bgt.n	800448c <lwip_standard_chksum+0x28>
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 8004498:	2900      	cmp	r1, #0
    ((u8_t *)&t)[0] = *(u8_t *)ps;
 800449a:	bfc4      	itt	gt
 800449c:	781b      	ldrbgt	r3, [r3, #0]
 800449e:	f88d 3006 	strbgt.w	r3, [sp, #6]
  }

  /* Add end bytes */
  sum += t;
 80044a2:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 80044a6:	4402      	add	r2, r0

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
 80044a8:	b290      	uxth	r0, r2
 80044aa:	eb00 4212 	add.w	r2, r0, r2, lsr #16
  sum = FOLD_U32T(sum);
 80044ae:	b290      	uxth	r0, r2
 80044b0:	eb00 4012 	add.w	r0, r0, r2, lsr #16

  /* Swap if alignment was odd */
  if (odd) {
 80044b4:	b124      	cbz	r4, 80044c0 <lwip_standard_chksum+0x5c>
    sum = SWAP_BYTES_IN_WORD(sum);
 80044b6:	0203      	lsls	r3, r0, #8
 80044b8:	b29b      	uxth	r3, r3
 80044ba:	f3c0 2007 	ubfx	r0, r0, #8, #8
 80044be:	4318      	orrs	r0, r3
  }

  return (u16_t)sum;
 80044c0:	b280      	uxth	r0, r0
}
 80044c2:	b003      	add	sp, #12
 80044c4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80044c8:	4770      	bx	lr
  u32_t sum = 0;
 80044ca:	2200      	movs	r2, #0
 80044cc:	e7e4      	b.n	8004498 <lwip_standard_chksum+0x34>
  while (len > 1) {
 80044ce:	2901      	cmp	r1, #1
  u8_t *pb = (u8_t *)dataptr;
 80044d0:	bfc8      	it	gt
 80044d2:	4603      	movgt	r3, r0
  while (len > 1) {
 80044d4:	dcd9      	bgt.n	800448a <lwip_standard_chksum+0x26>
  sum = FOLD_U32T(sum);
 80044d6:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 80044da:	e7ec      	b.n	80044b6 <lwip_standard_chksum+0x52>

080044dc <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len)
{
 80044dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80044e0:	4689      	mov	r9, r1
 80044e2:	4690      	mov	r8, r2
 80044e4:	461f      	mov	r7, r3
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 80044e6:	2800      	cmp	r0, #0
 80044e8:	d03f      	beq.n	800456a <inet_chksum_pseudo+0x8e>
 80044ea:	4605      	mov	r5, r0
 80044ec:	2600      	movs	r6, #0
 80044ee:	4634      	mov	r4, r6
 80044f0:	e001      	b.n	80044f6 <inet_chksum_pseudo+0x1a>
 80044f2:	682d      	ldr	r5, [r5, #0]
 80044f4:	b1a5      	cbz	r5, 8004520 <inet_chksum_pseudo+0x44>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 80044f6:	8969      	ldrh	r1, [r5, #10]
 80044f8:	6868      	ldr	r0, [r5, #4]
 80044fa:	f7ff ffb3 	bl	8004464 <lwip_standard_chksum>
 80044fe:	4404      	add	r4, r0
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 8004500:	b2a0      	uxth	r0, r4
 8004502:	eb00 4414 	add.w	r4, r0, r4, lsr #16
    if (q->len % 2 != 0) {
 8004506:	896b      	ldrh	r3, [r5, #10]
 8004508:	f013 0f01 	tst.w	r3, #1
 800450c:	d0f1      	beq.n	80044f2 <inet_chksum_pseudo+0x16>
      swapped = 1 - swapped;
 800450e:	f1c6 0601 	rsb	r6, r6, #1
 8004512:	b2f6      	uxtb	r6, r6
      acc = SWAP_BYTES_IN_WORD(acc);
 8004514:	0223      	lsls	r3, r4, #8
 8004516:	b29b      	uxth	r3, r3
 8004518:	f3c4 2407 	ubfx	r4, r4, #8, #8
 800451c:	431c      	orrs	r4, r3
 800451e:	e7e8      	b.n	80044f2 <inet_chksum_pseudo+0x16>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 8004520:	b126      	cbz	r6, 800452c <inet_chksum_pseudo+0x50>
    acc = SWAP_BYTES_IN_WORD(acc);
 8004522:	0223      	lsls	r3, r4, #8
 8004524:	b29b      	uxth	r3, r3
 8004526:	f3c4 2407 	ubfx	r4, r4, #8, #8
 800452a:	431c      	orrs	r4, r3
  }
  addr = ip4_addr_get_u32(src);
 800452c:	f8d9 2000 	ldr.w	r2, [r9]
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
 8004530:	f8d8 3000 	ldr.w	r3, [r8]
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
 8004534:	0c18      	lsrs	r0, r3, #16
 8004536:	fa10 f083 	uxtah	r0, r0, r3
 800453a:	fa10 f082 	uxtah	r0, r0, r2
 800453e:	eb00 4012 	add.w	r0, r0, r2, lsr #16
 8004542:	4404      	add	r4, r0
  acc += (u32_t)htons((u16_t)proto);
 8004544:	4638      	mov	r0, r7
 8004546:	f7ff fe31 	bl	80041ac <lwip_htons>
 800454a:	4404      	add	r4, r0
  acc += (u32_t)htons(proto_len);
 800454c:	f8bd 0020 	ldrh.w	r0, [sp, #32]
 8004550:	f7ff fe2c 	bl	80041ac <lwip_htons>
 8004554:	4420      	add	r0, r4

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 8004556:	b284      	uxth	r4, r0
 8004558:	eb04 4410 	add.w	r4, r4, r0, lsr #16
  acc = FOLD_U32T(acc);
 800455c:	b2a0      	uxth	r0, r4
 800455e:	eb00 4014 	add.w	r0, r0, r4, lsr #16
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 8004562:	43c0      	mvns	r0, r0
}
 8004564:	b280      	uxth	r0, r0
 8004566:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  acc = 0;
 800456a:	2400      	movs	r4, #0
 800456c:	e7de      	b.n	800452c <inet_chksum_pseudo+0x50>

0800456e <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
 800456e:	b508      	push	{r3, lr}
  return ~LWIP_CHKSUM(dataptr, len);
 8004570:	f7ff ff78 	bl	8004464 <lwip_standard_chksum>
 8004574:	43c0      	mvns	r0, r0
}
 8004576:	b280      	uxth	r0, r0
 8004578:	bd08      	pop	{r3, pc}

0800457a <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 800457a:	b570      	push	{r4, r5, r6, lr}
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 800457c:	b318      	cbz	r0, 80045c6 <inet_chksum_pbuf+0x4c>
 800457e:	4605      	mov	r5, r0
 8004580:	2600      	movs	r6, #0
 8004582:	4634      	mov	r4, r6
 8004584:	e001      	b.n	800458a <inet_chksum_pbuf+0x10>
 8004586:	682d      	ldr	r5, [r5, #0]
 8004588:	b1a5      	cbz	r5, 80045b4 <inet_chksum_pbuf+0x3a>
    acc += LWIP_CHKSUM(q->payload, q->len);
 800458a:	8969      	ldrh	r1, [r5, #10]
 800458c:	6868      	ldr	r0, [r5, #4]
 800458e:	f7ff ff69 	bl	8004464 <lwip_standard_chksum>
 8004592:	4420      	add	r0, r4
    acc = FOLD_U32T(acc);
 8004594:	b284      	uxth	r4, r0
 8004596:	eb04 4410 	add.w	r4, r4, r0, lsr #16
    if (q->len % 2 != 0) {
 800459a:	896b      	ldrh	r3, [r5, #10]
 800459c:	f013 0f01 	tst.w	r3, #1
 80045a0:	d0f1      	beq.n	8004586 <inet_chksum_pbuf+0xc>
      swapped = 1 - swapped;
 80045a2:	f1c6 0601 	rsb	r6, r6, #1
 80045a6:	b2f6      	uxtb	r6, r6
      acc = SWAP_BYTES_IN_WORD(acc);
 80045a8:	0223      	lsls	r3, r4, #8
 80045aa:	b29b      	uxth	r3, r3
 80045ac:	f3c4 2407 	ubfx	r4, r4, #8, #8
 80045b0:	431c      	orrs	r4, r3
 80045b2:	e7e8      	b.n	8004586 <inet_chksum_pbuf+0xc>
    }
  }

  if (swapped) {
 80045b4:	b126      	cbz	r6, 80045c0 <inet_chksum_pbuf+0x46>
    acc = SWAP_BYTES_IN_WORD(acc);
 80045b6:	0223      	lsls	r3, r4, #8
 80045b8:	b29b      	uxth	r3, r3
 80045ba:	f3c4 2407 	ubfx	r4, r4, #8, #8
 80045be:	431c      	orrs	r4, r3
  }
  return (u16_t)~(acc & 0xffffUL);
 80045c0:	43e0      	mvns	r0, r4
}
 80045c2:	b280      	uxth	r0, r0
 80045c4:	bd70      	pop	{r4, r5, r6, pc}
  acc = 0;
 80045c6:	2400      	movs	r4, #0
 80045c8:	e7fa      	b.n	80045c0 <inet_chksum_pbuf+0x46>
	...

080045cc <ip_route>:
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 80045cc:	4b11      	ldr	r3, [pc, #68]	; (8004614 <ip_route+0x48>)
 80045ce:	681b      	ldr	r3, [r3, #0]
 80045d0:	b963      	cbnz	r3, 80045ec <ip_route+0x20>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
 80045d2:	4b11      	ldr	r3, [pc, #68]	; (8004618 <ip_route+0x4c>)
 80045d4:	681b      	ldr	r3, [r3, #0]
 80045d6:	b1ab      	cbz	r3, 8004604 <ip_route+0x38>
 80045d8:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 80045dc:	f012 0f01 	tst.w	r2, #1
 80045e0:	d010      	beq.n	8004604 <ip_route+0x38>
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
 80045e2:	4618      	mov	r0, r3
 80045e4:	4770      	bx	lr
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 80045e6:	681b      	ldr	r3, [r3, #0]
 80045e8:	2b00      	cmp	r3, #0
 80045ea:	d0f2      	beq.n	80045d2 <ip_route+0x6>
    if (netif_is_up(netif)) {
 80045ec:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 80045f0:	f012 0f01 	tst.w	r2, #1
 80045f4:	d0f7      	beq.n	80045e6 <ip_route+0x1a>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
 80045f6:	6802      	ldr	r2, [r0, #0]
 80045f8:	6859      	ldr	r1, [r3, #4]
 80045fa:	404a      	eors	r2, r1
 80045fc:	6899      	ldr	r1, [r3, #8]
 80045fe:	420a      	tst	r2, r1
 8004600:	d1f1      	bne.n	80045e6 <ip_route+0x1a>
 8004602:	e7ee      	b.n	80045e2 <ip_route+0x16>
    IP_STATS_INC(ip.rterr);
 8004604:	4a05      	ldr	r2, [pc, #20]	; (800461c <ip_route+0x50>)
 8004606:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
 800460a:	3301      	adds	r3, #1
 800460c:	f8a2 3056 	strh.w	r3, [r2, #86]	; 0x56
    return NULL;
 8004610:	2300      	movs	r3, #0
 8004612:	e7e6      	b.n	80045e2 <ip_route+0x16>
 8004614:	2000b078 	.word	0x2000b078
 8004618:	2000b07c 	.word	0x2000b07c
 800461c:	2000b084 	.word	0x2000b084

08004620 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 8004620:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004624:	4606      	mov	r6, r0
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
 8004626:	4a86      	ldr	r2, [pc, #536]	; (8004840 <ip_input+0x220>)
 8004628:	f8b2 304a 	ldrh.w	r3, [r2, #74]	; 0x4a
 800462c:	3301      	adds	r3, #1
 800462e:	f8a2 304a 	strh.w	r3, [r2, #74]	; 0x4a
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 8004632:	f8d0 9004 	ldr.w	r9, [r0, #4]
  if (IPH_V(iphdr) != 4) {
 8004636:	f899 5000 	ldrb.w	r5, [r9]
 800463a:	092b      	lsrs	r3, r5, #4
 800463c:	2b04      	cmp	r3, #4
 800463e:	d00f      	beq.n	8004660 <ip_input+0x40>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
 8004640:	f001 f82f 	bl	80056a2 <pbuf_free>
    IP_STATS_INC(ip.err);
 8004644:	4b7e      	ldr	r3, [pc, #504]	; (8004840 <ip_input+0x220>)
 8004646:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 800464a:	3201      	adds	r2, #1
 800464c:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
    IP_STATS_INC(ip.drop);
 8004650:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 8004654:	3201      	adds	r2, #1
 8004656:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
  current_header = NULL;
  ip_addr_set_any(&current_iphdr_src);
  ip_addr_set_any(&current_iphdr_dest);

  return ERR_OK;
}
 800465a:	2000      	movs	r0, #0
 800465c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004660:	4688      	mov	r8, r1
  iphdr_hlen = IPH_HL(iphdr);
 8004662:	f005 050f 	and.w	r5, r5, #15
  iphdr_hlen *= 4;
 8004666:	00ad      	lsls	r5, r5, #2
  iphdr_len = ntohs(IPH_LEN(iphdr));
 8004668:	f8b9 0002 	ldrh.w	r0, [r9, #2]
 800466c:	f7ff fda3 	bl	80041b6 <lwip_ntohs>
 8004670:	4604      	mov	r4, r0
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 8004672:	8973      	ldrh	r3, [r6, #10]
 8004674:	42ab      	cmp	r3, r5
 8004676:	d302      	bcc.n	800467e <ip_input+0x5e>
 8004678:	8933      	ldrh	r3, [r6, #8]
 800467a:	4283      	cmp	r3, r0
 800467c:	d20e      	bcs.n	800469c <ip_input+0x7c>
    pbuf_free(p);
 800467e:	4630      	mov	r0, r6
 8004680:	f001 f80f 	bl	80056a2 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
 8004684:	4b6e      	ldr	r3, [pc, #440]	; (8004840 <ip_input+0x220>)
 8004686:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 800468a:	3201      	adds	r2, #1
 800468c:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    IP_STATS_INC(ip.drop);
 8004690:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 8004694:	3201      	adds	r2, #1
 8004696:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    return ERR_OK;
 800469a:	e7de      	b.n	800465a <ip_input+0x3a>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
 800469c:	4629      	mov	r1, r5
 800469e:	4648      	mov	r0, r9
 80046a0:	f7ff ff65 	bl	800456e <inet_chksum>
 80046a4:	b990      	cbnz	r0, 80046cc <ip_input+0xac>
  pbuf_realloc(p, iphdr_len);
 80046a6:	4621      	mov	r1, r4
 80046a8:	4630      	mov	r0, r6
 80046aa:	f001 f8c1 	bl	8005830 <pbuf_realloc>
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
 80046ae:	f8d9 2010 	ldr.w	r2, [r9, #16]
 80046b2:	4b64      	ldr	r3, [pc, #400]	; (8004844 <ip_input+0x224>)
 80046b4:	601a      	str	r2, [r3, #0]
  ip_addr_copy(current_iphdr_src, iphdr->src);
 80046b6:	f8d9 200c 	ldr.w	r2, [r9, #12]
 80046ba:	4b63      	ldr	r3, [pc, #396]	; (8004848 <ip_input+0x228>)
 80046bc:	601a      	str	r2, [r3, #0]
    netif = inp;
 80046be:	4644      	mov	r4, r8
    int first = 1;
 80046c0:	2701      	movs	r7, #1
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 80046c2:	f8df b180 	ldr.w	fp, [pc, #384]	; 8004844 <ip_input+0x224>
        netif = netif_list;
 80046c6:	f8df a18c 	ldr.w	sl, [pc, #396]	; 8004854 <ip_input+0x234>
 80046ca:	e016      	b.n	80046fa <ip_input+0xda>
    pbuf_free(p);
 80046cc:	4630      	mov	r0, r6
 80046ce:	f000 ffe8 	bl	80056a2 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
 80046d2:	4b5b      	ldr	r3, [pc, #364]	; (8004840 <ip_input+0x220>)
 80046d4:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
 80046d8:	3201      	adds	r2, #1
 80046da:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
    IP_STATS_INC(ip.drop);
 80046de:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 80046e2:	3201      	adds	r2, #1
 80046e4:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    return ERR_OK;
 80046e8:	e7b7      	b.n	800465a <ip_input+0x3a>
      if (first) {
 80046ea:	b1ff      	cbz	r7, 800472c <ip_input+0x10c>
        netif = netif_list;
 80046ec:	f8da 4000 	ldr.w	r4, [sl]
      if (netif == inp) {
 80046f0:	4544      	cmp	r4, r8
        netif = netif->next;
 80046f2:	bf08      	it	eq
 80046f4:	6824      	ldreq	r4, [r4, #0]
 80046f6:	2700      	movs	r7, #0
    } while(netif != NULL);
 80046f8:	b1d4      	cbz	r4, 8004730 <ip_input+0x110>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
 80046fa:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 80046fe:	f013 0f01 	tst.w	r3, #1
 8004702:	d0f2      	beq.n	80046ea <ip_input+0xca>
 8004704:	f114 0f04 	cmn.w	r4, #4
 8004708:	d0ef      	beq.n	80046ea <ip_input+0xca>
 800470a:	6863      	ldr	r3, [r4, #4]
 800470c:	2b00      	cmp	r3, #0
 800470e:	d0ec      	beq.n	80046ea <ip_input+0xca>
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 8004710:	f8db 0000 	ldr.w	r0, [fp]
 8004714:	4283      	cmp	r3, r0
 8004716:	d004      	beq.n	8004722 <ip_input+0x102>
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
 8004718:	4621      	mov	r1, r4
 800471a:	f000 f943 	bl	80049a4 <ip4_addr_isbroadcast>
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 800471e:	2800      	cmp	r0, #0
 8004720:	d0e3      	beq.n	80046ea <ip_input+0xca>
  if (netif == NULL) {
 8004722:	b12c      	cbz	r4, 8004730 <ip_input+0x110>
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
 8004724:	4b48      	ldr	r3, [pc, #288]	; (8004848 <ip_input+0x228>)
 8004726:	6818      	ldr	r0, [r3, #0]
 8004728:	b1c0      	cbz	r0, 800475c <ip_input+0x13c>
 800472a:	e00a      	b.n	8004742 <ip_input+0x122>
        netif = netif->next;
 800472c:	6824      	ldr	r4, [r4, #0]
 800472e:	e7df      	b.n	80046f0 <ip_input+0xd0>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
 8004730:	f899 3009 	ldrb.w	r3, [r9, #9]
 8004734:	2b11      	cmp	r3, #17
 8004736:	d055      	beq.n	80047e4 <ip_input+0x1c4>
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
 8004738:	4b43      	ldr	r3, [pc, #268]	; (8004848 <ip_input+0x228>)
 800473a:	6818      	ldr	r0, [r3, #0]
 800473c:	2800      	cmp	r0, #0
 800473e:	d062      	beq.n	8004806 <ip_input+0x1e6>
 8004740:	2400      	movs	r4, #0
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 8004742:	4641      	mov	r1, r8
 8004744:	f000 f92e 	bl	80049a4 <ip4_addr_isbroadcast>
 8004748:	2800      	cmp	r0, #0
 800474a:	d152      	bne.n	80047f2 <ip_input+0x1d2>
         (ip_addr_ismulticast(&current_iphdr_src))) {
 800474c:	4b3e      	ldr	r3, [pc, #248]	; (8004848 <ip_input+0x228>)
 800474e:	681b      	ldr	r3, [r3, #0]
 8004750:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 8004754:	2be0      	cmp	r3, #224	; 0xe0
 8004756:	d04c      	beq.n	80047f2 <ip_input+0x1d2>
  if (netif == NULL) {
 8004758:	2c00      	cmp	r4, #0
 800475a:	d054      	beq.n	8004806 <ip_input+0x1e6>
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 800475c:	f8b9 3006 	ldrh.w	r3, [r9, #6]
 8004760:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8004764:	b29b      	uxth	r3, r3
 8004766:	b143      	cbz	r3, 800477a <ip_input+0x15a>
    p = ip_reass(p);
 8004768:	4630      	mov	r0, r6
 800476a:	f000 f9e5 	bl	8004b38 <ip_reass>
    if (p == NULL) {
 800476e:	4606      	mov	r6, r0
 8004770:	2800      	cmp	r0, #0
 8004772:	f43f af72 	beq.w	800465a <ip_input+0x3a>
    iphdr = (struct ip_hdr *)p->payload;
 8004776:	f8d0 9004 	ldr.w	r9, [r0, #4]
  current_netif = inp;
 800477a:	4b34      	ldr	r3, [pc, #208]	; (800484c <ip_input+0x22c>)
 800477c:	f8c3 8000 	str.w	r8, [r3]
  current_header = iphdr;
 8004780:	4b33      	ldr	r3, [pc, #204]	; (8004850 <ip_input+0x230>)
 8004782:	f8c3 9000 	str.w	r9, [r3]
  if (raw_input(p, inp) == 0)
 8004786:	4641      	mov	r1, r8
 8004788:	4630      	mov	r0, r6
 800478a:	f001 f951 	bl	8005a30 <raw_input>
 800478e:	2800      	cmp	r0, #0
 8004790:	d141      	bne.n	8004816 <ip_input+0x1f6>
    switch (IPH_PROTO(iphdr)) {
 8004792:	f899 3009 	ldrb.w	r3, [r9, #9]
 8004796:	2b06      	cmp	r3, #6
 8004798:	d047      	beq.n	800482a <ip_input+0x20a>
 800479a:	2b11      	cmp	r3, #17
 800479c:	d037      	beq.n	800480e <ip_input+0x1ee>
 800479e:	2b01      	cmp	r3, #1
 80047a0:	d048      	beq.n	8004834 <ip_input+0x214>
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 80047a2:	4641      	mov	r1, r8
 80047a4:	4b27      	ldr	r3, [pc, #156]	; (8004844 <ip_input+0x224>)
 80047a6:	6818      	ldr	r0, [r3, #0]
 80047a8:	f000 f8fc 	bl	80049a4 <ip4_addr_isbroadcast>
 80047ac:	b958      	cbnz	r0, 80047c6 <ip_input+0x1a6>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 80047ae:	4b25      	ldr	r3, [pc, #148]	; (8004844 <ip_input+0x224>)
 80047b0:	681b      	ldr	r3, [r3, #0]
 80047b2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 80047b6:	2be0      	cmp	r3, #224	; 0xe0
 80047b8:	d005      	beq.n	80047c6 <ip_input+0x1a6>
        p->payload = iphdr;
 80047ba:	f8c6 9004 	str.w	r9, [r6, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 80047be:	2102      	movs	r1, #2
 80047c0:	4630      	mov	r0, r6
 80047c2:	f7ff fe43 	bl	800444c <icmp_dest_unreach>
      pbuf_free(p);
 80047c6:	4630      	mov	r0, r6
 80047c8:	f000 ff6b 	bl	80056a2 <pbuf_free>
      IP_STATS_INC(ip.proterr);
 80047cc:	4b1c      	ldr	r3, [pc, #112]	; (8004840 <ip_input+0x220>)
 80047ce:	f8b3 2058 	ldrh.w	r2, [r3, #88]	; 0x58
 80047d2:	3201      	adds	r2, #1
 80047d4:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
      IP_STATS_INC(ip.drop);
 80047d8:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 80047dc:	3201      	adds	r2, #1
 80047de:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
 80047e2:	e018      	b.n	8004816 <ip_input+0x1f6>
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
 80047e4:	444d      	add	r5, r9
 80047e6:	886b      	ldrh	r3, [r5, #2]
 80047e8:	f5b3 4f86 	cmp.w	r3, #17152	; 0x4300
 80047ec:	d1a4      	bne.n	8004738 <ip_input+0x118>
        netif = inp;
 80047ee:	4644      	mov	r4, r8
 80047f0:	e7b2      	b.n	8004758 <ip_input+0x138>
      pbuf_free(p);
 80047f2:	4630      	mov	r0, r6
 80047f4:	f000 ff55 	bl	80056a2 <pbuf_free>
      IP_STATS_INC(ip.drop);
 80047f8:	4a11      	ldr	r2, [pc, #68]	; (8004840 <ip_input+0x220>)
 80047fa:	f8b2 304e 	ldrh.w	r3, [r2, #78]	; 0x4e
 80047fe:	3301      	adds	r3, #1
 8004800:	f8a2 304e 	strh.w	r3, [r2, #78]	; 0x4e
      return ERR_OK;
 8004804:	e729      	b.n	800465a <ip_input+0x3a>
    pbuf_free(p);
 8004806:	4630      	mov	r0, r6
 8004808:	f000 ff4b 	bl	80056a2 <pbuf_free>
    return ERR_OK;
 800480c:	e725      	b.n	800465a <ip_input+0x3a>
      udp_input(p, inp);
 800480e:	4641      	mov	r1, r8
 8004810:	4630      	mov	r0, r6
 8004812:	f003 fcd3 	bl	80081bc <udp_input>
  current_netif = NULL;
 8004816:	2300      	movs	r3, #0
 8004818:	4a0c      	ldr	r2, [pc, #48]	; (800484c <ip_input+0x22c>)
 800481a:	6013      	str	r3, [r2, #0]
  current_header = NULL;
 800481c:	4a0c      	ldr	r2, [pc, #48]	; (8004850 <ip_input+0x230>)
 800481e:	6013      	str	r3, [r2, #0]
  ip_addr_set_any(&current_iphdr_src);
 8004820:	4a09      	ldr	r2, [pc, #36]	; (8004848 <ip_input+0x228>)
 8004822:	6013      	str	r3, [r2, #0]
  ip_addr_set_any(&current_iphdr_dest);
 8004824:	4a07      	ldr	r2, [pc, #28]	; (8004844 <ip_input+0x224>)
 8004826:	6013      	str	r3, [r2, #0]
  return ERR_OK;
 8004828:	e717      	b.n	800465a <ip_input+0x3a>
      tcp_input(p, inp);
 800482a:	4641      	mov	r1, r8
 800482c:	4630      	mov	r0, r6
 800482e:	f002 fb0f 	bl	8006e50 <tcp_input>
      break;
 8004832:	e7f0      	b.n	8004816 <ip_input+0x1f6>
      icmp_input(p, inp);
 8004834:	4641      	mov	r1, r8
 8004836:	4630      	mov	r0, r6
 8004838:	f7ff fd38 	bl	80042ac <icmp_input>
      break;
 800483c:	e7eb      	b.n	8004816 <ip_input+0x1f6>
 800483e:	bf00      	nop
 8004840:	2000b084 	.word	0x2000b084
 8004844:	2000894c 	.word	0x2000894c
 8004848:	20008944 	.word	0x20008944
 800484c:	20008948 	.word	0x20008948
 8004850:	20008950 	.word	0x20008950
 8004854:	2000b078 	.word	0x2000b078

08004858 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 8004858:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800485c:	b083      	sub	sp, #12
 800485e:	4605      	mov	r5, r0
 8004860:	f89d 9030 	ldrb.w	r9, [sp, #48]	; 0x30
 8004864:	f89d b034 	ldrb.w	fp, [sp, #52]	; 0x34
 8004868:	9e0e      	ldr	r6, [sp, #56]	; 0x38
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
 800486a:	2a00      	cmp	r2, #0
 800486c:	d065      	beq.n	800493a <ip_output_if+0xe2>
 800486e:	468a      	mov	sl, r1
 8004870:	4698      	mov	r8, r3
 8004872:	4617      	mov	r7, r2
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 8004874:	2114      	movs	r1, #20
 8004876:	f000 fed6 	bl	8005626 <pbuf_header>
 800487a:	2800      	cmp	r0, #0
 800487c:	d152      	bne.n	8004924 <ip_output_if+0xcc>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
 800487e:	686c      	ldr	r4, [r5, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 8004880:	f884 8008 	strb.w	r8, [r4, #8]
    IPH_PROTO_SET(iphdr, proto);
 8004884:	f884 b009 	strb.w	fp, [r4, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
 8004888:	6838      	ldr	r0, [r7, #0]
 800488a:	6120      	str	r0, [r4, #16]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 800488c:	2345      	movs	r3, #69	; 0x45
 800488e:	7023      	strb	r3, [r4, #0]
    IPH_TOS_SET(iphdr, tos);
 8004890:	f884 9001 	strb.w	r9, [r4, #1]
    chk_sum += LWIP_MAKE_U16(proto, ttl);
 8004894:	ea48 280b 	orr.w	r8, r8, fp, lsl #8
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
 8004898:	fa18 f880 	uxtah	r8, r8, r0
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
 800489c:	ea4f 2309 	mov.w	r3, r9, lsl #8
 80048a0:	f043 0345 	orr.w	r3, r3, #69	; 0x45
 80048a4:	4443      	add	r3, r8
 80048a6:	eb03 4810 	add.w	r8, r3, r0, lsr #16
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 80048aa:	8928      	ldrh	r0, [r5, #8]
 80048ac:	f7ff fc7e 	bl	80041ac <lwip_htons>
 80048b0:	4681      	mov	r9, r0
 80048b2:	8060      	strh	r0, [r4, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 80048b4:	2300      	movs	r3, #0
 80048b6:	71a3      	strb	r3, [r4, #6]
 80048b8:	71e3      	strb	r3, [r4, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
 80048ba:	f8df b09c 	ldr.w	fp, [pc, #156]	; 8004958 <ip_output_if+0x100>
 80048be:	f8bb 0000 	ldrh.w	r0, [fp]
 80048c2:	f7ff fc73 	bl	80041ac <lwip_htons>
 80048c6:	80a0      	strh	r0, [r4, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 80048c8:	f8bb 3000 	ldrh.w	r3, [fp]
 80048cc:	3301      	adds	r3, #1
 80048ce:	f8ab 3000 	strh.w	r3, [fp]

    if (ip_addr_isany(src)) {
 80048d2:	f1ba 0f00 	cmp.w	sl, #0
 80048d6:	d002      	beq.n	80048de <ip_output_if+0x86>
 80048d8:	f8da 3000 	ldr.w	r3, [sl]
 80048dc:	bb5b      	cbnz	r3, 8004936 <ip_output_if+0xde>
      ip_addr_copy(iphdr->src, netif->ip_addr);
 80048de:	6873      	ldr	r3, [r6, #4]
 80048e0:	60e3      	str	r3, [r4, #12]
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
 80048e2:	68e2      	ldr	r2, [r4, #12]
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
 80048e4:	fa18 f382 	uxtah	r3, r8, r2
 80048e8:	eb03 4312 	add.w	r3, r3, r2, lsr #16
 80048ec:	444b      	add	r3, r9
 80048ee:	4418      	add	r0, r3
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
 80048f0:	b283      	uxth	r3, r0
 80048f2:	eb03 4010 	add.w	r0, r3, r0, lsr #16
    chk_sum = (chk_sum >> 16) + chk_sum;
 80048f6:	eb00 4010 	add.w	r0, r0, r0, lsr #16
    chk_sum = ~chk_sum;
    iphdr->_chksum = chk_sum; /* network order */
 80048fa:	43c0      	mvns	r0, r0
 80048fc:	8160      	strh	r0, [r4, #10]
    iphdr = (struct ip_hdr *)p->payload;
    ip_addr_copy(dest_addr, iphdr->dest);
    dest = &dest_addr;
  }

  IP_STATS_INC(ip.xmit);
 80048fe:	4a15      	ldr	r2, [pc, #84]	; (8004954 <ip_output_if+0xfc>)
 8004900:	f8b2 3048 	ldrh.w	r3, [r2, #72]	; 0x48
 8004904:	3301      	adds	r3, #1
 8004906:	f8a2 3048 	strh.w	r3, [r2, #72]	; 0x48
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 800490a:	8c33      	ldrh	r3, [r6, #32]
 800490c:	b113      	cbz	r3, 8004914 <ip_output_if+0xbc>
 800490e:	892a      	ldrh	r2, [r5, #8]
 8004910:	429a      	cmp	r2, r3
 8004912:	d818      	bhi.n	8004946 <ip_output_if+0xee>
    return ip_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
 8004914:	6973      	ldr	r3, [r6, #20]
 8004916:	463a      	mov	r2, r7
 8004918:	4629      	mov	r1, r5
 800491a:	4630      	mov	r0, r6
 800491c:	4798      	blx	r3
}
 800491e:	b003      	add	sp, #12
 8004920:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      IP_STATS_INC(ip.err);
 8004924:	4a0b      	ldr	r2, [pc, #44]	; (8004954 <ip_output_if+0xfc>)
 8004926:	f8b2 305c 	ldrh.w	r3, [r2, #92]	; 0x5c
 800492a:	3301      	adds	r3, #1
 800492c:	f8a2 305c 	strh.w	r3, [r2, #92]	; 0x5c
      return ERR_BUF;
 8004930:	f06f 0001 	mvn.w	r0, #1
 8004934:	e7f3      	b.n	800491e <ip_output_if+0xc6>
      ip_addr_copy(iphdr->src, *src);
 8004936:	60e3      	str	r3, [r4, #12]
 8004938:	e7d3      	b.n	80048e2 <ip_output_if+0x8a>
    ip_addr_copy(dest_addr, iphdr->dest);
 800493a:	6843      	ldr	r3, [r0, #4]
 800493c:	691b      	ldr	r3, [r3, #16]
 800493e:	af02      	add	r7, sp, #8
 8004940:	f847 3d04 	str.w	r3, [r7, #-4]!
 8004944:	e7db      	b.n	80048fe <ip_output_if+0xa6>
    return ip_frag(p, netif, dest);
 8004946:	463a      	mov	r2, r7
 8004948:	4631      	mov	r1, r6
 800494a:	4628      	mov	r0, r5
 800494c:	f000 faac 	bl	8004ea8 <ip_frag>
 8004950:	e7e5      	b.n	800491e <ip_output_if+0xc6>
 8004952:	bf00      	nop
 8004954:	2000b084 	.word	0x2000b084
 8004958:	20000df0 	.word	0x20000df0

0800495c <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 800495c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800495e:	b085      	sub	sp, #20
 8004960:	4605      	mov	r5, r0
 8004962:	460e      	mov	r6, r1
 8004964:	4614      	mov	r4, r2
 8004966:	461f      	mov	r7, r3

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(dest)) == NULL) {
 8004968:	4610      	mov	r0, r2
 800496a:	f7ff fe2f 	bl	80045cc <ip_route>
 800496e:	b170      	cbz	r0, 800498e <ip_output+0x32>
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
 8004970:	9002      	str	r0, [sp, #8]
 8004972:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 8004976:	9301      	str	r3, [sp, #4]
 8004978:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 800497c:	9300      	str	r3, [sp, #0]
 800497e:	463b      	mov	r3, r7
 8004980:	4622      	mov	r2, r4
 8004982:	4631      	mov	r1, r6
 8004984:	4628      	mov	r0, r5
 8004986:	f7ff ff67 	bl	8004858 <ip_output_if>
}
 800498a:	b005      	add	sp, #20
 800498c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    IP_STATS_INC(ip.rterr);
 800498e:	4a04      	ldr	r2, [pc, #16]	; (80049a0 <ip_output+0x44>)
 8004990:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
 8004994:	3301      	adds	r3, #1
 8004996:	f8a2 3056 	strh.w	r3, [r2, #86]	; 0x56
    return ERR_RTE;
 800499a:	f06f 0003 	mvn.w	r0, #3
 800499e:	e7f4      	b.n	800498a <ip_output+0x2e>
 80049a0:	2000b084 	.word	0x2000b084

080049a4 <ip4_addr_isbroadcast>:
{
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 80049a4:	1e43      	subs	r3, r0, #1
 80049a6:	f113 0f03 	cmn.w	r3, #3
 80049aa:	d812      	bhi.n	80049d2 <ip4_addr_isbroadcast+0x2e>
      (addr == IPADDR_ANY)) {
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 80049ac:	f891 3029 	ldrb.w	r3, [r1, #41]	; 0x29
 80049b0:	f013 0f02 	tst.w	r3, #2
 80049b4:	d00f      	beq.n	80049d6 <ip4_addr_isbroadcast+0x32>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
 80049b6:	684b      	ldr	r3, [r1, #4]
 80049b8:	4298      	cmp	r0, r3
 80049ba:	d00e      	beq.n	80049da <ip4_addr_isbroadcast+0x36>
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
 80049bc:	688a      	ldr	r2, [r1, #8]
 80049be:	4043      	eors	r3, r0
 80049c0:	4213      	tst	r3, r2
 80049c2:	d10c      	bne.n	80049de <ip4_addr_isbroadcast+0x3a>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
 80049c4:	43d2      	mvns	r2, r2
 80049c6:	ea32 0300 	bics.w	r3, r2, r0
    return 1;
 80049ca:	bf0c      	ite	eq
 80049cc:	2001      	moveq	r0, #1
 80049ce:	2000      	movne	r0, #0
 80049d0:	4770      	bx	lr
 80049d2:	2001      	movs	r0, #1
 80049d4:	4770      	bx	lr
    return 0;
 80049d6:	2000      	movs	r0, #0
 80049d8:	4770      	bx	lr
    return 0;
 80049da:	2000      	movs	r0, #0
 80049dc:	4770      	bx	lr
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
 80049de:	2000      	movs	r0, #0
  }
}
 80049e0:	4770      	bx	lr
	...

080049e4 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 80049e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80049e8:	4607      	mov	r7, r0
 80049ea:	4688      	mov	r8, r1
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 80049ec:	6845      	ldr	r5, [r0, #4]
 80049ee:	686b      	ldr	r3, [r5, #4]
  if (iprh->start == 0) {
 80049f0:	889a      	ldrh	r2, [r3, #4]
 80049f2:	b30a      	cbz	r2, 8004a38 <ip_reass_free_complete_datagram+0x54>
  u16_t pbufs_freed = 0;
 80049f4:	2400      	movs	r4, #0
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
 80049f6:	687d      	ldr	r5, [r7, #4]
  while (p != NULL) {
 80049f8:	b165      	cbz	r5, 8004a14 <ip_reass_free_complete_datagram+0x30>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
 80049fa:	686b      	ldr	r3, [r5, #4]
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
 80049fc:	681e      	ldr	r6, [r3, #0]
    clen = pbuf_clen(pcur);
 80049fe:	4628      	mov	r0, r5
 8004a00:	f000 ff41 	bl	8005886 <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 8004a04:	4404      	add	r4, r0
 8004a06:	b2a4      	uxth	r4, r4
    pbuf_free(pcur);
 8004a08:	4628      	mov	r0, r5
 8004a0a:	f000 fe4a 	bl	80056a2 <pbuf_free>
    p = iprh->next_pbuf;
 8004a0e:	4635      	mov	r5, r6
  while (p != NULL) {
 8004a10:	2e00      	cmp	r6, #0
 8004a12:	d1f2      	bne.n	80049fa <ip_reass_free_complete_datagram+0x16>
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 8004a14:	4b18      	ldr	r3, [pc, #96]	; (8004a78 <ip_reass_free_complete_datagram+0x94>)
 8004a16:	681b      	ldr	r3, [r3, #0]
 8004a18:	429f      	cmp	r7, r3
 8004a1a:	d028      	beq.n	8004a6e <ip_reass_free_complete_datagram+0x8a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
 8004a1c:	683b      	ldr	r3, [r7, #0]
 8004a1e:	f8c8 3000 	str.w	r3, [r8]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 8004a22:	4639      	mov	r1, r7
 8004a24:	2005      	movs	r0, #5
 8004a26:	f000 fd45 	bl	80054b4 <memp_free>
  ip_reass_pbufcount -= pbufs_freed;
 8004a2a:	4a14      	ldr	r2, [pc, #80]	; (8004a7c <ip_reass_free_complete_datagram+0x98>)
 8004a2c:	8813      	ldrh	r3, [r2, #0]
 8004a2e:	1b1b      	subs	r3, r3, r4
 8004a30:	8013      	strh	r3, [r2, #0]
}
 8004a32:	4620      	mov	r0, r4
 8004a34:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ipr->p = iprh->next_pbuf;
 8004a38:	681b      	ldr	r3, [r3, #0]
 8004a3a:	6043      	str	r3, [r0, #4]
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 8004a3c:	686a      	ldr	r2, [r5, #4]
 8004a3e:	4603      	mov	r3, r0
 8004a40:	f853 1f08 	ldr.w	r1, [r3, #8]!
 8004a44:	685e      	ldr	r6, [r3, #4]
 8004a46:	689c      	ldr	r4, [r3, #8]
 8004a48:	68d8      	ldr	r0, [r3, #12]
 8004a4a:	6011      	str	r1, [r2, #0]
 8004a4c:	6056      	str	r6, [r2, #4]
 8004a4e:	6094      	str	r4, [r2, #8]
 8004a50:	60d0      	str	r0, [r2, #12]
 8004a52:	6919      	ldr	r1, [r3, #16]
 8004a54:	6111      	str	r1, [r2, #16]
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 8004a56:	2101      	movs	r1, #1
 8004a58:	4628      	mov	r0, r5
 8004a5a:	f7ff fcfd 	bl	8004458 <icmp_time_exceeded>
    clen = pbuf_clen(p);
 8004a5e:	4628      	mov	r0, r5
 8004a60:	f000 ff11 	bl	8005886 <pbuf_clen>
    pbufs_freed += clen;
 8004a64:	b284      	uxth	r4, r0
    pbuf_free(p);
 8004a66:	4628      	mov	r0, r5
 8004a68:	f000 fe1b 	bl	80056a2 <pbuf_free>
 8004a6c:	e7c3      	b.n	80049f6 <ip_reass_free_complete_datagram+0x12>
    reassdatagrams = ipr->next;
 8004a6e:	683a      	ldr	r2, [r7, #0]
 8004a70:	4b01      	ldr	r3, [pc, #4]	; (8004a78 <ip_reass_free_complete_datagram+0x94>)
 8004a72:	601a      	str	r2, [r3, #0]
 8004a74:	e7d5      	b.n	8004a22 <ip_reass_free_complete_datagram+0x3e>
 8004a76:	bf00      	nop
 8004a78:	20000df4 	.word	0x20000df4
 8004a7c:	20000df2 	.word	0x20000df2

08004a80 <ip_reass_remove_oldest_datagram>:
{
 8004a80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004a84:	4605      	mov	r5, r0
 8004a86:	4688      	mov	r8, r1
  int pbufs_freed = 0, pbufs_freed_current;
 8004a88:	2600      	movs	r6, #0
    r = reassdatagrams;
 8004a8a:	4f18      	ldr	r7, [pc, #96]	; (8004aec <ip_reass_remove_oldest_datagram+0x6c>)
 8004a8c:	e023      	b.n	8004ad6 <ip_reass_remove_oldest_datagram+0x56>
        other_datagrams++;
 8004a8e:	3401      	adds	r4, #1
        if (oldest == NULL) {
 8004a90:	b1b8      	cbz	r0, 8004ac2 <ip_reass_remove_oldest_datagram+0x42>
        } else if (r->timer <= oldest->timer) {
 8004a92:	f893 e01f 	ldrb.w	lr, [r3, #31]
 8004a96:	7fc2      	ldrb	r2, [r0, #31]
 8004a98:	4596      	cmp	lr, r2
 8004a9a:	bf98      	it	ls
 8004a9c:	4618      	movls	r0, r3
      if (r->next != NULL) {
 8004a9e:	681a      	ldr	r2, [r3, #0]
 8004aa0:	b18a      	cbz	r2, 8004ac6 <ip_reass_remove_oldest_datagram+0x46>
 8004aa2:	4619      	mov	r1, r3
 8004aa4:	4613      	mov	r3, r2
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 8004aa6:	695a      	ldr	r2, [r3, #20]
 8004aa8:	4562      	cmp	r2, ip
 8004aaa:	d1f0      	bne.n	8004a8e <ip_reass_remove_oldest_datagram+0xe>
 8004aac:	f8d5 e010 	ldr.w	lr, [r5, #16]
 8004ab0:	699a      	ldr	r2, [r3, #24]
 8004ab2:	4572      	cmp	r2, lr
 8004ab4:	d1eb      	bne.n	8004a8e <ip_reass_remove_oldest_datagram+0xe>
 8004ab6:	f8b3 e00c 	ldrh.w	lr, [r3, #12]
 8004aba:	88aa      	ldrh	r2, [r5, #4]
 8004abc:	4596      	cmp	lr, r2
 8004abe:	d1e6      	bne.n	8004a8e <ip_reass_remove_oldest_datagram+0xe>
 8004ac0:	e7ed      	b.n	8004a9e <ip_reass_remove_oldest_datagram+0x1e>
 8004ac2:	4618      	mov	r0, r3
 8004ac4:	e7eb      	b.n	8004a9e <ip_reass_remove_oldest_datagram+0x1e>
    if (oldest != NULL) {
 8004ac6:	b110      	cbz	r0, 8004ace <ip_reass_remove_oldest_datagram+0x4e>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
 8004ac8:	f7ff ff8c 	bl	80049e4 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
 8004acc:	4406      	add	r6, r0
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 8004ace:	4546      	cmp	r6, r8
 8004ad0:	da09      	bge.n	8004ae6 <ip_reass_remove_oldest_datagram+0x66>
 8004ad2:	2c01      	cmp	r4, #1
 8004ad4:	dd07      	ble.n	8004ae6 <ip_reass_remove_oldest_datagram+0x66>
    r = reassdatagrams;
 8004ad6:	683b      	ldr	r3, [r7, #0]
    while (r != NULL) {
 8004ad8:	b12b      	cbz	r3, 8004ae6 <ip_reass_remove_oldest_datagram+0x66>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 8004ada:	f8d5 c00c 	ldr.w	ip, [r5, #12]
 8004ade:	2400      	movs	r4, #0
 8004ae0:	4621      	mov	r1, r4
 8004ae2:	4620      	mov	r0, r4
 8004ae4:	e7df      	b.n	8004aa6 <ip_reass_remove_oldest_datagram+0x26>
}
 8004ae6:	4630      	mov	r0, r6
 8004ae8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004aec:	20000df4 	.word	0x20000df4

08004af0 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 8004af0:	b510      	push	{r4, lr}
 8004af2:	4604      	mov	r4, r0
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
 8004af4:	6940      	ldr	r0, [r0, #20]
 8004af6:	b108      	cbz	r0, 8004afc <ipfrag_free_pbuf_custom+0xc>
    pbuf_free(pcr->original);
 8004af8:	f000 fdd3 	bl	80056a2 <pbuf_free>
  memp_free(MEMP_FRAG_PBUF, p);
 8004afc:	4621      	mov	r1, r4
 8004afe:	2006      	movs	r0, #6
 8004b00:	f000 fcd8 	bl	80054b4 <memp_free>
 8004b04:	bd10      	pop	{r4, pc}
	...

08004b08 <ip_reass_tmr>:
{
 8004b08:	b538      	push	{r3, r4, r5, lr}
  r = reassdatagrams;
 8004b0a:	4b0a      	ldr	r3, [pc, #40]	; (8004b34 <ip_reass_tmr+0x2c>)
 8004b0c:	6818      	ldr	r0, [r3, #0]
  while (r != NULL) {
 8004b0e:	b178      	cbz	r0, 8004b30 <ip_reass_tmr+0x28>
 8004b10:	2400      	movs	r4, #0
 8004b12:	e005      	b.n	8004b20 <ip_reass_tmr+0x18>
      r = r->next;
 8004b14:	6805      	ldr	r5, [r0, #0]
      ip_reass_free_complete_datagram(tmp, prev);
 8004b16:	4621      	mov	r1, r4
 8004b18:	f7ff ff64 	bl	80049e4 <ip_reass_free_complete_datagram>
      r = r->next;
 8004b1c:	4628      	mov	r0, r5
  while (r != NULL) {
 8004b1e:	b138      	cbz	r0, 8004b30 <ip_reass_tmr+0x28>
    if (r->timer > 0) {
 8004b20:	7fc3      	ldrb	r3, [r0, #31]
 8004b22:	2b00      	cmp	r3, #0
 8004b24:	d0f6      	beq.n	8004b14 <ip_reass_tmr+0xc>
      r->timer--;
 8004b26:	3b01      	subs	r3, #1
 8004b28:	77c3      	strb	r3, [r0, #31]
 8004b2a:	4604      	mov	r4, r0
      r = r->next;
 8004b2c:	6800      	ldr	r0, [r0, #0]
 8004b2e:	e7f6      	b.n	8004b1e <ip_reass_tmr+0x16>
 8004b30:	bd38      	pop	{r3, r4, r5, pc}
 8004b32:	bf00      	nop
 8004b34:	20000df4 	.word	0x20000df4

08004b38 <ip_reass>:
{
 8004b38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004b3c:	b083      	sub	sp, #12
 8004b3e:	4607      	mov	r7, r0
  IPFRAG_STATS_INC(ip_frag.recv);
 8004b40:	4ab2      	ldr	r2, [pc, #712]	; (8004e0c <ip_reass+0x2d4>)
 8004b42:	8e53      	ldrh	r3, [r2, #50]	; 0x32
 8004b44:	3301      	adds	r3, #1
 8004b46:	8653      	strh	r3, [r2, #50]	; 0x32
  fraghdr = (struct ip_hdr*)p->payload;
 8004b48:	6846      	ldr	r6, [r0, #4]
  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 8004b4a:	7833      	ldrb	r3, [r6, #0]
 8004b4c:	f003 030f 	and.w	r3, r3, #15
 8004b50:	2b05      	cmp	r3, #5
 8004b52:	d11a      	bne.n	8004b8a <ip_reass+0x52>
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 8004b54:	88f0      	ldrh	r0, [r6, #6]
 8004b56:	f7ff fb2e 	bl	80041b6 <lwip_ntohs>
 8004b5a:	9001      	str	r0, [sp, #4]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8004b5c:	8870      	ldrh	r0, [r6, #2]
 8004b5e:	f7ff fb2a 	bl	80041b6 <lwip_ntohs>
 8004b62:	4683      	mov	fp, r0
 8004b64:	f896 8000 	ldrb.w	r8, [r6]
  clen = pbuf_clen(p);
 8004b68:	4638      	mov	r0, r7
 8004b6a:	f000 fe8c 	bl	8005886 <pbuf_clen>
 8004b6e:	4681      	mov	r9, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 8004b70:	4ba7      	ldr	r3, [pc, #668]	; (8004e10 <ip_reass+0x2d8>)
 8004b72:	881b      	ldrh	r3, [r3, #0]
 8004b74:	4403      	add	r3, r0
 8004b76:	2b0a      	cmp	r3, #10
 8004b78:	dc16      	bgt.n	8004ba8 <ip_reass+0x70>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 8004b7a:	4ba6      	ldr	r3, [pc, #664]	; (8004e14 <ip_reass+0x2dc>)
 8004b7c:	681c      	ldr	r4, [r3, #0]
 8004b7e:	2c00      	cmp	r4, #0
 8004b80:	f000 8091 	beq.w	8004ca6 <ip_reass+0x16e>
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 8004b84:	68f2      	ldr	r2, [r6, #12]
 8004b86:	2500      	movs	r5, #0
 8004b88:	e022      	b.n	8004bd0 <ip_reass+0x98>
    IPFRAG_STATS_INC(ip_frag.err);
 8004b8a:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8004b8e:	3301      	adds	r3, #1
 8004b90:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
  IPFRAG_STATS_INC(ip_frag.drop);
 8004b94:	4a9d      	ldr	r2, [pc, #628]	; (8004e0c <ip_reass+0x2d4>)
 8004b96:	8ed3      	ldrh	r3, [r2, #54]	; 0x36
 8004b98:	3301      	adds	r3, #1
 8004b9a:	86d3      	strh	r3, [r2, #54]	; 0x36
  pbuf_free(p);
 8004b9c:	4638      	mov	r0, r7
 8004b9e:	f000 fd80 	bl	80056a2 <pbuf_free>
  return NULL;
 8004ba2:	f04f 0800 	mov.w	r8, #0
 8004ba6:	e119      	b.n	8004ddc <ip_reass+0x2a4>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8004ba8:	4601      	mov	r1, r0
 8004baa:	4630      	mov	r0, r6
 8004bac:	f7ff ff68 	bl	8004a80 <ip_reass_remove_oldest_datagram>
 8004bb0:	b120      	cbz	r0, 8004bbc <ip_reass+0x84>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 8004bb2:	4b97      	ldr	r3, [pc, #604]	; (8004e10 <ip_reass+0x2d8>)
 8004bb4:	881b      	ldrh	r3, [r3, #0]
 8004bb6:	444b      	add	r3, r9
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 8004bb8:	2b0a      	cmp	r3, #10
 8004bba:	ddde      	ble.n	8004b7a <ip_reass+0x42>
      IPFRAG_STATS_INC(ip_frag.memerr);
 8004bbc:	4a93      	ldr	r2, [pc, #588]	; (8004e0c <ip_reass+0x2d4>)
 8004bbe:	8f93      	ldrh	r3, [r2, #60]	; 0x3c
 8004bc0:	3301      	adds	r3, #1
 8004bc2:	8793      	strh	r3, [r2, #60]	; 0x3c
      goto nullreturn;
 8004bc4:	e7e6      	b.n	8004b94 <ip_reass+0x5c>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 8004bc6:	6823      	ldr	r3, [r4, #0]
 8004bc8:	4625      	mov	r5, r4
 8004bca:	2b00      	cmp	r3, #0
 8004bcc:	d06b      	beq.n	8004ca6 <ip_reass+0x16e>
 8004bce:	461c      	mov	r4, r3
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 8004bd0:	6963      	ldr	r3, [r4, #20]
 8004bd2:	4293      	cmp	r3, r2
 8004bd4:	d1f7      	bne.n	8004bc6 <ip_reass+0x8e>
 8004bd6:	6933      	ldr	r3, [r6, #16]
 8004bd8:	69a1      	ldr	r1, [r4, #24]
 8004bda:	4299      	cmp	r1, r3
 8004bdc:	d1f3      	bne.n	8004bc6 <ip_reass+0x8e>
 8004bde:	89a1      	ldrh	r1, [r4, #12]
 8004be0:	88b3      	ldrh	r3, [r6, #4]
 8004be2:	4299      	cmp	r1, r3
 8004be4:	d1ef      	bne.n	8004bc6 <ip_reass+0x8e>
      IPFRAG_STATS_INC(ip_frag.cachehit);
 8004be6:	4a89      	ldr	r2, [pc, #548]	; (8004e0c <ip_reass+0x2d4>)
 8004be8:	f8b2 3046 	ldrh.w	r3, [r2, #70]	; 0x46
 8004bec:	3301      	adds	r3, #1
 8004bee:	f8a2 3046 	strh.w	r3, [r2, #70]	; 0x46
  if (ipr == NULL) {
 8004bf2:	2c00      	cmp	r4, #0
 8004bf4:	d056      	beq.n	8004ca4 <ip_reass+0x16c>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 8004bf6:	88f0      	ldrh	r0, [r6, #6]
 8004bf8:	f7ff fadd 	bl	80041b6 <lwip_ntohs>
 8004bfc:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8004c00:	2800      	cmp	r0, #0
 8004c02:	f000 8087 	beq.w	8004d14 <ip_reass+0x1dc>
  ip_reass_pbufcount += clen;
 8004c06:	4a82      	ldr	r2, [pc, #520]	; (8004e10 <ip_reass+0x2d8>)
 8004c08:	8813      	ldrh	r3, [r2, #0]
 8004c0a:	4499      	add	r9, r3
 8004c0c:	f8a2 9000 	strh.w	r9, [r2]
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
 8004c10:	88f3      	ldrh	r3, [r6, #6]
 8004c12:	f013 0f20 	tst.w	r3, #32
 8004c16:	d10c      	bne.n	8004c32 <ip_reass+0xfa>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 8004c18:	7fa3      	ldrb	r3, [r4, #30]
 8004c1a:	f043 0301 	orr.w	r3, r3, #1
 8004c1e:	77a3      	strb	r3, [r4, #30]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8004c20:	f008 080f 	and.w	r8, r8, #15
 8004c24:	ebab 0b88 	sub.w	fp, fp, r8, lsl #2
    ipr->datagram_len = offset + len;
 8004c28:	9b01      	ldr	r3, [sp, #4]
 8004c2a:	eb0b 0ac3 	add.w	sl, fp, r3, lsl #3
 8004c2e:	f8a4 a01c 	strh.w	sl, [r4, #28]
  fraghdr = (struct ip_hdr*)new_p->payload; 
 8004c32:	f8d7 8004 	ldr.w	r8, [r7, #4]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8004c36:	f8b8 0002 	ldrh.w	r0, [r8, #2]
 8004c3a:	f7ff fabc 	bl	80041b6 <lwip_ntohs>
 8004c3e:	f898 6000 	ldrb.w	r6, [r8]
 8004c42:	f006 060f 	and.w	r6, r6, #15
 8004c46:	eba0 0686 	sub.w	r6, r0, r6, lsl #2
 8004c4a:	b2b6      	uxth	r6, r6
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 8004c4c:	f8b8 0006 	ldrh.w	r0, [r8, #6]
 8004c50:	f7ff fab1 	bl	80041b6 <lwip_ntohs>
 8004c54:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8004c58:	00c0      	lsls	r0, r0, #3
  iprh = (struct ip_reass_helper*)new_p->payload;
 8004c5a:	f8d7 8004 	ldr.w	r8, [r7, #4]
  iprh->next_pbuf = NULL;
 8004c5e:	2300      	movs	r3, #0
 8004c60:	f888 3000 	strb.w	r3, [r8]
 8004c64:	f888 3001 	strb.w	r3, [r8, #1]
 8004c68:	f888 3002 	strb.w	r3, [r8, #2]
 8004c6c:	f888 3003 	strb.w	r3, [r8, #3]
  iprh->start = offset;
 8004c70:	f8a8 0004 	strh.w	r0, [r8, #4]
  iprh->end = offset + len;
 8004c74:	eb06 0c00 	add.w	ip, r6, r0
 8004c78:	fa1f fc8c 	uxth.w	ip, ip
 8004c7c:	f8a8 c006 	strh.w	ip, [r8, #6]
  for (q = ipr->p; q != NULL;) {
 8004c80:	6862      	ldr	r2, [r4, #4]
 8004c82:	2a00      	cmp	r2, #0
 8004c84:	f000 809a 	beq.w	8004dbc <ip_reass+0x284>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 8004c88:	6853      	ldr	r3, [r2, #4]
    if (iprh->start < iprh_tmp->start) {
 8004c8a:	8899      	ldrh	r1, [r3, #4]
 8004c8c:	4288      	cmp	r0, r1
 8004c8e:	f0c0 80ad 	bcc.w	8004dec <ip_reass+0x2b4>
    } else if(iprh->start == iprh_tmp->start) {
 8004c92:	f000 8097 	beq.w	8004dc4 <ip_reass+0x28c>
    } else if(iprh->start < iprh_tmp->end) {
 8004c96:	88da      	ldrh	r2, [r3, #6]
 8004c98:	4282      	cmp	r2, r0
 8004c9a:	f200 8093 	bhi.w	8004dc4 <ip_reass+0x28c>
 8004c9e:	f04f 0e01 	mov.w	lr, #1
 8004ca2:	e078      	b.n	8004d96 <ip_reass+0x25e>
 8004ca4:	462c      	mov	r4, r5
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 8004ca6:	2005      	movs	r0, #5
 8004ca8:	f000 fbce 	bl	8005448 <memp_malloc>
  if (ipr == NULL) {
 8004cac:	4682      	mov	sl, r0
 8004cae:	b1f8      	cbz	r0, 8004cf0 <ip_reass+0x1b8>
  memset(ipr, 0, sizeof(struct ip_reassdata));
 8004cb0:	2220      	movs	r2, #32
 8004cb2:	2100      	movs	r1, #0
 8004cb4:	4650      	mov	r0, sl
 8004cb6:	f004 f90b 	bl	8008ed0 <memset>
  ipr->timer = IP_REASS_MAXAGE;
 8004cba:	2303      	movs	r3, #3
 8004cbc:	f88a 301f 	strb.w	r3, [sl, #31]
  ipr->next = reassdatagrams;
 8004cc0:	4b54      	ldr	r3, [pc, #336]	; (8004e14 <ip_reass+0x2dc>)
 8004cc2:	681a      	ldr	r2, [r3, #0]
 8004cc4:	f8ca 2000 	str.w	r2, [sl]
  reassdatagrams = ipr;
 8004cc8:	f8c3 a000 	str.w	sl, [r3]
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 8004ccc:	6832      	ldr	r2, [r6, #0]
 8004cce:	6875      	ldr	r5, [r6, #4]
 8004cd0:	68b0      	ldr	r0, [r6, #8]
 8004cd2:	68f1      	ldr	r1, [r6, #12]
 8004cd4:	f8ca 2008 	str.w	r2, [sl, #8]
 8004cd8:	f8ca 500c 	str.w	r5, [sl, #12]
 8004cdc:	f8ca 0010 	str.w	r0, [sl, #16]
 8004ce0:	f8ca 1014 	str.w	r1, [sl, #20]
 8004ce4:	6932      	ldr	r2, [r6, #16]
 8004ce6:	f8ca 2018 	str.w	r2, [sl, #24]
 8004cea:	4625      	mov	r5, r4
 8004cec:	4654      	mov	r4, sl
 8004cee:	e78a      	b.n	8004c06 <ip_reass+0xce>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 8004cf0:	4649      	mov	r1, r9
 8004cf2:	4630      	mov	r0, r6
 8004cf4:	f7ff fec4 	bl	8004a80 <ip_reass_remove_oldest_datagram>
 8004cf8:	4581      	cmp	r9, r0
 8004cfa:	dd04      	ble.n	8004d06 <ip_reass+0x1ce>
      IPFRAG_STATS_INC(ip_frag.memerr);
 8004cfc:	4a43      	ldr	r2, [pc, #268]	; (8004e0c <ip_reass+0x2d4>)
 8004cfe:	8f93      	ldrh	r3, [r2, #60]	; 0x3c
 8004d00:	3301      	adds	r3, #1
 8004d02:	8793      	strh	r3, [r2, #60]	; 0x3c
 8004d04:	e746      	b.n	8004b94 <ip_reass+0x5c>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 8004d06:	2005      	movs	r0, #5
 8004d08:	f000 fb9e 	bl	8005448 <memp_malloc>
    if (ipr == NULL)
 8004d0c:	4682      	mov	sl, r0
 8004d0e:	2800      	cmp	r0, #0
 8004d10:	d1ce      	bne.n	8004cb0 <ip_reass+0x178>
 8004d12:	e7f3      	b.n	8004cfc <ip_reass+0x1c4>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 8004d14:	89e0      	ldrh	r0, [r4, #14]
 8004d16:	f7ff fa4e 	bl	80041b6 <lwip_ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 8004d1a:	f3c0 000c 	ubfx	r0, r0, #0, #13
 8004d1e:	2800      	cmp	r0, #0
 8004d20:	f43f af71 	beq.w	8004c06 <ip_reass+0xce>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 8004d24:	6832      	ldr	r2, [r6, #0]
 8004d26:	f8d6 e004 	ldr.w	lr, [r6, #4]
 8004d2a:	68b0      	ldr	r0, [r6, #8]
 8004d2c:	68f1      	ldr	r1, [r6, #12]
 8004d2e:	60a2      	str	r2, [r4, #8]
 8004d30:	f8c4 e00c 	str.w	lr, [r4, #12]
 8004d34:	6120      	str	r0, [r4, #16]
 8004d36:	6161      	str	r1, [r4, #20]
 8004d38:	6932      	ldr	r2, [r6, #16]
 8004d3a:	61a2      	str	r2, [r4, #24]
 8004d3c:	e763      	b.n	8004c06 <ip_reass+0xce>
      iprh->next_pbuf = q;
 8004d3e:	f8c8 6000 	str.w	r6, [r8]
      if (iprh_prev != NULL) {
 8004d42:	2b00      	cmp	r3, #0
 8004d44:	d056      	beq.n	8004df4 <ip_reass+0x2bc>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 8004d46:	88d9      	ldrh	r1, [r3, #6]
 8004d48:	4281      	cmp	r1, r0
 8004d4a:	d83b      	bhi.n	8004dc4 <ip_reass+0x28c>
 8004d4c:	8892      	ldrh	r2, [r2, #4]
 8004d4e:	4562      	cmp	r2, ip
 8004d50:	d338      	bcc.n	8004dc4 <ip_reass+0x28c>
        iprh_prev->next_pbuf = new_p;
 8004d52:	601f      	str	r7, [r3, #0]
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 8004d54:	7fa3      	ldrb	r3, [r4, #30]
 8004d56:	f013 0f01 	tst.w	r3, #1
 8004d5a:	d03d      	beq.n	8004dd8 <ip_reass+0x2a0>
    if (valid) {
 8004d5c:	f1be 0f00 	cmp.w	lr, #0
 8004d60:	d03a      	beq.n	8004dd8 <ip_reass+0x2a0>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
 8004d62:	6860      	ldr	r0, [r4, #4]
 8004d64:	6843      	ldr	r3, [r0, #4]
 8004d66:	889b      	ldrh	r3, [r3, #4]
 8004d68:	2b00      	cmp	r3, #0
 8004d6a:	d135      	bne.n	8004dd8 <ip_reass+0x2a0>
        q = iprh->next_pbuf;
 8004d6c:	f8d8 3000 	ldr.w	r3, [r8]
        while (q != NULL) {
 8004d70:	2b00      	cmp	r3, #0
 8004d72:	d051      	beq.n	8004e18 <ip_reass+0x2e0>
          iprh = (struct ip_reass_helper*)q->payload;
 8004d74:	685b      	ldr	r3, [r3, #4]
          if (iprh_prev->end != iprh->start) {
 8004d76:	8899      	ldrh	r1, [r3, #4]
 8004d78:	f8b8 2006 	ldrh.w	r2, [r8, #6]
 8004d7c:	4291      	cmp	r1, r2
 8004d7e:	d12b      	bne.n	8004dd8 <ip_reass+0x2a0>
          q = iprh->next_pbuf;
 8004d80:	681a      	ldr	r2, [r3, #0]
        while (q != NULL) {
 8004d82:	2a00      	cmp	r2, #0
 8004d84:	d048      	beq.n	8004e18 <ip_reass+0x2e0>
          iprh = (struct ip_reass_helper*)q->payload;
 8004d86:	6852      	ldr	r2, [r2, #4]
          if (iprh_prev->end != iprh->start) {
 8004d88:	88d9      	ldrh	r1, [r3, #6]
 8004d8a:	8893      	ldrh	r3, [r2, #4]
 8004d8c:	4299      	cmp	r1, r3
 8004d8e:	d123      	bne.n	8004dd8 <ip_reass+0x2a0>
          iprh = (struct ip_reass_helper*)q->payload;
 8004d90:	4613      	mov	r3, r2
 8004d92:	e7f5      	b.n	8004d80 <ip_reass+0x248>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 8004d94:	4613      	mov	r3, r2
    q = iprh_tmp->next_pbuf;
 8004d96:	681e      	ldr	r6, [r3, #0]
  for (q = ipr->p; q != NULL;) {
 8004d98:	b376      	cbz	r6, 8004df8 <ip_reass+0x2c0>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 8004d9a:	6872      	ldr	r2, [r6, #4]
    if (iprh->start < iprh_tmp->start) {
 8004d9c:	8891      	ldrh	r1, [r2, #4]
 8004d9e:	4288      	cmp	r0, r1
 8004da0:	d3cd      	bcc.n	8004d3e <ip_reass+0x206>
    } else if(iprh->start == iprh_tmp->start) {
 8004da2:	4288      	cmp	r0, r1
 8004da4:	d00e      	beq.n	8004dc4 <ip_reass+0x28c>
    } else if(iprh->start < iprh_tmp->end) {
 8004da6:	88d6      	ldrh	r6, [r2, #6]
 8004da8:	4286      	cmp	r6, r0
 8004daa:	d80b      	bhi.n	8004dc4 <ip_reass+0x28c>
      if (iprh_prev != NULL) {
 8004dac:	2b00      	cmp	r3, #0
 8004dae:	d0f1      	beq.n	8004d94 <ip_reass+0x25c>
        if (iprh_prev->end != iprh_tmp->start) {
 8004db0:	88db      	ldrh	r3, [r3, #6]
          valid = 0;
 8004db2:	428b      	cmp	r3, r1
 8004db4:	bf18      	it	ne
 8004db6:	f04f 0e00 	movne.w	lr, #0
 8004dba:	e7eb      	b.n	8004d94 <ip_reass+0x25c>
  int valid = 1;
 8004dbc:	f04f 0e01 	mov.w	lr, #1
      ipr->p = new_p;
 8004dc0:	6067      	str	r7, [r4, #4]
 8004dc2:	e7c7      	b.n	8004d54 <ip_reass+0x21c>
  ip_reass_pbufcount -= pbuf_clen(new_p);
 8004dc4:	4638      	mov	r0, r7
 8004dc6:	f000 fd5e 	bl	8005886 <pbuf_clen>
 8004dca:	4a11      	ldr	r2, [pc, #68]	; (8004e10 <ip_reass+0x2d8>)
 8004dcc:	8813      	ldrh	r3, [r2, #0]
 8004dce:	1a18      	subs	r0, r3, r0
 8004dd0:	8010      	strh	r0, [r2, #0]
  pbuf_free(new_p);
 8004dd2:	4638      	mov	r0, r7
 8004dd4:	f000 fc65 	bl	80056a2 <pbuf_free>
  return NULL;
 8004dd8:	f04f 0800 	mov.w	r8, #0
}
 8004ddc:	4640      	mov	r0, r8
 8004dde:	b003      	add	sp, #12
 8004de0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    reassdatagrams = ipr->next;
 8004de4:	6822      	ldr	r2, [r4, #0]
 8004de6:	4b0b      	ldr	r3, [pc, #44]	; (8004e14 <ip_reass+0x2dc>)
 8004de8:	601a      	str	r2, [r3, #0]
 8004dea:	e04d      	b.n	8004e88 <ip_reass+0x350>
      iprh->next_pbuf = q;
 8004dec:	f8c8 2000 	str.w	r2, [r8]
  int valid = 1;
 8004df0:	f04f 0e01 	mov.w	lr, #1
        ipr->p = new_p;
 8004df4:	6067      	str	r7, [r4, #4]
 8004df6:	e7ad      	b.n	8004d54 <ip_reass+0x21c>
    if (iprh_prev != NULL) {
 8004df8:	2b00      	cmp	r3, #0
 8004dfa:	d0e1      	beq.n	8004dc0 <ip_reass+0x288>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 8004dfc:	88da      	ldrh	r2, [r3, #6]
      iprh_prev->next_pbuf = new_p;
 8004dfe:	601f      	str	r7, [r3, #0]
      if (iprh_prev->end != iprh->start) {
 8004e00:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8004e04:	4293      	cmp	r3, r2
 8004e06:	d1e7      	bne.n	8004dd8 <ip_reass+0x2a0>
 8004e08:	e7a4      	b.n	8004d54 <ip_reass+0x21c>
 8004e0a:	bf00      	nop
 8004e0c:	2000b084 	.word	0x2000b084
 8004e10:	20000df2 	.word	0x20000df2
 8004e14:	20000df4 	.word	0x20000df4
    ipr->datagram_len += IP_HLEN;
 8004e18:	8ba3      	ldrh	r3, [r4, #28]
 8004e1a:	3314      	adds	r3, #20
 8004e1c:	83a3      	strh	r3, [r4, #28]
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 8004e1e:	6847      	ldr	r7, [r0, #4]
 8004e20:	683e      	ldr	r6, [r7, #0]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 8004e22:	4623      	mov	r3, r4
 8004e24:	f853 2f08 	ldr.w	r2, [r3, #8]!
 8004e28:	f8d3 e004 	ldr.w	lr, [r3, #4]
 8004e2c:	6898      	ldr	r0, [r3, #8]
 8004e2e:	68d9      	ldr	r1, [r3, #12]
 8004e30:	603a      	str	r2, [r7, #0]
 8004e32:	f8c7 e004 	str.w	lr, [r7, #4]
 8004e36:	60b8      	str	r0, [r7, #8]
 8004e38:	60f9      	str	r1, [r7, #12]
 8004e3a:	691a      	ldr	r2, [r3, #16]
 8004e3c:	613a      	str	r2, [r7, #16]
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 8004e3e:	8ba0      	ldrh	r0, [r4, #28]
 8004e40:	f7ff f9b4 	bl	80041ac <lwip_htons>
 8004e44:	8078      	strh	r0, [r7, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 8004e46:	2300      	movs	r3, #0
 8004e48:	71bb      	strb	r3, [r7, #6]
 8004e4a:	71fb      	strb	r3, [r7, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 8004e4c:	72bb      	strb	r3, [r7, #10]
 8004e4e:	72fb      	strb	r3, [r7, #11]
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 8004e50:	2114      	movs	r1, #20
 8004e52:	4638      	mov	r0, r7
 8004e54:	f7ff fb8b 	bl	800456e <inet_chksum>
 8004e58:	8178      	strh	r0, [r7, #10]
    p = ipr->p;
 8004e5a:	f8d4 8004 	ldr.w	r8, [r4, #4]
      pbuf_header(r, -IP_HLEN);
 8004e5e:	f06f 0913 	mvn.w	r9, #19
    while(r != NULL) {
 8004e62:	b15e      	cbz	r6, 8004e7c <ip_reass+0x344>
      iprh = (struct ip_reass_helper*)r->payload;
 8004e64:	6877      	ldr	r7, [r6, #4]
      pbuf_header(r, -IP_HLEN);
 8004e66:	4649      	mov	r1, r9
 8004e68:	4630      	mov	r0, r6
 8004e6a:	f000 fbdc 	bl	8005626 <pbuf_header>
      pbuf_cat(p, r);
 8004e6e:	4631      	mov	r1, r6
 8004e70:	4640      	mov	r0, r8
 8004e72:	f000 fd18 	bl	80058a6 <pbuf_cat>
      r = iprh->next_pbuf;
 8004e76:	683e      	ldr	r6, [r7, #0]
    while(r != NULL) {
 8004e78:	2e00      	cmp	r6, #0
 8004e7a:	d1f3      	bne.n	8004e64 <ip_reass+0x32c>
  if (reassdatagrams == ipr) {
 8004e7c:	4b08      	ldr	r3, [pc, #32]	; (8004ea0 <ip_reass+0x368>)
 8004e7e:	681b      	ldr	r3, [r3, #0]
 8004e80:	429c      	cmp	r4, r3
 8004e82:	d0af      	beq.n	8004de4 <ip_reass+0x2ac>
    prev->next = ipr->next;
 8004e84:	6823      	ldr	r3, [r4, #0]
 8004e86:	602b      	str	r3, [r5, #0]
  memp_free(MEMP_REASSDATA, ipr);
 8004e88:	4621      	mov	r1, r4
 8004e8a:	2005      	movs	r0, #5
 8004e8c:	f000 fb12 	bl	80054b4 <memp_free>
    ip_reass_pbufcount -= pbuf_clen(p);
 8004e90:	4640      	mov	r0, r8
 8004e92:	f000 fcf8 	bl	8005886 <pbuf_clen>
 8004e96:	4a03      	ldr	r2, [pc, #12]	; (8004ea4 <ip_reass+0x36c>)
 8004e98:	8813      	ldrh	r3, [r2, #0]
 8004e9a:	1a18      	subs	r0, r3, r0
 8004e9c:	8010      	strh	r0, [r2, #0]
    return p;
 8004e9e:	e79d      	b.n	8004ddc <ip_reass+0x2a4>
 8004ea0:	20000df4 	.word	0x20000df4
 8004ea4:	20000df2 	.word	0x20000df2

08004ea8 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 8004ea8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004eac:	b08d      	sub	sp, #52	; 0x34
 8004eae:	4604      	mov	r4, r0
 8004eb0:	9109      	str	r1, [sp, #36]	; 0x24
 8004eb2:	920a      	str	r2, [sp, #40]	; 0x28
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
 8004eb4:	8c0d      	ldrh	r5, [r1, #32]

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
#else /* IP_FRAG_USES_STATIC_BUF */
  original_iphdr = (struct ip_hdr *)p->payload;
 8004eb6:	f8d0 8004 	ldr.w	r8, [r0, #4]
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 8004eba:	f8b8 0006 	ldrh.w	r0, [r8, #6]
 8004ebe:	f7ff f97a 	bl	80041b6 <lwip_ntohs>
  ofo = tmp & IP_OFFMASK;
 8004ec2:	f3c0 030c 	ubfx	r3, r0, #0, #13
 8004ec6:	9303      	str	r3, [sp, #12]
  omf = tmp & IP_MF;
 8004ec8:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
 8004ecc:	9307      	str	r3, [sp, #28]

  left = p->tot_len - IP_HLEN;
 8004ece:	f8b4 9008 	ldrh.w	r9, [r4, #8]
 8004ed2:	f1a9 0914 	sub.w	r9, r9, #20
 8004ed6:	fa1f f989 	uxth.w	r9, r9

  nfb = (mtu - IP_HLEN) / 8;
 8004eda:	f1a5 0314 	sub.w	r3, r5, #20
 8004ede:	9306      	str	r3, [sp, #24]
 8004ee0:	2b00      	cmp	r3, #0
 8004ee2:	bfb8      	it	lt
 8004ee4:	3307      	addlt	r3, #7
 8004ee6:	f3c3 03cf 	ubfx	r3, r3, #3, #16
 8004eea:	9308      	str	r3, [sp, #32]

  while (left) {
 8004eec:	f1b9 0f00 	cmp.w	r9, #0
 8004ef0:	f000 80af 	beq.w	8005052 <ip_frag+0x1aa>
    if (!last) {
      tmp = tmp | IP_MF;
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 8004ef4:	00db      	lsls	r3, r3, #3
 8004ef6:	b29b      	uxth	r3, r3
 8004ef8:	930b      	str	r3, [sp, #44]	; 0x2c
 8004efa:	2600      	movs	r6, #0
 8004efc:	2514      	movs	r5, #20
 8004efe:	e084      	b.n	800500a <ip_frag+0x162>
 8004f00:	f8cd 9010 	str.w	r9, [sp, #16]
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 8004f04:	2200      	movs	r2, #0
 8004f06:	2114      	movs	r1, #20
 8004f08:	2002      	movs	r0, #2
 8004f0a:	f000 fbf9 	bl	8005700 <pbuf_alloc>
    if (rambuf == NULL) {
 8004f0e:	4682      	mov	sl, r0
 8004f10:	2800      	cmp	r0, #0
 8004f12:	f000 80a0 	beq.w	8005056 <ip_frag+0x1ae>
      return ERR_MEM;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 8004f16:	6843      	ldr	r3, [r0, #4]
 8004f18:	f8d8 2000 	ldr.w	r2, [r8]
 8004f1c:	f8d8 7004 	ldr.w	r7, [r8, #4]
 8004f20:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8004f24:	f8d8 100c 	ldr.w	r1, [r8, #12]
 8004f28:	601a      	str	r2, [r3, #0]
 8004f2a:	605f      	str	r7, [r3, #4]
 8004f2c:	6098      	str	r0, [r3, #8]
 8004f2e:	60d9      	str	r1, [r3, #12]
 8004f30:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8004f34:	611a      	str	r2, [r3, #16]
    iphdr = (struct ip_hdr *)rambuf->payload;
 8004f36:	f8da b004 	ldr.w	fp, [sl, #4]

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
 8004f3a:	6863      	ldr	r3, [r4, #4]
 8004f3c:	442b      	add	r3, r5
 8004f3e:	6063      	str	r3, [r4, #4]
    p->len -= poff;
 8004f40:	8963      	ldrh	r3, [r4, #10]
 8004f42:	1b5d      	subs	r5, r3, r5
 8004f44:	8165      	strh	r5, [r4, #10]

    left_to_copy = cop;
    while (left_to_copy) {
 8004f46:	9b04      	ldr	r3, [sp, #16]
 8004f48:	2b00      	cmp	r3, #0
 8004f4a:	d02c      	beq.n	8004fa6 <ip_frag+0xfe>
 8004f4c:	461d      	mov	r5, r3
 8004f4e:	e01f      	b.n	8004f90 <ip_frag+0xe8>
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 8004f50:	2006      	movs	r0, #6
 8004f52:	f000 fa79 	bl	8005448 <memp_malloc>
      if (!newpbuflen) {
        p = p->next;
        continue;
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
      if (pcr == NULL) {
 8004f56:	4607      	mov	r7, r0
 8004f58:	2800      	cmp	r0, #0
 8004f5a:	d066      	beq.n	800502a <ip_frag+0x182>
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
 8004f5c:	9601      	str	r6, [sp, #4]
 8004f5e:	6863      	ldr	r3, [r4, #4]
 8004f60:	9300      	str	r3, [sp, #0]
 8004f62:	4603      	mov	r3, r0
 8004f64:	2202      	movs	r2, #2
 8004f66:	4631      	mov	r1, r6
 8004f68:	2003      	movs	r0, #3
 8004f6a:	f000 fb2d 	bl	80055c8 <pbuf_alloced_custom>
      if (newpbuf == NULL) {
 8004f6e:	9002      	str	r0, [sp, #8]
 8004f70:	2800      	cmp	r0, #0
 8004f72:	d062      	beq.n	800503a <ip_frag+0x192>
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        return ERR_MEM;
      }
      pbuf_ref(p);
 8004f74:	4620      	mov	r0, r4
 8004f76:	f000 fc91 	bl	800589c <pbuf_ref>
      pcr->original = p;
 8004f7a:	617c      	str	r4, [r7, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 8004f7c:	4b37      	ldr	r3, [pc, #220]	; (800505c <ip_frag+0x1b4>)
 8004f7e:	613b      	str	r3, [r7, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 8004f80:	9902      	ldr	r1, [sp, #8]
 8004f82:	4650      	mov	r0, sl
 8004f84:	f000 fc8f 	bl	80058a6 <pbuf_cat>
      left_to_copy -= newpbuflen;
 8004f88:	1bad      	subs	r5, r5, r6
 8004f8a:	b2ad      	uxth	r5, r5
      if (left_to_copy) {
 8004f8c:	b15d      	cbz	r5, 8004fa6 <ip_frag+0xfe>
        p = p->next;
 8004f8e:	6824      	ldr	r4, [r4, #0]
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
 8004f90:	8966      	ldrh	r6, [r4, #10]
 8004f92:	42ae      	cmp	r6, r5
 8004f94:	bf28      	it	cs
 8004f96:	462e      	movcs	r6, r5
 8004f98:	b2b6      	uxth	r6, r6
      if (!newpbuflen) {
 8004f9a:	2e00      	cmp	r6, #0
 8004f9c:	d1d8      	bne.n	8004f50 <ip_frag+0xa8>
        p = p->next;
 8004f9e:	6824      	ldr	r4, [r4, #0]
    while (left_to_copy) {
 8004fa0:	2d00      	cmp	r5, #0
 8004fa2:	d1f5      	bne.n	8004f90 <ip_frag+0xe8>
 8004fa4:	462e      	mov	r6, r5
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 8004fa6:	9805      	ldr	r0, [sp, #20]
 8004fa8:	f7ff f900 	bl	80041ac <lwip_htons>
 8004fac:	f8ab 0006 	strh.w	r0, [fp, #6]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 8004fb0:	9d04      	ldr	r5, [sp, #16]
 8004fb2:	f105 0014 	add.w	r0, r5, #20
 8004fb6:	b280      	uxth	r0, r0
 8004fb8:	f7ff f8f8 	bl	80041ac <lwip_htons>
 8004fbc:	f8ab 0002 	strh.w	r0, [fp, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 8004fc0:	2300      	movs	r3, #0
 8004fc2:	f88b 300a 	strb.w	r3, [fp, #10]
 8004fc6:	f88b 300b 	strb.w	r3, [fp, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 8004fca:	2114      	movs	r1, #20
 8004fcc:	4658      	mov	r0, fp
 8004fce:	f7ff face 	bl	800456e <inet_chksum>
 8004fd2:	f8ab 000a 	strh.w	r0, [fp, #10]
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
 8004fd6:	9809      	ldr	r0, [sp, #36]	; 0x24
 8004fd8:	6943      	ldr	r3, [r0, #20]
 8004fda:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8004fdc:	4651      	mov	r1, sl
 8004fde:	4798      	blx	r3
    IPFRAG_STATS_INC(ip_frag.xmit);
 8004fe0:	4b1f      	ldr	r3, [pc, #124]	; (8005060 <ip_frag+0x1b8>)
 8004fe2:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8004fe4:	3301      	adds	r3, #1
 8004fe6:	4a1e      	ldr	r2, [pc, #120]	; (8005060 <ip_frag+0x1b8>)
 8004fe8:	8613      	strh	r3, [r2, #48]	; 0x30
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
 8004fea:	4650      	mov	r0, sl
 8004fec:	f000 fb59 	bl	80056a2 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 8004ff0:	eba9 0305 	sub.w	r3, r9, r5
 8004ff4:	fa1f f983 	uxth.w	r9, r3
    ofo += nfb;
 8004ff8:	9b03      	ldr	r3, [sp, #12]
 8004ffa:	9a08      	ldr	r2, [sp, #32]
 8004ffc:	4413      	add	r3, r2
 8004ffe:	b29b      	uxth	r3, r3
 8005000:	9303      	str	r3, [sp, #12]
 8005002:	4635      	mov	r5, r6
  while (left) {
 8005004:	f1b9 0f00 	cmp.w	r9, #0
 8005008:	d021      	beq.n	800504e <ip_frag+0x1a6>
    tmp = omf | (IP_OFFMASK & (ofo));
 800500a:	9b03      	ldr	r3, [sp, #12]
 800500c:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8005010:	9a07      	ldr	r2, [sp, #28]
 8005012:	4313      	orrs	r3, r2
 8005014:	9305      	str	r3, [sp, #20]
    if (!last) {
 8005016:	9a06      	ldr	r2, [sp, #24]
 8005018:	454a      	cmp	r2, r9
 800501a:	f6bf af71 	bge.w	8004f00 <ip_frag+0x58>
      tmp = tmp | IP_MF;
 800501e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8005022:	9305      	str	r3, [sp, #20]
    cop = last ? left : nfb * 8;
 8005024:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005026:	9304      	str	r3, [sp, #16]
 8005028:	e76c      	b.n	8004f04 <ip_frag+0x5c>
 800502a:	4650      	mov	r0, sl
        pbuf_free(rambuf);
 800502c:	f000 fb39 	bl	80056a2 <pbuf_free>
        return ERR_MEM;
 8005030:	f04f 30ff 	mov.w	r0, #4294967295
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
 8005034:	b00d      	add	sp, #52	; 0x34
 8005036:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  memp_free(MEMP_FRAG_PBUF, p);
 800503a:	4639      	mov	r1, r7
 800503c:	2006      	movs	r0, #6
 800503e:	f000 fa39 	bl	80054b4 <memp_free>
        pbuf_free(rambuf);
 8005042:	4650      	mov	r0, sl
 8005044:	f000 fb2d 	bl	80056a2 <pbuf_free>
        return ERR_MEM;
 8005048:	f04f 30ff 	mov.w	r0, #4294967295
 800504c:	e7f2      	b.n	8005034 <ip_frag+0x18c>
  return ERR_OK;
 800504e:	2000      	movs	r0, #0
 8005050:	e7f0      	b.n	8005034 <ip_frag+0x18c>
 8005052:	2000      	movs	r0, #0
 8005054:	e7ee      	b.n	8005034 <ip_frag+0x18c>
      return ERR_MEM;
 8005056:	f04f 30ff 	mov.w	r0, #4294967295
 800505a:	e7eb      	b.n	8005034 <ip_frag+0x18c>
 800505c:	08004af1 	.word	0x08004af1
 8005060:	2000b084 	.word	0x2000b084

08005064 <mem_init>:

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8005064:	4b0b      	ldr	r3, [pc, #44]	; (8005094 <mem_init+0x30>)
 8005066:	f023 0303 	bic.w	r3, r3, #3
 800506a:	4a0b      	ldr	r2, [pc, #44]	; (8005098 <mem_init+0x34>)
 800506c:	6013      	str	r3, [r2, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 800506e:	f242 7210 	movw	r2, #10000	; 0x2710
 8005072:	801a      	strh	r2, [r3, #0]
  mem->prev = 0;
 8005074:	2100      	movs	r1, #0
 8005076:	8059      	strh	r1, [r3, #2]
  mem->used = 0;
 8005078:	7119      	strb	r1, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 800507a:	1899      	adds	r1, r3, r2
 800507c:	4807      	ldr	r0, [pc, #28]	; (800509c <mem_init+0x38>)
 800507e:	6001      	str	r1, [r0, #0]
  ram_end->used = 1;
 8005080:	2001      	movs	r0, #1
 8005082:	7108      	strb	r0, [r1, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 8005084:	529a      	strh	r2, [r3, r2]
  ram_end->prev = MEM_SIZE_ALIGNED;
 8005086:	804a      	strh	r2, [r1, #2]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 8005088:	4905      	ldr	r1, [pc, #20]	; (80050a0 <mem_init+0x3c>)
 800508a:	600b      	str	r3, [r1, #0]

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
 800508c:	4b05      	ldr	r3, [pc, #20]	; (80050a4 <mem_init+0x40>)
 800508e:	f8a3 20a8 	strh.w	r2, [r3, #168]	; 0xa8
 8005092:	4770      	bx	lr
 8005094:	20008957 	.word	0x20008957
 8005098:	20000dfc 	.word	0x20000dfc
 800509c:	20000e00 	.word	0x20000e00
 80050a0:	20000df8 	.word	0x20000df8
 80050a4:	2000b084 	.word	0x2000b084

080050a8 <mem_free>:
mem_free(void *rmem)
{
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 80050a8:	2800      	cmp	r0, #0
 80050aa:	d050      	beq.n	800514e <mem_free+0xa6>
{
 80050ac:	b4f0      	push	{r4, r5, r6, r7}
 80050ae:	4603      	mov	r3, r0
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 80050b0:	4a27      	ldr	r2, [pc, #156]	; (8005150 <mem_free+0xa8>)
 80050b2:	6812      	ldr	r2, [r2, #0]
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 80050b4:	4290      	cmp	r0, r2
 80050b6:	d343      	bcc.n	8005140 <mem_free+0x98>
 80050b8:	4926      	ldr	r1, [pc, #152]	; (8005154 <mem_free+0xac>)
 80050ba:	680f      	ldr	r7, [r1, #0]
 80050bc:	42b8      	cmp	r0, r7
 80050be:	d23f      	bcs.n	8005140 <mem_free+0x98>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 80050c0:	f1a0 0108 	sub.w	r1, r0, #8
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 80050c4:	2000      	movs	r0, #0
 80050c6:	f803 0c04 	strb.w	r0, [r3, #-4]

  if (mem < lfree) {
 80050ca:	4823      	ldr	r0, [pc, #140]	; (8005158 <mem_free+0xb0>)
 80050cc:	6800      	ldr	r0, [r0, #0]
 80050ce:	4281      	cmp	r1, r0
    /* the newly freed struct is now the lowest */
    lfree = mem;
 80050d0:	bf3c      	itt	cc
 80050d2:	4821      	ldrcc	r0, [pc, #132]	; (8005158 <mem_free+0xb0>)
 80050d4:	6001      	strcc	r1, [r0, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
 80050d6:	1a8c      	subs	r4, r1, r2
 80050d8:	b2a4      	uxth	r4, r4
 80050da:	4d20      	ldr	r5, [pc, #128]	; (800515c <mem_free+0xb4>)
 80050dc:	f8b5 00aa 	ldrh.w	r0, [r5, #170]	; 0xaa
 80050e0:	f833 6c08 	ldrh.w	r6, [r3, #-8]
 80050e4:	1b80      	subs	r0, r0, r6
 80050e6:	4420      	add	r0, r4
 80050e8:	f8a5 00aa 	strh.w	r0, [r5, #170]	; 0xaa
  nmem = (struct mem *)(void *)&ram[mem->next];
 80050ec:	f833 5c08 	ldrh.w	r5, [r3, #-8]
 80050f0:	1950      	adds	r0, r2, r5
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 80050f2:	4281      	cmp	r1, r0
 80050f4:	d00f      	beq.n	8005116 <mem_free+0x6e>
 80050f6:	7906      	ldrb	r6, [r0, #4]
 80050f8:	b96e      	cbnz	r6, 8005116 <mem_free+0x6e>
 80050fa:	4287      	cmp	r7, r0
 80050fc:	d00b      	beq.n	8005116 <mem_free+0x6e>
    if (lfree == nmem) {
 80050fe:	4e16      	ldr	r6, [pc, #88]	; (8005158 <mem_free+0xb0>)
 8005100:	6836      	ldr	r6, [r6, #0]
 8005102:	42b0      	cmp	r0, r6
      lfree = mem;
 8005104:	bf04      	itt	eq
 8005106:	4814      	ldreq	r0, [pc, #80]	; (8005158 <mem_free+0xb0>)
 8005108:	6001      	streq	r1, [r0, #0]
    mem->next = nmem->next;
 800510a:	5b50      	ldrh	r0, [r2, r5]
 800510c:	f823 0c08 	strh.w	r0, [r3, #-8]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 8005110:	5b50      	ldrh	r0, [r2, r5]
 8005112:	4410      	add	r0, r2
 8005114:	8044      	strh	r4, [r0, #2]
  pmem = (struct mem *)(void *)&ram[mem->prev];
 8005116:	f833 0c06 	ldrh.w	r0, [r3, #-6]
 800511a:	1814      	adds	r4, r2, r0
  if (pmem != mem && pmem->used == 0) {
 800511c:	42a1      	cmp	r1, r4
 800511e:	d015      	beq.n	800514c <mem_free+0xa4>
 8005120:	7925      	ldrb	r5, [r4, #4]
 8005122:	b99d      	cbnz	r5, 800514c <mem_free+0xa4>
    if (lfree == mem) {
 8005124:	4d0c      	ldr	r5, [pc, #48]	; (8005158 <mem_free+0xb0>)
 8005126:	682d      	ldr	r5, [r5, #0]
 8005128:	42a9      	cmp	r1, r5
      lfree = pmem;
 800512a:	bf04      	itt	eq
 800512c:	490a      	ldreq	r1, [pc, #40]	; (8005158 <mem_free+0xb0>)
 800512e:	600c      	streq	r4, [r1, #0]
    pmem->next = mem->next;
 8005130:	f833 1c08 	ldrh.w	r1, [r3, #-8]
 8005134:	5211      	strh	r1, [r2, r0]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 8005136:	f833 3c08 	ldrh.w	r3, [r3, #-8]
 800513a:	441a      	add	r2, r3
 800513c:	8050      	strh	r0, [r2, #2]
 800513e:	e005      	b.n	800514c <mem_free+0xa4>
    MEM_STATS_INC(illegal);
 8005140:	4a06      	ldr	r2, [pc, #24]	; (800515c <mem_free+0xb4>)
 8005142:	f8b2 30b0 	ldrh.w	r3, [r2, #176]	; 0xb0
 8005146:	3301      	adds	r3, #1
 8005148:	f8a2 30b0 	strh.w	r3, [r2, #176]	; 0xb0
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 800514c:	bcf0      	pop	{r4, r5, r6, r7}
 800514e:	4770      	bx	lr
 8005150:	20000dfc 	.word	0x20000dfc
 8005154:	20000e00 	.word	0x20000e00
 8005158:	20000df8 	.word	0x20000df8
 800515c:	2000b084 	.word	0x2000b084

08005160 <mem_trim>:
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 8005160:	3103      	adds	r1, #3
 8005162:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 8005166:	400b      	ands	r3, r1
 8005168:	2b0c      	cmp	r3, #12
 800516a:	bf38      	it	cc
 800516c:	230c      	movcc	r3, #12
  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 800516e:	f242 7210 	movw	r2, #10000	; 0x2710
 8005172:	4293      	cmp	r3, r2
 8005174:	d86e      	bhi.n	8005254 <mem_trim+0xf4>
    return NULL;
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8005176:	4a39      	ldr	r2, [pc, #228]	; (800525c <mem_trim+0xfc>)
 8005178:	6812      	ldr	r2, [r2, #0]
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 800517a:	4282      	cmp	r2, r0
 800517c:	d837      	bhi.n	80051ee <mem_trim+0x8e>
 800517e:	4938      	ldr	r1, [pc, #224]	; (8005260 <mem_trim+0x100>)
 8005180:	6809      	ldr	r1, [r1, #0]
 8005182:	4288      	cmp	r0, r1
 8005184:	d233      	bcs.n	80051ee <mem_trim+0x8e>
{
 8005186:	b5f0      	push	{r4, r5, r6, r7, lr}
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8005188:	f1a0 0408 	sub.w	r4, r0, #8
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
 800518c:	1aa4      	subs	r4, r4, r2
 800518e:	b2a4      	uxth	r4, r4

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 8005190:	f830 5c08 	ldrh.w	r5, [r0, #-8]
 8005194:	f1a5 0108 	sub.w	r1, r5, #8
 8005198:	1b09      	subs	r1, r1, r4
 800519a:	b289      	uxth	r1, r1
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
  if (newsize > size) {
 800519c:	4299      	cmp	r1, r3
 800519e:	d35b      	bcc.n	8005258 <mem_trim+0xf8>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
 80051a0:	d05b      	beq.n	800525a <mem_trim+0xfa>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = (struct mem *)(void *)&ram[mem->next];
 80051a2:	1956      	adds	r6, r2, r5
  if(mem2->used == 0) {
 80051a4:	7937      	ldrb	r7, [r6, #4]
 80051a6:	bb7f      	cbnz	r7, 8005208 <mem_trim+0xa8>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
 80051a8:	5b57      	ldrh	r7, [r2, r5]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 80051aa:	f104 0508 	add.w	r5, r4, #8
 80051ae:	441d      	add	r5, r3
 80051b0:	b2ad      	uxth	r5, r5
    if (lfree == mem2) {
 80051b2:	f8df e0b4 	ldr.w	lr, [pc, #180]	; 8005268 <mem_trim+0x108>
 80051b6:	f8de e000 	ldr.w	lr, [lr]
 80051ba:	4576      	cmp	r6, lr
 80051bc:	d01e      	beq.n	80051fc <mem_trim+0x9c>
      lfree = (struct mem *)(void *)&ram[ptr2];
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
 80051be:	1956      	adds	r6, r2, r5
    mem2->used = 0;
 80051c0:	f04f 0e00 	mov.w	lr, #0
 80051c4:	f886 e004 	strb.w	lr, [r6, #4]
    /* restore the next pointer */
    mem2->next = next;
 80051c8:	5357      	strh	r7, [r2, r5]
    /* link it back to mem */
    mem2->prev = ptr;
 80051ca:	8074      	strh	r4, [r6, #2]
    /* link mem to it */
    mem->next = ptr2;
 80051cc:	f820 5c08 	strh.w	r5, [r0, #-8]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 80051d0:	5b54      	ldrh	r4, [r2, r5]
 80051d2:	f242 7610 	movw	r6, #10000	; 0x2710
 80051d6:	42b4      	cmp	r4, r6
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 80051d8:	bf1c      	itt	ne
 80051da:	1912      	addne	r2, r2, r4
 80051dc:	8055      	strhne	r5, [r2, #2]
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 80051de:	4c21      	ldr	r4, [pc, #132]	; (8005264 <mem_trim+0x104>)
 80051e0:	f8b4 20aa 	ldrh.w	r2, [r4, #170]	; 0xaa
 80051e4:	4413      	add	r3, r2
 80051e6:	1a5b      	subs	r3, r3, r1
 80051e8:	f8a4 30aa 	strh.w	r3, [r4, #170]	; 0xaa
 80051ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
    MEM_STATS_INC(illegal);
 80051ee:	4a1d      	ldr	r2, [pc, #116]	; (8005264 <mem_trim+0x104>)
 80051f0:	f8b2 30b0 	ldrh.w	r3, [r2, #176]	; 0xb0
 80051f4:	3301      	adds	r3, #1
 80051f6:	f8a2 30b0 	strh.w	r3, [r2, #176]	; 0xb0
    return rmem;
 80051fa:	4770      	bx	lr
      lfree = (struct mem *)(void *)&ram[ptr2];
 80051fc:	1956      	adds	r6, r2, r5
 80051fe:	f8df e068 	ldr.w	lr, [pc, #104]	; 8005268 <mem_trim+0x108>
 8005202:	f8ce 6000 	str.w	r6, [lr]
 8005206:	e7da      	b.n	80051be <mem_trim+0x5e>
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 8005208:	f103 0514 	add.w	r5, r3, #20
 800520c:	428d      	cmp	r5, r1
 800520e:	d824      	bhi.n	800525a <mem_trim+0xfa>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8005210:	f104 0508 	add.w	r5, r4, #8
 8005214:	441d      	add	r5, r3
 8005216:	b2ad      	uxth	r5, r5
    mem2 = (struct mem *)(void *)&ram[ptr2];
 8005218:	1956      	adds	r6, r2, r5
    if (mem2 < lfree) {
 800521a:	4f13      	ldr	r7, [pc, #76]	; (8005268 <mem_trim+0x108>)
 800521c:	683f      	ldr	r7, [r7, #0]
 800521e:	42be      	cmp	r6, r7
      lfree = mem2;
 8005220:	bf3c      	itt	cc
 8005222:	4f11      	ldrcc	r7, [pc, #68]	; (8005268 <mem_trim+0x108>)
 8005224:	603e      	strcc	r6, [r7, #0]
    }
    mem2->used = 0;
 8005226:	2700      	movs	r7, #0
 8005228:	7137      	strb	r7, [r6, #4]
    mem2->next = mem->next;
 800522a:	f830 7c08 	ldrh.w	r7, [r0, #-8]
 800522e:	5357      	strh	r7, [r2, r5]
    mem2->prev = ptr;
 8005230:	8074      	strh	r4, [r6, #2]
    mem->next = ptr2;
 8005232:	f820 5c08 	strh.w	r5, [r0, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8005236:	5b54      	ldrh	r4, [r2, r5]
 8005238:	f242 7610 	movw	r6, #10000	; 0x2710
 800523c:	42b4      	cmp	r4, r6
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 800523e:	bf1c      	itt	ne
 8005240:	1912      	addne	r2, r2, r4
 8005242:	8055      	strhne	r5, [r2, #2]
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 8005244:	4a07      	ldr	r2, [pc, #28]	; (8005264 <mem_trim+0x104>)
 8005246:	f8b2 40aa 	ldrh.w	r4, [r2, #170]	; 0xaa
 800524a:	4423      	add	r3, r4
 800524c:	1a5b      	subs	r3, r3, r1
 800524e:	f8a2 30aa 	strh.w	r3, [r2, #170]	; 0xaa
 8005252:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NULL;
 8005254:	2000      	movs	r0, #0
 8005256:	4770      	bx	lr
    return NULL;
 8005258:	2000      	movs	r0, #0
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
 800525a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800525c:	20000dfc 	.word	0x20000dfc
 8005260:	20000e00 	.word	0x20000e00
 8005264:	2000b084 	.word	0x2000b084
 8005268:	20000df8 	.word	0x20000df8

0800526c <mem_malloc>:
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 800526c:	2800      	cmp	r0, #0
 800526e:	f000 808f 	beq.w	8005390 <mem_malloc+0x124>
{
 8005272:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005274:	4602      	mov	r2, r0
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 8005276:	3203      	adds	r2, #3
 8005278:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 800527c:	4013      	ands	r3, r2
 800527e:	2b0c      	cmp	r3, #12
 8005280:	bf38      	it	cc
 8005282:	230c      	movcc	r3, #12
 8005284:	469e      	mov	lr, r3
  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
 8005286:	f242 7310 	movw	r3, #10000	; 0x2710
 800528a:	459e      	cmp	lr, r3
 800528c:	f200 8082 	bhi.w	8005394 <mem_malloc+0x128>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8005290:	4b41      	ldr	r3, [pc, #260]	; (8005398 <mem_malloc+0x12c>)
 8005292:	f8d3 c000 	ldr.w	ip, [r3]
 8005296:	4b41      	ldr	r3, [pc, #260]	; (800539c <mem_malloc+0x130>)
 8005298:	681a      	ldr	r2, [r3, #0]
 800529a:	eba2 020c 	sub.w	r2, r2, ip
 800529e:	b293      	uxth	r3, r2
 80052a0:	f5ce 511c 	rsb	r1, lr, #9984	; 0x2700
 80052a4:	3110      	adds	r1, #16
 80052a6:	428b      	cmp	r3, r1
 80052a8:	da6a      	bge.n	8005380 <mem_malloc+0x114>
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 80052aa:	f06f 0607 	mvn.w	r6, #7
 80052ae:	4675      	mov	r5, lr
 80052b0:	e030      	b.n	8005314 <mem_malloc+0xa8>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 80052b2:	2201      	movs	r2, #1
 80052b4:	7102      	strb	r2, [r0, #4]
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
 80052b6:	4a3a      	ldr	r2, [pc, #232]	; (80053a0 <mem_malloc+0x134>)
 80052b8:	f8b2 10aa 	ldrh.w	r1, [r2, #170]	; 0xaa
 80052bc:	440c      	add	r4, r1
 80052be:	1ae3      	subs	r3, r4, r3
 80052c0:	b29b      	uxth	r3, r3
 80052c2:	f8a2 30aa 	strh.w	r3, [r2, #170]	; 0xaa
 80052c6:	f8b2 20ac 	ldrh.w	r2, [r2, #172]	; 0xac
 80052ca:	429a      	cmp	r2, r3
 80052cc:	bf3c      	itt	cc
 80052ce:	4a34      	ldrcc	r2, [pc, #208]	; (80053a0 <mem_malloc+0x134>)
 80052d0:	f8a2 30ac 	strhcc.w	r3, [r2, #172]	; 0xac
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 80052d4:	4b31      	ldr	r3, [pc, #196]	; (800539c <mem_malloc+0x130>)
 80052d6:	681b      	ldr	r3, [r3, #0]
 80052d8:	4298      	cmp	r0, r3
 80052da:	d001      	beq.n	80052e0 <mem_malloc+0x74>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 80052dc:	3008      	adds	r0, #8
 80052de:	bdf0      	pop	{r4, r5, r6, r7, pc}
          while (cur->used && cur != ram_end) {
 80052e0:	7903      	ldrb	r3, [r0, #4]
 80052e2:	b183      	cbz	r3, 8005306 <mem_malloc+0x9a>
 80052e4:	4b2f      	ldr	r3, [pc, #188]	; (80053a4 <mem_malloc+0x138>)
 80052e6:	6819      	ldr	r1, [r3, #0]
 80052e8:	4288      	cmp	r0, r1
 80052ea:	d00e      	beq.n	800530a <mem_malloc+0x9e>
            cur = (struct mem *)(void *)&ram[cur->next];
 80052ec:	4b2a      	ldr	r3, [pc, #168]	; (8005398 <mem_malloc+0x12c>)
 80052ee:	681c      	ldr	r4, [r3, #0]
 80052f0:	4603      	mov	r3, r0
 80052f2:	881b      	ldrh	r3, [r3, #0]
 80052f4:	4423      	add	r3, r4
          while (cur->used && cur != ram_end) {
 80052f6:	791a      	ldrb	r2, [r3, #4]
 80052f8:	b112      	cbz	r2, 8005300 <mem_malloc+0x94>
 80052fa:	428b      	cmp	r3, r1
 80052fc:	d1f9      	bne.n	80052f2 <mem_malloc+0x86>
            cur = (struct mem *)(void *)&ram[cur->next];
 80052fe:	460b      	mov	r3, r1
          lfree = cur;
 8005300:	4a26      	ldr	r2, [pc, #152]	; (800539c <mem_malloc+0x130>)
 8005302:	6013      	str	r3, [r2, #0]
 8005304:	e7ea      	b.n	80052dc <mem_malloc+0x70>
      mem = (struct mem *)(void *)&ram[ptr];
 8005306:	4603      	mov	r3, r0
 8005308:	e7fa      	b.n	8005300 <mem_malloc+0x94>
 800530a:	4603      	mov	r3, r0
 800530c:	e7f8      	b.n	8005300 <mem_malloc+0x94>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 800530e:	8803      	ldrh	r3, [r0, #0]
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8005310:	428b      	cmp	r3, r1
 8005312:	da35      	bge.n	8005380 <mem_malloc+0x114>
      mem = (struct mem *)(void *)&ram[ptr];
 8005314:	eb0c 0003 	add.w	r0, ip, r3
      if ((!mem->used) &&
 8005318:	7902      	ldrb	r2, [r0, #4]
 800531a:	2a00      	cmp	r2, #0
 800531c:	d1f7      	bne.n	800530e <mem_malloc+0xa2>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 800531e:	f83c 4003 	ldrh.w	r4, [ip, r3]
 8005322:	1af2      	subs	r2, r6, r3
 8005324:	4422      	add	r2, r4
 8005326:	462f      	mov	r7, r5
      if ((!mem->used) &&
 8005328:	4572      	cmp	r2, lr
 800532a:	d3f0      	bcc.n	800530e <mem_malloc+0xa2>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 800532c:	3714      	adds	r7, #20
 800532e:	42ba      	cmp	r2, r7
 8005330:	d3bf      	bcc.n	80052b2 <mem_malloc+0x46>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 8005332:	f10e 0208 	add.w	r2, lr, #8
 8005336:	441a      	add	r2, r3
 8005338:	b292      	uxth	r2, r2
          mem2 = (struct mem *)(void *)&ram[ptr2];
 800533a:	eb0c 0102 	add.w	r1, ip, r2
          mem2->used = 0;
 800533e:	2400      	movs	r4, #0
 8005340:	710c      	strb	r4, [r1, #4]
          mem2->next = mem->next;
 8005342:	8804      	ldrh	r4, [r0, #0]
 8005344:	f82c 4002 	strh.w	r4, [ip, r2]
          mem2->prev = ptr;
 8005348:	804b      	strh	r3, [r1, #2]
          mem->next = ptr2;
 800534a:	8002      	strh	r2, [r0, #0]
          mem->used = 1;
 800534c:	2301      	movs	r3, #1
 800534e:	7103      	strb	r3, [r0, #4]
          if (mem2->next != MEM_SIZE_ALIGNED) {
 8005350:	f83c 3002 	ldrh.w	r3, [ip, r2]
 8005354:	f242 7110 	movw	r1, #10000	; 0x2710
 8005358:	428b      	cmp	r3, r1
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 800535a:	bf1c      	itt	ne
 800535c:	4463      	addne	r3, ip
 800535e:	805a      	strhne	r2, [r3, #2]
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
 8005360:	4a0f      	ldr	r2, [pc, #60]	; (80053a0 <mem_malloc+0x134>)
 8005362:	f8b2 30aa 	ldrh.w	r3, [r2, #170]	; 0xaa
 8005366:	3308      	adds	r3, #8
 8005368:	4473      	add	r3, lr
 800536a:	b29b      	uxth	r3, r3
 800536c:	f8a2 30aa 	strh.w	r3, [r2, #170]	; 0xaa
 8005370:	f8b2 20ac 	ldrh.w	r2, [r2, #172]	; 0xac
 8005374:	429a      	cmp	r2, r3
 8005376:	d2ad      	bcs.n	80052d4 <mem_malloc+0x68>
 8005378:	4a09      	ldr	r2, [pc, #36]	; (80053a0 <mem_malloc+0x134>)
 800537a:	f8a2 30ac 	strh.w	r3, [r2, #172]	; 0xac
 800537e:	e7a9      	b.n	80052d4 <mem_malloc+0x68>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
 8005380:	4a07      	ldr	r2, [pc, #28]	; (80053a0 <mem_malloc+0x134>)
 8005382:	f8b2 30ae 	ldrh.w	r3, [r2, #174]	; 0xae
 8005386:	3301      	adds	r3, #1
 8005388:	f8a2 30ae 	strh.w	r3, [r2, #174]	; 0xae
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
 800538c:	2000      	movs	r0, #0
 800538e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NULL;
 8005390:	2000      	movs	r0, #0
 8005392:	4770      	bx	lr
    return NULL;
 8005394:	2000      	movs	r0, #0
}
 8005396:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005398:	20000dfc 	.word	0x20000dfc
 800539c:	20000df8 	.word	0x20000df8
 80053a0:	2000b084 	.word	0x2000b084
 80053a4:	20000e00 	.word	0x20000e00

080053a8 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 80053a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80053ac:	4b21      	ldr	r3, [pc, #132]	; (8005434 <memp_init+0x8c>)
 80053ae:	f8df c090 	ldr.w	ip, [pc, #144]	; 8005440 <memp_init+0x98>
 80053b2:	f103 0464 	add.w	r4, r3, #100	; 0x64
 80053b6:	4661      	mov	r1, ip
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    MEMP_STATS_AVAIL(used, i, 0);
 80053b8:	2200      	movs	r2, #0
 80053ba:	f8a3 20b4 	strh.w	r2, [r3, #180]	; 0xb4
    MEMP_STATS_AVAIL(max, i, 0);
 80053be:	f8a3 20b6 	strh.w	r2, [r3, #182]	; 0xb6
    MEMP_STATS_AVAIL(err, i, 0);
 80053c2:	f8a3 20b8 	strh.w	r2, [r3, #184]	; 0xb8
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
 80053c6:	f831 0b02 	ldrh.w	r0, [r1], #2
 80053ca:	f8a3 00b2 	strh.w	r0, [r3, #178]	; 0xb2
 80053ce:	330a      	adds	r3, #10
  for (i = 0; i < MEMP_MAX; ++i) {
 80053d0:	42a3      	cmp	r3, r4
 80053d2:	d1f2      	bne.n	80053ba <memp_init+0x12>
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
 80053d4:	4f18      	ldr	r7, [pc, #96]	; (8005438 <memp_init+0x90>)
 80053d6:	f027 0703 	bic.w	r7, r7, #3
 80053da:	4e18      	ldr	r6, [pc, #96]	; (800543c <memp_init+0x94>)
 80053dc:	f8df e064 	ldr.w	lr, [pc, #100]	; 8005444 <memp_init+0x9c>
 80053e0:	f106 0a28 	add.w	sl, r6, #40	; 0x28
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
 80053e4:	f04f 0900 	mov.w	r9, #0
 80053e8:	e015      	b.n	8005416 <memp_init+0x6e>
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 80053ea:	4603      	mov	r3, r0
      memp->next = memp_tab[i];
 80053ec:	6019      	str	r1, [r3, #0]
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 80053ee:	1958      	adds	r0, r3, r5
 80053f0:	3201      	adds	r2, #1
      memp_tab[i] = memp;
 80053f2:	4619      	mov	r1, r3
    for (j = 0; j < memp_num[i]; ++j) {
 80053f4:	b293      	uxth	r3, r2
 80053f6:	42a3      	cmp	r3, r4
 80053f8:	d3f7      	bcc.n	80053ea <memp_init+0x42>
 80053fa:	3c01      	subs	r4, #1
 80053fc:	b2a4      	uxth	r4, r4
 80053fe:	fb04 5305 	mla	r3, r4, r5, r5
 8005402:	fb04 7405 	mla	r4, r4, r5, r7
 8005406:	f8c8 4000 	str.w	r4, [r8]
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 800540a:	441f      	add	r7, r3
 800540c:	3604      	adds	r6, #4
 800540e:	f10e 0e02 	add.w	lr, lr, #2
  for (i = 0; i < MEMP_MAX; ++i) {
 8005412:	4556      	cmp	r6, sl
 8005414:	d00c      	beq.n	8005430 <memp_init+0x88>
 8005416:	46b0      	mov	r8, r6
    memp_tab[i] = NULL;
 8005418:	f8c6 9000 	str.w	r9, [r6]
    for (j = 0; j < memp_num[i]; ++j) {
 800541c:	f83c 4b02 	ldrh.w	r4, [ip], #2
 8005420:	2c00      	cmp	r4, #0
 8005422:	d0f3      	beq.n	800540c <memp_init+0x64>
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 8005424:	f8be 5000 	ldrh.w	r5, [lr]
 8005428:	463b      	mov	r3, r7
 800542a:	2200      	movs	r2, #0
 800542c:	4611      	mov	r1, r2
 800542e:	e7dd      	b.n	80053ec <memp_init+0x44>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
 8005430:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005434:	2000b084 	.word	0x2000b084
 8005438:	20000e07 	.word	0x20000e07
 800543c:	200076c8 	.word	0x200076c8
 8005440:	08009014 	.word	0x08009014
 8005444:	08009028 	.word	0x08009028

08005448 <memp_malloc>:
#endif
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 8005448:	2809      	cmp	r0, #9
 800544a:	d82a      	bhi.n	80054a2 <memp_malloc+0x5a>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
 800544c:	4b17      	ldr	r3, [pc, #92]	; (80054ac <memp_malloc+0x64>)
 800544e:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
  
  if (memp != NULL) {
 8005452:	b1d2      	cbz	r2, 800548a <memp_malloc+0x42>
    memp_tab[type] = memp->next;
 8005454:	6811      	ldr	r1, [r2, #0]
 8005456:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
 800545a:	eb00 0180 	add.w	r1, r0, r0, lsl #2
 800545e:	4b14      	ldr	r3, [pc, #80]	; (80054b0 <memp_malloc+0x68>)
 8005460:	eb03 0141 	add.w	r1, r3, r1, lsl #1
 8005464:	f8b1 30b4 	ldrh.w	r3, [r1, #180]	; 0xb4
 8005468:	3301      	adds	r3, #1
 800546a:	b29b      	uxth	r3, r3
 800546c:	f8a1 30b4 	strh.w	r3, [r1, #180]	; 0xb4
 8005470:	f8b1 10b6 	ldrh.w	r1, [r1, #182]	; 0xb6
 8005474:	4299      	cmp	r1, r3
 8005476:	d216      	bcs.n	80054a6 <memp_malloc+0x5e>
 8005478:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800547c:	490c      	ldr	r1, [pc, #48]	; (80054b0 <memp_malloc+0x68>)
 800547e:	eb01 0040 	add.w	r0, r1, r0, lsl #1
 8005482:	f8a0 30b6 	strh.w	r3, [r0, #182]	; 0xb6
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
 8005486:	4610      	mov	r0, r2
 8005488:	4770      	bx	lr
    MEMP_STATS_INC(err, type);
 800548a:	4b09      	ldr	r3, [pc, #36]	; (80054b0 <memp_malloc+0x68>)
 800548c:	0082      	lsls	r2, r0, #2
 800548e:	1811      	adds	r1, r2, r0
 8005490:	eb03 0141 	add.w	r1, r3, r1, lsl #1
 8005494:	f8b1 30b8 	ldrh.w	r3, [r1, #184]	; 0xb8
 8005498:	3301      	adds	r3, #1
 800549a:	f8a1 30b8 	strh.w	r3, [r1, #184]	; 0xb8
  return memp;
 800549e:	2000      	movs	r0, #0
 80054a0:	4770      	bx	lr
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 80054a2:	2000      	movs	r0, #0
 80054a4:	4770      	bx	lr
  return memp;
 80054a6:	4610      	mov	r0, r2
}
 80054a8:	4770      	bx	lr
 80054aa:	bf00      	nop
 80054ac:	200076c8 	.word	0x200076c8
 80054b0:	2000b084 	.word	0x2000b084

080054b4 <memp_free>:
memp_free(memp_t type, void *mem)
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
 80054b4:	b191      	cbz	r1, 80054dc <memp_free+0x28>
{
 80054b6:	b410      	push	{r4}
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
 80054b8:	eb00 0280 	add.w	r2, r0, r0, lsl #2
 80054bc:	4b08      	ldr	r3, [pc, #32]	; (80054e0 <memp_free+0x2c>)
 80054be:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 80054c2:	f8b3 20b4 	ldrh.w	r2, [r3, #180]	; 0xb4
 80054c6:	3a01      	subs	r2, #1
 80054c8:	f8a3 20b4 	strh.w	r2, [r3, #180]	; 0xb4
  
  memp->next = memp_tab[type]; 
 80054cc:	4b05      	ldr	r3, [pc, #20]	; (80054e4 <memp_free+0x30>)
 80054ce:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 80054d2:	600a      	str	r2, [r1, #0]
  memp_tab[type] = memp;
 80054d4:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
 80054d8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80054dc:	4770      	bx	lr
 80054de:	bf00      	nop
 80054e0:	2000b084 	.word	0x2000b084
 80054e4:	200076c8 	.word	0x200076c8

080054e8 <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
 80054e8:	4770      	bx	lr
	...

080054ec <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
 80054ec:	b570      	push	{r4, r5, r6, lr}
 80054ee:	4604      	mov	r4, r0
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
 80054f0:	2900      	cmp	r1, #0
 80054f2:	d027      	beq.n	8005544 <netif_set_ipaddr+0x58>
 80054f4:	460d      	mov	r5, r1
 80054f6:	680a      	ldr	r2, [r1, #0]
 80054f8:	6843      	ldr	r3, [r0, #4]
 80054fa:	429a      	cmp	r2, r3
 80054fc:	d005      	beq.n	800550a <netif_set_ipaddr+0x1e>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 80054fe:	4b12      	ldr	r3, [pc, #72]	; (8005548 <netif_set_ipaddr+0x5c>)
 8005500:	6818      	ldr	r0, [r3, #0]
    while (pcb != NULL) {
 8005502:	b958      	cbnz	r0, 800551c <netif_set_ipaddr+0x30>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8005504:	4b11      	ldr	r3, [pc, #68]	; (800554c <netif_set_ipaddr+0x60>)
 8005506:	681b      	ldr	r3, [r3, #0]
 8005508:	b98b      	cbnz	r3, 800552e <netif_set_ipaddr+0x42>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 800550a:	682b      	ldr	r3, [r5, #0]
 800550c:	6063      	str	r3, [r4, #4]
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->ip_addr),
    ip4_addr2_16(&netif->ip_addr),
    ip4_addr3_16(&netif->ip_addr),
    ip4_addr4_16(&netif->ip_addr)));
}
 800550e:	bd70      	pop	{r4, r5, r6, pc}
        struct tcp_pcb *next = pcb->next;
 8005510:	68c6      	ldr	r6, [r0, #12]
        tcp_abort(pcb);
 8005512:	f000 feef 	bl	80062f4 <tcp_abort>
        pcb = next;
 8005516:	4630      	mov	r0, r6
    while (pcb != NULL) {
 8005518:	2800      	cmp	r0, #0
 800551a:	d0f3      	beq.n	8005504 <netif_set_ipaddr+0x18>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 800551c:	6802      	ldr	r2, [r0, #0]
 800551e:	6863      	ldr	r3, [r4, #4]
 8005520:	429a      	cmp	r2, r3
 8005522:	d0f5      	beq.n	8005510 <netif_set_ipaddr+0x24>
        pcb = pcb->next;
 8005524:	68c0      	ldr	r0, [r0, #12]
 8005526:	e7f7      	b.n	8005518 <netif_set_ipaddr+0x2c>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8005528:	68db      	ldr	r3, [r3, #12]
 800552a:	2b00      	cmp	r3, #0
 800552c:	d0ed      	beq.n	800550a <netif_set_ipaddr+0x1e>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 800552e:	2b00      	cmp	r3, #0
 8005530:	d0fa      	beq.n	8005528 <netif_set_ipaddr+0x3c>
 8005532:	681a      	ldr	r2, [r3, #0]
 8005534:	2a00      	cmp	r2, #0
 8005536:	d0f7      	beq.n	8005528 <netif_set_ipaddr+0x3c>
 8005538:	6861      	ldr	r1, [r4, #4]
 800553a:	428a      	cmp	r2, r1
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 800553c:	bf04      	itt	eq
 800553e:	682a      	ldreq	r2, [r5, #0]
 8005540:	601a      	streq	r2, [r3, #0]
 8005542:	e7f1      	b.n	8005528 <netif_set_ipaddr+0x3c>
  ip_addr_set(&(netif->ip_addr), ipaddr);
 8005544:	2300      	movs	r3, #0
 8005546:	e7e1      	b.n	800550c <netif_set_ipaddr+0x20>
 8005548:	2000b1a0 	.word	0x2000b1a0
 800554c:	2000b1a8 	.word	0x2000b1a8

08005550 <netif_set_addr>:
{
 8005550:	b570      	push	{r4, r5, r6, lr}
 8005552:	4604      	mov	r4, r0
 8005554:	4616      	mov	r6, r2
 8005556:	461d      	mov	r5, r3
  netif_set_ipaddr(netif, ipaddr);
 8005558:	f7ff ffc8 	bl	80054ec <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 800555c:	b12e      	cbz	r6, 800556a <netif_set_addr+0x1a>
 800555e:	6833      	ldr	r3, [r6, #0]
 8005560:	60a3      	str	r3, [r4, #8]
  ip_addr_set(&(netif->gw), gw);
 8005562:	b125      	cbz	r5, 800556e <netif_set_addr+0x1e>
 8005564:	682b      	ldr	r3, [r5, #0]
 8005566:	60e3      	str	r3, [r4, #12]
 8005568:	bd70      	pop	{r4, r5, r6, pc}
  ip_addr_set(&(netif->netmask), netmask);
 800556a:	2300      	movs	r3, #0
 800556c:	e7f8      	b.n	8005560 <netif_set_addr+0x10>
  ip_addr_set(&(netif->gw), gw);
 800556e:	2300      	movs	r3, #0
 8005570:	e7f9      	b.n	8005566 <netif_set_addr+0x16>
	...

08005574 <netif_add>:
{
 8005574:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005576:	4604      	mov	r4, r0
  ip_addr_set_zero(&netif->ip_addr);
 8005578:	2500      	movs	r5, #0
 800557a:	6045      	str	r5, [r0, #4]
  ip_addr_set_zero(&netif->netmask);
 800557c:	6085      	str	r5, [r0, #8]
  ip_addr_set_zero(&netif->gw);
 800557e:	60c5      	str	r5, [r0, #12]
  netif->flags = 0;
 8005580:	f880 5029 	strb.w	r5, [r0, #41]	; 0x29
  netif->state = state;
 8005584:	9d06      	ldr	r5, [sp, #24]
 8005586:	61c5      	str	r5, [r0, #28]
  netif->num = netif_num++;
 8005588:	4e0a      	ldr	r6, [pc, #40]	; (80055b4 <netif_add+0x40>)
 800558a:	7835      	ldrb	r5, [r6, #0]
 800558c:	1c6f      	adds	r7, r5, #1
 800558e:	7037      	strb	r7, [r6, #0]
 8005590:	f880 502c 	strb.w	r5, [r0, #44]	; 0x2c
  netif->input = input;
 8005594:	9d08      	ldr	r5, [sp, #32]
 8005596:	6105      	str	r5, [r0, #16]
  netif_set_addr(netif, ipaddr, netmask, gw);
 8005598:	f7ff ffda 	bl	8005550 <netif_set_addr>
  if (init(netif) != ERR_OK) {
 800559c:	4620      	mov	r0, r4
 800559e:	9b07      	ldr	r3, [sp, #28]
 80055a0:	4798      	blx	r3
 80055a2:	b928      	cbnz	r0, 80055b0 <netif_add+0x3c>
  netif->next = netif_list;
 80055a4:	4b04      	ldr	r3, [pc, #16]	; (80055b8 <netif_add+0x44>)
 80055a6:	681a      	ldr	r2, [r3, #0]
 80055a8:	6022      	str	r2, [r4, #0]
  netif_list = netif;
 80055aa:	601c      	str	r4, [r3, #0]
  return netif;
 80055ac:	4620      	mov	r0, r4
 80055ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return NULL;
 80055b0:	2000      	movs	r0, #0
}
 80055b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80055b4:	200076f0 	.word	0x200076f0
 80055b8:	2000b078 	.word	0x2000b078

080055bc <netif_set_default>:
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
 80055bc:	4b01      	ldr	r3, [pc, #4]	; (80055c4 <netif_set_default+0x8>)
 80055be:	6018      	str	r0, [r3, #0]
 80055c0:	4770      	bx	lr
 80055c2:	bf00      	nop
 80055c4:	2000b07c 	.word	0x2000b07c

080055c8 <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf*
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
 80055c8:	b470      	push	{r4, r5, r6}
 80055ca:	9c03      	ldr	r4, [sp, #12]
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (l) {
 80055cc:	2803      	cmp	r0, #3
 80055ce:	d826      	bhi.n	800561e <pbuf_alloced_custom+0x56>
 80055d0:	e8df f000 	tbb	[pc, r0]
 80055d4:	06040208 	.word	0x06040208
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    break;
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 80055d8:	2022      	movs	r0, #34	; 0x22
 80055da:	e004      	b.n	80055e6 <pbuf_alloced_custom+0x1e>
    break;
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
 80055dc:	200e      	movs	r0, #14
    break;
 80055de:	e002      	b.n	80055e6 <pbuf_alloced_custom+0x1e>
  case PBUF_RAW:
    offset = 0;
 80055e0:	2000      	movs	r0, #0
    break;
 80055e2:	e000      	b.n	80055e6 <pbuf_alloced_custom+0x1e>
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 80055e4:	2036      	movs	r0, #54	; 0x36
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 80055e6:	3003      	adds	r0, #3
 80055e8:	f020 0503 	bic.w	r5, r0, #3
 80055ec:	440d      	add	r5, r1
 80055ee:	f8bd 6010 	ldrh.w	r6, [sp, #16]
 80055f2:	42b5      	cmp	r5, r6
 80055f4:	dc15      	bgt.n	8005622 <pbuf_alloced_custom+0x5a>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
  }

  p->pbuf.next = NULL;
 80055f6:	2500      	movs	r5, #0
 80055f8:	601d      	str	r5, [r3, #0]
  if (payload_mem != NULL) {
 80055fa:	b16c      	cbz	r4, 8005618 <pbuf_alloced_custom+0x50>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 80055fc:	f020 0003 	bic.w	r0, r0, #3
 8005600:	4420      	add	r0, r4
 8005602:	6058      	str	r0, [r3, #4]
  } else {
    p->pbuf.payload = NULL;
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 8005604:	2002      	movs	r0, #2
 8005606:	7358      	strb	r0, [r3, #13]
  p->pbuf.len = p->pbuf.tot_len = length;
 8005608:	8119      	strh	r1, [r3, #8]
 800560a:	8159      	strh	r1, [r3, #10]
  p->pbuf.type = type;
 800560c:	731a      	strb	r2, [r3, #12]
  p->pbuf.ref = 1;
 800560e:	2201      	movs	r2, #1
 8005610:	81da      	strh	r2, [r3, #14]
  return &p->pbuf;
 8005612:	4618      	mov	r0, r3
}
 8005614:	bc70      	pop	{r4, r5, r6}
 8005616:	4770      	bx	lr
    p->pbuf.payload = NULL;
 8005618:	2000      	movs	r0, #0
 800561a:	6058      	str	r0, [r3, #4]
 800561c:	e7f2      	b.n	8005604 <pbuf_alloced_custom+0x3c>
    return NULL;
 800561e:	2000      	movs	r0, #0
 8005620:	e7f8      	b.n	8005614 <pbuf_alloced_custom+0x4c>
    return NULL;
 8005622:	2000      	movs	r0, #0
 8005624:	e7f6      	b.n	8005614 <pbuf_alloced_custom+0x4c>

08005626 <pbuf_header>:
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
 8005626:	2900      	cmp	r1, #0
 8005628:	d033      	beq.n	8005692 <pbuf_header+0x6c>
 800562a:	460b      	mov	r3, r1
 800562c:	2800      	cmp	r0, #0
 800562e:	d032      	beq.n	8005696 <pbuf_header+0x70>
{
 8005630:	b410      	push	{r4}
    return 0;
  }
 
  if (header_size_increment < 0){
 8005632:	2900      	cmp	r1, #0
 8005634:	db0b      	blt.n	800564e <pbuf_header+0x28>
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
 8005636:	b28c      	uxth	r4, r1
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 8005638:	7b02      	ldrb	r2, [r0, #12]
  /* remember current payload pointer */
  payload = p->payload;
 800563a:	6841      	ldr	r1, [r0, #4]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 800563c:	b172      	cbz	r2, 800565c <pbuf_header+0x36>
 800563e:	2a03      	cmp	r2, #3
 8005640:	d00c      	beq.n	800565c <pbuf_header+0x36>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 8005642:	3a01      	subs	r2, #1
 8005644:	b292      	uxth	r2, r2
 8005646:	2a01      	cmp	r2, #1
 8005648:	d919      	bls.n	800567e <pbuf_header+0x58>
      return 1;
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
 800564a:	2001      	movs	r0, #1
 800564c:	e014      	b.n	8005678 <pbuf_header+0x52>
    increment_magnitude = -header_size_increment;
 800564e:	424c      	negs	r4, r1
 8005650:	b2a4      	uxth	r4, r4
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8005652:	8942      	ldrh	r2, [r0, #10]
 8005654:	42a2      	cmp	r2, r4
 8005656:	d2ef      	bcs.n	8005638 <pbuf_header+0x12>
 8005658:	2001      	movs	r0, #1
 800565a:	e00d      	b.n	8005678 <pbuf_header+0x52>
    p->payload = (u8_t *)p->payload - header_size_increment;
 800565c:	1ac9      	subs	r1, r1, r3
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 800565e:	f100 0210 	add.w	r2, r0, #16
 8005662:	4291      	cmp	r1, r2
 8005664:	d319      	bcc.n	800569a <pbuf_header+0x74>
    p->payload = (u8_t *)p->payload - header_size_increment;
 8005666:	6041      	str	r1, [r0, #4]
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 8005668:	b29b      	uxth	r3, r3
 800566a:	8942      	ldrh	r2, [r0, #10]
 800566c:	441a      	add	r2, r3
 800566e:	8142      	strh	r2, [r0, #10]
  p->tot_len += header_size_increment;
 8005670:	8902      	ldrh	r2, [r0, #8]
 8005672:	4413      	add	r3, r2
 8005674:	8103      	strh	r3, [r0, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 8005676:	2000      	movs	r0, #0
}
 8005678:	f85d 4b04 	ldr.w	r4, [sp], #4
 800567c:	4770      	bx	lr
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 800567e:	2b00      	cmp	r3, #0
 8005680:	db01      	blt.n	8005686 <pbuf_header+0x60>
      return 1;
 8005682:	2001      	movs	r0, #1
 8005684:	e7f8      	b.n	8005678 <pbuf_header+0x52>
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8005686:	8942      	ldrh	r2, [r0, #10]
 8005688:	42a2      	cmp	r2, r4
 800568a:	d308      	bcc.n	800569e <pbuf_header+0x78>
      p->payload = (u8_t *)p->payload - header_size_increment;
 800568c:	1ac9      	subs	r1, r1, r3
 800568e:	6041      	str	r1, [r0, #4]
 8005690:	e7ea      	b.n	8005668 <pbuf_header+0x42>
    return 0;
 8005692:	2000      	movs	r0, #0
 8005694:	4770      	bx	lr
 8005696:	2000      	movs	r0, #0
 8005698:	4770      	bx	lr
      return 1;
 800569a:	2001      	movs	r0, #1
 800569c:	e7ec      	b.n	8005678 <pbuf_header+0x52>
      return 1;
 800569e:	2001      	movs	r0, #1
 80056a0:	e7ea      	b.n	8005678 <pbuf_header+0x52>

080056a2 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 80056a2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 80056a4:	b340      	cbz	r0, 80056f8 <pbuf_free+0x56>
 80056a6:	4601      	mov	r1, r0
 80056a8:	2400      	movs	r4, #0
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
 80056aa:	2508      	movs	r5, #8
          memp_free(MEMP_PBUF_POOL, p);
 80056ac:	2609      	movs	r6, #9
 80056ae:	e006      	b.n	80056be <pbuf_free+0x1c>
        pc->custom_free_function(p);
 80056b0:	690b      	ldr	r3, [r1, #16]
 80056b2:	4608      	mov	r0, r1
 80056b4:	4798      	blx	r3
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
        }
      }
      count++;
 80056b6:	3401      	adds	r4, #1
 80056b8:	b2e4      	uxtb	r4, r4
      /* proceed to next pbuf */
      p = q;
 80056ba:	4639      	mov	r1, r7
  while (p != NULL) {
 80056bc:	b1ef      	cbz	r7, 80056fa <pbuf_free+0x58>
    ref = --(p->ref);
 80056be:	89cb      	ldrh	r3, [r1, #14]
 80056c0:	3b01      	subs	r3, #1
 80056c2:	b29b      	uxth	r3, r3
 80056c4:	81cb      	strh	r3, [r1, #14]
    if (ref == 0) {
 80056c6:	b9c3      	cbnz	r3, 80056fa <pbuf_free+0x58>
      q = p->next;
 80056c8:	680f      	ldr	r7, [r1, #0]
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 80056ca:	7b4b      	ldrb	r3, [r1, #13]
 80056cc:	f013 0f02 	tst.w	r3, #2
 80056d0:	d1ee      	bne.n	80056b0 <pbuf_free+0xe>
      type = p->type;
 80056d2:	7b0b      	ldrb	r3, [r1, #12]
        if (type == PBUF_POOL) {
 80056d4:	2b03      	cmp	r3, #3
 80056d6:	d007      	beq.n	80056e8 <pbuf_free+0x46>
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 80056d8:	3b01      	subs	r3, #1
 80056da:	b29b      	uxth	r3, r3
 80056dc:	2b01      	cmp	r3, #1
 80056de:	d907      	bls.n	80056f0 <pbuf_free+0x4e>
          mem_free(p);
 80056e0:	4608      	mov	r0, r1
 80056e2:	f7ff fce1 	bl	80050a8 <mem_free>
 80056e6:	e7e6      	b.n	80056b6 <pbuf_free+0x14>
          memp_free(MEMP_PBUF_POOL, p);
 80056e8:	4630      	mov	r0, r6
 80056ea:	f7ff fee3 	bl	80054b4 <memp_free>
 80056ee:	e7e2      	b.n	80056b6 <pbuf_free+0x14>
          memp_free(MEMP_PBUF, p);
 80056f0:	4628      	mov	r0, r5
 80056f2:	f7ff fedf 	bl	80054b4 <memp_free>
 80056f6:	e7de      	b.n	80056b6 <pbuf_free+0x14>
    return 0;
 80056f8:	2400      	movs	r4, #0
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
 80056fa:	4620      	mov	r0, r4
 80056fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08005700 <pbuf_alloc>:
{
 8005700:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  switch (layer) {
 8005704:	2803      	cmp	r0, #3
 8005706:	f200 808d 	bhi.w	8005824 <pbuf_alloc+0x124>
 800570a:	e8df f000 	tbb	[pc, r0]
 800570e:	0208      	.short	0x0208
 8005710:	0604      	.short	0x0604
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 8005712:	2422      	movs	r4, #34	; 0x22
 8005714:	e004      	b.n	8005720 <pbuf_alloc+0x20>
    offset = PBUF_LINK_HLEN;
 8005716:	240e      	movs	r4, #14
    break;
 8005718:	e002      	b.n	8005720 <pbuf_alloc+0x20>
    offset = 0;
 800571a:	2400      	movs	r4, #0
    break;
 800571c:	e000      	b.n	8005720 <pbuf_alloc+0x20>
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 800571e:	2436      	movs	r4, #54	; 0x36
 8005720:	4617      	mov	r7, r2
 8005722:	460d      	mov	r5, r1
  switch (type) {
 8005724:	2a03      	cmp	r2, #3
 8005726:	d87f      	bhi.n	8005828 <pbuf_alloc+0x128>
 8005728:	e8df f002 	tbb	[pc, r2]
 800572c:	026f6f51 	.word	0x026f6f51
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8005730:	2009      	movs	r0, #9
 8005732:	f7ff fe89 	bl	8005448 <memp_malloc>
    if (p == NULL) {
 8005736:	4606      	mov	r6, r0
 8005738:	2800      	cmp	r0, #0
 800573a:	d03c      	beq.n	80057b6 <pbuf_alloc+0xb6>
    p->type = type;
 800573c:	2303      	movs	r3, #3
 800573e:	7303      	strb	r3, [r0, #12]
    p->next = NULL;
 8005740:	2300      	movs	r3, #0
 8005742:	6003      	str	r3, [r0, #0]
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8005744:	1903      	adds	r3, r0, r4
 8005746:	3313      	adds	r3, #19
 8005748:	f023 0303 	bic.w	r3, r3, #3
 800574c:	6043      	str	r3, [r0, #4]
    p->tot_len = length;
 800574e:	8105      	strh	r5, [r0, #8]
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8005750:	3403      	adds	r4, #3
 8005752:	f024 0403 	bic.w	r4, r4, #3
 8005756:	f5c4 64bd 	rsb	r4, r4, #1512	; 0x5e8
 800575a:	3404      	adds	r4, #4
 800575c:	42ac      	cmp	r4, r5
 800575e:	bfa8      	it	ge
 8005760:	462c      	movge	r4, r5
 8005762:	8144      	strh	r4, [r0, #10]
    p->ref = 1;
 8005764:	2301      	movs	r3, #1
 8005766:	81c3      	strh	r3, [r0, #14]
    rem_len = length - p->len;
 8005768:	b2a4      	uxth	r4, r4
 800576a:	1b2d      	subs	r5, r5, r4
    while (rem_len > 0) {
 800576c:	2d00      	cmp	r5, #0
 800576e:	dd45      	ble.n	80057fc <pbuf_alloc+0xfc>
 8005770:	4682      	mov	sl, r0
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8005772:	f04f 0809 	mov.w	r8, #9
      q->type = type;
 8005776:	f04f 0903 	mov.w	r9, #3
      q->flags = 0;
 800577a:	2700      	movs	r7, #0
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 800577c:	4640      	mov	r0, r8
 800577e:	f7ff fe63 	bl	8005448 <memp_malloc>
      if (q == NULL) {
 8005782:	4604      	mov	r4, r0
 8005784:	b1d8      	cbz	r0, 80057be <pbuf_alloc+0xbe>
      q->type = type;
 8005786:	f880 900c 	strb.w	r9, [r0, #12]
      q->flags = 0;
 800578a:	7347      	strb	r7, [r0, #13]
      q->next = NULL;
 800578c:	6007      	str	r7, [r0, #0]
      r->next = q;
 800578e:	f8ca 0000 	str.w	r0, [sl]
      q->tot_len = (u16_t)rem_len;
 8005792:	b2ab      	uxth	r3, r5
 8005794:	8103      	strh	r3, [r0, #8]
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8005796:	f240 52ec 	movw	r2, #1516	; 0x5ec
 800579a:	4293      	cmp	r3, r2
 800579c:	bf28      	it	cs
 800579e:	4613      	movcs	r3, r2
 80057a0:	8143      	strh	r3, [r0, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 80057a2:	f100 0210 	add.w	r2, r0, #16
 80057a6:	6042      	str	r2, [r0, #4]
      q->ref = 1;
 80057a8:	2201      	movs	r2, #1
 80057aa:	81c2      	strh	r2, [r0, #14]
      rem_len -= q->len;
 80057ac:	1aed      	subs	r5, r5, r3
      r = q;
 80057ae:	4682      	mov	sl, r0
    while (rem_len > 0) {
 80057b0:	2d00      	cmp	r5, #0
 80057b2:	dce3      	bgt.n	800577c <pbuf_alloc+0x7c>
 80057b4:	e022      	b.n	80057fc <pbuf_alloc+0xfc>
  pbuf_free_ooseq_pending = 1;
 80057b6:	2201      	movs	r2, #1
 80057b8:	4b1c      	ldr	r3, [pc, #112]	; (800582c <pbuf_alloc+0x12c>)
 80057ba:	701a      	strb	r2, [r3, #0]
 80057bc:	e022      	b.n	8005804 <pbuf_alloc+0x104>
 80057be:	2201      	movs	r2, #1
 80057c0:	4b1a      	ldr	r3, [pc, #104]	; (800582c <pbuf_alloc+0x12c>)
 80057c2:	701a      	strb	r2, [r3, #0]
        pbuf_free(p);
 80057c4:	4630      	mov	r0, r6
 80057c6:	f7ff ff6c 	bl	80056a2 <pbuf_free>
        return NULL;
 80057ca:	4626      	mov	r6, r4
 80057cc:	e01a      	b.n	8005804 <pbuf_alloc+0x104>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
 80057ce:	f104 0013 	add.w	r0, r4, #19
 80057d2:	f020 0003 	bic.w	r0, r0, #3
 80057d6:	1ccb      	adds	r3, r1, #3
 80057d8:	f023 0303 	bic.w	r3, r3, #3
 80057dc:	4418      	add	r0, r3
 80057de:	b280      	uxth	r0, r0
 80057e0:	f7ff fd44 	bl	800526c <mem_malloc>
    if (p == NULL) {
 80057e4:	4606      	mov	r6, r0
 80057e6:	b168      	cbz	r0, 8005804 <pbuf_alloc+0x104>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 80057e8:	4404      	add	r4, r0
 80057ea:	3413      	adds	r4, #19
 80057ec:	f024 0403 	bic.w	r4, r4, #3
 80057f0:	6044      	str	r4, [r0, #4]
    p->len = p->tot_len = length;
 80057f2:	8105      	strh	r5, [r0, #8]
 80057f4:	8145      	strh	r5, [r0, #10]
    p->next = NULL;
 80057f6:	2300      	movs	r3, #0
 80057f8:	6003      	str	r3, [r0, #0]
    p->type = type;
 80057fa:	7303      	strb	r3, [r0, #12]
  p->ref = 1;
 80057fc:	2301      	movs	r3, #1
 80057fe:	81f3      	strh	r3, [r6, #14]
  p->flags = 0;
 8005800:	2300      	movs	r3, #0
 8005802:	7373      	strb	r3, [r6, #13]
}
 8005804:	4630      	mov	r0, r6
 8005806:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 800580a:	2008      	movs	r0, #8
 800580c:	f7ff fe1c 	bl	8005448 <memp_malloc>
    if (p == NULL) {
 8005810:	4606      	mov	r6, r0
 8005812:	2800      	cmp	r0, #0
 8005814:	d0f6      	beq.n	8005804 <pbuf_alloc+0x104>
    p->payload = NULL;
 8005816:	2300      	movs	r3, #0
 8005818:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
 800581a:	8105      	strh	r5, [r0, #8]
 800581c:	8145      	strh	r5, [r0, #10]
    p->next = NULL;
 800581e:	6003      	str	r3, [r0, #0]
    p->type = type;
 8005820:	7307      	strb	r7, [r0, #12]
    break;
 8005822:	e7eb      	b.n	80057fc <pbuf_alloc+0xfc>
    return NULL;
 8005824:	2600      	movs	r6, #0
 8005826:	e7ed      	b.n	8005804 <pbuf_alloc+0x104>
    return NULL;
 8005828:	2600      	movs	r6, #0
 800582a:	e7eb      	b.n	8005804 <pbuf_alloc+0x104>
 800582c:	2000b080 	.word	0x2000b080

08005830 <pbuf_realloc>:
  if (new_len >= p->tot_len) {
 8005830:	8902      	ldrh	r2, [r0, #8]
 8005832:	428a      	cmp	r2, r1
 8005834:	d926      	bls.n	8005884 <pbuf_realloc+0x54>
{
 8005836:	b538      	push	{r3, r4, r5, lr}
 8005838:	4604      	mov	r4, r0
  while (rem_len > q->len) {
 800583a:	8943      	ldrh	r3, [r0, #10]
 800583c:	4299      	cmp	r1, r3
 800583e:	d91f      	bls.n	8005880 <pbuf_realloc+0x50>
 8005840:	460d      	mov	r5, r1
    q->tot_len += (u16_t)grow;
 8005842:	1a89      	subs	r1, r1, r2
    rem_len -= q->len;
 8005844:	1aeb      	subs	r3, r5, r3
 8005846:	b29d      	uxth	r5, r3
    q->tot_len += (u16_t)grow;
 8005848:	8923      	ldrh	r3, [r4, #8]
 800584a:	440b      	add	r3, r1
 800584c:	8123      	strh	r3, [r4, #8]
    q = q->next;
 800584e:	6824      	ldr	r4, [r4, #0]
  while (rem_len > q->len) {
 8005850:	8963      	ldrh	r3, [r4, #10]
 8005852:	42ab      	cmp	r3, r5
 8005854:	d3f6      	bcc.n	8005844 <pbuf_realloc+0x14>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 8005856:	7b22      	ldrb	r2, [r4, #12]
 8005858:	b94a      	cbnz	r2, 800586e <pbuf_realloc+0x3e>
 800585a:	429d      	cmp	r5, r3
 800585c:	d007      	beq.n	800586e <pbuf_realloc+0x3e>
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 800585e:	6863      	ldr	r3, [r4, #4]
 8005860:	1b1b      	subs	r3, r3, r4
 8005862:	18e9      	adds	r1, r5, r3
 8005864:	b289      	uxth	r1, r1
 8005866:	4620      	mov	r0, r4
 8005868:	f7ff fc7a 	bl	8005160 <mem_trim>
 800586c:	4604      	mov	r4, r0
  q->len = rem_len;
 800586e:	8165      	strh	r5, [r4, #10]
  q->tot_len = q->len;
 8005870:	8125      	strh	r5, [r4, #8]
  if (q->next != NULL) {
 8005872:	6820      	ldr	r0, [r4, #0]
 8005874:	b108      	cbz	r0, 800587a <pbuf_realloc+0x4a>
    pbuf_free(q->next);
 8005876:	f7ff ff14 	bl	80056a2 <pbuf_free>
  q->next = NULL;
 800587a:	2300      	movs	r3, #0
 800587c:	6023      	str	r3, [r4, #0]
 800587e:	bd38      	pop	{r3, r4, r5, pc}
  while (rem_len > q->len) {
 8005880:	460d      	mov	r5, r1
 8005882:	e7e8      	b.n	8005856 <pbuf_realloc+0x26>
 8005884:	4770      	bx	lr

08005886 <pbuf_clen>:
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 8005886:	4603      	mov	r3, r0
 8005888:	b130      	cbz	r0, 8005898 <pbuf_clen+0x12>
 800588a:	2000      	movs	r0, #0
    ++len;
 800588c:	3001      	adds	r0, #1
 800588e:	b2c0      	uxtb	r0, r0
    p = p->next;
 8005890:	681b      	ldr	r3, [r3, #0]
  while (p != NULL) {
 8005892:	2b00      	cmp	r3, #0
 8005894:	d1fa      	bne.n	800588c <pbuf_clen+0x6>
 8005896:	4770      	bx	lr
  len = 0;
 8005898:	2000      	movs	r0, #0
  }
  return len;
}
 800589a:	4770      	bx	lr

0800589c <pbuf_ref>:
void
pbuf_ref(struct pbuf *p)
{
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 800589c:	b110      	cbz	r0, 80058a4 <pbuf_ref+0x8>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
 800589e:	89c3      	ldrh	r3, [r0, #14]
 80058a0:	3301      	adds	r3, #1
 80058a2:	81c3      	strh	r3, [r0, #14]
 80058a4:	4770      	bx	lr

080058a6 <pbuf_cat>:
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 80058a6:	b1b0      	cbz	r0, 80058d6 <pbuf_cat+0x30>
{
 80058a8:	b410      	push	{r4}
 80058aa:	4604      	mov	r4, r0
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 80058ac:	b189      	cbz	r1, 80058d2 <pbuf_cat+0x2c>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 80058ae:	6802      	ldr	r2, [r0, #0]
 80058b0:	b912      	cbnz	r2, 80058b8 <pbuf_cat+0x12>
 80058b2:	4602      	mov	r2, r0
 80058b4:	e008      	b.n	80058c8 <pbuf_cat+0x22>
 80058b6:	461a      	mov	r2, r3
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 80058b8:	8923      	ldrh	r3, [r4, #8]
 80058ba:	8908      	ldrh	r0, [r1, #8]
 80058bc:	4403      	add	r3, r0
 80058be:	8123      	strh	r3, [r4, #8]
  for (p = h; p->next != NULL; p = p->next) {
 80058c0:	6813      	ldr	r3, [r2, #0]
 80058c2:	4614      	mov	r4, r2
 80058c4:	2b00      	cmp	r3, #0
 80058c6:	d1f6      	bne.n	80058b6 <pbuf_cat+0x10>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 80058c8:	8913      	ldrh	r3, [r2, #8]
 80058ca:	8908      	ldrh	r0, [r1, #8]
 80058cc:	4403      	add	r3, r0
 80058ce:	8113      	strh	r3, [r2, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 80058d0:	6011      	str	r1, [r2, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 80058d2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80058d6:	4770      	bx	lr

080058d8 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 80058d8:	b510      	push	{r4, lr}
 80058da:	460c      	mov	r4, r1
  pbuf_cat(h, t);
 80058dc:	f7ff ffe3 	bl	80058a6 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 80058e0:	4620      	mov	r0, r4
 80058e2:	f7ff ffdb 	bl	800589c <pbuf_ref>
 80058e6:	bd10      	pop	{r4, pc}

080058e8 <pbuf_copy>:

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 80058e8:	b310      	cbz	r0, 8005930 <pbuf_copy+0x48>
{
 80058ea:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80058ee:	460e      	mov	r6, r1
 80058f0:	4607      	mov	r7, r0
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 80058f2:	b301      	cbz	r1, 8005936 <pbuf_copy+0x4e>
 80058f4:	8902      	ldrh	r2, [r0, #8]
 80058f6:	890b      	ldrh	r3, [r1, #8]
 80058f8:	429a      	cmp	r2, r3
 80058fa:	d320      	bcc.n	800593e <pbuf_copy+0x56>
 80058fc:	f04f 0900 	mov.w	r9, #0
 8005900:	464d      	mov	r5, r9
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
 8005902:	46c8      	mov	r8, r9
 8005904:	e02e      	b.n	8005964 <pbuf_copy+0x7c>
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
 8005906:	683f      	ldr	r7, [r7, #0]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 8005908:	b10f      	cbz	r7, 800590e <pbuf_copy+0x26>
      offset_to = 0;
 800590a:	4645      	mov	r5, r8
 800590c:	e049      	b.n	80059a2 <pbuf_copy+0xba>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 800590e:	2e00      	cmp	r6, #0
 8005910:	bf14      	ite	ne
 8005912:	f06f 000d 	mvnne.w	r0, #13
 8005916:	2000      	moveq	r0, #0
 8005918:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 800591c:	6833      	ldr	r3, [r6, #0]
 800591e:	2b00      	cmp	r3, #0
 8005920:	d045      	beq.n	80059ae <pbuf_copy+0xc6>
 8005922:	f06f 0005 	mvn.w	r0, #5
 8005926:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  return ERR_OK;
 800592a:	2000      	movs	r0, #0
 800592c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8005930:	f06f 000d 	mvn.w	r0, #13
 8005934:	4770      	bx	lr
 8005936:	f06f 000d 	mvn.w	r0, #13
 800593a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800593e:	f06f 000d 	mvn.w	r0, #13
 8005942:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 8005946:	f06f 0005 	mvn.w	r0, #5
 800594a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 800594e:	2f00      	cmp	r7, #0
 8005950:	d034      	beq.n	80059bc <pbuf_copy+0xd4>
 8005952:	897a      	ldrh	r2, [r7, #10]
 8005954:	893b      	ldrh	r3, [r7, #8]
 8005956:	429a      	cmp	r2, r3
 8005958:	d133      	bne.n	80059c2 <pbuf_copy+0xda>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 800595a:	683b      	ldr	r3, [r7, #0]
 800595c:	2b00      	cmp	r3, #0
 800595e:	d1f2      	bne.n	8005946 <pbuf_copy+0x5e>
  } while (p_from);
 8005960:	2e00      	cmp	r6, #0
 8005962:	d0e2      	beq.n	800592a <pbuf_copy+0x42>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 8005964:	897b      	ldrh	r3, [r7, #10]
 8005966:	8974      	ldrh	r4, [r6, #10]
 8005968:	1b59      	subs	r1, r3, r5
 800596a:	eba4 0209 	sub.w	r2, r4, r9
 800596e:	4291      	cmp	r1, r2
      len = p_from->len - offset_from;
 8005970:	bfa7      	ittee	ge
 8005972:	4614      	movge	r4, r2
 8005974:	b2a4      	uxthge	r4, r4
      len = p_to->len - offset_to;
 8005976:	1b5b      	sublt	r3, r3, r5
 8005978:	b29c      	uxthlt	r4, r3
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 800597a:	6878      	ldr	r0, [r7, #4]
 800597c:	6871      	ldr	r1, [r6, #4]
 800597e:	4622      	mov	r2, r4
 8005980:	4449      	add	r1, r9
 8005982:	4428      	add	r0, r5
 8005984:	f003 fa99 	bl	8008eba <memcpy>
    offset_to += len;
 8005988:	4425      	add	r5, r4
 800598a:	b2ad      	uxth	r5, r5
    offset_from += len;
 800598c:	444c      	add	r4, r9
 800598e:	fa1f f984 	uxth.w	r9, r4
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 8005992:	897b      	ldrh	r3, [r7, #10]
    if (offset_from >= p_from->len) {
 8005994:	8972      	ldrh	r2, [r6, #10]
 8005996:	454a      	cmp	r2, r9
      p_from = p_from->next;
 8005998:	bf9c      	itt	ls
 800599a:	6836      	ldrls	r6, [r6, #0]
      offset_from = 0;
 800599c:	46c1      	movls	r9, r8
    if (offset_to == p_to->len) {
 800599e:	429d      	cmp	r5, r3
 80059a0:	d0b1      	beq.n	8005906 <pbuf_copy+0x1e>
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 80059a2:	2e00      	cmp	r6, #0
 80059a4:	d0d3      	beq.n	800594e <pbuf_copy+0x66>
 80059a6:	8972      	ldrh	r2, [r6, #10]
 80059a8:	8933      	ldrh	r3, [r6, #8]
 80059aa:	429a      	cmp	r2, r3
 80059ac:	d0b6      	beq.n	800591c <pbuf_copy+0x34>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 80059ae:	2f00      	cmp	r7, #0
 80059b0:	d0d8      	beq.n	8005964 <pbuf_copy+0x7c>
 80059b2:	897a      	ldrh	r2, [r7, #10]
 80059b4:	893b      	ldrh	r3, [r7, #8]
 80059b6:	429a      	cmp	r2, r3
 80059b8:	d1d4      	bne.n	8005964 <pbuf_copy+0x7c>
 80059ba:	e7ce      	b.n	800595a <pbuf_copy+0x72>
  return ERR_OK;
 80059bc:	2000      	movs	r0, #0
 80059be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80059c2:	2000      	movs	r0, #0
}
 80059c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080059c8 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 80059c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 80059cc:	b338      	cbz	r0, 8005a1e <pbuf_copy_partial+0x56>
 80059ce:	460f      	mov	r7, r1
 80059d0:	4691      	mov	r9, r2
 80059d2:	4605      	mov	r5, r0
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 80059d4:	b339      	cbz	r1, 8005a26 <pbuf_copy_partial+0x5e>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 80059d6:	b342      	cbz	r2, 8005a2a <pbuf_copy_partial+0x62>
 80059d8:	2600      	movs	r6, #0
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
      copied_total += buf_copy_len;
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
 80059da:	46b0      	mov	r8, r6
 80059dc:	e017      	b.n	8005a0e <pbuf_copy_partial+0x46>
      buf_copy_len = p->len - offset;
 80059de:	896c      	ldrh	r4, [r5, #10]
 80059e0:	1ae4      	subs	r4, r4, r3
 80059e2:	b2a4      	uxth	r4, r4
 80059e4:	454c      	cmp	r4, r9
 80059e6:	bf28      	it	cs
 80059e8:	464c      	movcs	r4, r9
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 80059ea:	6869      	ldr	r1, [r5, #4]
 80059ec:	4622      	mov	r2, r4
 80059ee:	4419      	add	r1, r3
 80059f0:	19b8      	adds	r0, r7, r6
 80059f2:	f003 fa62 	bl	8008eba <memcpy>
      copied_total += buf_copy_len;
 80059f6:	4426      	add	r6, r4
 80059f8:	b2b6      	uxth	r6, r6
      len -= buf_copy_len;
 80059fa:	eba9 0404 	sub.w	r4, r9, r4
 80059fe:	fa1f f984 	uxth.w	r9, r4
      offset = 0;
 8005a02:	4643      	mov	r3, r8
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8005a04:	682d      	ldr	r5, [r5, #0]
 8005a06:	f1b9 0f00 	cmp.w	r9, #0
 8005a0a:	d009      	beq.n	8005a20 <pbuf_copy_partial+0x58>
 8005a0c:	b145      	cbz	r5, 8005a20 <pbuf_copy_partial+0x58>
    if ((offset != 0) && (offset >= p->len)) {
 8005a0e:	2b00      	cmp	r3, #0
 8005a10:	d0e5      	beq.n	80059de <pbuf_copy_partial+0x16>
 8005a12:	8969      	ldrh	r1, [r5, #10]
 8005a14:	4299      	cmp	r1, r3
 8005a16:	d8e2      	bhi.n	80059de <pbuf_copy_partial+0x16>
      offset -= p->len;
 8005a18:	1a5b      	subs	r3, r3, r1
 8005a1a:	b29b      	uxth	r3, r3
 8005a1c:	e7f2      	b.n	8005a04 <pbuf_copy_partial+0x3c>
  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8005a1e:	2600      	movs	r6, #0
    }
  }
  return copied_total;
}
 8005a20:	4630      	mov	r0, r6
 8005a22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8005a26:	2600      	movs	r6, #0
 8005a28:	e7fa      	b.n	8005a20 <pbuf_copy_partial+0x58>
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8005a2a:	4616      	mov	r6, r2
 8005a2c:	e7f8      	b.n	8005a20 <pbuf_copy_partial+0x58>
	...

08005a30 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
 8005a30:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);
 8005a34:	6843      	ldr	r3, [r0, #4]
 8005a36:	7a5e      	ldrb	r6, [r3, #9]

  prev = NULL;
  pcb = raw_pcbs;
 8005a38:	4b18      	ldr	r3, [pc, #96]	; (8005a9c <raw_input+0x6c>)
 8005a3a:	681c      	ldr	r4, [r3, #0]
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 8005a3c:	b35c      	cbz	r4, 8005a96 <raw_input+0x66>
 8005a3e:	4682      	mov	sl, r0
 8005a40:	2500      	movs	r5, #0
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 8005a42:	f8df 805c 	ldr.w	r8, [pc, #92]	; 8005aa0 <raw_input+0x70>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
 8005a46:	f8df 905c 	ldr.w	r9, [pc, #92]	; 8005aa4 <raw_input+0x74>
 8005a4a:	e003      	b.n	8005a54 <raw_input+0x24>
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
 8005a4c:	68e3      	ldr	r3, [r4, #12]
 8005a4e:	4625      	mov	r5, r4
  while ((eaten == 0) && (pcb != NULL)) {
 8005a50:	b1f3      	cbz	r3, 8005a90 <raw_input+0x60>
    pcb = pcb->next;
 8005a52:	461c      	mov	r4, r3
    if ((pcb->protocol == proto) &&
 8005a54:	7c23      	ldrb	r3, [r4, #16]
 8005a56:	42b3      	cmp	r3, r6
 8005a58:	d1f8      	bne.n	8005a4c <raw_input+0x1c>
 8005a5a:	b12c      	cbz	r4, 8005a68 <raw_input+0x38>
        (ip_addr_isany(&pcb->local_ip) ||
 8005a5c:	6823      	ldr	r3, [r4, #0]
 8005a5e:	b11b      	cbz	r3, 8005a68 <raw_input+0x38>
 8005a60:	f8d9 2000 	ldr.w	r2, [r9]
 8005a64:	4293      	cmp	r3, r2
 8005a66:	d1f1      	bne.n	8005a4c <raw_input+0x1c>
        if (pcb->recv != NULL) {
 8005a68:	6967      	ldr	r7, [r4, #20]
 8005a6a:	2f00      	cmp	r7, #0
 8005a6c:	d0ee      	beq.n	8005a4c <raw_input+0x1c>
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 8005a6e:	4643      	mov	r3, r8
 8005a70:	4652      	mov	r2, sl
 8005a72:	4621      	mov	r1, r4
 8005a74:	69a0      	ldr	r0, [r4, #24]
 8005a76:	47b8      	blx	r7
 8005a78:	2800      	cmp	r0, #0
 8005a7a:	d0e7      	beq.n	8005a4c <raw_input+0x1c>
            if (prev != NULL) {
 8005a7c:	b12d      	cbz	r5, 8005a8a <raw_input+0x5a>
              prev->next = pcb->next;
 8005a7e:	68e3      	ldr	r3, [r4, #12]
 8005a80:	60eb      	str	r3, [r5, #12]
              pcb->next = raw_pcbs;
 8005a82:	4b06      	ldr	r3, [pc, #24]	; (8005a9c <raw_input+0x6c>)
 8005a84:	681a      	ldr	r2, [r3, #0]
 8005a86:	60e2      	str	r2, [r4, #12]
              raw_pcbs = pcb;
 8005a88:	601c      	str	r4, [r3, #0]
    pcb = pcb->next;
 8005a8a:	2001      	movs	r0, #1
  }
  return eaten;
}
 8005a8c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005a90:	2000      	movs	r0, #0
 8005a92:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  u8_t eaten = 0;
 8005a96:	2000      	movs	r0, #0
 8005a98:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005a9c:	200076f4 	.word	0x200076f4
 8005aa0:	20008944 	.word	0x20008944
 8005aa4:	2000894c 	.word	0x2000894c

08005aa8 <stats_init>:
#include <string.h>

struct stats_ lwip_stats;

void stats_init(void)
{
 8005aa8:	4770      	bx	lr

08005aaa <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
 8005aaa:	4770      	bx	lr

08005aac <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 8005aac:	b470      	push	{r4, r5, r6}
 8005aae:	4602      	mov	r2, r0
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8005ab0:	6a85      	ldr	r5, [r0, #40]	; 0x28
 8005ab2:	8d84      	ldrh	r4, [r0, #44]	; 0x2c

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8005ab4:	6b01      	ldr	r1, [r0, #48]	; 0x30
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8005ab6:	1963      	adds	r3, r4, r5
 8005ab8:	1a58      	subs	r0, r3, r1
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8005aba:	8ed3      	ldrh	r3, [r2, #54]	; 0x36
 8005abc:	f640 3668 	movw	r6, #2920	; 0xb68
 8005ac0:	42b3      	cmp	r3, r6
 8005ac2:	bf94      	ite	ls
 8005ac4:	1ac3      	subls	r3, r0, r3
 8005ac6:	1b83      	subhi	r3, r0, r6
 8005ac8:	2b00      	cmp	r3, #0
 8005aca:	db02      	blt.n	8005ad2 <tcp_update_rcv_ann_wnd+0x26>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 8005acc:	85d4      	strh	r4, [r2, #46]	; 0x2e
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
  }
}
 8005ace:	bc70      	pop	{r4, r5, r6}
 8005ad0:	4770      	bx	lr
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 8005ad2:	1a6b      	subs	r3, r5, r1
 8005ad4:	2b00      	cmp	r3, #0
 8005ad6:	dd03      	ble.n	8005ae0 <tcp_update_rcv_ann_wnd+0x34>
      pcb->rcv_ann_wnd = 0;
 8005ad8:	2300      	movs	r3, #0
 8005ada:	85d3      	strh	r3, [r2, #46]	; 0x2e
    return 0;
 8005adc:	4618      	mov	r0, r3
 8005ade:	e7f6      	b.n	8005ace <tcp_update_rcv_ann_wnd+0x22>
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 8005ae0:	1b49      	subs	r1, r1, r5
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
 8005ae2:	85d1      	strh	r1, [r2, #46]	; 0x2e
    return 0;
 8005ae4:	2000      	movs	r0, #0
 8005ae6:	e7f2      	b.n	8005ace <tcp_update_rcv_ann_wnd+0x22>

08005ae8 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 8005ae8:	b510      	push	{r4, lr}
 8005aea:	4604      	mov	r4, r0
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8005aec:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 8005aee:	4419      	add	r1, r3
 8005af0:	b289      	uxth	r1, r1
  if (pcb->rcv_wnd > TCP_WND) {
 8005af2:	f241 63d0 	movw	r3, #5840	; 0x16d0
 8005af6:	4299      	cmp	r1, r3
  pcb->rcv_wnd += len;
 8005af8:	bf92      	itee	ls
 8005afa:	8581      	strhls	r1, [r0, #44]	; 0x2c
    pcb->rcv_wnd = TCP_WND;
 8005afc:	f241 63d0 	movwhi	r3, #5840	; 0x16d0
 8005b00:	8583      	strhhi	r3, [r0, #44]	; 0x2c
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 8005b02:	f7ff ffd3 	bl	8005aac <tcp_update_rcv_ann_wnd>

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8005b06:	f240 53b3 	movw	r3, #1459	; 0x5b3
 8005b0a:	4298      	cmp	r0, r3
 8005b0c:	dc00      	bgt.n	8005b10 <tcp_recved+0x28>
 8005b0e:	bd10      	pop	{r4, pc}
    tcp_ack_now(pcb);
 8005b10:	7fa3      	ldrb	r3, [r4, #30]
 8005b12:	f043 0302 	orr.w	r3, r3, #2
 8005b16:	77a3      	strb	r3, [r4, #30]
    tcp_output(pcb);
 8005b18:	4620      	mov	r0, r4
 8005b1a:	f002 f801 	bl	8007b20 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
 8005b1e:	e7f6      	b.n	8005b0e <tcp_recved+0x26>

08005b20 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
 8005b20:	b150      	cbz	r0, 8005b38 <tcp_seg_free+0x18>
{
 8005b22:	b510      	push	{r4, lr}
 8005b24:	4604      	mov	r4, r0
    if (seg->p != NULL) {
 8005b26:	6840      	ldr	r0, [r0, #4]
 8005b28:	b108      	cbz	r0, 8005b2e <tcp_seg_free+0xe>
      pbuf_free(seg->p);
 8005b2a:	f7ff fdba 	bl	80056a2 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8005b2e:	4621      	mov	r1, r4
 8005b30:	2004      	movs	r0, #4
 8005b32:	f7ff fcbf 	bl	80054b4 <memp_free>
 8005b36:	bd10      	pop	{r4, pc}
 8005b38:	4770      	bx	lr

08005b3a <tcp_segs_free>:
  while (seg != NULL) {
 8005b3a:	4603      	mov	r3, r0
 8005b3c:	b140      	cbz	r0, 8005b50 <tcp_segs_free+0x16>
{
 8005b3e:	b510      	push	{r4, lr}
    struct tcp_seg *next = seg->next;
 8005b40:	681c      	ldr	r4, [r3, #0]
    tcp_seg_free(seg);
 8005b42:	4618      	mov	r0, r3
 8005b44:	f7ff ffec 	bl	8005b20 <tcp_seg_free>
    seg = next;
 8005b48:	4623      	mov	r3, r4
  while (seg != NULL) {
 8005b4a:	2c00      	cmp	r4, #0
 8005b4c:	d1f8      	bne.n	8005b40 <tcp_segs_free+0x6>
 8005b4e:	bd10      	pop	{r4, pc}
 8005b50:	4770      	bx	lr

08005b52 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 8005b52:	b538      	push	{r3, r4, r5, lr}
 8005b54:	4605      	mov	r5, r0
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 8005b56:	2004      	movs	r0, #4
 8005b58:	f7ff fc76 	bl	8005448 <memp_malloc>
  if (cseg == NULL) {
 8005b5c:	4604      	mov	r4, r0
 8005b5e:	b150      	cbz	r0, 8005b76 <tcp_seg_copy+0x24>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
 8005b60:	6828      	ldr	r0, [r5, #0]
 8005b62:	6869      	ldr	r1, [r5, #4]
 8005b64:	68aa      	ldr	r2, [r5, #8]
 8005b66:	68eb      	ldr	r3, [r5, #12]
 8005b68:	6020      	str	r0, [r4, #0]
 8005b6a:	6061      	str	r1, [r4, #4]
 8005b6c:	60a2      	str	r2, [r4, #8]
 8005b6e:	60e3      	str	r3, [r4, #12]
  pbuf_ref(cseg->p);
 8005b70:	6860      	ldr	r0, [r4, #4]
 8005b72:	f7ff fe93 	bl	800589c <pbuf_ref>
  return cseg;
}
 8005b76:	4620      	mov	r0, r4
 8005b78:	bd38      	pop	{r3, r4, r5, pc}

08005b7a <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 8005b7a:	b538      	push	{r3, r4, r5, lr}
  if (pcb->state != CLOSED &&
 8005b7c:	7e03      	ldrb	r3, [r0, #24]
 8005b7e:	2b01      	cmp	r3, #1
 8005b80:	d91a      	bls.n	8005bb8 <tcp_pcb_purge+0x3e>
 8005b82:	2b0a      	cmp	r3, #10
 8005b84:	d018      	beq.n	8005bb8 <tcp_pcb_purge+0x3e>
 8005b86:	4604      	mov	r4, r0
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 8005b88:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8005b8a:	b118      	cbz	r0, 8005b94 <tcp_pcb_purge+0x1a>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 8005b8c:	f7ff fd89 	bl	80056a2 <pbuf_free>
      pcb->refused_data = NULL;
 8005b90:	2300      	movs	r3, #0
 8005b92:	67a3      	str	r3, [r4, #120]	; 0x78
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
 8005b94:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8005b96:	f7ff ffd0 	bl	8005b3a <tcp_segs_free>
    pcb->ooseq = NULL;
 8005b9a:	2500      	movs	r5, #0
 8005b9c:	6765      	str	r5, [r4, #116]	; 0x74
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 8005b9e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005ba2:	86a3      	strh	r3, [r4, #52]	; 0x34

    tcp_segs_free(pcb->unsent);
 8005ba4:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8005ba6:	f7ff ffc8 	bl	8005b3a <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 8005baa:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8005bac:	f7ff ffc5 	bl	8005b3a <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 8005bb0:	66e5      	str	r5, [r4, #108]	; 0x6c
 8005bb2:	6725      	str	r5, [r4, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 8005bb4:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
 8005bb8:	bd38      	pop	{r3, r4, r5, pc}
	...

08005bbc <tcp_slowtmr>:
{
 8005bbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005bc0:	b083      	sub	sp, #12
  ++tcp_ticks;
 8005bc2:	4ab6      	ldr	r2, [pc, #728]	; (8005e9c <tcp_slowtmr+0x2e0>)
 8005bc4:	6813      	ldr	r3, [r2, #0]
 8005bc6:	3301      	adds	r3, #1
 8005bc8:	6013      	str	r3, [r2, #0]
  ++tcp_timer_ctr;
 8005bca:	4ab5      	ldr	r2, [pc, #724]	; (8005ea0 <tcp_slowtmr+0x2e4>)
 8005bcc:	7813      	ldrb	r3, [r2, #0]
 8005bce:	3301      	adds	r3, #1
 8005bd0:	7013      	strb	r3, [r2, #0]
    if (pcb->last_timer == tcp_timer_ctr) {
 8005bd2:	4615      	mov	r5, r2
        tcp_active_pcbs_changed = 0;
 8005bd4:	4fb3      	ldr	r7, [pc, #716]	; (8005ea4 <tcp_slowtmr+0x2e8>)
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 8005bd6:	f8df b2e0 	ldr.w	fp, [pc, #736]	; 8005eb8 <tcp_slowtmr+0x2fc>
  pcb = tcp_active_pcbs;
 8005bda:	4bb3      	ldr	r3, [pc, #716]	; (8005ea8 <tcp_slowtmr+0x2ec>)
 8005bdc:	681c      	ldr	r4, [r3, #0]
  while (pcb != NULL) {
 8005bde:	2c00      	cmp	r4, #0
 8005be0:	f000 816c 	beq.w	8005ebc <tcp_slowtmr+0x300>
 8005be4:	2600      	movs	r6, #0
 8005be6:	e003      	b.n	8005bf0 <tcp_slowtmr+0x34>
      pcb = pcb->next;
 8005be8:	68e4      	ldr	r4, [r4, #12]
  while (pcb != NULL) {
 8005bea:	2c00      	cmp	r4, #0
 8005bec:	f000 8166 	beq.w	8005ebc <tcp_slowtmr+0x300>
    if (pcb->last_timer == tcp_timer_ctr) {
 8005bf0:	782b      	ldrb	r3, [r5, #0]
 8005bf2:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 8005bf6:	429a      	cmp	r2, r3
 8005bf8:	d0f6      	beq.n	8005be8 <tcp_slowtmr+0x2c>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 8005bfa:	7e22      	ldrb	r2, [r4, #24]
    pcb->last_timer = tcp_timer_ctr;
 8005bfc:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 8005c00:	2a02      	cmp	r2, #2
 8005c02:	d024      	beq.n	8005c4e <tcp_slowtmr+0x92>
    else if (pcb->nrtx == TCP_MAXRTX) {
 8005c04:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8005c08:	2b0c      	cmp	r3, #12
 8005c0a:	d061      	beq.n	8005cd0 <tcp_slowtmr+0x114>
      if (pcb->persist_backoff > 0) {
 8005c0c:	f894 8095 	ldrb.w	r8, [r4, #149]	; 0x95
 8005c10:	f1b8 0f00 	cmp.w	r8, #0
 8005c14:	d027      	beq.n	8005c66 <tcp_slowtmr+0xaa>
        pcb->persist_cnt++;
 8005c16:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
 8005c1a:	3301      	adds	r3, #1
 8005c1c:	b2db      	uxtb	r3, r3
 8005c1e:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 8005c22:	4aa2      	ldr	r2, [pc, #648]	; (8005eac <tcp_slowtmr+0x2f0>)
 8005c24:	4442      	add	r2, r8
 8005c26:	f812 2c01 	ldrb.w	r2, [r2, #-1]
 8005c2a:	429a      	cmp	r2, r3
 8005c2c:	d873      	bhi.n	8005d16 <tcp_slowtmr+0x15a>
          pcb->persist_cnt = 0;
 8005c2e:	2300      	movs	r3, #0
 8005c30:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 8005c34:	f1b8 0f06 	cmp.w	r8, #6
            pcb->persist_backoff++;
 8005c38:	bf9c      	itt	ls
 8005c3a:	f108 0801 	addls.w	r8, r8, #1
 8005c3e:	f884 8095 	strbls.w	r8, [r4, #149]	; 0x95
          tcp_zero_window_probe(pcb);
 8005c42:	4620      	mov	r0, r4
 8005c44:	f002 f9b4 	bl	8007fb0 <tcp_zero_window_probe>
    pcb_remove = 0;
 8005c48:	f04f 0800 	mov.w	r8, #0
 8005c4c:	e042      	b.n	8005cd4 <tcp_slowtmr+0x118>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 8005c4e:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8005c52:	2b06      	cmp	r3, #6
 8005c54:	f000 808f 	beq.w	8005d76 <tcp_slowtmr+0x1ba>
    else if (pcb->nrtx == TCP_MAXRTX) {
 8005c58:	2b0c      	cmp	r3, #12
 8005c5a:	d1d7      	bne.n	8005c0c <tcp_slowtmr+0x50>
    pcb_reset = 0;
 8005c5c:	f04f 0900 	mov.w	r9, #0
    else if (pcb->nrtx == TCP_MAXRTX) {
 8005c60:	f04f 0801 	mov.w	r8, #1
 8005c64:	e08e      	b.n	8005d84 <tcp_slowtmr+0x1c8>
        if(pcb->rtime >= 0) {
 8005c66:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
 8005c6a:	2900      	cmp	r1, #0
          ++pcb->rtime;
 8005c6c:	bfa4      	itt	ge
 8005c6e:	3101      	addge	r1, #1
 8005c70:	86a1      	strhge	r1, [r4, #52]	; 0x34
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 8005c72:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8005c74:	b371      	cbz	r1, 8005cd4 <tcp_slowtmr+0x118>
 8005c76:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
 8005c7a:	f9b4 1044 	ldrsh.w	r1, [r4, #68]	; 0x44
 8005c7e:	4288      	cmp	r0, r1
 8005c80:	db28      	blt.n	8005cd4 <tcp_slowtmr+0x118>
          if (pcb->state != SYN_SENT) {
 8005c82:	2a02      	cmp	r2, #2
 8005c84:	d00b      	beq.n	8005c9e <tcp_slowtmr+0xe2>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 8005c86:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
 8005c8a:	f9b4 2042 	ldrsh.w	r2, [r4, #66]	; 0x42
 8005c8e:	eb02 02e1 	add.w	r2, r2, r1, asr #3
 8005c92:	4987      	ldr	r1, [pc, #540]	; (8005eb0 <tcp_slowtmr+0x2f4>)
 8005c94:	5ccb      	ldrb	r3, [r1, r3]
 8005c96:	fa02 f303 	lsl.w	r3, r2, r3
 8005c9a:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
          pcb->rtime = 0;
 8005c9e:	2300      	movs	r3, #0
 8005ca0:	86a3      	strh	r3, [r4, #52]	; 0x34
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 8005ca2:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 8005ca6:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
          pcb->ssthresh = eff_wnd >> 1;
 8005caa:	4293      	cmp	r3, r2
 8005cac:	bf28      	it	cs
 8005cae:	4613      	movcs	r3, r2
 8005cb0:	085b      	lsrs	r3, r3, #1
 8005cb2:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
          if (pcb->ssthresh < (pcb->mss << 1)) {
 8005cb6:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8005cb8:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
            pcb->ssthresh = (pcb->mss << 1);
 8005cbc:	bfbc      	itt	lt
 8005cbe:	0053      	lsllt	r3, r2, #1
 8005cc0:	f8a4 304e 	strhlt.w	r3, [r4, #78]	; 0x4e
          pcb->cwnd = pcb->mss;
 8005cc4:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
          tcp_rexmit_rto(pcb);
 8005cc8:	4620      	mov	r0, r4
 8005cca:	f002 f8d3 	bl	8007e74 <tcp_rexmit_rto>
 8005cce:	e001      	b.n	8005cd4 <tcp_slowtmr+0x118>
      ++pcb_remove;
 8005cd0:	f04f 0801 	mov.w	r8, #1
    if (pcb->state == FIN_WAIT_2) {
 8005cd4:	7e23      	ldrb	r3, [r4, #24]
 8005cd6:	2b06      	cmp	r3, #6
 8005cd8:	d020      	beq.n	8005d1c <tcp_slowtmr+0x160>
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
 8005cda:	7a22      	ldrb	r2, [r4, #8]
 8005cdc:	f012 0f08 	tst.w	r2, #8
 8005ce0:	d04e      	beq.n	8005d80 <tcp_slowtmr+0x1c4>
 8005ce2:	2b04      	cmp	r3, #4
 8005ce4:	d001      	beq.n	8005cea <tcp_slowtmr+0x12e>
       ((pcb->state == ESTABLISHED) ||
 8005ce6:	2b07      	cmp	r3, #7
 8005ce8:	d17e      	bne.n	8005de8 <tcp_slowtmr+0x22c>
      if((u32_t)(tcp_ticks - pcb->tmr) >
 8005cea:	4b6c      	ldr	r3, [pc, #432]	; (8005e9c <tcp_slowtmr+0x2e0>)
 8005cec:	681a      	ldr	r2, [r3, #0]
 8005cee:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005cf0:	1ad2      	subs	r2, r2, r3
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 8005cf2:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 8005cf6:	f501 2324 	add.w	r3, r1, #671744	; 0xa4000
 8005cfa:	f603 43b8 	addw	r3, r3, #3256	; 0xcb8
 8005cfe:	fbab 0303 	umull	r0, r3, fp, r3
      if((u32_t)(tcp_ticks - pcb->tmr) >
 8005d02:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 8005d06:	d91e      	bls.n	8005d46 <tcp_slowtmr+0x18a>
        ++pcb_remove;
 8005d08:	f108 0801 	add.w	r8, r8, #1
 8005d0c:	fa5f f888 	uxtb.w	r8, r8
        ++pcb_reset;
 8005d10:	f04f 0901 	mov.w	r9, #1
 8005d14:	e036      	b.n	8005d84 <tcp_slowtmr+0x1c8>
    pcb_remove = 0;
 8005d16:	f04f 0800 	mov.w	r8, #0
 8005d1a:	e7db      	b.n	8005cd4 <tcp_slowtmr+0x118>
      if (pcb->flags & TF_RXCLOSED) {
 8005d1c:	7fa3      	ldrb	r3, [r4, #30]
 8005d1e:	f013 0f10 	tst.w	r3, #16
 8005d22:	d009      	beq.n	8005d38 <tcp_slowtmr+0x17c>
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 8005d24:	4b5d      	ldr	r3, [pc, #372]	; (8005e9c <tcp_slowtmr+0x2e0>)
 8005d26:	681b      	ldr	r3, [r3, #0]
 8005d28:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8005d2a:	1a9b      	subs	r3, r3, r2
 8005d2c:	2b28      	cmp	r3, #40	; 0x28
 8005d2e:	d903      	bls.n	8005d38 <tcp_slowtmr+0x17c>
          ++pcb_remove;
 8005d30:	f108 0801 	add.w	r8, r8, #1
 8005d34:	fa5f f888 	uxtb.w	r8, r8
    if (pcb->ooseq != NULL &&
 8005d38:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8005d3a:	2800      	cmp	r0, #0
 8005d3c:	f000 80e1 	beq.w	8005f02 <tcp_slowtmr+0x346>
    pcb_reset = 0;
 8005d40:	f04f 0900 	mov.w	r9, #0
 8005d44:	e020      	b.n	8005d88 <tcp_slowtmr+0x1cc>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 8005d46:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
 8005d4a:	485a      	ldr	r0, [pc, #360]	; (8005eb4 <tcp_slowtmr+0x2f8>)
 8005d4c:	fb00 1303 	mla	r3, r0, r3, r1
              / TCP_SLOW_INTERVAL)
 8005d50:	fbab 1303 	umull	r1, r3, fp, r3
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 8005d54:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 8005d58:	d802      	bhi.n	8005d60 <tcp_slowtmr+0x1a4>
    pcb_reset = 0;
 8005d5a:	f04f 0900 	mov.w	r9, #0
 8005d5e:	e011      	b.n	8005d84 <tcp_slowtmr+0x1c8>
        tcp_keepalive(pcb);
 8005d60:	4620      	mov	r0, r4
 8005d62:	f002 f8f5 	bl	8007f50 <tcp_keepalive>
        pcb->keep_cnt_sent++;
 8005d66:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
 8005d6a:	3301      	adds	r3, #1
 8005d6c:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
    pcb_reset = 0;
 8005d70:	f04f 0900 	mov.w	r9, #0
 8005d74:	e006      	b.n	8005d84 <tcp_slowtmr+0x1c8>
 8005d76:	f04f 0900 	mov.w	r9, #0
 8005d7a:	f04f 0801 	mov.w	r8, #1
 8005d7e:	e001      	b.n	8005d84 <tcp_slowtmr+0x1c8>
 8005d80:	f04f 0900 	mov.w	r9, #0
    if (pcb->ooseq != NULL &&
 8005d84:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8005d86:	b150      	cbz	r0, 8005d9e <tcp_slowtmr+0x1e2>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
 8005d88:	4b44      	ldr	r3, [pc, #272]	; (8005e9c <tcp_slowtmr+0x2e0>)
 8005d8a:	681a      	ldr	r2, [r3, #0]
 8005d8c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005d8e:	1ad2      	subs	r2, r2, r3
 8005d90:	f9b4 3044 	ldrsh.w	r3, [r4, #68]	; 0x44
 8005d94:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    if (pcb->ooseq != NULL &&
 8005d98:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
 8005d9c:	d227      	bcs.n	8005dee <tcp_slowtmr+0x232>
    if (pcb->state == SYN_RCVD) {
 8005d9e:	7e23      	ldrb	r3, [r4, #24]
 8005da0:	2b03      	cmp	r3, #3
 8005da2:	d029      	beq.n	8005df8 <tcp_slowtmr+0x23c>
    if (pcb->state == LAST_ACK) {
 8005da4:	2b09      	cmp	r3, #9
 8005da6:	d032      	beq.n	8005e0e <tcp_slowtmr+0x252>
    if (pcb_remove) {
 8005da8:	f1b8 0f00 	cmp.w	r8, #0
 8005dac:	d13a      	bne.n	8005e24 <tcp_slowtmr+0x268>
      pcb = pcb->next;
 8005dae:	f8d4 800c 	ldr.w	r8, [r4, #12]
      ++prev->polltmr;
 8005db2:	7fe3      	ldrb	r3, [r4, #31]
 8005db4:	3301      	adds	r3, #1
 8005db6:	b2db      	uxtb	r3, r3
 8005db8:	77e3      	strb	r3, [r4, #31]
      if (prev->polltmr >= prev->pollinterval) {
 8005dba:	f894 2020 	ldrb.w	r2, [r4, #32]
 8005dbe:	429a      	cmp	r2, r3
 8005dc0:	d869      	bhi.n	8005e96 <tcp_slowtmr+0x2da>
        prev->polltmr = 0;
 8005dc2:	2300      	movs	r3, #0
 8005dc4:	77e3      	strb	r3, [r4, #31]
        tcp_active_pcbs_changed = 0;
 8005dc6:	703b      	strb	r3, [r7, #0]
        TCP_EVENT_POLL(prev, err);
 8005dc8:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8005dcc:	2b00      	cmp	r3, #0
 8005dce:	d05a      	beq.n	8005e86 <tcp_slowtmr+0x2ca>
 8005dd0:	4621      	mov	r1, r4
 8005dd2:	6920      	ldr	r0, [r4, #16]
 8005dd4:	4798      	blx	r3
        if (tcp_active_pcbs_changed) {
 8005dd6:	783b      	ldrb	r3, [r7, #0]
 8005dd8:	2b00      	cmp	r3, #0
 8005dda:	f47f aefe 	bne.w	8005bda <tcp_slowtmr+0x1e>
        if (err == ERR_OK) {
 8005dde:	2800      	cmp	r0, #0
 8005de0:	d051      	beq.n	8005e86 <tcp_slowtmr+0x2ca>
 8005de2:	4626      	mov	r6, r4
      pcb = pcb->next;
 8005de4:	4644      	mov	r4, r8
 8005de6:	e700      	b.n	8005bea <tcp_slowtmr+0x2e>
    pcb_reset = 0;
 8005de8:	f04f 0900 	mov.w	r9, #0
 8005dec:	e7ca      	b.n	8005d84 <tcp_slowtmr+0x1c8>
      tcp_segs_free(pcb->ooseq);
 8005dee:	f7ff fea4 	bl	8005b3a <tcp_segs_free>
      pcb->ooseq = NULL;
 8005df2:	2300      	movs	r3, #0
 8005df4:	6763      	str	r3, [r4, #116]	; 0x74
 8005df6:	e7d2      	b.n	8005d9e <tcp_slowtmr+0x1e2>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 8005df8:	4b28      	ldr	r3, [pc, #160]	; (8005e9c <tcp_slowtmr+0x2e0>)
 8005dfa:	681b      	ldr	r3, [r3, #0]
 8005dfc:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8005dfe:	1a9b      	subs	r3, r3, r2
 8005e00:	2b28      	cmp	r3, #40	; 0x28
 8005e02:	d9d1      	bls.n	8005da8 <tcp_slowtmr+0x1ec>
        ++pcb_remove;
 8005e04:	f108 0801 	add.w	r8, r8, #1
 8005e08:	fa5f f888 	uxtb.w	r8, r8
 8005e0c:	e7cc      	b.n	8005da8 <tcp_slowtmr+0x1ec>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8005e0e:	4b23      	ldr	r3, [pc, #140]	; (8005e9c <tcp_slowtmr+0x2e0>)
 8005e10:	681b      	ldr	r3, [r3, #0]
 8005e12:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8005e14:	1a9b      	subs	r3, r3, r2
 8005e16:	2bf0      	cmp	r3, #240	; 0xf0
        ++pcb_remove;
 8005e18:	bf84      	itt	hi
 8005e1a:	f108 0801 	addhi.w	r8, r8, #1
 8005e1e:	fa5f f888 	uxtbhi.w	r8, r8
 8005e22:	e7c1      	b.n	8005da8 <tcp_slowtmr+0x1ec>
      tcp_pcb_purge(pcb);
 8005e24:	4620      	mov	r0, r4
 8005e26:	f7ff fea8 	bl	8005b7a <tcp_pcb_purge>
      if (prev != NULL) {
 8005e2a:	b1ee      	cbz	r6, 8005e68 <tcp_slowtmr+0x2ac>
        prev->next = pcb->next;
 8005e2c:	68e3      	ldr	r3, [r4, #12]
 8005e2e:	60f3      	str	r3, [r6, #12]
      if (pcb_reset) {
 8005e30:	f1b9 0f00 	cmp.w	r9, #0
 8005e34:	d11c      	bne.n	8005e70 <tcp_slowtmr+0x2b4>
      err_fn = pcb->errf;
 8005e36:	f8d4 808c 	ldr.w	r8, [r4, #140]	; 0x8c
      err_arg = pcb->callback_arg;
 8005e3a:	f8d4 a010 	ldr.w	sl, [r4, #16]
      pcb = pcb->next;
 8005e3e:	f8d4 900c 	ldr.w	r9, [r4, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 8005e42:	4621      	mov	r1, r4
 8005e44:	2002      	movs	r0, #2
 8005e46:	f7ff fb35 	bl	80054b4 <memp_free>
      tcp_active_pcbs_changed = 0;
 8005e4a:	2300      	movs	r3, #0
 8005e4c:	703b      	strb	r3, [r7, #0]
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
 8005e4e:	f1b8 0f00 	cmp.w	r8, #0
 8005e52:	d01e      	beq.n	8005e92 <tcp_slowtmr+0x2d6>
 8005e54:	f06f 0109 	mvn.w	r1, #9
 8005e58:	4650      	mov	r0, sl
 8005e5a:	47c0      	blx	r8
      if (tcp_active_pcbs_changed) {
 8005e5c:	783b      	ldrb	r3, [r7, #0]
 8005e5e:	2b00      	cmp	r3, #0
 8005e60:	f47f aebb 	bne.w	8005bda <tcp_slowtmr+0x1e>
      pcb = pcb->next;
 8005e64:	464c      	mov	r4, r9
 8005e66:	e6c0      	b.n	8005bea <tcp_slowtmr+0x2e>
        tcp_active_pcbs = pcb->next;
 8005e68:	68e3      	ldr	r3, [r4, #12]
 8005e6a:	4a0f      	ldr	r2, [pc, #60]	; (8005ea8 <tcp_slowtmr+0x2ec>)
 8005e6c:	6013      	str	r3, [r2, #0]
 8005e6e:	e7df      	b.n	8005e30 <tcp_slowtmr+0x274>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8005e70:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8005e72:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8005e74:	8ba3      	ldrh	r3, [r4, #28]
 8005e76:	9301      	str	r3, [sp, #4]
 8005e78:	8b63      	ldrh	r3, [r4, #26]
 8005e7a:	9300      	str	r3, [sp, #0]
 8005e7c:	1d23      	adds	r3, r4, #4
 8005e7e:	4622      	mov	r2, r4
 8005e80:	f001 ffa6 	bl	8007dd0 <tcp_rst>
 8005e84:	e7d7      	b.n	8005e36 <tcp_slowtmr+0x27a>
          tcp_output(prev);
 8005e86:	4620      	mov	r0, r4
 8005e88:	f001 fe4a 	bl	8007b20 <tcp_output>
 8005e8c:	4626      	mov	r6, r4
      pcb = pcb->next;
 8005e8e:	4644      	mov	r4, r8
 8005e90:	e6ab      	b.n	8005bea <tcp_slowtmr+0x2e>
      pcb = pcb->next;
 8005e92:	464c      	mov	r4, r9
 8005e94:	e6a9      	b.n	8005bea <tcp_slowtmr+0x2e>
 8005e96:	4626      	mov	r6, r4
      pcb = pcb->next;
 8005e98:	4644      	mov	r4, r8
 8005e9a:	e6a6      	b.n	8005bea <tcp_slowtmr+0x2e>
 8005e9c:	2000b1a4 	.word	0x2000b1a4
 8005ea0:	200076f9 	.word	0x200076f9
 8005ea4:	2000b19c 	.word	0x2000b19c
 8005ea8:	2000b1a0 	.word	0x2000b1a0
 8005eac:	0800904c 	.word	0x0800904c
 8005eb0:	0800903c 	.word	0x0800903c
 8005eb4:	000124f8 	.word	0x000124f8
 8005eb8:	10624dd3 	.word	0x10624dd3
  pcb = tcp_tw_pcbs;
 8005ebc:	4b14      	ldr	r3, [pc, #80]	; (8005f10 <tcp_slowtmr+0x354>)
 8005ebe:	681c      	ldr	r4, [r3, #0]
  while (pcb != NULL) {
 8005ec0:	b314      	cbz	r4, 8005f08 <tcp_slowtmr+0x34c>
 8005ec2:	2500      	movs	r5, #0
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8005ec4:	4e13      	ldr	r6, [pc, #76]	; (8005f14 <tcp_slowtmr+0x358>)
      memp_free(MEMP_TCP_PCB, pcb2);
 8005ec6:	2702      	movs	r7, #2
        tcp_tw_pcbs = pcb->next;
 8005ec8:	4698      	mov	r8, r3
 8005eca:	e006      	b.n	8005eda <tcp_slowtmr+0x31e>
 8005ecc:	68e3      	ldr	r3, [r4, #12]
 8005ece:	f8c8 3000 	str.w	r3, [r8]
 8005ed2:	e00e      	b.n	8005ef2 <tcp_slowtmr+0x336>
      pcb = pcb->next;
 8005ed4:	4625      	mov	r5, r4
 8005ed6:	68e4      	ldr	r4, [r4, #12]
  while (pcb != NULL) {
 8005ed8:	b1b4      	cbz	r4, 8005f08 <tcp_slowtmr+0x34c>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8005eda:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8005edc:	6833      	ldr	r3, [r6, #0]
 8005ede:	1a9b      	subs	r3, r3, r2
    if (pcb_remove) {
 8005ee0:	2bf0      	cmp	r3, #240	; 0xf0
 8005ee2:	d9f7      	bls.n	8005ed4 <tcp_slowtmr+0x318>
      tcp_pcb_purge(pcb);
 8005ee4:	4620      	mov	r0, r4
 8005ee6:	f7ff fe48 	bl	8005b7a <tcp_pcb_purge>
      if (prev != NULL) {
 8005eea:	2d00      	cmp	r5, #0
 8005eec:	d0ee      	beq.n	8005ecc <tcp_slowtmr+0x310>
        prev->next = pcb->next;
 8005eee:	68e3      	ldr	r3, [r4, #12]
 8005ef0:	60eb      	str	r3, [r5, #12]
      pcb = pcb->next;
 8005ef2:	f8d4 900c 	ldr.w	r9, [r4, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 8005ef6:	4621      	mov	r1, r4
 8005ef8:	4638      	mov	r0, r7
 8005efa:	f7ff fadb 	bl	80054b4 <memp_free>
      pcb = pcb->next;
 8005efe:	464c      	mov	r4, r9
 8005f00:	e7ea      	b.n	8005ed8 <tcp_slowtmr+0x31c>
    pcb_reset = 0;
 8005f02:	f04f 0900 	mov.w	r9, #0
 8005f06:	e74f      	b.n	8005da8 <tcp_slowtmr+0x1ec>
}
 8005f08:	b003      	add	sp, #12
 8005f0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005f0e:	bf00      	nop
 8005f10:	2000b1b4 	.word	0x2000b1b4
 8005f14:	2000b1a4 	.word	0x2000b1a4

08005f18 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 8005f18:	b510      	push	{r4, lr}
 8005f1a:	460c      	mov	r4, r1
  TCP_RMV(pcblist, pcb);
 8005f1c:	6802      	ldr	r2, [r0, #0]
 8005f1e:	428a      	cmp	r2, r1
 8005f20:	d00b      	beq.n	8005f3a <tcp_pcb_remove+0x22>
 8005f22:	4b18      	ldr	r3, [pc, #96]	; (8005f84 <tcp_pcb_remove+0x6c>)
 8005f24:	601a      	str	r2, [r3, #0]
 8005f26:	b17a      	cbz	r2, 8005f48 <tcp_pcb_remove+0x30>
 8005f28:	68d3      	ldr	r3, [r2, #12]
 8005f2a:	4299      	cmp	r1, r3
 8005f2c:	d01d      	beq.n	8005f6a <tcp_pcb_remove+0x52>
 8005f2e:	b1f3      	cbz	r3, 8005f6e <tcp_pcb_remove+0x56>
 8005f30:	68da      	ldr	r2, [r3, #12]
 8005f32:	4294      	cmp	r4, r2
 8005f34:	d004      	beq.n	8005f40 <tcp_pcb_remove+0x28>
 8005f36:	4613      	mov	r3, r2
 8005f38:	e7f9      	b.n	8005f2e <tcp_pcb_remove+0x16>
 8005f3a:	68d3      	ldr	r3, [r2, #12]
 8005f3c:	6003      	str	r3, [r0, #0]
 8005f3e:	e003      	b.n	8005f48 <tcp_pcb_remove+0x30>
 8005f40:	4a10      	ldr	r2, [pc, #64]	; (8005f84 <tcp_pcb_remove+0x6c>)
 8005f42:	6013      	str	r3, [r2, #0]
 8005f44:	68e2      	ldr	r2, [r4, #12]
 8005f46:	60da      	str	r2, [r3, #12]
 8005f48:	2300      	movs	r3, #0
 8005f4a:	60e3      	str	r3, [r4, #12]

  tcp_pcb_purge(pcb);
 8005f4c:	4620      	mov	r0, r4
 8005f4e:	f7ff fe14 	bl	8005b7a <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 8005f52:	7e23      	ldrb	r3, [r4, #24]
 8005f54:	2b0a      	cmp	r3, #10
 8005f56:	d005      	beq.n	8005f64 <tcp_pcb_remove+0x4c>
 8005f58:	2b01      	cmp	r3, #1
 8005f5a:	d003      	beq.n	8005f64 <tcp_pcb_remove+0x4c>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 8005f5c:	7fa3      	ldrb	r3, [r4, #30]
     pcb->state != LISTEN &&
 8005f5e:	f013 0f01 	tst.w	r3, #1
 8005f62:	d108      	bne.n	8005f76 <tcp_pcb_remove+0x5e>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 8005f64:	2300      	movs	r3, #0
 8005f66:	7623      	strb	r3, [r4, #24]
 8005f68:	bd10      	pop	{r4, pc}
  TCP_RMV(pcblist, pcb);
 8005f6a:	4613      	mov	r3, r2
 8005f6c:	e7ea      	b.n	8005f44 <tcp_pcb_remove+0x2c>
 8005f6e:	2200      	movs	r2, #0
 8005f70:	4b04      	ldr	r3, [pc, #16]	; (8005f84 <tcp_pcb_remove+0x6c>)
 8005f72:	601a      	str	r2, [r3, #0]
 8005f74:	e7e8      	b.n	8005f48 <tcp_pcb_remove+0x30>
    pcb->flags |= TF_ACK_NOW;
 8005f76:	f043 0302 	orr.w	r3, r3, #2
 8005f7a:	77a3      	strb	r3, [r4, #30]
    tcp_output(pcb);
 8005f7c:	4620      	mov	r0, r4
 8005f7e:	f001 fdcf 	bl	8007b20 <tcp_output>
 8005f82:	e7ef      	b.n	8005f64 <tcp_pcb_remove+0x4c>
 8005f84:	2000b1ac 	.word	0x2000b1ac

08005f88 <tcp_close_shutdown>:
{
 8005f88:	b510      	push	{r4, lr}
 8005f8a:	b082      	sub	sp, #8
 8005f8c:	4604      	mov	r4, r0
  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 8005f8e:	b121      	cbz	r1, 8005f9a <tcp_close_shutdown+0x12>
 8005f90:	7e03      	ldrb	r3, [r0, #24]
 8005f92:	2b04      	cmp	r3, #4
 8005f94:	d00b      	beq.n	8005fae <tcp_close_shutdown+0x26>
 8005f96:	2b07      	cmp	r3, #7
 8005f98:	d009      	beq.n	8005fae <tcp_close_shutdown+0x26>
  switch (pcb->state) {
 8005f9a:	7e23      	ldrb	r3, [r4, #24]
 8005f9c:	2b07      	cmp	r3, #7
 8005f9e:	f200 80ae 	bhi.w	80060fe <tcp_close_shutdown+0x176>
 8005fa2:	e8df f003 	tbb	[pc, r3]
 8005fa6:	774e      	.short	0x774e
 8005fa8:	ac9a8c80 	.word	0xac9a8c80
 8005fac:	a3ac      	.short	0xa3ac
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 8005fae:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8005fb0:	b1e3      	cbz	r3, 8005fec <tcp_close_shutdown+0x64>
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8005fb2:	8ba3      	ldrh	r3, [r4, #28]
 8005fb4:	9301      	str	r3, [sp, #4]
 8005fb6:	8b63      	ldrh	r3, [r4, #26]
 8005fb8:	9300      	str	r3, [sp, #0]
 8005fba:	1d23      	adds	r3, r4, #4
 8005fbc:	4622      	mov	r2, r4
 8005fbe:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8005fc0:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8005fc2:	f001 ff05 	bl	8007dd0 <tcp_rst>
      tcp_pcb_purge(pcb);
 8005fc6:	4620      	mov	r0, r4
 8005fc8:	f7ff fdd7 	bl	8005b7a <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8005fcc:	4b4e      	ldr	r3, [pc, #312]	; (8006108 <tcp_close_shutdown+0x180>)
 8005fce:	681a      	ldr	r2, [r3, #0]
 8005fd0:	4294      	cmp	r4, r2
 8005fd2:	d011      	beq.n	8005ff8 <tcp_close_shutdown+0x70>
 8005fd4:	4b4d      	ldr	r3, [pc, #308]	; (800610c <tcp_close_shutdown+0x184>)
 8005fd6:	601a      	str	r2, [r3, #0]
 8005fd8:	b1aa      	cbz	r2, 8006006 <tcp_close_shutdown+0x7e>
 8005fda:	68d3      	ldr	r3, [r2, #12]
 8005fdc:	429c      	cmp	r4, r3
 8005fde:	d020      	beq.n	8006022 <tcp_close_shutdown+0x9a>
 8005fe0:	b30b      	cbz	r3, 8006026 <tcp_close_shutdown+0x9e>
 8005fe2:	68da      	ldr	r2, [r3, #12]
 8005fe4:	4294      	cmp	r4, r2
 8005fe6:	d00a      	beq.n	8005ffe <tcp_close_shutdown+0x76>
 8005fe8:	4613      	mov	r3, r2
 8005fea:	e7f9      	b.n	8005fe0 <tcp_close_shutdown+0x58>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 8005fec:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 8005fee:	f241 63d0 	movw	r3, #5840	; 0x16d0
 8005ff2:	429a      	cmp	r2, r3
 8005ff4:	d1dd      	bne.n	8005fb2 <tcp_close_shutdown+0x2a>
 8005ff6:	e7d0      	b.n	8005f9a <tcp_close_shutdown+0x12>
      TCP_RMV_ACTIVE(pcb);
 8005ff8:	68d2      	ldr	r2, [r2, #12]
 8005ffa:	601a      	str	r2, [r3, #0]
 8005ffc:	e003      	b.n	8006006 <tcp_close_shutdown+0x7e>
 8005ffe:	4a43      	ldr	r2, [pc, #268]	; (800610c <tcp_close_shutdown+0x184>)
 8006000:	6013      	str	r3, [r2, #0]
 8006002:	68e2      	ldr	r2, [r4, #12]
 8006004:	60da      	str	r2, [r3, #12]
 8006006:	2300      	movs	r3, #0
 8006008:	60e3      	str	r3, [r4, #12]
 800600a:	2201      	movs	r2, #1
 800600c:	4b40      	ldr	r3, [pc, #256]	; (8006110 <tcp_close_shutdown+0x188>)
 800600e:	701a      	strb	r2, [r3, #0]
      if (pcb->state == ESTABLISHED) {
 8006010:	7e23      	ldrb	r3, [r4, #24]
 8006012:	2b04      	cmp	r3, #4
 8006014:	d00b      	beq.n	800602e <tcp_close_shutdown+0xa6>
        memp_free(MEMP_TCP_PCB, pcb);
 8006016:	4621      	mov	r1, r4
 8006018:	2002      	movs	r0, #2
 800601a:	f7ff fa4b 	bl	80054b4 <memp_free>
      return ERR_OK;
 800601e:	2300      	movs	r3, #0
 8006020:	e02f      	b.n	8006082 <tcp_close_shutdown+0xfa>
      TCP_RMV_ACTIVE(pcb);
 8006022:	4613      	mov	r3, r2
 8006024:	e7ed      	b.n	8006002 <tcp_close_shutdown+0x7a>
 8006026:	2200      	movs	r2, #0
 8006028:	4b38      	ldr	r3, [pc, #224]	; (800610c <tcp_close_shutdown+0x184>)
 800602a:	601a      	str	r2, [r3, #0]
 800602c:	e7eb      	b.n	8006006 <tcp_close_shutdown+0x7e>
        pcb->state = TIME_WAIT;
 800602e:	230a      	movs	r3, #10
 8006030:	7623      	strb	r3, [r4, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 8006032:	4b38      	ldr	r3, [pc, #224]	; (8006114 <tcp_close_shutdown+0x18c>)
 8006034:	681a      	ldr	r2, [r3, #0]
 8006036:	60e2      	str	r2, [r4, #12]
 8006038:	601c      	str	r4, [r3, #0]
 800603a:	f002 f853 	bl	80080e4 <tcp_timer_needed>
      return ERR_OK;
 800603e:	2300      	movs	r3, #0
 8006040:	e01f      	b.n	8006082 <tcp_close_shutdown+0xfa>
    if (pcb->local_port != 0) {
 8006042:	8b63      	ldrh	r3, [r4, #26]
 8006044:	b1c3      	cbz	r3, 8006078 <tcp_close_shutdown+0xf0>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8006046:	4b34      	ldr	r3, [pc, #208]	; (8006118 <tcp_close_shutdown+0x190>)
 8006048:	681a      	ldr	r2, [r3, #0]
 800604a:	4294      	cmp	r4, r2
 800604c:	d00b      	beq.n	8006066 <tcp_close_shutdown+0xde>
 800604e:	4b2f      	ldr	r3, [pc, #188]	; (800610c <tcp_close_shutdown+0x184>)
 8006050:	601a      	str	r2, [r3, #0]
 8006052:	b17a      	cbz	r2, 8006074 <tcp_close_shutdown+0xec>
 8006054:	68d3      	ldr	r3, [r2, #12]
 8006056:	429c      	cmp	r4, r3
 8006058:	d016      	beq.n	8006088 <tcp_close_shutdown+0x100>
 800605a:	b1bb      	cbz	r3, 800608c <tcp_close_shutdown+0x104>
 800605c:	68da      	ldr	r2, [r3, #12]
 800605e:	4294      	cmp	r4, r2
 8006060:	d004      	beq.n	800606c <tcp_close_shutdown+0xe4>
 8006062:	4613      	mov	r3, r2
 8006064:	e7f9      	b.n	800605a <tcp_close_shutdown+0xd2>
 8006066:	68d2      	ldr	r2, [r2, #12]
 8006068:	601a      	str	r2, [r3, #0]
 800606a:	e003      	b.n	8006074 <tcp_close_shutdown+0xec>
 800606c:	4a27      	ldr	r2, [pc, #156]	; (800610c <tcp_close_shutdown+0x184>)
 800606e:	6013      	str	r3, [r2, #0]
 8006070:	68e2      	ldr	r2, [r4, #12]
 8006072:	60da      	str	r2, [r3, #12]
 8006074:	2300      	movs	r3, #0
 8006076:	60e3      	str	r3, [r4, #12]
    memp_free(MEMP_TCP_PCB, pcb);
 8006078:	4621      	mov	r1, r4
 800607a:	2002      	movs	r0, #2
 800607c:	f7ff fa1a 	bl	80054b4 <memp_free>
    err = ERR_OK;
 8006080:	2300      	movs	r3, #0
}
 8006082:	4618      	mov	r0, r3
 8006084:	b002      	add	sp, #8
 8006086:	bd10      	pop	{r4, pc}
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8006088:	4613      	mov	r3, r2
 800608a:	e7f1      	b.n	8006070 <tcp_close_shutdown+0xe8>
 800608c:	2200      	movs	r2, #0
 800608e:	4b1f      	ldr	r3, [pc, #124]	; (800610c <tcp_close_shutdown+0x184>)
 8006090:	601a      	str	r2, [r3, #0]
 8006092:	e7ef      	b.n	8006074 <tcp_close_shutdown+0xec>
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 8006094:	4621      	mov	r1, r4
 8006096:	4821      	ldr	r0, [pc, #132]	; (800611c <tcp_close_shutdown+0x194>)
 8006098:	f7ff ff3e 	bl	8005f18 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 800609c:	4621      	mov	r1, r4
 800609e:	2003      	movs	r0, #3
 80060a0:	f7ff fa08 	bl	80054b4 <memp_free>
    break;
 80060a4:	e7ec      	b.n	8006080 <tcp_close_shutdown+0xf8>
    TCP_PCB_REMOVE_ACTIVE(pcb);
 80060a6:	4621      	mov	r1, r4
 80060a8:	4817      	ldr	r0, [pc, #92]	; (8006108 <tcp_close_shutdown+0x180>)
 80060aa:	f7ff ff35 	bl	8005f18 <tcp_pcb_remove>
 80060ae:	2201      	movs	r2, #1
 80060b0:	4b17      	ldr	r3, [pc, #92]	; (8006110 <tcp_close_shutdown+0x188>)
 80060b2:	701a      	strb	r2, [r3, #0]
    memp_free(MEMP_TCP_PCB, pcb);
 80060b4:	4621      	mov	r1, r4
 80060b6:	2002      	movs	r0, #2
 80060b8:	f7ff f9fc 	bl	80054b4 <memp_free>
    break;
 80060bc:	e7e0      	b.n	8006080 <tcp_close_shutdown+0xf8>
    err = tcp_send_fin(pcb);
 80060be:	4620      	mov	r0, r4
 80060c0:	f001 fcdc 	bl	8007a7c <tcp_send_fin>
    if (err == ERR_OK) {
 80060c4:	4603      	mov	r3, r0
 80060c6:	2800      	cmp	r0, #0
 80060c8:	d1db      	bne.n	8006082 <tcp_close_shutdown+0xfa>
      pcb->state = FIN_WAIT_1;
 80060ca:	2305      	movs	r3, #5
 80060cc:	7623      	strb	r3, [r4, #24]
  if (pcb != NULL && err == ERR_OK) {
 80060ce:	b1c4      	cbz	r4, 8006102 <tcp_close_shutdown+0x17a>
    tcp_output(pcb);
 80060d0:	4620      	mov	r0, r4
 80060d2:	f001 fd25 	bl	8007b20 <tcp_output>
  return err;
 80060d6:	2300      	movs	r3, #0
 80060d8:	e7d3      	b.n	8006082 <tcp_close_shutdown+0xfa>
    err = tcp_send_fin(pcb);
 80060da:	4620      	mov	r0, r4
 80060dc:	f001 fcce 	bl	8007a7c <tcp_send_fin>
    if (err == ERR_OK) {
 80060e0:	4603      	mov	r3, r0
 80060e2:	2800      	cmp	r0, #0
 80060e4:	d1cd      	bne.n	8006082 <tcp_close_shutdown+0xfa>
      pcb->state = FIN_WAIT_1;
 80060e6:	2305      	movs	r3, #5
 80060e8:	7623      	strb	r3, [r4, #24]
 80060ea:	e7f0      	b.n	80060ce <tcp_close_shutdown+0x146>
    err = tcp_send_fin(pcb);
 80060ec:	4620      	mov	r0, r4
 80060ee:	f001 fcc5 	bl	8007a7c <tcp_send_fin>
    if (err == ERR_OK) {
 80060f2:	4603      	mov	r3, r0
 80060f4:	2800      	cmp	r0, #0
 80060f6:	d1c4      	bne.n	8006082 <tcp_close_shutdown+0xfa>
      pcb->state = LAST_ACK;
 80060f8:	2309      	movs	r3, #9
 80060fa:	7623      	strb	r3, [r4, #24]
 80060fc:	e7e7      	b.n	80060ce <tcp_close_shutdown+0x146>
    err = ERR_OK;
 80060fe:	2300      	movs	r3, #0
 8006100:	e7bf      	b.n	8006082 <tcp_close_shutdown+0xfa>
  if (pcb != NULL && err == ERR_OK) {
 8006102:	2300      	movs	r3, #0
 8006104:	e7bd      	b.n	8006082 <tcp_close_shutdown+0xfa>
 8006106:	bf00      	nop
 8006108:	2000b1a0 	.word	0x2000b1a0
 800610c:	2000b1ac 	.word	0x2000b1ac
 8006110:	2000b19c 	.word	0x2000b19c
 8006114:	2000b1b4 	.word	0x2000b1b4
 8006118:	2000b1b0 	.word	0x2000b1b0
 800611c:	2000b1a8 	.word	0x2000b1a8

08006120 <tcp_close>:
{
 8006120:	b508      	push	{r3, lr}
  if (pcb->state != LISTEN) {
 8006122:	7e03      	ldrb	r3, [r0, #24]
 8006124:	2b01      	cmp	r3, #1
 8006126:	d003      	beq.n	8006130 <tcp_close+0x10>
    pcb->flags |= TF_RXCLOSED;
 8006128:	7f83      	ldrb	r3, [r0, #30]
 800612a:	f043 0310 	orr.w	r3, r3, #16
 800612e:	7783      	strb	r3, [r0, #30]
  return tcp_close_shutdown(pcb, 1);
 8006130:	2101      	movs	r1, #1
 8006132:	f7ff ff29 	bl	8005f88 <tcp_close_shutdown>
}
 8006136:	bd08      	pop	{r3, pc}

08006138 <tcp_recv_null>:
{
 8006138:	b510      	push	{r4, lr}
 800613a:	4608      	mov	r0, r1
  if (p != NULL) {
 800613c:	b142      	cbz	r2, 8006150 <tcp_recv_null+0x18>
 800613e:	4614      	mov	r4, r2
    tcp_recved(pcb, p->tot_len);
 8006140:	8911      	ldrh	r1, [r2, #8]
 8006142:	f7ff fcd1 	bl	8005ae8 <tcp_recved>
    pbuf_free(p);
 8006146:	4620      	mov	r0, r4
 8006148:	f7ff faab 	bl	80056a2 <pbuf_free>
  return ERR_OK;
 800614c:	2000      	movs	r0, #0
 800614e:	bd10      	pop	{r4, pc}
  } else if (err == ERR_OK) {
 8006150:	b10b      	cbz	r3, 8006156 <tcp_recv_null+0x1e>
  return ERR_OK;
 8006152:	2000      	movs	r0, #0
}
 8006154:	bd10      	pop	{r4, pc}
    return tcp_close(pcb);
 8006156:	f7ff ffe3 	bl	8006120 <tcp_close>
 800615a:	bd10      	pop	{r4, pc}

0800615c <tcp_process_refused_data>:
{
 800615c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800615e:	4604      	mov	r4, r0
  u8_t refused_flags = pcb->refused_data->flags;
 8006160:	6f86      	ldr	r6, [r0, #120]	; 0x78
 8006162:	7b77      	ldrb	r7, [r6, #13]
  pcb->refused_data = NULL;
 8006164:	2300      	movs	r3, #0
 8006166:	6783      	str	r3, [r0, #120]	; 0x78
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 8006168:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
 800616c:	b1e5      	cbz	r5, 80061a8 <tcp_process_refused_data+0x4c>
 800616e:	4632      	mov	r2, r6
 8006170:	4601      	mov	r1, r0
 8006172:	6900      	ldr	r0, [r0, #16]
 8006174:	47a8      	blx	r5
 8006176:	4605      	mov	r5, r0
  if (err == ERR_OK) {
 8006178:	b9f5      	cbnz	r5, 80061b8 <tcp_process_refused_data+0x5c>
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
 800617a:	f017 0f20 	tst.w	r7, #32
 800617e:	d020      	beq.n	80061c2 <tcp_process_refused_data+0x66>
      if (pcb->rcv_wnd != TCP_WND) {
 8006180:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006182:	f241 62d0 	movw	r2, #5840	; 0x16d0
 8006186:	4293      	cmp	r3, r2
        pcb->rcv_wnd++;
 8006188:	bf1c      	itt	ne
 800618a:	3301      	addne	r3, #1
 800618c:	85a3      	strhne	r3, [r4, #44]	; 0x2c
      TCP_EVENT_CLOSED(pcb, err);
 800618e:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
 8006192:	b1b6      	cbz	r6, 80061c2 <tcp_process_refused_data+0x66>
 8006194:	2300      	movs	r3, #0
 8006196:	461a      	mov	r2, r3
 8006198:	4621      	mov	r1, r4
 800619a:	6920      	ldr	r0, [r4, #16]
 800619c:	47b0      	blx	r6
        return ERR_ABRT;
 800619e:	f110 0f0a 	cmn.w	r0, #10
 80061a2:	bf08      	it	eq
 80061a4:	4605      	moveq	r5, r0
 80061a6:	e00c      	b.n	80061c2 <tcp_process_refused_data+0x66>
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 80061a8:	2300      	movs	r3, #0
 80061aa:	4632      	mov	r2, r6
 80061ac:	4601      	mov	r1, r0
 80061ae:	4618      	mov	r0, r3
 80061b0:	f7ff ffc2 	bl	8006138 <tcp_recv_null>
 80061b4:	4605      	mov	r5, r0
 80061b6:	e7df      	b.n	8006178 <tcp_process_refused_data+0x1c>
  } else if (err == ERR_ABRT) {
 80061b8:	f115 0f0a 	cmn.w	r5, #10
    pcb->refused_data = refused_data;
 80061bc:	bf1c      	itt	ne
 80061be:	67a6      	strne	r6, [r4, #120]	; 0x78
  return ERR_OK;
 80061c0:	2500      	movne	r5, #0
}
 80061c2:	4628      	mov	r0, r5
 80061c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080061c8 <tcp_fasttmr>:
{
 80061c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  ++tcp_timer_ctr;
 80061cc:	4a18      	ldr	r2, [pc, #96]	; (8006230 <tcp_fasttmr+0x68>)
 80061ce:	7813      	ldrb	r3, [r2, #0]
 80061d0:	3301      	adds	r3, #1
 80061d2:	7013      	strb	r3, [r2, #0]
  pcb = tcp_active_pcbs;
 80061d4:	4f17      	ldr	r7, [pc, #92]	; (8006234 <tcp_fasttmr+0x6c>)
    if (pcb->last_timer != tcp_timer_ctr) {
 80061d6:	4615      	mov	r5, r2
        tcp_active_pcbs_changed = 0;
 80061d8:	4e17      	ldr	r6, [pc, #92]	; (8006238 <tcp_fasttmr+0x70>)
 80061da:	f04f 0800 	mov.w	r8, #0
  pcb = tcp_active_pcbs;
 80061de:	683c      	ldr	r4, [r7, #0]
  while(pcb != NULL) {
 80061e0:	b324      	cbz	r4, 800622c <tcp_fasttmr+0x64>
    if (pcb->last_timer != tcp_timer_ctr) {
 80061e2:	782b      	ldrb	r3, [r5, #0]
 80061e4:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 80061e8:	429a      	cmp	r2, r3
 80061ea:	d100      	bne.n	80061ee <tcp_fasttmr+0x26>
 80061ec:	e7fe      	b.n	80061ec <tcp_fasttmr+0x24>
      pcb->last_timer = tcp_timer_ctr;
 80061ee:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
      if (pcb->flags & TF_ACK_DELAY) {
 80061f2:	7fa3      	ldrb	r3, [r4, #30]
 80061f4:	f013 0f01 	tst.w	r3, #1
 80061f8:	d10d      	bne.n	8006216 <tcp_fasttmr+0x4e>
      next = pcb->next;
 80061fa:	f8d4 900c 	ldr.w	r9, [r4, #12]
      if (pcb->refused_data != NULL) {
 80061fe:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8006200:	b13b      	cbz	r3, 8006212 <tcp_fasttmr+0x4a>
        tcp_active_pcbs_changed = 0;
 8006202:	f886 8000 	strb.w	r8, [r6]
        tcp_process_refused_data(pcb);
 8006206:	4620      	mov	r0, r4
 8006208:	f7ff ffa8 	bl	800615c <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 800620c:	7833      	ldrb	r3, [r6, #0]
 800620e:	2b00      	cmp	r3, #0
 8006210:	d1e5      	bne.n	80061de <tcp_fasttmr+0x16>
{
 8006212:	464c      	mov	r4, r9
 8006214:	e7e4      	b.n	80061e0 <tcp_fasttmr+0x18>
        tcp_ack_now(pcb);
 8006216:	f043 0302 	orr.w	r3, r3, #2
 800621a:	77a3      	strb	r3, [r4, #30]
        tcp_output(pcb);
 800621c:	4620      	mov	r0, r4
 800621e:	f001 fc7f 	bl	8007b20 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8006222:	7fa3      	ldrb	r3, [r4, #30]
 8006224:	f023 0303 	bic.w	r3, r3, #3
 8006228:	77a3      	strb	r3, [r4, #30]
 800622a:	e7e6      	b.n	80061fa <tcp_fasttmr+0x32>
 800622c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006230:	200076f9 	.word	0x200076f9
 8006234:	2000b1a0 	.word	0x2000b1a0
 8006238:	2000b19c 	.word	0x2000b19c

0800623c <tcp_tmr>:
{
 800623c:	b508      	push	{r3, lr}
  tcp_fasttmr();
 800623e:	f7ff ffc3 	bl	80061c8 <tcp_fasttmr>
  if (++tcp_timer & 1) {
 8006242:	4a06      	ldr	r2, [pc, #24]	; (800625c <tcp_tmr+0x20>)
 8006244:	7813      	ldrb	r3, [r2, #0]
 8006246:	3301      	adds	r3, #1
 8006248:	b2db      	uxtb	r3, r3
 800624a:	7013      	strb	r3, [r2, #0]
 800624c:	f013 0f01 	tst.w	r3, #1
 8006250:	d100      	bne.n	8006254 <tcp_tmr+0x18>
 8006252:	bd08      	pop	{r3, pc}
    tcp_slowtmr();
 8006254:	f7ff fcb2 	bl	8005bbc <tcp_slowtmr>
}
 8006258:	e7fb      	b.n	8006252 <tcp_tmr+0x16>
 800625a:	bf00      	nop
 800625c:	200076f8 	.word	0x200076f8

08006260 <tcp_abandon>:
{
 8006260:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006264:	b083      	sub	sp, #12
 8006266:	4604      	mov	r4, r0
  if (pcb->state == TIME_WAIT) {
 8006268:	7e03      	ldrb	r3, [r0, #24]
 800626a:	2b0a      	cmp	r3, #10
 800626c:	d027      	beq.n	80062be <tcp_abandon+0x5e>
 800626e:	460e      	mov	r6, r1
    seqno = pcb->snd_nxt;
 8006270:	f8d0 8050 	ldr.w	r8, [r0, #80]	; 0x50
    ackno = pcb->rcv_nxt;
 8006274:	f8d0 9028 	ldr.w	r9, [r0, #40]	; 0x28
    errf = pcb->errf;
 8006278:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
    errf_arg = pcb->callback_arg;
 800627c:	6907      	ldr	r7, [r0, #16]
    TCP_PCB_REMOVE_ACTIVE(pcb);
 800627e:	4601      	mov	r1, r0
 8006280:	4819      	ldr	r0, [pc, #100]	; (80062e8 <tcp_abandon+0x88>)
 8006282:	f7ff fe49 	bl	8005f18 <tcp_pcb_remove>
 8006286:	2201      	movs	r2, #1
 8006288:	4b18      	ldr	r3, [pc, #96]	; (80062ec <tcp_abandon+0x8c>)
 800628a:	701a      	strb	r2, [r3, #0]
    if (pcb->unacked != NULL) {
 800628c:	6f20      	ldr	r0, [r4, #112]	; 0x70
 800628e:	b108      	cbz	r0, 8006294 <tcp_abandon+0x34>
      tcp_segs_free(pcb->unacked);
 8006290:	f7ff fc53 	bl	8005b3a <tcp_segs_free>
    if (pcb->unsent != NULL) {
 8006294:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8006296:	b108      	cbz	r0, 800629c <tcp_abandon+0x3c>
      tcp_segs_free(pcb->unsent);
 8006298:	f7ff fc4f 	bl	8005b3a <tcp_segs_free>
    if (pcb->ooseq != NULL) {
 800629c:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800629e:	b108      	cbz	r0, 80062a4 <tcp_abandon+0x44>
      tcp_segs_free(pcb->ooseq);
 80062a0:	f7ff fc4b 	bl	8005b3a <tcp_segs_free>
    if (reset) {
 80062a4:	b9a6      	cbnz	r6, 80062d0 <tcp_abandon+0x70>
    memp_free(MEMP_TCP_PCB, pcb);
 80062a6:	4621      	mov	r1, r4
 80062a8:	2002      	movs	r0, #2
 80062aa:	f7ff f903 	bl	80054b4 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 80062ae:	b11d      	cbz	r5, 80062b8 <tcp_abandon+0x58>
 80062b0:	f06f 0109 	mvn.w	r1, #9
 80062b4:	4638      	mov	r0, r7
 80062b6:	47a8      	blx	r5
}
 80062b8:	b003      	add	sp, #12
 80062ba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 80062be:	4601      	mov	r1, r0
 80062c0:	480b      	ldr	r0, [pc, #44]	; (80062f0 <tcp_abandon+0x90>)
 80062c2:	f7ff fe29 	bl	8005f18 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 80062c6:	4621      	mov	r1, r4
 80062c8:	2002      	movs	r0, #2
 80062ca:	f7ff f8f3 	bl	80054b4 <memp_free>
 80062ce:	e7f3      	b.n	80062b8 <tcp_abandon+0x58>
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
 80062d0:	8ba3      	ldrh	r3, [r4, #28]
 80062d2:	9301      	str	r3, [sp, #4]
 80062d4:	8b63      	ldrh	r3, [r4, #26]
 80062d6:	9300      	str	r3, [sp, #0]
 80062d8:	1d23      	adds	r3, r4, #4
 80062da:	4622      	mov	r2, r4
 80062dc:	4649      	mov	r1, r9
 80062de:	4640      	mov	r0, r8
 80062e0:	f001 fd76 	bl	8007dd0 <tcp_rst>
 80062e4:	e7df      	b.n	80062a6 <tcp_abandon+0x46>
 80062e6:	bf00      	nop
 80062e8:	2000b1a0 	.word	0x2000b1a0
 80062ec:	2000b19c 	.word	0x2000b19c
 80062f0:	2000b1b4 	.word	0x2000b1b4

080062f4 <tcp_abort>:
{
 80062f4:	b508      	push	{r3, lr}
  tcp_abandon(pcb, 1);
 80062f6:	2101      	movs	r1, #1
 80062f8:	f7ff ffb2 	bl	8006260 <tcp_abandon>
 80062fc:	bd08      	pop	{r3, pc}
	...

08006300 <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 8006300:	4b03      	ldr	r3, [pc, #12]	; (8006310 <tcp_next_iss+0x10>)
 8006302:	6818      	ldr	r0, [r3, #0]
 8006304:	4a03      	ldr	r2, [pc, #12]	; (8006314 <tcp_next_iss+0x14>)
 8006306:	6812      	ldr	r2, [r2, #0]
 8006308:	4410      	add	r0, r2
 800630a:	6018      	str	r0, [r3, #0]
  return iss;
}
 800630c:	4770      	bx	lr
 800630e:	bf00      	nop
 8006310:	2000014c 	.word	0x2000014c
 8006314:	2000b1a4 	.word	0x2000b1a4

08006318 <tcp_alloc>:
{
 8006318:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800631a:	4605      	mov	r5, r0
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800631c:	2002      	movs	r0, #2
 800631e:	f7ff f893 	bl	8005448 <memp_malloc>
  if (pcb == NULL) {
 8006322:	4604      	mov	r4, r0
 8006324:	2800      	cmp	r0, #0
 8006326:	d03b      	beq.n	80063a0 <tcp_alloc+0x88>
    memset(pcb, 0, sizeof(struct tcp_pcb));
 8006328:	2298      	movs	r2, #152	; 0x98
 800632a:	2100      	movs	r1, #0
 800632c:	4620      	mov	r0, r4
 800632e:	f002 fdcf 	bl	8008ed0 <memset>
    pcb->prio = prio;
 8006332:	7665      	strb	r5, [r4, #25]
    pcb->snd_buf = TCP_SND_BUF;
 8006334:	f640 3368 	movw	r3, #2920	; 0xb68
 8006338:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
    pcb->snd_queuelen = 0;
 800633c:	2500      	movs	r5, #0
 800633e:	f8a4 5068 	strh.w	r5, [r4, #104]	; 0x68
    pcb->rcv_wnd = TCP_WND;
 8006342:	f241 63d0 	movw	r3, #5840	; 0x16d0
 8006346:	85a3      	strh	r3, [r4, #44]	; 0x2c
    pcb->rcv_ann_wnd = TCP_WND;
 8006348:	85e3      	strh	r3, [r4, #46]	; 0x2e
    pcb->tos = 0;
 800634a:	7265      	strb	r5, [r4, #9]
    pcb->ttl = TCP_TTL;
 800634c:	23ff      	movs	r3, #255	; 0xff
 800634e:	72a3      	strb	r3, [r4, #10]
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 8006350:	f44f 7306 	mov.w	r3, #536	; 0x218
 8006354:	86e3      	strh	r3, [r4, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 8006356:	2306      	movs	r3, #6
 8006358:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
    pcb->sa = 0;
 800635c:	f8a4 5040 	strh.w	r5, [r4, #64]	; 0x40
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 8006360:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
    pcb->rtime = -1;
 8006364:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006368:	86a3      	strh	r3, [r4, #52]	; 0x34
    pcb->cwnd = 1;
 800636a:	2301      	movs	r3, #1
 800636c:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    iss = tcp_next_iss();
 8006370:	f7ff ffc6 	bl	8006300 <tcp_next_iss>
    pcb->snd_wl2 = iss;
 8006374:	65a0      	str	r0, [r4, #88]	; 0x58
    pcb->snd_nxt = iss;
 8006376:	6520      	str	r0, [r4, #80]	; 0x50
    pcb->lastack = iss;
 8006378:	64a0      	str	r0, [r4, #72]	; 0x48
    pcb->snd_lbb = iss;   
 800637a:	65e0      	str	r0, [r4, #92]	; 0x5c
    pcb->tmr = tcp_ticks;
 800637c:	4b2c      	ldr	r3, [pc, #176]	; (8006430 <tcp_alloc+0x118>)
 800637e:	681b      	ldr	r3, [r3, #0]
 8006380:	6263      	str	r3, [r4, #36]	; 0x24
    pcb->last_timer = tcp_timer_ctr;
 8006382:	4b2c      	ldr	r3, [pc, #176]	; (8006434 <tcp_alloc+0x11c>)
 8006384:	781b      	ldrb	r3, [r3, #0]
 8006386:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    pcb->polltmr = 0;
 800638a:	77e5      	strb	r5, [r4, #31]
    pcb->recv = tcp_recv_null;
 800638c:	4b2a      	ldr	r3, [pc, #168]	; (8006438 <tcp_alloc+0x120>)
 800638e:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 8006392:	4b2a      	ldr	r3, [pc, #168]	; (800643c <tcp_alloc+0x124>)
 8006394:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    pcb->keep_cnt_sent = 0;
 8006398:	f884 5096 	strb.w	r5, [r4, #150]	; 0x96
}
 800639c:	4620      	mov	r0, r4
 800639e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80063a0:	4b27      	ldr	r3, [pc, #156]	; (8006440 <tcp_alloc+0x128>)
 80063a2:	681b      	ldr	r3, [r3, #0]
 80063a4:	b17b      	cbz	r3, 80063c6 <tcp_alloc+0xae>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80063a6:	4a22      	ldr	r2, [pc, #136]	; (8006430 <tcp_alloc+0x118>)
 80063a8:	6810      	ldr	r0, [r2, #0]
 80063aa:	2100      	movs	r1, #0
 80063ac:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80063ae:	1a82      	subs	r2, r0, r2
 80063b0:	428a      	cmp	r2, r1
      inactivity = tcp_ticks - pcb->tmr;
 80063b2:	bf24      	itt	cs
 80063b4:	4611      	movcs	r1, r2
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80063b6:	461c      	movcs	r4, r3
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80063b8:	68db      	ldr	r3, [r3, #12]
 80063ba:	2b00      	cmp	r3, #0
 80063bc:	d1f6      	bne.n	80063ac <tcp_alloc+0x94>
  if (inactive != NULL) {
 80063be:	b114      	cbz	r4, 80063c6 <tcp_alloc+0xae>
    tcp_abort(inactive);
 80063c0:	4620      	mov	r0, r4
 80063c2:	f7ff ff97 	bl	80062f4 <tcp_abort>
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 80063c6:	2002      	movs	r0, #2
 80063c8:	f7ff f83e 	bl	8005448 <memp_malloc>
    if (pcb == NULL) {
 80063cc:	4604      	mov	r4, r0
 80063ce:	b130      	cbz	r0, 80063de <tcp_alloc+0xc6>
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 80063d0:	4a1c      	ldr	r2, [pc, #112]	; (8006444 <tcp_alloc+0x12c>)
 80063d2:	f8b2 30cc 	ldrh.w	r3, [r2, #204]	; 0xcc
 80063d6:	3b01      	subs	r3, #1
 80063d8:	f8a2 30cc 	strh.w	r3, [r2, #204]	; 0xcc
 80063dc:	e7a4      	b.n	8006328 <tcp_alloc+0x10>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80063de:	4b1a      	ldr	r3, [pc, #104]	; (8006448 <tcp_alloc+0x130>)
 80063e0:	681b      	ldr	r3, [r3, #0]
 80063e2:	b1bb      	cbz	r3, 8006414 <tcp_alloc+0xfc>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80063e4:	4a12      	ldr	r2, [pc, #72]	; (8006430 <tcp_alloc+0x118>)
 80063e6:	6817      	ldr	r7, [r2, #0]
 80063e8:	2600      	movs	r6, #0
 80063ea:	207f      	movs	r0, #127	; 0x7f
 80063ec:	e001      	b.n	80063f2 <tcp_alloc+0xda>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80063ee:	68db      	ldr	r3, [r3, #12]
 80063f0:	b163      	cbz	r3, 800640c <tcp_alloc+0xf4>
    if (pcb->prio <= prio &&
 80063f2:	7e5a      	ldrb	r2, [r3, #25]
 80063f4:	4295      	cmp	r5, r2
 80063f6:	d3fa      	bcc.n	80063ee <tcp_alloc+0xd6>
 80063f8:	4282      	cmp	r2, r0
 80063fa:	d8f8      	bhi.n	80063ee <tcp_alloc+0xd6>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80063fc:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80063fe:	1a79      	subs	r1, r7, r1
       pcb->prio <= mprio &&
 8006400:	42b1      	cmp	r1, r6
 8006402:	d3f4      	bcc.n	80063ee <tcp_alloc+0xd6>
      mprio = pcb->prio;
 8006404:	4610      	mov	r0, r2
      inactivity = tcp_ticks - pcb->tmr;
 8006406:	460e      	mov	r6, r1
       pcb->prio <= mprio &&
 8006408:	461c      	mov	r4, r3
 800640a:	e7f0      	b.n	80063ee <tcp_alloc+0xd6>
  if (inactive != NULL) {
 800640c:	b114      	cbz	r4, 8006414 <tcp_alloc+0xfc>
    tcp_abort(inactive);
 800640e:	4620      	mov	r0, r4
 8006410:	f7ff ff70 	bl	80062f4 <tcp_abort>
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8006414:	2002      	movs	r0, #2
 8006416:	f7ff f817 	bl	8005448 <memp_malloc>
      if (pcb != NULL) {
 800641a:	4604      	mov	r4, r0
 800641c:	2800      	cmp	r0, #0
 800641e:	d0bd      	beq.n	800639c <tcp_alloc+0x84>
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 8006420:	4a08      	ldr	r2, [pc, #32]	; (8006444 <tcp_alloc+0x12c>)
 8006422:	f8b2 30cc 	ldrh.w	r3, [r2, #204]	; 0xcc
 8006426:	3b01      	subs	r3, #1
 8006428:	f8a2 30cc 	strh.w	r3, [r2, #204]	; 0xcc
 800642c:	e7d0      	b.n	80063d0 <tcp_alloc+0xb8>
 800642e:	bf00      	nop
 8006430:	2000b1a4 	.word	0x2000b1a4
 8006434:	200076f9 	.word	0x200076f9
 8006438:	08006139 	.word	0x08006139
 800643c:	006ddd00 	.word	0x006ddd00
 8006440:	2000b1b4 	.word	0x2000b1b4
 8006444:	2000b084 	.word	0x2000b084
 8006448:	2000b1a0 	.word	0x2000b1a0

0800644c <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
 800644c:	b510      	push	{r4, lr}
 800644e:	4604      	mov	r4, r0
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
 8006450:	4608      	mov	r0, r1
 8006452:	f7fe f8bb 	bl	80045cc <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
 8006456:	b138      	cbz	r0, 8006468 <tcp_eff_send_mss+0x1c>
 8006458:	8c00      	ldrh	r0, [r0, #32]
 800645a:	b138      	cbz	r0, 800646c <tcp_eff_send_mss+0x20>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
 800645c:	3828      	subs	r0, #40	; 0x28
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 800645e:	b280      	uxth	r0, r0
 8006460:	42a0      	cmp	r0, r4
 8006462:	bf28      	it	cs
 8006464:	4620      	movcs	r0, r4
 8006466:	bd10      	pop	{r4, pc}
 8006468:	4620      	mov	r0, r4
 800646a:	bd10      	pop	{r4, pc}
 800646c:	4620      	mov	r0, r4
  }
  return sendmss;
}
 800646e:	bd10      	pop	{r4, pc}

08006470 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 8006470:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006472:	4605      	mov	r5, r0
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 8006474:	4b22      	ldr	r3, [pc, #136]	; (8006500 <tcp_parseopt+0x90>)
 8006476:	681c      	ldr	r4, [r3, #0]

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
 8006478:	89a0      	ldrh	r0, [r4, #12]
 800647a:	f7fd fe9c 	bl	80041b6 <lwip_ntohs>
 800647e:	f3c0 300f 	ubfx	r0, r0, #12, #16
 8006482:	2805      	cmp	r0, #5
 8006484:	d800      	bhi.n	8006488 <tcp_parseopt+0x18>
 8006486:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 8006488:	4b1d      	ldr	r3, [pc, #116]	; (8006500 <tcp_parseopt+0x90>)
 800648a:	681b      	ldr	r3, [r3, #0]
 800648c:	8998      	ldrh	r0, [r3, #12]
 800648e:	f7fd fe92 	bl	80041b6 <lwip_ntohs>
 8006492:	0b06      	lsrs	r6, r0, #12
 8006494:	3e05      	subs	r6, #5
 8006496:	00b6      	lsls	r6, r6, #2
 8006498:	b2b6      	uxth	r6, r6
    for (c = 0; c < max_c; ) {
 800649a:	2e00      	cmp	r6, #0
 800649c:	d0f3      	beq.n	8006486 <tcp_parseopt+0x16>
  opts = (u8_t *)tcphdr + TCP_HLEN;
 800649e:	f104 0214 	add.w	r2, r4, #20
 80064a2:	2300      	movs	r3, #0
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 80064a4:	f240 57b3 	movw	r7, #1459	; 0x5b3
 80064a8:	f240 54b4 	movw	r4, #1460	; 0x5b4
 80064ac:	e003      	b.n	80064b6 <tcp_parseopt+0x46>
        ++c;
 80064ae:	3301      	adds	r3, #1
 80064b0:	b29b      	uxth	r3, r3
    for (c = 0; c < max_c; ) {
 80064b2:	429e      	cmp	r6, r3
 80064b4:	d9e7      	bls.n	8006486 <tcp_parseopt+0x16>
      opt = opts[c];
 80064b6:	4618      	mov	r0, r3
      switch (opt) {
 80064b8:	5cd1      	ldrb	r1, [r2, r3]
 80064ba:	2901      	cmp	r1, #1
 80064bc:	d0f7      	beq.n	80064ae <tcp_parseopt+0x3e>
 80064be:	2900      	cmp	r1, #0
 80064c0:	d0e1      	beq.n	8006486 <tcp_parseopt+0x16>
 80064c2:	2902      	cmp	r1, #2
 80064c4:	d006      	beq.n	80064d4 <tcp_parseopt+0x64>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
 80064c6:	4410      	add	r0, r2
 80064c8:	7841      	ldrb	r1, [r0, #1]
 80064ca:	2900      	cmp	r1, #0
 80064cc:	d0db      	beq.n	8006486 <tcp_parseopt+0x16>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
 80064ce:	440b      	add	r3, r1
 80064d0:	b29b      	uxth	r3, r3
 80064d2:	e7ee      	b.n	80064b2 <tcp_parseopt+0x42>
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
 80064d4:	18d1      	adds	r1, r2, r3
 80064d6:	7849      	ldrb	r1, [r1, #1]
 80064d8:	2904      	cmp	r1, #4
 80064da:	d1d4      	bne.n	8006486 <tcp_parseopt+0x16>
 80064dc:	1d19      	adds	r1, r3, #4
 80064de:	42b1      	cmp	r1, r6
 80064e0:	dcd1      	bgt.n	8006486 <tcp_parseopt+0x16>
        mss = (opts[c + 2] << 8) | opts[c + 3];
 80064e2:	4410      	add	r0, r2
 80064e4:	f890 e002 	ldrb.w	lr, [r0, #2]
 80064e8:	78c1      	ldrb	r1, [r0, #3]
 80064ea:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 80064ee:	1e48      	subs	r0, r1, #1
 80064f0:	b280      	uxth	r0, r0
 80064f2:	42b8      	cmp	r0, r7
 80064f4:	bf88      	it	hi
 80064f6:	4621      	movhi	r1, r4
 80064f8:	86e9      	strh	r1, [r5, #54]	; 0x36
        c += 0x04;
 80064fa:	3304      	adds	r3, #4
 80064fc:	b29b      	uxth	r3, r3
        break;
 80064fe:	e7d8      	b.n	80064b2 <tcp_parseopt+0x42>
 8006500:	20007720 	.word	0x20007720

08006504 <tcp_oos_insert_segment>:
{
 8006504:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006508:	4605      	mov	r5, r0
 800650a:	4688      	mov	r8, r1
  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800650c:	68c3      	ldr	r3, [r0, #12]
 800650e:	8998      	ldrh	r0, [r3, #12]
 8006510:	f7fd fe51 	bl	80041b6 <lwip_ntohs>
 8006514:	f010 0f01 	tst.w	r0, #1
 8006518:	d114      	bne.n	8006544 <tcp_oos_insert_segment+0x40>
    while (next &&
 800651a:	f1b8 0f00 	cmp.w	r8, #0
 800651e:	d04a      	beq.n	80065b6 <tcp_oos_insert_segment+0xb2>
           TCP_SEQ_GEQ((seqno + cseg->len),
 8006520:	f8d8 200c 	ldr.w	r2, [r8, #12]
 8006524:	892b      	ldrh	r3, [r5, #8]
 8006526:	6851      	ldr	r1, [r2, #4]
 8006528:	1a5b      	subs	r3, r3, r1
 800652a:	4924      	ldr	r1, [pc, #144]	; (80065bc <tcp_oos_insert_segment+0xb8>)
 800652c:	6809      	ldr	r1, [r1, #0]
 800652e:	440b      	add	r3, r1
 8006530:	f8b8 1008 	ldrh.w	r1, [r8, #8]
 8006534:	1a5b      	subs	r3, r3, r1
    while (next &&
 8006536:	2b00      	cmp	r3, #0
 8006538:	bfb8      	it	lt
 800653a:	4644      	movlt	r4, r8
 800653c:	db29      	blt.n	8006592 <tcp_oos_insert_segment+0x8e>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 800653e:	2701      	movs	r7, #1
           TCP_SEQ_GEQ((seqno + cseg->len),
 8006540:	4e1e      	ldr	r6, [pc, #120]	; (80065bc <tcp_oos_insert_segment+0xb8>)
 8006542:	e015      	b.n	8006570 <tcp_oos_insert_segment+0x6c>
    tcp_segs_free(next);
 8006544:	4640      	mov	r0, r8
 8006546:	f7ff faf8 	bl	8005b3a <tcp_segs_free>
    next = NULL;
 800654a:	2400      	movs	r4, #0
 800654c:	e030      	b.n	80065b0 <tcp_oos_insert_segment+0xac>
      next = next->next;
 800654e:	f8d8 4000 	ldr.w	r4, [r8]
      tcp_seg_free(old_seg);
 8006552:	4640      	mov	r0, r8
 8006554:	f7ff fae4 	bl	8005b20 <tcp_seg_free>
    while (next &&
 8006558:	b36c      	cbz	r4, 80065b6 <tcp_oos_insert_segment+0xb2>
           TCP_SEQ_GEQ((seqno + cseg->len),
 800655a:	68e2      	ldr	r2, [r4, #12]
 800655c:	892b      	ldrh	r3, [r5, #8]
 800655e:	6831      	ldr	r1, [r6, #0]
 8006560:	440b      	add	r3, r1
 8006562:	6851      	ldr	r1, [r2, #4]
 8006564:	1a5b      	subs	r3, r3, r1
 8006566:	8921      	ldrh	r1, [r4, #8]
 8006568:	1a5b      	subs	r3, r3, r1
    while (next &&
 800656a:	2b00      	cmp	r3, #0
 800656c:	db11      	blt.n	8006592 <tcp_oos_insert_segment+0x8e>
      next = next->next;
 800656e:	46a0      	mov	r8, r4
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 8006570:	8990      	ldrh	r0, [r2, #12]
 8006572:	f7fd fe20 	bl	80041b6 <lwip_ntohs>
 8006576:	f010 0f01 	tst.w	r0, #1
 800657a:	d0e8      	beq.n	800654e <tcp_oos_insert_segment+0x4a>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 800657c:	f8d5 900c 	ldr.w	r9, [r5, #12]
 8006580:	f8b9 400c 	ldrh.w	r4, [r9, #12]
 8006584:	4638      	mov	r0, r7
 8006586:	f7fd fe11 	bl	80041ac <lwip_htons>
 800658a:	4320      	orrs	r0, r4
 800658c:	f8a9 000c 	strh.w	r0, [r9, #12]
 8006590:	e7dd      	b.n	800654e <tcp_oos_insert_segment+0x4a>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 8006592:	4b0a      	ldr	r3, [pc, #40]	; (80065bc <tcp_oos_insert_segment+0xb8>)
 8006594:	6819      	ldr	r1, [r3, #0]
 8006596:	68e3      	ldr	r3, [r4, #12]
 8006598:	685a      	ldr	r2, [r3, #4]
 800659a:	892b      	ldrh	r3, [r5, #8]
 800659c:	440b      	add	r3, r1
 800659e:	1a9b      	subs	r3, r3, r2
    if (next &&
 80065a0:	2b00      	cmp	r3, #0
 80065a2:	dd05      	ble.n	80065b0 <tcp_oos_insert_segment+0xac>
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 80065a4:	1a52      	subs	r2, r2, r1
 80065a6:	b291      	uxth	r1, r2
 80065a8:	8129      	strh	r1, [r5, #8]
      pbuf_realloc(cseg->p, cseg->len);
 80065aa:	6868      	ldr	r0, [r5, #4]
 80065ac:	f7ff f940 	bl	8005830 <pbuf_realloc>
  cseg->next = next;
 80065b0:	602c      	str	r4, [r5, #0]
}
 80065b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    next = NULL;
 80065b6:	2400      	movs	r4, #0
 80065b8:	e7fa      	b.n	80065b0 <tcp_oos_insert_segment+0xac>
 80065ba:	bf00      	nop
 80065bc:	2000771c 	.word	0x2000771c

080065c0 <tcp_receive>:
{
 80065c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80065c4:	4604      	mov	r4, r0
  if (flags & TCP_ACK) {
 80065c6:	4bae      	ldr	r3, [pc, #696]	; (8006880 <tcp_receive+0x2c0>)
 80065c8:	781b      	ldrb	r3, [r3, #0]
 80065ca:	f013 0f10 	tst.w	r3, #16
 80065ce:	f000 8169 	beq.w	80068a4 <tcp_receive+0x2e4>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 80065d2:	7e00      	ldrb	r0, [r0, #24]
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 80065d4:	f8b4 6060 	ldrh.w	r6, [r4, #96]	; 0x60
 80065d8:	6da5      	ldr	r5, [r4, #88]	; 0x58
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 80065da:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80065dc:	4ba9      	ldr	r3, [pc, #676]	; (8006884 <tcp_receive+0x2c4>)
 80065de:	681b      	ldr	r3, [r3, #0]
 80065e0:	1ad1      	subs	r1, r2, r3
 80065e2:	2900      	cmp	r1, #0
 80065e4:	db26      	blt.n	8006634 <tcp_receive+0x74>
 80065e6:	429a      	cmp	r2, r3
 80065e8:	d019      	beq.n	800661e <tcp_receive+0x5e>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 80065ea:	4aa7      	ldr	r2, [pc, #668]	; (8006888 <tcp_receive+0x2c8>)
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 80065ec:	6812      	ldr	r2, [r2, #0]
 80065ee:	4295      	cmp	r5, r2
 80065f0:	d01b      	beq.n	800662a <tcp_receive+0x6a>
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 80065f2:	4ba5      	ldr	r3, [pc, #660]	; (8006888 <tcp_receive+0x2c8>)
 80065f4:	681a      	ldr	r2, [r3, #0]
 80065f6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80065f8:	1ad1      	subs	r1, r2, r3
 80065fa:	2900      	cmp	r1, #0
 80065fc:	dd3f      	ble.n	800667e <tcp_receive+0xbe>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
 80065fe:	2901      	cmp	r1, #1
 8006600:	d403      	bmi.n	800660a <tcp_receive+0x4a>
 8006602:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8006604:	1a51      	subs	r1, r2, r1
 8006606:	2900      	cmp	r1, #0
 8006608:	dd6c      	ble.n	80066e4 <tcp_receive+0x124>
      pcb->acked = 0;
 800660a:	2300      	movs	r3, #0
 800660c:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    while (pcb->unsent != NULL &&
 8006610:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006612:	2b00      	cmp	r3, #0
 8006614:	f000 813e 	beq.w	8006894 <tcp_receive+0x2d4>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 8006618:	4e9b      	ldr	r6, [pc, #620]	; (8006888 <tcp_receive+0x2c8>)
        pcb->unsent_oversize = 0;
 800661a:	2700      	movs	r7, #0
 800661c:	e0fa      	b.n	8006814 <tcp_receive+0x254>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800661e:	4a9a      	ldr	r2, [pc, #616]	; (8006888 <tcp_receive+0x2c8>)
 8006620:	6812      	ldr	r2, [r2, #0]
 8006622:	1aaa      	subs	r2, r5, r2
 8006624:	2a00      	cmp	r2, #0
 8006626:	dae0      	bge.n	80065ea <tcp_receive+0x2a>
 8006628:	e004      	b.n	8006634 <tcp_receive+0x74>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 800662a:	4a98      	ldr	r2, [pc, #608]	; (800688c <tcp_receive+0x2cc>)
 800662c:	6812      	ldr	r2, [r2, #0]
 800662e:	89d2      	ldrh	r2, [r2, #14]
 8006630:	42b2      	cmp	r2, r6
 8006632:	d9de      	bls.n	80065f2 <tcp_receive+0x32>
      pcb->snd_wnd = tcphdr->wnd;
 8006634:	4a95      	ldr	r2, [pc, #596]	; (800688c <tcp_receive+0x2cc>)
 8006636:	6812      	ldr	r2, [r2, #0]
 8006638:	89d1      	ldrh	r1, [r2, #14]
 800663a:	b28f      	uxth	r7, r1
 800663c:	f8a4 1060 	strh.w	r1, [r4, #96]	; 0x60
      if (pcb->snd_wnd_max < tcphdr->wnd) {
 8006640:	89d2      	ldrh	r2, [r2, #14]
 8006642:	b291      	uxth	r1, r2
 8006644:	f8b4 e062 	ldrh.w	lr, [r4, #98]	; 0x62
 8006648:	458e      	cmp	lr, r1
        pcb->snd_wnd_max = tcphdr->wnd;
 800664a:	bf38      	it	cc
 800664c:	f8a4 2062 	strhcc.w	r2, [r4, #98]	; 0x62
      pcb->snd_wl1 = seqno;
 8006650:	6563      	str	r3, [r4, #84]	; 0x54
      pcb->snd_wl2 = ackno;
 8006652:	4b8d      	ldr	r3, [pc, #564]	; (8006888 <tcp_receive+0x2c8>)
 8006654:	681b      	ldr	r3, [r3, #0]
 8006656:	65a3      	str	r3, [r4, #88]	; 0x58
      if (pcb->snd_wnd == 0) {
 8006658:	b94f      	cbnz	r7, 800666e <tcp_receive+0xae>
        if (pcb->persist_backoff == 0) {
 800665a:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
 800665e:	2b00      	cmp	r3, #0
 8006660:	d1c7      	bne.n	80065f2 <tcp_receive+0x32>
          pcb->persist_cnt = 0;
 8006662:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
          pcb->persist_backoff = 1;
 8006666:	2301      	movs	r3, #1
 8006668:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
 800666c:	e7c1      	b.n	80065f2 <tcp_receive+0x32>
      } else if (pcb->persist_backoff > 0) {
 800666e:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
 8006672:	2b00      	cmp	r3, #0
 8006674:	d0bd      	beq.n	80065f2 <tcp_receive+0x32>
          pcb->persist_backoff = 0;
 8006676:	2300      	movs	r3, #0
 8006678:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
 800667c:	e7b9      	b.n	80065f2 <tcp_receive+0x32>
      pcb->acked = 0;
 800667e:	2100      	movs	r1, #0
 8006680:	f8a4 1064 	strh.w	r1, [r4, #100]	; 0x64
      if (tcplen == 0) {
 8006684:	4982      	ldr	r1, [pc, #520]	; (8006890 <tcp_receive+0x2d0>)
 8006686:	8809      	ldrh	r1, [r1, #0]
 8006688:	b931      	cbnz	r1, 8006698 <tcp_receive+0xd8>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 800668a:	4435      	add	r5, r6
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
 800668c:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
 8006690:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8006692:	4401      	add	r1, r0
 8006694:	428d      	cmp	r5, r1
 8006696:	d003      	beq.n	80066a0 <tcp_receive+0xe0>
        pcb->dupacks = 0;
 8006698:	2300      	movs	r3, #0
 800669a:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
 800669e:	e7b7      	b.n	8006610 <tcp_receive+0x50>
          if (pcb->rtime >= 0) {
 80066a0:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
 80066a4:	2900      	cmp	r1, #0
 80066a6:	dbf7      	blt.n	8006698 <tcp_receive+0xd8>
            if (pcb->lastack == ackno) {
 80066a8:	429a      	cmp	r2, r3
 80066aa:	d1f5      	bne.n	8006698 <tcp_receive+0xd8>
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 80066ac:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
 80066b0:	1c53      	adds	r3, r2, #1
 80066b2:	b2db      	uxtb	r3, r3
 80066b4:	429a      	cmp	r2, r3
                ++pcb->dupacks;
 80066b6:	bf38      	it	cc
 80066b8:	f884 3047 	strbcc.w	r3, [r4, #71]	; 0x47
              if (pcb->dupacks > 3) {
 80066bc:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
 80066c0:	2b03      	cmp	r3, #3
 80066c2:	d909      	bls.n	80066d8 <tcp_receive+0x118>
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 80066c4:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 80066c8:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80066ca:	4413      	add	r3, r2
 80066cc:	b29b      	uxth	r3, r3
 80066ce:	429a      	cmp	r2, r3
 80066d0:	d29e      	bcs.n	8006610 <tcp_receive+0x50>
                  pcb->cwnd += pcb->mss;
 80066d2:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 80066d6:	e79b      	b.n	8006610 <tcp_receive+0x50>
              } else if (pcb->dupacks == 3) {
 80066d8:	2b03      	cmp	r3, #3
 80066da:	d199      	bne.n	8006610 <tcp_receive+0x50>
                tcp_rexmit_fast(pcb);
 80066dc:	4620      	mov	r0, r4
 80066de:	f001 fc0b 	bl	8007ef8 <tcp_rexmit_fast>
 80066e2:	e795      	b.n	8006610 <tcp_receive+0x50>
      if (pcb->flags & TF_INFR) {
 80066e4:	7fa1      	ldrb	r1, [r4, #30]
 80066e6:	f011 0f04 	tst.w	r1, #4
 80066ea:	d006      	beq.n	80066fa <tcp_receive+0x13a>
        pcb->flags &= ~TF_INFR;
 80066ec:	f021 0104 	bic.w	r1, r1, #4
 80066f0:	77a1      	strb	r1, [r4, #30]
        pcb->cwnd = pcb->ssthresh;
 80066f2:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
 80066f6:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
      pcb->nrtx = 0;
 80066fa:	2500      	movs	r5, #0
 80066fc:	f884 5046 	strb.w	r5, [r4, #70]	; 0x46
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 8006700:	f9b4 6040 	ldrsh.w	r6, [r4, #64]	; 0x40
 8006704:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
 8006708:	eb01 01e6 	add.w	r1, r1, r6, asr #3
 800670c:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 8006710:	1ad3      	subs	r3, r2, r3
 8006712:	b29b      	uxth	r3, r3
 8006714:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
      pcb->snd_buf += pcb->acked;
 8006718:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
 800671c:	440b      	add	r3, r1
 800671e:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
      pcb->dupacks = 0;
 8006722:	f884 5047 	strb.w	r5, [r4, #71]	; 0x47
      pcb->lastack = ackno;
 8006726:	64a2      	str	r2, [r4, #72]	; 0x48
      if (pcb->state >= ESTABLISHED) {
 8006728:	2803      	cmp	r0, #3
 800672a:	d918      	bls.n	800675e <tcp_receive+0x19e>
        if (pcb->cwnd < pcb->ssthresh) {
 800672c:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 8006730:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 8006734:	4293      	cmp	r3, r2
 8006736:	d907      	bls.n	8006748 <tcp_receive+0x188>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 8006738:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800673a:	4413      	add	r3, r2
 800673c:	b29b      	uxth	r3, r3
 800673e:	429a      	cmp	r2, r3
 8006740:	d20d      	bcs.n	800675e <tcp_receive+0x19e>
            pcb->cwnd += pcb->mss;
 8006742:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 8006746:	e00a      	b.n	800675e <tcp_receive+0x19e>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 8006748:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800674a:	fb03 f303 	mul.w	r3, r3, r3
 800674e:	fb93 f3f2 	sdiv	r3, r3, r2
 8006752:	4413      	add	r3, r2
 8006754:	b29b      	uxth	r3, r3
          if (new_cwnd > pcb->cwnd) {
 8006756:	429a      	cmp	r2, r3
            pcb->cwnd = new_cwnd;
 8006758:	bf38      	it	cc
 800675a:	f8a4 304c 	strhcc.w	r3, [r4, #76]	; 0x4c
      while (pcb->unacked != NULL &&
 800675e:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8006760:	2b00      	cmp	r3, #0
 8006762:	d042      	beq.n	80067ea <tcp_receive+0x22a>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 8006764:	4e48      	ldr	r6, [pc, #288]	; (8006888 <tcp_receive+0x2c8>)
 8006766:	e00d      	b.n	8006784 <tcp_receive+0x1c4>
        pcb->snd_queuelen -= pbuf_clen(next->p);
 8006768:	6868      	ldr	r0, [r5, #4]
 800676a:	f7ff f88c 	bl	8005886 <pbuf_clen>
 800676e:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8006772:	1a18      	subs	r0, r3, r0
 8006774:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
        tcp_seg_free(next);
 8006778:	4628      	mov	r0, r5
 800677a:	f7ff f9d1 	bl	8005b20 <tcp_seg_free>
      while (pcb->unacked != NULL &&
 800677e:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8006780:	2b00      	cmp	r3, #0
 8006782:	d032      	beq.n	80067ea <tcp_receive+0x22a>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 8006784:	68db      	ldr	r3, [r3, #12]
 8006786:	6858      	ldr	r0, [r3, #4]
 8006788:	f7fd fd26 	bl	80041d8 <lwip_ntohl>
 800678c:	4605      	mov	r5, r0
 800678e:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8006790:	891f      	ldrh	r7, [r3, #8]
 8006792:	68db      	ldr	r3, [r3, #12]
 8006794:	8998      	ldrh	r0, [r3, #12]
 8006796:	f7fd fd0e 	bl	80041b6 <lwip_ntohs>
 800679a:	f010 0003 	ands.w	r0, r0, #3
 800679e:	bf18      	it	ne
 80067a0:	2001      	movne	r0, #1
 80067a2:	4438      	add	r0, r7
 80067a4:	6833      	ldr	r3, [r6, #0]
 80067a6:	1aed      	subs	r5, r5, r3
 80067a8:	4428      	add	r0, r5
      while (pcb->unacked != NULL &&
 80067aa:	2800      	cmp	r0, #0
 80067ac:	dc16      	bgt.n	80067dc <tcp_receive+0x21c>
        next = pcb->unacked;
 80067ae:	6f25      	ldr	r5, [r4, #112]	; 0x70
        pcb->unacked = pcb->unacked->next;
 80067b0:	682b      	ldr	r3, [r5, #0]
 80067b2:	6723      	str	r3, [r4, #112]	; 0x70
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 80067b4:	6868      	ldr	r0, [r5, #4]
 80067b6:	f7ff f866 	bl	8005886 <pbuf_clen>
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 80067ba:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 80067be:	2b00      	cmp	r3, #0
 80067c0:	d0d2      	beq.n	8006768 <tcp_receive+0x1a8>
 80067c2:	68eb      	ldr	r3, [r5, #12]
 80067c4:	8998      	ldrh	r0, [r3, #12]
 80067c6:	f7fd fcf6 	bl	80041b6 <lwip_ntohs>
 80067ca:	f010 0f01 	tst.w	r0, #1
 80067ce:	d0cb      	beq.n	8006768 <tcp_receive+0x1a8>
          pcb->acked--;
 80067d0:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 80067d4:	3b01      	subs	r3, #1
 80067d6:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 80067da:	e7c5      	b.n	8006768 <tcp_receive+0x1a8>
      if(pcb->unacked == NULL)
 80067dc:	6f23      	ldr	r3, [r4, #112]	; 0x70
 80067de:	b123      	cbz	r3, 80067ea <tcp_receive+0x22a>
        pcb->rtime = 0;
 80067e0:	2300      	movs	r3, #0
 80067e2:	86a3      	strh	r3, [r4, #52]	; 0x34
      pcb->polltmr = 0;
 80067e4:	2300      	movs	r3, #0
 80067e6:	77e3      	strb	r3, [r4, #31]
 80067e8:	e712      	b.n	8006610 <tcp_receive+0x50>
        pcb->rtime = -1;
 80067ea:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80067ee:	86a3      	strh	r3, [r4, #52]	; 0x34
 80067f0:	e7f8      	b.n	80067e4 <tcp_receive+0x224>
        pcb->unsent_oversize = 0;
 80067f2:	f8a4 706a 	strh.w	r7, [r4, #106]	; 0x6a
 80067f6:	e02e      	b.n	8006856 <tcp_receive+0x296>
      pcb->snd_queuelen -= pbuf_clen(next->p);
 80067f8:	6868      	ldr	r0, [r5, #4]
 80067fa:	f7ff f844 	bl	8005886 <pbuf_clen>
 80067fe:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8006802:	1a18      	subs	r0, r3, r0
 8006804:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
      tcp_seg_free(next);
 8006808:	4628      	mov	r0, r5
 800680a:	f7ff f989 	bl	8005b20 <tcp_seg_free>
    while (pcb->unsent != NULL &&
 800680e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006810:	2b00      	cmp	r3, #0
 8006812:	d03f      	beq.n	8006894 <tcp_receive+0x2d4>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 8006814:	6835      	ldr	r5, [r6, #0]
 8006816:	68db      	ldr	r3, [r3, #12]
 8006818:	6858      	ldr	r0, [r3, #4]
 800681a:	f7fd fcdd 	bl	80041d8 <lwip_ntohl>
 800681e:	4681      	mov	r9, r0
 8006820:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006822:	f8b3 8008 	ldrh.w	r8, [r3, #8]
 8006826:	68db      	ldr	r3, [r3, #12]
 8006828:	8998      	ldrh	r0, [r3, #12]
 800682a:	f7fd fcc4 	bl	80041b6 <lwip_ntohs>
 800682e:	eba5 0509 	sub.w	r5, r5, r9
 8006832:	f010 0003 	ands.w	r0, r0, #3
 8006836:	bf18      	it	ne
 8006838:	2001      	movne	r0, #1
 800683a:	4440      	add	r0, r8
 800683c:	1a2d      	subs	r5, r5, r0
    while (pcb->unsent != NULL &&
 800683e:	2d00      	cmp	r5, #0
 8006840:	db28      	blt.n	8006894 <tcp_receive+0x2d4>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 8006842:	6833      	ldr	r3, [r6, #0]
 8006844:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8006846:	1a9b      	subs	r3, r3, r2
 8006848:	2b00      	cmp	r3, #0
 800684a:	dc23      	bgt.n	8006894 <tcp_receive+0x2d4>
      next = pcb->unsent;
 800684c:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
      pcb->unsent = pcb->unsent->next;
 800684e:	682b      	ldr	r3, [r5, #0]
 8006850:	66e3      	str	r3, [r4, #108]	; 0x6c
      if (pcb->unsent == NULL) {
 8006852:	2b00      	cmp	r3, #0
 8006854:	d0cd      	beq.n	80067f2 <tcp_receive+0x232>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 8006856:	6868      	ldr	r0, [r5, #4]
 8006858:	f7ff f815 	bl	8005886 <pbuf_clen>
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 800685c:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8006860:	2b00      	cmp	r3, #0
 8006862:	d0c9      	beq.n	80067f8 <tcp_receive+0x238>
 8006864:	68eb      	ldr	r3, [r5, #12]
 8006866:	8998      	ldrh	r0, [r3, #12]
 8006868:	f7fd fca5 	bl	80041b6 <lwip_ntohs>
 800686c:	f010 0f01 	tst.w	r0, #1
 8006870:	d0c2      	beq.n	80067f8 <tcp_receive+0x238>
        pcb->acked--;
 8006872:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8006876:	3b01      	subs	r3, #1
 8006878:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 800687c:	e7bc      	b.n	80067f8 <tcp_receive+0x238>
 800687e:	bf00      	nop
 8006880:	20007700 	.word	0x20007700
 8006884:	2000771c 	.word	0x2000771c
 8006888:	200076fc 	.word	0x200076fc
 800688c:	20007720 	.word	0x20007720
 8006890:	20007724 	.word	0x20007724
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 8006894:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006896:	b12b      	cbz	r3, 80068a4 <tcp_receive+0x2e4>
 8006898:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800689a:	49a1      	ldr	r1, [pc, #644]	; (8006b20 <tcp_receive+0x560>)
 800689c:	6809      	ldr	r1, [r1, #0]
 800689e:	1a52      	subs	r2, r2, r1
 80068a0:	2a00      	cmp	r2, #0
 80068a2:	db23      	blt.n	80068ec <tcp_receive+0x32c>
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 80068a4:	4b9f      	ldr	r3, [pc, #636]	; (8006b24 <tcp_receive+0x564>)
 80068a6:	881b      	ldrh	r3, [r3, #0]
 80068a8:	2b00      	cmp	r3, #0
 80068aa:	f000 8256 	beq.w	8006d5a <tcp_receive+0x79a>
 80068ae:	7e22      	ldrb	r2, [r4, #24]
 80068b0:	2a06      	cmp	r2, #6
 80068b2:	f200 8252 	bhi.w	8006d5a <tcp_receive+0x79a>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
 80068b6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80068b8:	4a9b      	ldr	r2, [pc, #620]	; (8006b28 <tcp_receive+0x568>)
 80068ba:	6812      	ldr	r2, [r2, #0]
 80068bc:	1a8d      	subs	r5, r1, r2
 80068be:	2d01      	cmp	r5, #1
 80068c0:	d405      	bmi.n	80068ce <tcp_receive+0x30e>
 80068c2:	f1c2 0001 	rsb	r0, r2, #1
 80068c6:	1ac3      	subs	r3, r0, r3
 80068c8:	440b      	add	r3, r1
 80068ca:	2b00      	cmp	r3, #0
 80068cc:	dd2e      	ble.n	800692c <tcp_receive+0x36c>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
 80068ce:	1a53      	subs	r3, r2, r1
 80068d0:	2b00      	cmp	r3, #0
 80068d2:	db55      	blt.n	8006980 <tcp_receive+0x3c0>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 80068d4:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 80068d6:	f1c3 0301 	rsb	r3, r3, #1
 80068da:	4413      	add	r3, r2
 80068dc:	1a5b      	subs	r3, r3, r1
 80068de:	2b00      	cmp	r3, #0
 80068e0:	dd53      	ble.n	800698a <tcp_receive+0x3ca>
      tcp_send_empty_ack(pcb);
 80068e2:	4620      	mov	r0, r4
 80068e4:	f001 f8ec 	bl	8007ac0 <tcp_send_empty_ack>
 80068e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      m = m - (pcb->sa >> 3);
 80068ec:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
      m = (s16_t)(tcp_ticks - pcb->rttest);
 80068f0:	4a8e      	ldr	r2, [pc, #568]	; (8006b2c <tcp_receive+0x56c>)
 80068f2:	6812      	ldr	r2, [r2, #0]
 80068f4:	1ad3      	subs	r3, r2, r3
      m = m - (pcb->sa >> 3);
 80068f6:	eba3 03e1 	sub.w	r3, r3, r1, asr #3
 80068fa:	b29b      	uxth	r3, r3
 80068fc:	b218      	sxth	r0, r3
      pcb->sa += m;
 80068fe:	185a      	adds	r2, r3, r1
 8006900:	b212      	sxth	r2, r2
 8006902:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
      if (m < 0) {
 8006906:	2800      	cmp	r0, #0
        m = -m;
 8006908:	bfbc      	itt	lt
 800690a:	425b      	neglt	r3, r3
 800690c:	b218      	sxthlt	r0, r3
      m = m - (pcb->sv >> 2);
 800690e:	f9b4 3042 	ldrsh.w	r3, [r4, #66]	; 0x42
      pcb->sv += m;
 8006912:	eba3 03a3 	sub.w	r3, r3, r3, asr #2
 8006916:	4403      	add	r3, r0
 8006918:	b29b      	uxth	r3, r3
 800691a:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 800691e:	eb03 03e2 	add.w	r3, r3, r2, asr #3
 8006922:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
      pcb->rttest = 0;
 8006926:	2300      	movs	r3, #0
 8006928:	63a3      	str	r3, [r4, #56]	; 0x38
 800692a:	e7bb      	b.n	80068a4 <tcp_receive+0x2e4>
      off = pcb->rcv_nxt - seqno;
 800692c:	462b      	mov	r3, r5
      p = inseg.p;
 800692e:	4a80      	ldr	r2, [pc, #512]	; (8006b30 <tcp_receive+0x570>)
 8006930:	6850      	ldr	r0, [r2, #4]
      if (inseg.p->len < off) {
 8006932:	8942      	ldrh	r2, [r0, #10]
 8006934:	4295      	cmp	r5, r2
 8006936:	dd1e      	ble.n	8006976 <tcp_receive+0x3b6>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 8006938:	8901      	ldrh	r1, [r0, #8]
 800693a:	1b49      	subs	r1, r1, r5
 800693c:	b289      	uxth	r1, r1
          p->len = 0;
 800693e:	2500      	movs	r5, #0
          off -= p->len;
 8006940:	1a9b      	subs	r3, r3, r2
          p->tot_len = new_tot_len;
 8006942:	8101      	strh	r1, [r0, #8]
          p->len = 0;
 8006944:	8145      	strh	r5, [r0, #10]
          p = p->next;
 8006946:	6800      	ldr	r0, [r0, #0]
        while (p->len < off) {
 8006948:	8942      	ldrh	r2, [r0, #10]
 800694a:	429a      	cmp	r2, r3
 800694c:	dbf8      	blt.n	8006940 <tcp_receive+0x380>
        if(pbuf_header(p, (s16_t)-off)) {
 800694e:	425b      	negs	r3, r3
 8006950:	b219      	sxth	r1, r3
 8006952:	f7fe fe68 	bl	8005626 <pbuf_header>
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 8006956:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006958:	4975      	ldr	r1, [pc, #468]	; (8006b30 <tcp_receive+0x570>)
 800695a:	4873      	ldr	r0, [pc, #460]	; (8006b28 <tcp_receive+0x568>)
 800695c:	6803      	ldr	r3, [r0, #0]
 800695e:	890d      	ldrh	r5, [r1, #8]
 8006960:	442b      	add	r3, r5
 8006962:	1a9b      	subs	r3, r3, r2
 8006964:	810b      	strh	r3, [r1, #8]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 8006966:	68cb      	ldr	r3, [r1, #12]
 8006968:	6002      	str	r2, [r0, #0]
 800696a:	605a      	str	r2, [r3, #4]
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 800696c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800696e:	1a53      	subs	r3, r2, r1
 8006970:	2b00      	cmp	r3, #0
 8006972:	daaf      	bge.n	80068d4 <tcp_receive+0x314>
 8006974:	e7b5      	b.n	80068e2 <tcp_receive+0x322>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
 8006976:	4269      	negs	r1, r5
 8006978:	b209      	sxth	r1, r1
 800697a:	f7fe fe54 	bl	8005626 <pbuf_header>
 800697e:	e7ea      	b.n	8006956 <tcp_receive+0x396>
        tcp_ack_now(pcb);
 8006980:	7fa3      	ldrb	r3, [r4, #30]
 8006982:	f043 0302 	orr.w	r3, r3, #2
 8006986:	77a3      	strb	r3, [r4, #30]
 8006988:	e7ab      	b.n	80068e2 <tcp_receive+0x322>
      if (pcb->rcv_nxt == seqno) {
 800698a:	428a      	cmp	r2, r1
 800698c:	d013      	beq.n	80069b6 <tcp_receive+0x3f6>
        tcp_send_empty_ack(pcb);
 800698e:	4620      	mov	r0, r4
 8006990:	f001 f896 	bl	8007ac0 <tcp_send_empty_ack>
        if (pcb->ooseq == NULL) {
 8006994:	6f66      	ldr	r6, [r4, #116]	; 0x74
 8006996:	2e00      	cmp	r6, #0
 8006998:	f000 8128 	beq.w	8006bec <tcp_receive+0x62c>
            if (seqno == next->tcphdr->seqno) {
 800699c:	68f1      	ldr	r1, [r6, #12]
 800699e:	684a      	ldr	r2, [r1, #4]
 80069a0:	4b61      	ldr	r3, [pc, #388]	; (8006b28 <tcp_receive+0x568>)
 80069a2:	6818      	ldr	r0, [r3, #0]
 80069a4:	4282      	cmp	r2, r0
 80069a6:	f000 8127 	beq.w	8006bf8 <tcp_receive+0x638>
 80069aa:	2700      	movs	r7, #0
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 80069ac:	f100 3eff 	add.w	lr, r0, #4294967295
 80069b0:	f100 0c01 	add.w	ip, r0, #1
 80069b4:	e143      	b.n	8006c3e <tcp_receive+0x67e>
        tcplen = TCP_TCPLEN(&inseg);
 80069b6:	4b5e      	ldr	r3, [pc, #376]	; (8006b30 <tcp_receive+0x570>)
 80069b8:	891d      	ldrh	r5, [r3, #8]
 80069ba:	68db      	ldr	r3, [r3, #12]
 80069bc:	8998      	ldrh	r0, [r3, #12]
 80069be:	f7fd fbfa 	bl	80041b6 <lwip_ntohs>
 80069c2:	f010 0303 	ands.w	r3, r0, #3
 80069c6:	bf18      	it	ne
 80069c8:	2301      	movne	r3, #1
 80069ca:	442b      	add	r3, r5
 80069cc:	b29b      	uxth	r3, r3
 80069ce:	4a55      	ldr	r2, [pc, #340]	; (8006b24 <tcp_receive+0x564>)
 80069d0:	8013      	strh	r3, [r2, #0]
        if (tcplen > pcb->rcv_wnd) {
 80069d2:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 80069d4:	429a      	cmp	r2, r3
 80069d6:	d317      	bcc.n	8006a08 <tcp_receive+0x448>
        if (pcb->ooseq != NULL) {
 80069d8:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80069da:	2b00      	cmp	r3, #0
 80069dc:	f000 81d1 	beq.w	8006d82 <tcp_receive+0x7c2>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 80069e0:	4b53      	ldr	r3, [pc, #332]	; (8006b30 <tcp_receive+0x570>)
 80069e2:	68db      	ldr	r3, [r3, #12]
 80069e4:	8998      	ldrh	r0, [r3, #12]
 80069e6:	f7fd fbe6 	bl	80041b6 <lwip_ntohs>
 80069ea:	f010 0f01 	tst.w	r0, #1
 80069ee:	d042      	beq.n	8006a76 <tcp_receive+0x4b6>
            while (pcb->ooseq != NULL) {
 80069f0:	6f60      	ldr	r0, [r4, #116]	; 0x74
 80069f2:	2800      	cmp	r0, #0
 80069f4:	f000 81c5 	beq.w	8006d82 <tcp_receive+0x7c2>
              pcb->ooseq = pcb->ooseq->next;
 80069f8:	6803      	ldr	r3, [r0, #0]
 80069fa:	6763      	str	r3, [r4, #116]	; 0x74
              tcp_seg_free(old_ooseq);
 80069fc:	f7ff f890 	bl	8005b20 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
 8006a00:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8006a02:	2800      	cmp	r0, #0
 8006a04:	d1f8      	bne.n	80069f8 <tcp_receive+0x438>
 8006a06:	e1bc      	b.n	8006d82 <tcp_receive+0x7c2>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8006a08:	4b49      	ldr	r3, [pc, #292]	; (8006b30 <tcp_receive+0x570>)
 8006a0a:	68db      	ldr	r3, [r3, #12]
 8006a0c:	8998      	ldrh	r0, [r3, #12]
 8006a0e:	f7fd fbd2 	bl	80041b6 <lwip_ntohs>
 8006a12:	f010 0f01 	tst.w	r0, #1
 8006a16:	d11f      	bne.n	8006a58 <tcp_receive+0x498>
          inseg.len = pcb->rcv_wnd;
 8006a18:	4b45      	ldr	r3, [pc, #276]	; (8006b30 <tcp_receive+0x570>)
 8006a1a:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 8006a1c:	811a      	strh	r2, [r3, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8006a1e:	68db      	ldr	r3, [r3, #12]
 8006a20:	8998      	ldrh	r0, [r3, #12]
 8006a22:	f7fd fbc8 	bl	80041b6 <lwip_ntohs>
 8006a26:	f010 0f02 	tst.w	r0, #2
 8006a2a:	d003      	beq.n	8006a34 <tcp_receive+0x474>
            inseg.len -= 1;
 8006a2c:	4a40      	ldr	r2, [pc, #256]	; (8006b30 <tcp_receive+0x570>)
 8006a2e:	8913      	ldrh	r3, [r2, #8]
 8006a30:	3b01      	subs	r3, #1
 8006a32:	8113      	strh	r3, [r2, #8]
          pbuf_realloc(inseg.p, inseg.len);
 8006a34:	4d3e      	ldr	r5, [pc, #248]	; (8006b30 <tcp_receive+0x570>)
 8006a36:	8929      	ldrh	r1, [r5, #8]
 8006a38:	6868      	ldr	r0, [r5, #4]
 8006a3a:	f7fe fef9 	bl	8005830 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 8006a3e:	892e      	ldrh	r6, [r5, #8]
 8006a40:	68eb      	ldr	r3, [r5, #12]
 8006a42:	8998      	ldrh	r0, [r3, #12]
 8006a44:	f7fd fbb7 	bl	80041b6 <lwip_ntohs>
 8006a48:	f010 0003 	ands.w	r0, r0, #3
 8006a4c:	bf18      	it	ne
 8006a4e:	2001      	movne	r0, #1
 8006a50:	4406      	add	r6, r0
 8006a52:	4b34      	ldr	r3, [pc, #208]	; (8006b24 <tcp_receive+0x564>)
 8006a54:	801e      	strh	r6, [r3, #0]
 8006a56:	e7bf      	b.n	80069d8 <tcp_receive+0x418>
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
 8006a58:	4b35      	ldr	r3, [pc, #212]	; (8006b30 <tcp_receive+0x570>)
 8006a5a:	68de      	ldr	r6, [r3, #12]
 8006a5c:	89b5      	ldrh	r5, [r6, #12]
 8006a5e:	4628      	mov	r0, r5
 8006a60:	f7fd fba9 	bl	80041b6 <lwip_ntohs>
 8006a64:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 8006a68:	f7fd fba0 	bl	80041ac <lwip_htons>
 8006a6c:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 8006a70:	4305      	orrs	r5, r0
 8006a72:	81b5      	strh	r5, [r6, #12]
 8006a74:	e7d0      	b.n	8006a18 <tcp_receive+0x458>
            next = pcb->ooseq;
 8006a76:	f8d4 9074 	ldr.w	r9, [r4, #116]	; 0x74
            while (next &&
 8006a7a:	f1b9 0f00 	cmp.w	r9, #0
 8006a7e:	f000 817e 	beq.w	8006d7e <tcp_receive+0x7be>
                   TCP_SEQ_GEQ(seqno + tcplen,
 8006a82:	f8d9 200c 	ldr.w	r2, [r9, #12]
 8006a86:	4b27      	ldr	r3, [pc, #156]	; (8006b24 <tcp_receive+0x564>)
 8006a88:	881b      	ldrh	r3, [r3, #0]
 8006a8a:	4927      	ldr	r1, [pc, #156]	; (8006b28 <tcp_receive+0x568>)
 8006a8c:	6809      	ldr	r1, [r1, #0]
 8006a8e:	440b      	add	r3, r1
 8006a90:	6851      	ldr	r1, [r2, #4]
 8006a92:	1a5b      	subs	r3, r3, r1
 8006a94:	f8b9 1008 	ldrh.w	r1, [r9, #8]
 8006a98:	1a5b      	subs	r3, r3, r1
            while (next &&
 8006a9a:	2b00      	cmp	r3, #0
 8006a9c:	f2c0 81a2 	blt.w	8006de4 <tcp_receive+0x824>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 8006aa0:	f8df 808c 	ldr.w	r8, [pc, #140]	; 8006b30 <tcp_receive+0x570>
                tcplen = TCP_TCPLEN(&inseg);
 8006aa4:	4e1f      	ldr	r6, [pc, #124]	; (8006b24 <tcp_receive+0x564>)
                   TCP_SEQ_GEQ(seqno + tcplen,
 8006aa6:	4f20      	ldr	r7, [pc, #128]	; (8006b28 <tcp_receive+0x568>)
 8006aa8:	e013      	b.n	8006ad2 <tcp_receive+0x512>
              next = next->next;
 8006aaa:	f8d9 5000 	ldr.w	r5, [r9]
              tcp_seg_free(prev);
 8006aae:	4648      	mov	r0, r9
 8006ab0:	f7ff f836 	bl	8005b20 <tcp_seg_free>
            while (next &&
 8006ab4:	2d00      	cmp	r5, #0
 8006ab6:	f000 8162 	beq.w	8006d7e <tcp_receive+0x7be>
                   TCP_SEQ_GEQ(seqno + tcplen,
 8006aba:	68ea      	ldr	r2, [r5, #12]
 8006abc:	8833      	ldrh	r3, [r6, #0]
 8006abe:	6839      	ldr	r1, [r7, #0]
 8006ac0:	440b      	add	r3, r1
 8006ac2:	6851      	ldr	r1, [r2, #4]
 8006ac4:	1a5b      	subs	r3, r3, r1
 8006ac6:	8929      	ldrh	r1, [r5, #8]
 8006ac8:	1a5b      	subs	r3, r3, r1
            while (next &&
 8006aca:	2b00      	cmp	r3, #0
 8006acc:	f2c0 818b 	blt.w	8006de6 <tcp_receive+0x826>
              next = next->next;
 8006ad0:	46a9      	mov	r9, r5
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 8006ad2:	8990      	ldrh	r0, [r2, #12]
 8006ad4:	f7fd fb6f 	bl	80041b6 <lwip_ntohs>
 8006ad8:	f010 0f01 	tst.w	r0, #1
 8006adc:	d0e5      	beq.n	8006aaa <tcp_receive+0x4ea>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 8006ade:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8006ae2:	8998      	ldrh	r0, [r3, #12]
 8006ae4:	f7fd fb67 	bl	80041b6 <lwip_ntohs>
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 8006ae8:	f010 0f02 	tst.w	r0, #2
 8006aec:	d1dd      	bne.n	8006aaa <tcp_receive+0x4ea>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 8006aee:	f8d8 a00c 	ldr.w	sl, [r8, #12]
 8006af2:	f8ba 500c 	ldrh.w	r5, [sl, #12]
 8006af6:	2001      	movs	r0, #1
 8006af8:	f7fd fb58 	bl	80041ac <lwip_htons>
 8006afc:	4328      	orrs	r0, r5
 8006afe:	f8aa 000c 	strh.w	r0, [sl, #12]
                tcplen = TCP_TCPLEN(&inseg);
 8006b02:	f8b8 5008 	ldrh.w	r5, [r8, #8]
 8006b06:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8006b0a:	8998      	ldrh	r0, [r3, #12]
 8006b0c:	f7fd fb53 	bl	80041b6 <lwip_ntohs>
 8006b10:	f010 0003 	ands.w	r0, r0, #3
 8006b14:	bf18      	it	ne
 8006b16:	2001      	movne	r0, #1
 8006b18:	4405      	add	r5, r0
 8006b1a:	8035      	strh	r5, [r6, #0]
 8006b1c:	e7c5      	b.n	8006aaa <tcp_receive+0x4ea>
 8006b1e:	bf00      	nop
 8006b20:	200076fc 	.word	0x200076fc
 8006b24:	20007724 	.word	0x20007724
 8006b28:	2000771c 	.word	0x2000771c
 8006b2c:	2000b1a4 	.word	0x2000b1a4
 8006b30:	20007704 	.word	0x20007704
              recv_data = cseg->p;
 8006b34:	f8c8 1000 	str.w	r1, [r8]
            cseg->p = NULL;
 8006b38:	2300      	movs	r3, #0
 8006b3a:	606b      	str	r3, [r5, #4]
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 8006b3c:	68eb      	ldr	r3, [r5, #12]
 8006b3e:	8998      	ldrh	r0, [r3, #12]
 8006b40:	f7fd fb39 	bl	80041b6 <lwip_ntohs>
 8006b44:	f010 0f01 	tst.w	r0, #1
 8006b48:	d008      	beq.n	8006b5c <tcp_receive+0x59c>
            recv_flags |= TF_GOT_FIN;
 8006b4a:	7833      	ldrb	r3, [r6, #0]
 8006b4c:	f043 0320 	orr.w	r3, r3, #32
 8006b50:	7033      	strb	r3, [r6, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 8006b52:	7e23      	ldrb	r3, [r4, #24]
 8006b54:	2b04      	cmp	r3, #4
              pcb->state = CLOSE_WAIT;
 8006b56:	bf04      	itt	eq
 8006b58:	2307      	moveq	r3, #7
 8006b5a:	7623      	strbeq	r3, [r4, #24]
          pcb->ooseq = cseg->next;
 8006b5c:	682b      	ldr	r3, [r5, #0]
 8006b5e:	6763      	str	r3, [r4, #116]	; 0x74
          tcp_seg_free(cseg);
 8006b60:	4628      	mov	r0, r5
 8006b62:	f7fe ffdd 	bl	8005b20 <tcp_seg_free>
        while (pcb->ooseq != NULL &&
 8006b66:	6f65      	ldr	r5, [r4, #116]	; 0x74
 8006b68:	2d00      	cmp	r5, #0
 8006b6a:	d032      	beq.n	8006bd2 <tcp_receive+0x612>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 8006b6c:	68eb      	ldr	r3, [r5, #12]
 8006b6e:	685a      	ldr	r2, [r3, #4]
        while (pcb->ooseq != NULL &&
 8006b70:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006b72:	428a      	cmp	r2, r1
 8006b74:	d12d      	bne.n	8006bd2 <tcp_receive+0x612>
          seqno = pcb->ooseq->tcphdr->seqno;
 8006b76:	603a      	str	r2, [r7, #0]
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 8006b78:	f8b5 9008 	ldrh.w	r9, [r5, #8]
 8006b7c:	8998      	ldrh	r0, [r3, #12]
 8006b7e:	f7fd fb1a 	bl	80041b6 <lwip_ntohs>
 8006b82:	f010 0003 	ands.w	r0, r0, #3
 8006b86:	bf18      	it	ne
 8006b88:	2001      	movne	r0, #1
 8006b8a:	4448      	add	r0, r9
 8006b8c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8006b8e:	4418      	add	r0, r3
 8006b90:	62a0      	str	r0, [r4, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 8006b92:	68eb      	ldr	r3, [r5, #12]
 8006b94:	8998      	ldrh	r0, [r3, #12]
 8006b96:	f7fd fb0e 	bl	80041b6 <lwip_ntohs>
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 8006b9a:	f8b5 9008 	ldrh.w	r9, [r5, #8]
 8006b9e:	68eb      	ldr	r3, [r5, #12]
 8006ba0:	8998      	ldrh	r0, [r3, #12]
 8006ba2:	f7fd fb08 	bl	80041b6 <lwip_ntohs>
 8006ba6:	f010 0003 	ands.w	r0, r0, #3
 8006baa:	bf18      	it	ne
 8006bac:	2001      	movne	r0, #1
 8006bae:	4448      	add	r0, r9
 8006bb0:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006bb2:	1a18      	subs	r0, r3, r0
 8006bb4:	85a0      	strh	r0, [r4, #44]	; 0x2c
          tcp_update_rcv_ann_wnd(pcb);
 8006bb6:	4620      	mov	r0, r4
 8006bb8:	f7fe ff78 	bl	8005aac <tcp_update_rcv_ann_wnd>
          if (cseg->p->tot_len > 0) {
 8006bbc:	6869      	ldr	r1, [r5, #4]
 8006bbe:	890b      	ldrh	r3, [r1, #8]
 8006bc0:	2b00      	cmp	r3, #0
 8006bc2:	d0bb      	beq.n	8006b3c <tcp_receive+0x57c>
            if (recv_data) {
 8006bc4:	f8d8 0000 	ldr.w	r0, [r8]
 8006bc8:	2800      	cmp	r0, #0
 8006bca:	d0b3      	beq.n	8006b34 <tcp_receive+0x574>
              pbuf_cat(recv_data, cseg->p);
 8006bcc:	f7fe fe6b 	bl	80058a6 <pbuf_cat>
 8006bd0:	e7b2      	b.n	8006b38 <tcp_receive+0x578>
        tcp_ack(pcb);
 8006bd2:	7fa3      	ldrb	r3, [r4, #30]
 8006bd4:	f013 0f01 	tst.w	r3, #1
 8006bd8:	bf1a      	itte	ne
 8006bda:	f023 0301 	bicne.w	r3, r3, #1
 8006bde:	f043 0302 	orrne.w	r3, r3, #2
 8006be2:	f043 0301 	orreq.w	r3, r3, #1
 8006be6:	77a3      	strb	r3, [r4, #30]
 8006be8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          pcb->ooseq = tcp_seg_copy(&inseg);
 8006bec:	4893      	ldr	r0, [pc, #588]	; (8006e3c <tcp_receive+0x87c>)
 8006bee:	f7fe ffb0 	bl	8005b52 <tcp_seg_copy>
 8006bf2:	6760      	str	r0, [r4, #116]	; 0x74
 8006bf4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if (seqno == next->tcphdr->seqno) {
 8006bf8:	4635      	mov	r5, r6
 8006bfa:	2600      	movs	r6, #0
              if (inseg.len > next->len) {
 8006bfc:	4b8f      	ldr	r3, [pc, #572]	; (8006e3c <tcp_receive+0x87c>)
 8006bfe:	891a      	ldrh	r2, [r3, #8]
 8006c00:	892b      	ldrh	r3, [r5, #8]
 8006c02:	429a      	cmp	r2, r3
 8006c04:	d94f      	bls.n	8006ca6 <tcp_receive+0x6e6>
                cseg = tcp_seg_copy(&inseg);
 8006c06:	488d      	ldr	r0, [pc, #564]	; (8006e3c <tcp_receive+0x87c>)
 8006c08:	f7fe ffa3 	bl	8005b52 <tcp_seg_copy>
                if (cseg != NULL) {
 8006c0c:	4603      	mov	r3, r0
 8006c0e:	2800      	cmp	r0, #0
 8006c10:	d049      	beq.n	8006ca6 <tcp_receive+0x6e6>
                  if (prev != NULL) {
 8006c12:	b136      	cbz	r6, 8006c22 <tcp_receive+0x662>
                    prev->next = cseg;
 8006c14:	6030      	str	r0, [r6, #0]
                  tcp_oos_insert_segment(cseg, next);
 8006c16:	4629      	mov	r1, r5
 8006c18:	4618      	mov	r0, r3
 8006c1a:	f7ff fc73 	bl	8006504 <tcp_oos_insert_segment>
 8006c1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                    pcb->ooseq = cseg;
 8006c22:	6760      	str	r0, [r4, #116]	; 0x74
 8006c24:	e7f7      	b.n	8006c16 <tcp_receive+0x656>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 8006c26:	1a83      	subs	r3, r0, r2
 8006c28:	2b00      	cmp	r3, #0
 8006c2a:	db2f      	blt.n	8006c8c <tcp_receive+0x6cc>
              if (next->next == NULL &&
 8006c2c:	6835      	ldr	r5, [r6, #0]
 8006c2e:	2d00      	cmp	r5, #0
 8006c30:	d036      	beq.n	8006ca0 <tcp_receive+0x6e0>
            if (seqno == next->tcphdr->seqno) {
 8006c32:	68e9      	ldr	r1, [r5, #12]
 8006c34:	684a      	ldr	r2, [r1, #4]
 8006c36:	4637      	mov	r7, r6
 8006c38:	4282      	cmp	r2, r0
 8006c3a:	d0df      	beq.n	8006bfc <tcp_receive+0x63c>
              if (next->next == NULL &&
 8006c3c:	462e      	mov	r6, r5
              if (prev == NULL) {
 8006c3e:	2f00      	cmp	r7, #0
 8006c40:	d0f1      	beq.n	8006c26 <tcp_receive+0x666>
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 8006c42:	68fb      	ldr	r3, [r7, #12]
 8006c44:	685b      	ldr	r3, [r3, #4]
 8006c46:	ebae 0303 	sub.w	r3, lr, r3
 8006c4a:	2b00      	cmp	r3, #0
 8006c4c:	dbee      	blt.n	8006c2c <tcp_receive+0x66c>
 8006c4e:	ebac 0302 	sub.w	r3, ip, r2
 8006c52:	2b00      	cmp	r3, #0
 8006c54:	dcea      	bgt.n	8006c2c <tcp_receive+0x66c>
                  cseg = tcp_seg_copy(&inseg);
 8006c56:	4879      	ldr	r0, [pc, #484]	; (8006e3c <tcp_receive+0x87c>)
 8006c58:	f7fe ff7b 	bl	8005b52 <tcp_seg_copy>
                  if (cseg != NULL) {
 8006c5c:	4604      	mov	r4, r0
 8006c5e:	b310      	cbz	r0, 8006ca6 <tcp_receive+0x6e6>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 8006c60:	68fb      	ldr	r3, [r7, #12]
 8006c62:	6859      	ldr	r1, [r3, #4]
 8006c64:	4b76      	ldr	r3, [pc, #472]	; (8006e40 <tcp_receive+0x880>)
 8006c66:	681b      	ldr	r3, [r3, #0]
 8006c68:	893a      	ldrh	r2, [r7, #8]
 8006c6a:	440a      	add	r2, r1
 8006c6c:	1ad2      	subs	r2, r2, r3
 8006c6e:	2a00      	cmp	r2, #0
 8006c70:	dd05      	ble.n	8006c7e <tcp_receive+0x6be>
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 8006c72:	1a5b      	subs	r3, r3, r1
 8006c74:	b299      	uxth	r1, r3
 8006c76:	8139      	strh	r1, [r7, #8]
                      pbuf_realloc(prev->p, prev->len);
 8006c78:	6878      	ldr	r0, [r7, #4]
 8006c7a:	f7fe fdd9 	bl	8005830 <pbuf_realloc>
                    prev->next = cseg;
 8006c7e:	603c      	str	r4, [r7, #0]
                    tcp_oos_insert_segment(cseg, next);
 8006c80:	4631      	mov	r1, r6
 8006c82:	4620      	mov	r0, r4
 8006c84:	f7ff fc3e 	bl	8006504 <tcp_oos_insert_segment>
 8006c88:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                  cseg = tcp_seg_copy(&inseg);
 8006c8c:	486b      	ldr	r0, [pc, #428]	; (8006e3c <tcp_receive+0x87c>)
 8006c8e:	f7fe ff60 	bl	8005b52 <tcp_seg_copy>
                  if (cseg != NULL) {
 8006c92:	b140      	cbz	r0, 8006ca6 <tcp_receive+0x6e6>
                    pcb->ooseq = cseg;
 8006c94:	6760      	str	r0, [r4, #116]	; 0x74
                    tcp_oos_insert_segment(cseg, next);
 8006c96:	4631      	mov	r1, r6
 8006c98:	f7ff fc34 	bl	8006504 <tcp_oos_insert_segment>
 8006c9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 8006ca0:	1a82      	subs	r2, r0, r2
              if (next->next == NULL &&
 8006ca2:	2a00      	cmp	r2, #0
 8006ca4:	dc01      	bgt.n	8006caa <tcp_receive+0x6ea>
 8006ca6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 8006caa:	8988      	ldrh	r0, [r1, #12]
 8006cac:	f7fd fa83 	bl	80041b6 <lwip_ntohs>
 8006cb0:	f010 0f01 	tst.w	r0, #1
 8006cb4:	d1f7      	bne.n	8006ca6 <tcp_receive+0x6e6>
                next->next = tcp_seg_copy(&inseg);
 8006cb6:	4861      	ldr	r0, [pc, #388]	; (8006e3c <tcp_receive+0x87c>)
 8006cb8:	f7fe ff4b 	bl	8005b52 <tcp_seg_copy>
 8006cbc:	6030      	str	r0, [r6, #0]
                if (next->next != NULL) {
 8006cbe:	2800      	cmp	r0, #0
 8006cc0:	d0f1      	beq.n	8006ca6 <tcp_receive+0x6e6>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 8006cc2:	68f3      	ldr	r3, [r6, #12]
 8006cc4:	6859      	ldr	r1, [r3, #4]
 8006cc6:	4b5e      	ldr	r3, [pc, #376]	; (8006e40 <tcp_receive+0x880>)
 8006cc8:	681b      	ldr	r3, [r3, #0]
 8006cca:	8932      	ldrh	r2, [r6, #8]
 8006ccc:	440a      	add	r2, r1
 8006cce:	1ad2      	subs	r2, r2, r3
 8006cd0:	2a00      	cmp	r2, #0
 8006cd2:	dd05      	ble.n	8006ce0 <tcp_receive+0x720>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 8006cd4:	1a5b      	subs	r3, r3, r1
 8006cd6:	b299      	uxth	r1, r3
 8006cd8:	8131      	strh	r1, [r6, #8]
                    pbuf_realloc(next->p, next->len);
 8006cda:	6870      	ldr	r0, [r6, #4]
 8006cdc:	f7fe fda8 	bl	8005830 <pbuf_realloc>
                  if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
 8006ce0:	4b58      	ldr	r3, [pc, #352]	; (8006e44 <tcp_receive+0x884>)
 8006ce2:	881a      	ldrh	r2, [r3, #0]
 8006ce4:	4b56      	ldr	r3, [pc, #344]	; (8006e40 <tcp_receive+0x880>)
 8006ce6:	681b      	ldr	r3, [r3, #0]
 8006ce8:	441a      	add	r2, r3
 8006cea:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006cec:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006cee:	440b      	add	r3, r1
 8006cf0:	429a      	cmp	r2, r3
 8006cf2:	d9d8      	bls.n	8006ca6 <tcp_receive+0x6e6>
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 8006cf4:	6833      	ldr	r3, [r6, #0]
 8006cf6:	68db      	ldr	r3, [r3, #12]
 8006cf8:	8998      	ldrh	r0, [r3, #12]
 8006cfa:	f7fd fa5c 	bl	80041b6 <lwip_ntohs>
 8006cfe:	f010 0f01 	tst.w	r0, #1
 8006d02:	d11b      	bne.n	8006d3c <tcp_receive+0x77c>
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
 8006d04:	6832      	ldr	r2, [r6, #0]
 8006d06:	4b4e      	ldr	r3, [pc, #312]	; (8006e40 <tcp_receive+0x880>)
 8006d08:	6819      	ldr	r1, [r3, #0]
 8006d0a:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006d0c:	1a5b      	subs	r3, r3, r1
 8006d0e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006d10:	440b      	add	r3, r1
 8006d12:	8113      	strh	r3, [r2, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 8006d14:	6833      	ldr	r3, [r6, #0]
 8006d16:	8919      	ldrh	r1, [r3, #8]
 8006d18:	6858      	ldr	r0, [r3, #4]
 8006d1a:	f7fe fd89 	bl	8005830 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 8006d1e:	6833      	ldr	r3, [r6, #0]
 8006d20:	891c      	ldrh	r4, [r3, #8]
 8006d22:	68db      	ldr	r3, [r3, #12]
 8006d24:	8998      	ldrh	r0, [r3, #12]
 8006d26:	f7fd fa46 	bl	80041b6 <lwip_ntohs>
 8006d2a:	f010 0003 	ands.w	r0, r0, #3
 8006d2e:	bf18      	it	ne
 8006d30:	2001      	movne	r0, #1
 8006d32:	4404      	add	r4, r0
 8006d34:	4b43      	ldr	r3, [pc, #268]	; (8006e44 <tcp_receive+0x884>)
 8006d36:	801c      	strh	r4, [r3, #0]
 8006d38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
 8006d3c:	6833      	ldr	r3, [r6, #0]
 8006d3e:	68df      	ldr	r7, [r3, #12]
 8006d40:	89bd      	ldrh	r5, [r7, #12]
 8006d42:	4628      	mov	r0, r5
 8006d44:	f7fd fa37 	bl	80041b6 <lwip_ntohs>
 8006d48:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 8006d4c:	f7fd fa2e 	bl	80041ac <lwip_htons>
 8006d50:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 8006d54:	4305      	orrs	r5, r0
 8006d56:	81bd      	strh	r5, [r7, #12]
 8006d58:	e7d4      	b.n	8006d04 <tcp_receive+0x744>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
 8006d5a:	4b39      	ldr	r3, [pc, #228]	; (8006e40 <tcp_receive+0x880>)
 8006d5c:	681b      	ldr	r3, [r3, #0]
 8006d5e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006d60:	1a99      	subs	r1, r3, r2
 8006d62:	2900      	cmp	r1, #0
 8006d64:	db05      	blt.n	8006d72 <tcp_receive+0x7b2>
 8006d66:	3301      	adds	r3, #1
 8006d68:	1a9b      	subs	r3, r3, r2
 8006d6a:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 8006d6c:	1a9b      	subs	r3, r3, r2
 8006d6e:	2b00      	cmp	r3, #0
 8006d70:	dd99      	ble.n	8006ca6 <tcp_receive+0x6e6>
      tcp_ack_now(pcb);
 8006d72:	7fa3      	ldrb	r3, [r4, #30]
 8006d74:	f043 0302 	orr.w	r3, r3, #2
 8006d78:	77a3      	strb	r3, [r4, #30]
}
 8006d7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
              next = next->next;
 8006d7e:	2500      	movs	r5, #0
            pcb->ooseq = next;
 8006d80:	6765      	str	r5, [r4, #116]	; 0x74
        pcb->rcv_nxt = seqno + tcplen;
 8006d82:	4b30      	ldr	r3, [pc, #192]	; (8006e44 <tcp_receive+0x884>)
 8006d84:	881a      	ldrh	r2, [r3, #0]
 8006d86:	4b2e      	ldr	r3, [pc, #184]	; (8006e40 <tcp_receive+0x880>)
 8006d88:	681b      	ldr	r3, [r3, #0]
 8006d8a:	4413      	add	r3, r2
 8006d8c:	62a3      	str	r3, [r4, #40]	; 0x28
        pcb->rcv_wnd -= tcplen;
 8006d8e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8006d90:	1a9b      	subs	r3, r3, r2
 8006d92:	85a3      	strh	r3, [r4, #44]	; 0x2c
        tcp_update_rcv_ann_wnd(pcb);
 8006d94:	4620      	mov	r0, r4
 8006d96:	f7fe fe89 	bl	8005aac <tcp_update_rcv_ann_wnd>
        if (inseg.p->tot_len > 0) {
 8006d9a:	4b28      	ldr	r3, [pc, #160]	; (8006e3c <tcp_receive+0x87c>)
 8006d9c:	685b      	ldr	r3, [r3, #4]
 8006d9e:	891a      	ldrh	r2, [r3, #8]
 8006da0:	b122      	cbz	r2, 8006dac <tcp_receive+0x7ec>
          recv_data = inseg.p;
 8006da2:	4a29      	ldr	r2, [pc, #164]	; (8006e48 <tcp_receive+0x888>)
 8006da4:	6013      	str	r3, [r2, #0]
          inseg.p = NULL;
 8006da6:	2200      	movs	r2, #0
 8006da8:	4b24      	ldr	r3, [pc, #144]	; (8006e3c <tcp_receive+0x87c>)
 8006daa:	605a      	str	r2, [r3, #4]
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8006dac:	4b23      	ldr	r3, [pc, #140]	; (8006e3c <tcp_receive+0x87c>)
 8006dae:	68db      	ldr	r3, [r3, #12]
 8006db0:	8998      	ldrh	r0, [r3, #12]
 8006db2:	f7fd fa00 	bl	80041b6 <lwip_ntohs>
 8006db6:	f010 0f01 	tst.w	r0, #1
 8006dba:	d004      	beq.n	8006dc6 <tcp_receive+0x806>
          recv_flags |= TF_GOT_FIN;
 8006dbc:	4a23      	ldr	r2, [pc, #140]	; (8006e4c <tcp_receive+0x88c>)
 8006dbe:	7813      	ldrb	r3, [r2, #0]
 8006dc0:	f043 0320 	orr.w	r3, r3, #32
 8006dc4:	7013      	strb	r3, [r2, #0]
        while (pcb->ooseq != NULL &&
 8006dc6:	6f65      	ldr	r5, [r4, #116]	; 0x74
 8006dc8:	2d00      	cmp	r5, #0
 8006dca:	f43f af02 	beq.w	8006bd2 <tcp_receive+0x612>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 8006dce:	68eb      	ldr	r3, [r5, #12]
 8006dd0:	685a      	ldr	r2, [r3, #4]
        while (pcb->ooseq != NULL &&
 8006dd2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006dd4:	428a      	cmp	r2, r1
 8006dd6:	f47f aefc 	bne.w	8006bd2 <tcp_receive+0x612>
          seqno = pcb->ooseq->tcphdr->seqno;
 8006dda:	4f19      	ldr	r7, [pc, #100]	; (8006e40 <tcp_receive+0x880>)
            if (recv_data) {
 8006ddc:	f8df 8068 	ldr.w	r8, [pc, #104]	; 8006e48 <tcp_receive+0x888>
            recv_flags |= TF_GOT_FIN;
 8006de0:	4e1a      	ldr	r6, [pc, #104]	; (8006e4c <tcp_receive+0x88c>)
 8006de2:	e6c8      	b.n	8006b76 <tcp_receive+0x5b6>
            next = pcb->ooseq;
 8006de4:	464d      	mov	r5, r9
                TCP_SEQ_GT(seqno + tcplen,
 8006de6:	4b16      	ldr	r3, [pc, #88]	; (8006e40 <tcp_receive+0x880>)
 8006de8:	6819      	ldr	r1, [r3, #0]
 8006dea:	68eb      	ldr	r3, [r5, #12]
 8006dec:	685a      	ldr	r2, [r3, #4]
 8006dee:	4b15      	ldr	r3, [pc, #84]	; (8006e44 <tcp_receive+0x884>)
 8006df0:	881b      	ldrh	r3, [r3, #0]
 8006df2:	440b      	add	r3, r1
 8006df4:	1a9b      	subs	r3, r3, r2
            if (next &&
 8006df6:	2b00      	cmp	r3, #0
 8006df8:	ddc2      	ble.n	8006d80 <tcp_receive+0x7c0>
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 8006dfa:	4b10      	ldr	r3, [pc, #64]	; (8006e3c <tcp_receive+0x87c>)
 8006dfc:	1a52      	subs	r2, r2, r1
 8006dfe:	811a      	strh	r2, [r3, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8006e00:	68db      	ldr	r3, [r3, #12]
 8006e02:	8998      	ldrh	r0, [r3, #12]
 8006e04:	f7fd f9d7 	bl	80041b6 <lwip_ntohs>
 8006e08:	f010 0f02 	tst.w	r0, #2
 8006e0c:	d003      	beq.n	8006e16 <tcp_receive+0x856>
                inseg.len -= 1;
 8006e0e:	4a0b      	ldr	r2, [pc, #44]	; (8006e3c <tcp_receive+0x87c>)
 8006e10:	8913      	ldrh	r3, [r2, #8]
 8006e12:	3b01      	subs	r3, #1
 8006e14:	8113      	strh	r3, [r2, #8]
              pbuf_realloc(inseg.p, inseg.len);
 8006e16:	4e09      	ldr	r6, [pc, #36]	; (8006e3c <tcp_receive+0x87c>)
 8006e18:	8931      	ldrh	r1, [r6, #8]
 8006e1a:	6870      	ldr	r0, [r6, #4]
 8006e1c:	f7fe fd08 	bl	8005830 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 8006e20:	8937      	ldrh	r7, [r6, #8]
 8006e22:	68f3      	ldr	r3, [r6, #12]
 8006e24:	8998      	ldrh	r0, [r3, #12]
 8006e26:	f7fd f9c6 	bl	80041b6 <lwip_ntohs>
 8006e2a:	f010 0003 	ands.w	r0, r0, #3
 8006e2e:	bf18      	it	ne
 8006e30:	2001      	movne	r0, #1
 8006e32:	4407      	add	r7, r0
 8006e34:	4b03      	ldr	r3, [pc, #12]	; (8006e44 <tcp_receive+0x884>)
 8006e36:	801f      	strh	r7, [r3, #0]
 8006e38:	e7a2      	b.n	8006d80 <tcp_receive+0x7c0>
 8006e3a:	bf00      	nop
 8006e3c:	20007704 	.word	0x20007704
 8006e40:	2000771c 	.word	0x2000771c
 8006e44:	20007724 	.word	0x20007724
 8006e48:	20007714 	.word	0x20007714
 8006e4c:	20007718 	.word	0x20007718

08006e50 <tcp_input>:
{
 8006e50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006e54:	b083      	sub	sp, #12
 8006e56:	4604      	mov	r4, r0
 8006e58:	460d      	mov	r5, r1
  TCP_STATS_INC(tcp.recv);
 8006e5a:	4aa5      	ldr	r2, [pc, #660]	; (80070f0 <tcp_input+0x2a0>)
 8006e5c:	f8b2 3092 	ldrh.w	r3, [r2, #146]	; 0x92
 8006e60:	3301      	adds	r3, #1
 8006e62:	f8a2 3092 	strh.w	r3, [r2, #146]	; 0x92
  iphdr = (struct ip_hdr *)p->payload;
 8006e66:	6843      	ldr	r3, [r0, #4]
 8006e68:	7819      	ldrb	r1, [r3, #0]
 8006e6a:	f001 010f 	and.w	r1, r1, #15
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 8006e6e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8006e72:	4aa0      	ldr	r2, [pc, #640]	; (80070f4 <tcp_input+0x2a4>)
 8006e74:	6013      	str	r3, [r2, #0]
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 8006e76:	0089      	lsls	r1, r1, #2
 8006e78:	4249      	negs	r1, r1
 8006e7a:	f7fe fbd4 	bl	8005626 <pbuf_header>
 8006e7e:	b910      	cbnz	r0, 8006e86 <tcp_input+0x36>
 8006e80:	8923      	ldrh	r3, [r4, #8]
 8006e82:	2b13      	cmp	r3, #19
 8006e84:	d811      	bhi.n	8006eaa <tcp_input+0x5a>
    TCP_STATS_INC(tcp.lenerr);
 8006e86:	4a9a      	ldr	r2, [pc, #616]	; (80070f0 <tcp_input+0x2a0>)
 8006e88:	f8b2 309a 	ldrh.w	r3, [r2, #154]	; 0x9a
 8006e8c:	3301      	adds	r3, #1
 8006e8e:	f8a2 309a 	strh.w	r3, [r2, #154]	; 0x9a
  TCP_STATS_INC(tcp.drop);
 8006e92:	4a97      	ldr	r2, [pc, #604]	; (80070f0 <tcp_input+0x2a0>)
 8006e94:	f8b2 3096 	ldrh.w	r3, [r2, #150]	; 0x96
 8006e98:	3301      	adds	r3, #1
 8006e9a:	f8a2 3096 	strh.w	r3, [r2, #150]	; 0x96
  pbuf_free(p);
 8006e9e:	4620      	mov	r0, r4
 8006ea0:	f7fe fbff 	bl	80056a2 <pbuf_free>
}
 8006ea4:	b003      	add	sp, #12
 8006ea6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 8006eaa:	4629      	mov	r1, r5
 8006eac:	4b92      	ldr	r3, [pc, #584]	; (80070f8 <tcp_input+0x2a8>)
 8006eae:	6818      	ldr	r0, [r3, #0]
 8006eb0:	f7fd fd78 	bl	80049a4 <ip4_addr_isbroadcast>
 8006eb4:	b9a8      	cbnz	r0, 8006ee2 <tcp_input+0x92>
      ip_addr_ismulticast(&current_iphdr_dest)) {
 8006eb6:	4b90      	ldr	r3, [pc, #576]	; (80070f8 <tcp_input+0x2a8>)
 8006eb8:	681b      	ldr	r3, [r3, #0]
 8006eba:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 8006ebe:	2be0      	cmp	r3, #224	; 0xe0
 8006ec0:	d00f      	beq.n	8006ee2 <tcp_input+0x92>
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 8006ec2:	8923      	ldrh	r3, [r4, #8]
 8006ec4:	9300      	str	r3, [sp, #0]
 8006ec6:	2306      	movs	r3, #6
 8006ec8:	4a8b      	ldr	r2, [pc, #556]	; (80070f8 <tcp_input+0x2a8>)
 8006eca:	498c      	ldr	r1, [pc, #560]	; (80070fc <tcp_input+0x2ac>)
 8006ecc:	4620      	mov	r0, r4
 8006ece:	f7fd fb05 	bl	80044dc <inet_chksum_pseudo>
 8006ed2:	b168      	cbz	r0, 8006ef0 <tcp_input+0xa0>
    TCP_STATS_INC(tcp.chkerr);
 8006ed4:	4a86      	ldr	r2, [pc, #536]	; (80070f0 <tcp_input+0x2a0>)
 8006ed6:	f8b2 3098 	ldrh.w	r3, [r2, #152]	; 0x98
 8006eda:	3301      	adds	r3, #1
 8006edc:	f8a2 3098 	strh.w	r3, [r2, #152]	; 0x98
    goto dropped;
 8006ee0:	e7d7      	b.n	8006e92 <tcp_input+0x42>
    TCP_STATS_INC(tcp.proterr);
 8006ee2:	4a83      	ldr	r2, [pc, #524]	; (80070f0 <tcp_input+0x2a0>)
 8006ee4:	f8b2 30a0 	ldrh.w	r3, [r2, #160]	; 0xa0
 8006ee8:	3301      	adds	r3, #1
 8006eea:	f8a2 30a0 	strh.w	r3, [r2, #160]	; 0xa0
    goto dropped;
 8006eee:	e7d0      	b.n	8006e92 <tcp_input+0x42>
  hdrlen = TCPH_HDRLEN(tcphdr);
 8006ef0:	4b80      	ldr	r3, [pc, #512]	; (80070f4 <tcp_input+0x2a4>)
 8006ef2:	681b      	ldr	r3, [r3, #0]
 8006ef4:	8998      	ldrh	r0, [r3, #12]
 8006ef6:	f7fd f95e 	bl	80041b6 <lwip_ntohs>
 8006efa:	0b00      	lsrs	r0, r0, #12
  if(pbuf_header(p, -(hdrlen * 4))){
 8006efc:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
 8006f00:	0081      	lsls	r1, r0, #2
 8006f02:	b209      	sxth	r1, r1
 8006f04:	4620      	mov	r0, r4
 8006f06:	f7fe fb8e 	bl	8005626 <pbuf_header>
 8006f0a:	b130      	cbz	r0, 8006f1a <tcp_input+0xca>
    TCP_STATS_INC(tcp.lenerr);
 8006f0c:	4a78      	ldr	r2, [pc, #480]	; (80070f0 <tcp_input+0x2a0>)
 8006f0e:	f8b2 309a 	ldrh.w	r3, [r2, #154]	; 0x9a
 8006f12:	3301      	adds	r3, #1
 8006f14:	f8a2 309a 	strh.w	r3, [r2, #154]	; 0x9a
    goto dropped;
 8006f18:	e7bb      	b.n	8006e92 <tcp_input+0x42>
  tcphdr->src = ntohs(tcphdr->src);
 8006f1a:	4d76      	ldr	r5, [pc, #472]	; (80070f4 <tcp_input+0x2a4>)
 8006f1c:	682e      	ldr	r6, [r5, #0]
 8006f1e:	8830      	ldrh	r0, [r6, #0]
 8006f20:	f7fd f949 	bl	80041b6 <lwip_ntohs>
 8006f24:	8030      	strh	r0, [r6, #0]
  tcphdr->dest = ntohs(tcphdr->dest);
 8006f26:	682e      	ldr	r6, [r5, #0]
 8006f28:	8870      	ldrh	r0, [r6, #2]
 8006f2a:	f7fd f944 	bl	80041b6 <lwip_ntohs>
 8006f2e:	8070      	strh	r0, [r6, #2]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 8006f30:	682e      	ldr	r6, [r5, #0]
 8006f32:	6870      	ldr	r0, [r6, #4]
 8006f34:	f7fd f950 	bl	80041d8 <lwip_ntohl>
 8006f38:	6070      	str	r0, [r6, #4]
 8006f3a:	4b71      	ldr	r3, [pc, #452]	; (8007100 <tcp_input+0x2b0>)
 8006f3c:	6018      	str	r0, [r3, #0]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8006f3e:	682e      	ldr	r6, [r5, #0]
 8006f40:	68b0      	ldr	r0, [r6, #8]
 8006f42:	f7fd f949 	bl	80041d8 <lwip_ntohl>
 8006f46:	60b0      	str	r0, [r6, #8]
 8006f48:	4b6e      	ldr	r3, [pc, #440]	; (8007104 <tcp_input+0x2b4>)
 8006f4a:	6018      	str	r0, [r3, #0]
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8006f4c:	682e      	ldr	r6, [r5, #0]
 8006f4e:	89f0      	ldrh	r0, [r6, #14]
 8006f50:	f7fd f931 	bl	80041b6 <lwip_ntohs>
 8006f54:	81f0      	strh	r0, [r6, #14]
  flags = TCPH_FLAGS(tcphdr);
 8006f56:	682b      	ldr	r3, [r5, #0]
 8006f58:	8998      	ldrh	r0, [r3, #12]
 8006f5a:	f7fd f92c 	bl	80041b6 <lwip_ntohs>
 8006f5e:	fa5f fe80 	uxtb.w	lr, r0
 8006f62:	f00e 023f 	and.w	r2, lr, #63	; 0x3f
 8006f66:	4b68      	ldr	r3, [pc, #416]	; (8007108 <tcp_input+0x2b8>)
 8006f68:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 8006f6a:	f01e 0303 	ands.w	r3, lr, #3
 8006f6e:	bf18      	it	ne
 8006f70:	2301      	movne	r3, #1
 8006f72:	8921      	ldrh	r1, [r4, #8]
 8006f74:	440b      	add	r3, r1
 8006f76:	b299      	uxth	r1, r3
 8006f78:	4b64      	ldr	r3, [pc, #400]	; (800710c <tcp_input+0x2bc>)
 8006f7a:	8019      	strh	r1, [r3, #0]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8006f7c:	4b64      	ldr	r3, [pc, #400]	; (8007110 <tcp_input+0x2c0>)
 8006f7e:	6818      	ldr	r0, [r3, #0]
 8006f80:	2800      	cmp	r0, #0
 8006f82:	d060      	beq.n	8007046 <tcp_input+0x1f6>
    if (pcb->remote_port == tcphdr->src &&
 8006f84:	682f      	ldr	r7, [r5, #0]
 8006f86:	883e      	ldrh	r6, [r7, #0]
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8006f88:	4b5c      	ldr	r3, [pc, #368]	; (80070fc <tcp_input+0x2ac>)
 8006f8a:	f8d3 c000 	ldr.w	ip, [r3]
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
 8006f8e:	4b5a      	ldr	r3, [pc, #360]	; (80070f8 <tcp_input+0x2a8>)
 8006f90:	f8d3 8000 	ldr.w	r8, [r3]
 8006f94:	4605      	mov	r5, r0
 8006f96:	2200      	movs	r2, #0
 8006f98:	e004      	b.n	8006fa4 <tcp_input+0x154>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8006f9a:	68eb      	ldr	r3, [r5, #12]
 8006f9c:	462a      	mov	r2, r5
 8006f9e:	2b00      	cmp	r3, #0
 8006fa0:	d051      	beq.n	8007046 <tcp_input+0x1f6>
 8006fa2:	461d      	mov	r5, r3
    if (pcb->remote_port == tcphdr->src &&
 8006fa4:	8bab      	ldrh	r3, [r5, #28]
 8006fa6:	42b3      	cmp	r3, r6
 8006fa8:	d1f7      	bne.n	8006f9a <tcp_input+0x14a>
 8006faa:	f8b5 901a 	ldrh.w	r9, [r5, #26]
 8006fae:	887b      	ldrh	r3, [r7, #2]
 8006fb0:	4599      	cmp	r9, r3
 8006fb2:	d1f2      	bne.n	8006f9a <tcp_input+0x14a>
       pcb->local_port == tcphdr->dest &&
 8006fb4:	686b      	ldr	r3, [r5, #4]
 8006fb6:	4563      	cmp	r3, ip
 8006fb8:	d1ef      	bne.n	8006f9a <tcp_input+0x14a>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8006fba:	682b      	ldr	r3, [r5, #0]
 8006fbc:	4543      	cmp	r3, r8
 8006fbe:	d1ec      	bne.n	8006f9a <tcp_input+0x14a>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 8006fc0:	68eb      	ldr	r3, [r5, #12]
      if (prev != NULL) {
 8006fc2:	b11a      	cbz	r2, 8006fcc <tcp_input+0x17c>
        prev->next = pcb->next;
 8006fc4:	60d3      	str	r3, [r2, #12]
        pcb->next = tcp_active_pcbs;
 8006fc6:	60e8      	str	r0, [r5, #12]
        tcp_active_pcbs = pcb;
 8006fc8:	4b51      	ldr	r3, [pc, #324]	; (8007110 <tcp_input+0x2c0>)
 8006fca:	601d      	str	r5, [r3, #0]
  if (pcb == NULL) {
 8006fcc:	2d00      	cmp	r5, #0
 8006fce:	d03a      	beq.n	8007046 <tcp_input+0x1f6>
    inseg.next = NULL;
 8006fd0:	4b50      	ldr	r3, [pc, #320]	; (8007114 <tcp_input+0x2c4>)
 8006fd2:	2200      	movs	r2, #0
 8006fd4:	601a      	str	r2, [r3, #0]
    inseg.len = p->tot_len;
 8006fd6:	8921      	ldrh	r1, [r4, #8]
 8006fd8:	8119      	strh	r1, [r3, #8]
    inseg.p = p;
 8006fda:	605c      	str	r4, [r3, #4]
    inseg.tcphdr = tcphdr;
 8006fdc:	60df      	str	r7, [r3, #12]
    recv_data = NULL;
 8006fde:	4b4e      	ldr	r3, [pc, #312]	; (8007118 <tcp_input+0x2c8>)
 8006fe0:	601a      	str	r2, [r3, #0]
    recv_flags = 0;
 8006fe2:	4b4e      	ldr	r3, [pc, #312]	; (800711c <tcp_input+0x2cc>)
 8006fe4:	701a      	strb	r2, [r3, #0]
    if (flags & TCP_PSH) {
 8006fe6:	f01e 0f08 	tst.w	lr, #8
 8006fea:	d003      	beq.n	8006ff4 <tcp_input+0x1a4>
      p->flags |= PBUF_FLAG_PUSH;
 8006fec:	7b63      	ldrb	r3, [r4, #13]
 8006fee:	f043 0301 	orr.w	r3, r3, #1
 8006ff2:	7363      	strb	r3, [r4, #13]
    if (pcb->refused_data != NULL) {
 8006ff4:	6fab      	ldr	r3, [r5, #120]	; 0x78
 8006ff6:	2b00      	cmp	r3, #0
 8006ff8:	f000 811d 	beq.w	8007236 <tcp_input+0x3e6>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 8006ffc:	4628      	mov	r0, r5
 8006ffe:	f7ff f8ad 	bl	800615c <tcp_process_refused_data>
 8007002:	f110 0f0a 	cmn.w	r0, #10
 8007006:	d008      	beq.n	800701a <tcp_input+0x1ca>
 8007008:	6fab      	ldr	r3, [r5, #120]	; 0x78
 800700a:	2b00      	cmp	r3, #0
 800700c:	f000 8113 	beq.w	8007236 <tcp_input+0x3e6>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 8007010:	4b3e      	ldr	r3, [pc, #248]	; (800710c <tcp_input+0x2bc>)
 8007012:	881b      	ldrh	r3, [r3, #0]
 8007014:	2b00      	cmp	r3, #0
 8007016:	f000 810e 	beq.w	8007236 <tcp_input+0x3e6>
        TCP_STATS_INC(tcp.drop);
 800701a:	4a35      	ldr	r2, [pc, #212]	; (80070f0 <tcp_input+0x2a0>)
 800701c:	f8b2 3096 	ldrh.w	r3, [r2, #150]	; 0x96
 8007020:	3301      	adds	r3, #1
 8007022:	f8a2 3096 	strh.w	r3, [r2, #150]	; 0x96
    tcp_input_pcb = NULL;
 8007026:	2300      	movs	r3, #0
 8007028:	4a3d      	ldr	r2, [pc, #244]	; (8007120 <tcp_input+0x2d0>)
 800702a:	6013      	str	r3, [r2, #0]
    recv_data = NULL;
 800702c:	4a3a      	ldr	r2, [pc, #232]	; (8007118 <tcp_input+0x2c8>)
 800702e:	6013      	str	r3, [r2, #0]
    if (inseg.p != NULL)
 8007030:	4b38      	ldr	r3, [pc, #224]	; (8007114 <tcp_input+0x2c4>)
 8007032:	6858      	ldr	r0, [r3, #4]
 8007034:	2800      	cmp	r0, #0
 8007036:	f43f af35 	beq.w	8006ea4 <tcp_input+0x54>
      pbuf_free(inseg.p);
 800703a:	f7fe fb32 	bl	80056a2 <pbuf_free>
      inseg.p = NULL;
 800703e:	2200      	movs	r2, #0
 8007040:	4b34      	ldr	r3, [pc, #208]	; (8007114 <tcp_input+0x2c4>)
 8007042:	605a      	str	r2, [r3, #4]
 8007044:	e72e      	b.n	8006ea4 <tcp_input+0x54>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8007046:	4b37      	ldr	r3, [pc, #220]	; (8007124 <tcp_input+0x2d4>)
 8007048:	6818      	ldr	r0, [r3, #0]
 800704a:	2800      	cmp	r0, #0
 800704c:	d042      	beq.n	80070d4 <tcp_input+0x284>
      if (pcb->remote_port == tcphdr->src &&
 800704e:	4b29      	ldr	r3, [pc, #164]	; (80070f4 <tcp_input+0x2a4>)
 8007050:	681f      	ldr	r7, [r3, #0]
 8007052:	883a      	ldrh	r2, [r7, #0]
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8007054:	4b29      	ldr	r3, [pc, #164]	; (80070fc <tcp_input+0x2ac>)
 8007056:	f8d3 8000 	ldr.w	r8, [r3]
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
 800705a:	4b27      	ldr	r3, [pc, #156]	; (80070f8 <tcp_input+0x2a8>)
 800705c:	f8d3 c000 	ldr.w	ip, [r3]
 8007060:	e00f      	b.n	8007082 <tcp_input+0x232>
  } else if (flags & TCP_FIN) {
 8007062:	f01e 0f01 	tst.w	lr, #1
 8007066:	d002      	beq.n	800706e <tcp_input+0x21e>
    pcb->tmr = tcp_ticks;
 8007068:	4b2f      	ldr	r3, [pc, #188]	; (8007128 <tcp_input+0x2d8>)
 800706a:	681b      	ldr	r3, [r3, #0]
 800706c:	6243      	str	r3, [r0, #36]	; 0x24
  if ((tcplen > 0))  {
 800706e:	b369      	cbz	r1, 80070cc <tcp_input+0x27c>
    pcb->flags |= TF_ACK_NOW;
 8007070:	7f83      	ldrb	r3, [r0, #30]
 8007072:	f043 0302 	orr.w	r3, r3, #2
 8007076:	7783      	strb	r3, [r0, #30]
    return tcp_output(pcb);
 8007078:	f000 fd52 	bl	8007b20 <tcp_output>
 800707c:	e026      	b.n	80070cc <tcp_input+0x27c>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800707e:	68c0      	ldr	r0, [r0, #12]
 8007080:	b340      	cbz	r0, 80070d4 <tcp_input+0x284>
      if (pcb->remote_port == tcphdr->src &&
 8007082:	8b83      	ldrh	r3, [r0, #28]
 8007084:	4293      	cmp	r3, r2
 8007086:	d1fa      	bne.n	800707e <tcp_input+0x22e>
         pcb->local_port == tcphdr->dest &&
 8007088:	8b45      	ldrh	r5, [r0, #26]
      if (pcb->remote_port == tcphdr->src &&
 800708a:	887e      	ldrh	r6, [r7, #2]
 800708c:	42ae      	cmp	r6, r5
 800708e:	d1f6      	bne.n	800707e <tcp_input+0x22e>
         pcb->local_port == tcphdr->dest &&
 8007090:	6846      	ldr	r6, [r0, #4]
 8007092:	4546      	cmp	r6, r8
 8007094:	d1f3      	bne.n	800707e <tcp_input+0x22e>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8007096:	6806      	ldr	r6, [r0, #0]
 8007098:	4566      	cmp	r6, ip
 800709a:	d1f0      	bne.n	800707e <tcp_input+0x22e>
  if (flags & TCP_RST)  {
 800709c:	f01e 0f04 	tst.w	lr, #4
 80070a0:	d114      	bne.n	80070cc <tcp_input+0x27c>
  if (flags & TCP_SYN) {
 80070a2:	f01e 0f02 	tst.w	lr, #2
 80070a6:	d0dc      	beq.n	8007062 <tcp_input+0x212>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
 80070a8:	4a15      	ldr	r2, [pc, #84]	; (8007100 <tcp_input+0x2b0>)
 80070aa:	6816      	ldr	r6, [r2, #0]
 80070ac:	6a82      	ldr	r2, [r0, #40]	; 0x28
 80070ae:	1ab2      	subs	r2, r6, r2
 80070b0:	d4dd      	bmi.n	800706e <tcp_input+0x21e>
 80070b2:	8d87      	ldrh	r7, [r0, #44]	; 0x2c
 80070b4:	1bd2      	subs	r2, r2, r7
 80070b6:	2a00      	cmp	r2, #0
 80070b8:	dcd9      	bgt.n	800706e <tcp_input+0x21e>
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 80070ba:	9301      	str	r3, [sp, #4]
 80070bc:	9500      	str	r5, [sp, #0]
 80070be:	4b0f      	ldr	r3, [pc, #60]	; (80070fc <tcp_input+0x2ac>)
 80070c0:	4a0d      	ldr	r2, [pc, #52]	; (80070f8 <tcp_input+0x2a8>)
 80070c2:	4431      	add	r1, r6
 80070c4:	480f      	ldr	r0, [pc, #60]	; (8007104 <tcp_input+0x2b4>)
 80070c6:	6800      	ldr	r0, [r0, #0]
 80070c8:	f000 fe82 	bl	8007dd0 <tcp_rst>
        pbuf_free(p);
 80070cc:	4620      	mov	r0, r4
 80070ce:	f7fe fae8 	bl	80056a2 <pbuf_free>
        return;
 80070d2:	e6e7      	b.n	8006ea4 <tcp_input+0x54>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80070d4:	4b15      	ldr	r3, [pc, #84]	; (800712c <tcp_input+0x2dc>)
 80070d6:	681f      	ldr	r7, [r3, #0]
 80070d8:	2f00      	cmp	r7, #0
 80070da:	f000 837c 	beq.w	80077d6 <tcp_input+0x986>
      if (lpcb->local_port == tcphdr->dest) {
 80070de:	4b05      	ldr	r3, [pc, #20]	; (80070f4 <tcp_input+0x2a4>)
 80070e0:	681e      	ldr	r6, [r3, #0]
 80070e2:	8870      	ldrh	r0, [r6, #2]
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
 80070e4:	4b04      	ldr	r3, [pc, #16]	; (80070f8 <tcp_input+0x2a8>)
 80070e6:	f8d3 c000 	ldr.w	ip, [r3]
 80070ea:	463d      	mov	r5, r7
 80070ec:	2200      	movs	r2, #0
 80070ee:	e025      	b.n	800713c <tcp_input+0x2ec>
 80070f0:	2000b084 	.word	0x2000b084
 80070f4:	20007720 	.word	0x20007720
 80070f8:	2000894c 	.word	0x2000894c
 80070fc:	20008944 	.word	0x20008944
 8007100:	2000771c 	.word	0x2000771c
 8007104:	200076fc 	.word	0x200076fc
 8007108:	20007700 	.word	0x20007700
 800710c:	20007724 	.word	0x20007724
 8007110:	2000b1a0 	.word	0x2000b1a0
 8007114:	20007704 	.word	0x20007704
 8007118:	20007714 	.word	0x20007714
 800711c:	20007718 	.word	0x20007718
 8007120:	2000b1b8 	.word	0x2000b1b8
 8007124:	2000b1b4 	.word	0x2000b1b4
 8007128:	2000b1a4 	.word	0x2000b1a4
 800712c:	2000b1a8 	.word	0x2000b1a8
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8007130:	68eb      	ldr	r3, [r5, #12]
 8007132:	462a      	mov	r2, r5
 8007134:	2b00      	cmp	r3, #0
 8007136:	f000 834e 	beq.w	80077d6 <tcp_input+0x986>
 800713a:	461d      	mov	r5, r3
      if (lpcb->local_port == tcphdr->dest) {
 800713c:	8b6b      	ldrh	r3, [r5, #26]
 800713e:	4283      	cmp	r3, r0
 8007140:	d1f6      	bne.n	8007130 <tcp_input+0x2e0>
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
 8007142:	682b      	ldr	r3, [r5, #0]
 8007144:	4563      	cmp	r3, ip
 8007146:	d002      	beq.n	800714e <tcp_input+0x2fe>
 8007148:	b10d      	cbz	r5, 800714e <tcp_input+0x2fe>
            ip_addr_isany(&(lpcb->local_ip))) {
 800714a:	2b00      	cmp	r3, #0
 800714c:	d1f0      	bne.n	8007130 <tcp_input+0x2e0>
    if (lpcb != NULL) {
 800714e:	2d00      	cmp	r5, #0
 8007150:	f000 8341 	beq.w	80077d6 <tcp_input+0x986>
      if (prev != NULL) {
 8007154:	b122      	cbz	r2, 8007160 <tcp_input+0x310>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 8007156:	68eb      	ldr	r3, [r5, #12]
 8007158:	60d3      	str	r3, [r2, #12]
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 800715a:	60ef      	str	r7, [r5, #12]
        tcp_listen_pcbs.listen_pcbs = lpcb;
 800715c:	4ba3      	ldr	r3, [pc, #652]	; (80073ec <tcp_input+0x59c>)
 800715e:	601d      	str	r5, [r3, #0]
  if (flags & TCP_RST) {
 8007160:	f01e 0f04 	tst.w	lr, #4
 8007164:	d157      	bne.n	8007216 <tcp_input+0x3c6>
  if (flags & TCP_ACK) {
 8007166:	f01e 0f10 	tst.w	lr, #16
 800716a:	d147      	bne.n	80071fc <tcp_input+0x3ac>
  } else if (flags & TCP_SYN) {
 800716c:	f01e 0f02 	tst.w	lr, #2
 8007170:	d051      	beq.n	8007216 <tcp_input+0x3c6>
    npcb = tcp_alloc(pcb->prio);
 8007172:	7e68      	ldrb	r0, [r5, #25]
 8007174:	f7ff f8d0 	bl	8006318 <tcp_alloc>
    if (npcb == NULL) {
 8007178:	4606      	mov	r6, r0
 800717a:	2800      	cmp	r0, #0
 800717c:	d04f      	beq.n	800721e <tcp_input+0x3ce>
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
 800717e:	4b9c      	ldr	r3, [pc, #624]	; (80073f0 <tcp_input+0x5a0>)
 8007180:	681b      	ldr	r3, [r3, #0]
 8007182:	6003      	str	r3, [r0, #0]
    npcb->local_port = pcb->local_port;
 8007184:	8b6b      	ldrh	r3, [r5, #26]
 8007186:	8343      	strh	r3, [r0, #26]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 8007188:	4b9a      	ldr	r3, [pc, #616]	; (80073f4 <tcp_input+0x5a4>)
 800718a:	681b      	ldr	r3, [r3, #0]
 800718c:	6043      	str	r3, [r0, #4]
    npcb->remote_port = tcphdr->src;
 800718e:	4b9a      	ldr	r3, [pc, #616]	; (80073f8 <tcp_input+0x5a8>)
 8007190:	681a      	ldr	r2, [r3, #0]
 8007192:	8813      	ldrh	r3, [r2, #0]
 8007194:	8383      	strh	r3, [r0, #28]
    npcb->state = SYN_RCVD;
 8007196:	2303      	movs	r3, #3
 8007198:	7603      	strb	r3, [r0, #24]
    npcb->rcv_nxt = seqno + 1;
 800719a:	4b98      	ldr	r3, [pc, #608]	; (80073fc <tcp_input+0x5ac>)
 800719c:	681b      	ldr	r3, [r3, #0]
 800719e:	1c59      	adds	r1, r3, #1
 80071a0:	6281      	str	r1, [r0, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 80071a2:	6301      	str	r1, [r0, #48]	; 0x30
    npcb->snd_wnd = tcphdr->wnd;
 80071a4:	89d1      	ldrh	r1, [r2, #14]
 80071a6:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60
    npcb->snd_wnd_max = tcphdr->wnd;
 80071aa:	89d2      	ldrh	r2, [r2, #14]
 80071ac:	f8a0 2062 	strh.w	r2, [r0, #98]	; 0x62
    npcb->ssthresh = npcb->snd_wnd;
 80071b0:	f8a0 104e 	strh.w	r1, [r0, #78]	; 0x4e
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 80071b4:	3b01      	subs	r3, #1
 80071b6:	6543      	str	r3, [r0, #84]	; 0x54
    npcb->callback_arg = pcb->callback_arg;
 80071b8:	692b      	ldr	r3, [r5, #16]
 80071ba:	6103      	str	r3, [r0, #16]
    npcb->accept = pcb->accept;
 80071bc:	696b      	ldr	r3, [r5, #20]
 80071be:	6143      	str	r3, [r0, #20]
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 80071c0:	7a2b      	ldrb	r3, [r5, #8]
 80071c2:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 80071c6:	7203      	strb	r3, [r0, #8]
    TCP_REG_ACTIVE(npcb);
 80071c8:	4b8d      	ldr	r3, [pc, #564]	; (8007400 <tcp_input+0x5b0>)
 80071ca:	681a      	ldr	r2, [r3, #0]
 80071cc:	60c2      	str	r2, [r0, #12]
 80071ce:	6018      	str	r0, [r3, #0]
 80071d0:	f000 ff88 	bl	80080e4 <tcp_timer_needed>
 80071d4:	2201      	movs	r2, #1
 80071d6:	4b8b      	ldr	r3, [pc, #556]	; (8007404 <tcp_input+0x5b4>)
 80071d8:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
 80071da:	4630      	mov	r0, r6
 80071dc:	f7ff f948 	bl	8006470 <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 80071e0:	1d31      	adds	r1, r6, #4
 80071e2:	8ef0      	ldrh	r0, [r6, #54]	; 0x36
 80071e4:	f7ff f932 	bl	800644c <tcp_eff_send_mss>
 80071e8:	86f0      	strh	r0, [r6, #54]	; 0x36
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 80071ea:	2112      	movs	r1, #18
 80071ec:	4630      	mov	r0, r6
 80071ee:	f000 fbc5 	bl	800797c <tcp_enqueue_flags>
    if (rc != ERR_OK) {
 80071f2:	b9d8      	cbnz	r0, 800722c <tcp_input+0x3dc>
    return tcp_output(npcb);
 80071f4:	4630      	mov	r0, r6
 80071f6:	f000 fc93 	bl	8007b20 <tcp_output>
 80071fa:	e00c      	b.n	8007216 <tcp_input+0x3c6>
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 80071fc:	4b7f      	ldr	r3, [pc, #508]	; (80073fc <tcp_input+0x5ac>)
 80071fe:	6818      	ldr	r0, [r3, #0]
 8007200:	8833      	ldrh	r3, [r6, #0]
 8007202:	9301      	str	r3, [sp, #4]
 8007204:	8873      	ldrh	r3, [r6, #2]
 8007206:	9300      	str	r3, [sp, #0]
 8007208:	4b7a      	ldr	r3, [pc, #488]	; (80073f4 <tcp_input+0x5a4>)
 800720a:	4a79      	ldr	r2, [pc, #484]	; (80073f0 <tcp_input+0x5a0>)
 800720c:	4401      	add	r1, r0
 800720e:	487e      	ldr	r0, [pc, #504]	; (8007408 <tcp_input+0x5b8>)
 8007210:	6800      	ldr	r0, [r0, #0]
 8007212:	f000 fddd 	bl	8007dd0 <tcp_rst>
      pbuf_free(p);
 8007216:	4620      	mov	r0, r4
 8007218:	f7fe fa43 	bl	80056a2 <pbuf_free>
      return;
 800721c:	e642      	b.n	8006ea4 <tcp_input+0x54>
      TCP_STATS_INC(tcp.memerr);
 800721e:	4a7b      	ldr	r2, [pc, #492]	; (800740c <tcp_input+0x5bc>)
 8007220:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 8007224:	3301      	adds	r3, #1
 8007226:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
 800722a:	e7f4      	b.n	8007216 <tcp_input+0x3c6>
      tcp_abandon(npcb, 0);
 800722c:	2100      	movs	r1, #0
 800722e:	4630      	mov	r0, r6
 8007230:	f7ff f816 	bl	8006260 <tcp_abandon>
 8007234:	e7ef      	b.n	8007216 <tcp_input+0x3c6>
    tcp_input_pcb = pcb;
 8007236:	4b76      	ldr	r3, [pc, #472]	; (8007410 <tcp_input+0x5c0>)
 8007238:	601d      	str	r5, [r3, #0]
  if (flags & TCP_RST) {
 800723a:	4b76      	ldr	r3, [pc, #472]	; (8007414 <tcp_input+0x5c4>)
 800723c:	781b      	ldrb	r3, [r3, #0]
 800723e:	f013 0f04 	tst.w	r3, #4
 8007242:	d036      	beq.n	80072b2 <tcp_input+0x462>
    if (pcb->state == SYN_SENT) {
 8007244:	7e2b      	ldrb	r3, [r5, #24]
 8007246:	2b02      	cmp	r3, #2
 8007248:	d021      	beq.n	800728e <tcp_input+0x43e>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 800724a:	4b6c      	ldr	r3, [pc, #432]	; (80073fc <tcp_input+0x5ac>)
 800724c:	681b      	ldr	r3, [r3, #0]
 800724e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8007250:	1a9b      	subs	r3, r3, r2
 8007252:	d406      	bmi.n	8007262 <tcp_input+0x412>
 8007254:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
 8007256:	1a9b      	subs	r3, r3, r2
  u8_t acceptable = 0;
 8007258:	2b00      	cmp	r3, #0
 800725a:	bfcc      	ite	gt
 800725c:	2300      	movgt	r3, #0
 800725e:	2301      	movle	r3, #1
    if (acceptable) {
 8007260:	b9eb      	cbnz	r3, 800729e <tcp_input+0x44e>
      if (recv_flags & TF_RESET) {
 8007262:	4b6d      	ldr	r3, [pc, #436]	; (8007418 <tcp_input+0x5c8>)
 8007264:	781b      	ldrb	r3, [r3, #0]
 8007266:	f013 0f08 	tst.w	r3, #8
 800726a:	f000 8248 	beq.w	80076fe <tcp_input+0x8ae>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
 800726e:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 8007272:	b11b      	cbz	r3, 800727c <tcp_input+0x42c>
 8007274:	f06f 010a 	mvn.w	r1, #10
 8007278:	6928      	ldr	r0, [r5, #16]
 800727a:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800727c:	4629      	mov	r1, r5
 800727e:	4860      	ldr	r0, [pc, #384]	; (8007400 <tcp_input+0x5b0>)
 8007280:	f7fe fe4a 	bl	8005f18 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 8007284:	4629      	mov	r1, r5
 8007286:	2002      	movs	r0, #2
 8007288:	f7fe f914 	bl	80054b4 <memp_free>
 800728c:	e6cb      	b.n	8007026 <tcp_input+0x1d6>
      if (ackno == pcb->snd_nxt) {
 800728e:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8007290:	4a5d      	ldr	r2, [pc, #372]	; (8007408 <tcp_input+0x5b8>)
 8007292:	6812      	ldr	r2, [r2, #0]
  u8_t acceptable = 0;
 8007294:	4293      	cmp	r3, r2
 8007296:	bf14      	ite	ne
 8007298:	2300      	movne	r3, #0
 800729a:	2301      	moveq	r3, #1
 800729c:	e7e0      	b.n	8007260 <tcp_input+0x410>
      recv_flags |= TF_RESET;
 800729e:	4a5e      	ldr	r2, [pc, #376]	; (8007418 <tcp_input+0x5c8>)
 80072a0:	7813      	ldrb	r3, [r2, #0]
 80072a2:	f043 0308 	orr.w	r3, r3, #8
 80072a6:	7013      	strb	r3, [r2, #0]
      pcb->flags &= ~TF_ACK_DELAY;
 80072a8:	7fab      	ldrb	r3, [r5, #30]
 80072aa:	f023 0301 	bic.w	r3, r3, #1
 80072ae:	77ab      	strb	r3, [r5, #30]
 80072b0:	e7d7      	b.n	8007262 <tcp_input+0x412>
  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
 80072b2:	f013 0f02 	tst.w	r3, #2
 80072b6:	d009      	beq.n	80072cc <tcp_input+0x47c>
 80072b8:	7e2b      	ldrb	r3, [r5, #24]
 80072ba:	3b02      	subs	r3, #2
 80072bc:	b2db      	uxtb	r3, r3
 80072be:	2b01      	cmp	r3, #1
 80072c0:	d904      	bls.n	80072cc <tcp_input+0x47c>
    tcp_ack_now(pcb);
 80072c2:	7fab      	ldrb	r3, [r5, #30]
 80072c4:	f043 0302 	orr.w	r3, r3, #2
 80072c8:	77ab      	strb	r3, [r5, #30]
 80072ca:	e7ca      	b.n	8007262 <tcp_input+0x412>
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 80072cc:	7fab      	ldrb	r3, [r5, #30]
 80072ce:	f013 0f10 	tst.w	r3, #16
 80072d2:	d102      	bne.n	80072da <tcp_input+0x48a>
    pcb->tmr = tcp_ticks;
 80072d4:	4b51      	ldr	r3, [pc, #324]	; (800741c <tcp_input+0x5cc>)
 80072d6:	681b      	ldr	r3, [r3, #0]
 80072d8:	626b      	str	r3, [r5, #36]	; 0x24
  pcb->keep_cnt_sent = 0;
 80072da:	2300      	movs	r3, #0
 80072dc:	f885 3096 	strb.w	r3, [r5, #150]	; 0x96
  tcp_parseopt(pcb);
 80072e0:	4628      	mov	r0, r5
 80072e2:	f7ff f8c5 	bl	8006470 <tcp_parseopt>
  switch (pcb->state) {
 80072e6:	7e2b      	ldrb	r3, [r5, #24]
 80072e8:	3b02      	subs	r3, #2
 80072ea:	2b07      	cmp	r3, #7
 80072ec:	d8b9      	bhi.n	8007262 <tcp_input+0x412>
 80072ee:	e8df f013 	tbh	[pc, r3, lsl #1]
 80072f2:	0008      	.short	0x0008
 80072f4:	00f70099 	.word	0x00f70099
 80072f8:	01600107 	.word	0x01600107
 80072fc:	019b00f7 	.word	0x019b00f7
 8007300:	01f1      	.short	0x01f1
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 8007302:	4b44      	ldr	r3, [pc, #272]	; (8007414 <tcp_input+0x5c4>)
 8007304:	781b      	ldrb	r3, [r3, #0]
 8007306:	f003 0312 	and.w	r3, r3, #18
 800730a:	2b12      	cmp	r3, #18
 800730c:	d016      	beq.n	800733c <tcp_input+0x4ec>
    else if (flags & TCP_ACK) {
 800730e:	4b41      	ldr	r3, [pc, #260]	; (8007414 <tcp_input+0x5c4>)
 8007310:	781b      	ldrb	r3, [r3, #0]
 8007312:	f013 0f10 	tst.w	r3, #16
 8007316:	d0a4      	beq.n	8007262 <tcp_input+0x412>
        tcphdr->dest, tcphdr->src);
 8007318:	4b37      	ldr	r3, [pc, #220]	; (80073f8 <tcp_input+0x5a8>)
 800731a:	681b      	ldr	r3, [r3, #0]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 800731c:	4a40      	ldr	r2, [pc, #256]	; (8007420 <tcp_input+0x5d0>)
 800731e:	8810      	ldrh	r0, [r2, #0]
 8007320:	4a36      	ldr	r2, [pc, #216]	; (80073fc <tcp_input+0x5ac>)
 8007322:	6811      	ldr	r1, [r2, #0]
 8007324:	881a      	ldrh	r2, [r3, #0]
 8007326:	9201      	str	r2, [sp, #4]
 8007328:	885b      	ldrh	r3, [r3, #2]
 800732a:	9300      	str	r3, [sp, #0]
 800732c:	4b31      	ldr	r3, [pc, #196]	; (80073f4 <tcp_input+0x5a4>)
 800732e:	4a30      	ldr	r2, [pc, #192]	; (80073f0 <tcp_input+0x5a0>)
 8007330:	4401      	add	r1, r0
 8007332:	4835      	ldr	r0, [pc, #212]	; (8007408 <tcp_input+0x5b8>)
 8007334:	6800      	ldr	r0, [r0, #0]
 8007336:	f000 fd4b 	bl	8007dd0 <tcp_rst>
 800733a:	e792      	b.n	8007262 <tcp_input+0x412>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
 800733c:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800733e:	68db      	ldr	r3, [r3, #12]
 8007340:	6858      	ldr	r0, [r3, #4]
 8007342:	f7fc ff49 	bl	80041d8 <lwip_ntohl>
 8007346:	3001      	adds	r0, #1
 8007348:	4b2f      	ldr	r3, [pc, #188]	; (8007408 <tcp_input+0x5b8>)
 800734a:	681b      	ldr	r3, [r3, #0]
 800734c:	4298      	cmp	r0, r3
 800734e:	d1de      	bne.n	800730e <tcp_input+0x4be>
      pcb->snd_buf++;
 8007350:	f8b5 3066 	ldrh.w	r3, [r5, #102]	; 0x66
 8007354:	3301      	adds	r3, #1
 8007356:	f8a5 3066 	strh.w	r3, [r5, #102]	; 0x66
      pcb->rcv_nxt = seqno + 1;
 800735a:	4b28      	ldr	r3, [pc, #160]	; (80073fc <tcp_input+0x5ac>)
 800735c:	681b      	ldr	r3, [r3, #0]
 800735e:	1c5a      	adds	r2, r3, #1
 8007360:	62aa      	str	r2, [r5, #40]	; 0x28
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 8007362:	632a      	str	r2, [r5, #48]	; 0x30
      pcb->lastack = ackno;
 8007364:	64a8      	str	r0, [r5, #72]	; 0x48
      pcb->snd_wnd = tcphdr->wnd;
 8007366:	4a24      	ldr	r2, [pc, #144]	; (80073f8 <tcp_input+0x5a8>)
 8007368:	6812      	ldr	r2, [r2, #0]
 800736a:	89d1      	ldrh	r1, [r2, #14]
 800736c:	f8a5 1060 	strh.w	r1, [r5, #96]	; 0x60
      pcb->snd_wnd_max = tcphdr->wnd;
 8007370:	89d2      	ldrh	r2, [r2, #14]
 8007372:	f8a5 2062 	strh.w	r2, [r5, #98]	; 0x62
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 8007376:	3b01      	subs	r3, #1
 8007378:	656b      	str	r3, [r5, #84]	; 0x54
      pcb->state = ESTABLISHED;
 800737a:	2304      	movs	r3, #4
 800737c:	762b      	strb	r3, [r5, #24]
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 800737e:	18e9      	adds	r1, r5, r3
 8007380:	8ee8      	ldrh	r0, [r5, #54]	; 0x36
 8007382:	f7ff f863 	bl	800644c <tcp_eff_send_mss>
 8007386:	86e8      	strh	r0, [r5, #54]	; 0x36
      pcb->ssthresh = pcb->mss * 10;
 8007388:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 800738c:	005b      	lsls	r3, r3, #1
 800738e:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 8007392:	f8b5 304c 	ldrh.w	r3, [r5, #76]	; 0x4c
 8007396:	2b01      	cmp	r3, #1
 8007398:	bf04      	itt	eq
 800739a:	0040      	lsleq	r0, r0, #1
 800739c:	b280      	uxtheq	r0, r0
 800739e:	f8a5 004c 	strh.w	r0, [r5, #76]	; 0x4c
      --pcb->snd_queuelen;
 80073a2:	f8b5 3068 	ldrh.w	r3, [r5, #104]	; 0x68
 80073a6:	3b01      	subs	r3, #1
 80073a8:	f8a5 3068 	strh.w	r3, [r5, #104]	; 0x68
      rseg = pcb->unacked;
 80073ac:	6f28      	ldr	r0, [r5, #112]	; 0x70
      pcb->unacked = rseg->next;
 80073ae:	6803      	ldr	r3, [r0, #0]
 80073b0:	672b      	str	r3, [r5, #112]	; 0x70
      tcp_seg_free(rseg);
 80073b2:	f7fe fbb5 	bl	8005b20 <tcp_seg_free>
      if(pcb->unacked == NULL)
 80073b6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80073b8:	b993      	cbnz	r3, 80073e0 <tcp_input+0x590>
        pcb->rtime = -1;
 80073ba:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80073be:	86ab      	strh	r3, [r5, #52]	; 0x34
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 80073c0:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 80073c4:	b13b      	cbz	r3, 80073d6 <tcp_input+0x586>
 80073c6:	2200      	movs	r2, #0
 80073c8:	4629      	mov	r1, r5
 80073ca:	6928      	ldr	r0, [r5, #16]
 80073cc:	4798      	blx	r3
      if (err == ERR_ABRT) {
 80073ce:	f110 0f0a 	cmn.w	r0, #10
 80073d2:	f43f ae28 	beq.w	8007026 <tcp_input+0x1d6>
      tcp_ack_now(pcb);
 80073d6:	7fab      	ldrb	r3, [r5, #30]
 80073d8:	f043 0302 	orr.w	r3, r3, #2
 80073dc:	77ab      	strb	r3, [r5, #30]
 80073de:	e740      	b.n	8007262 <tcp_input+0x412>
        pcb->rtime = 0;
 80073e0:	2300      	movs	r3, #0
 80073e2:	86ab      	strh	r3, [r5, #52]	; 0x34
        pcb->nrtx = 0;
 80073e4:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
 80073e8:	e7ea      	b.n	80073c0 <tcp_input+0x570>
 80073ea:	bf00      	nop
 80073ec:	2000b1a8 	.word	0x2000b1a8
 80073f0:	2000894c 	.word	0x2000894c
 80073f4:	20008944 	.word	0x20008944
 80073f8:	20007720 	.word	0x20007720
 80073fc:	2000771c 	.word	0x2000771c
 8007400:	2000b1a0 	.word	0x2000b1a0
 8007404:	2000b19c 	.word	0x2000b19c
 8007408:	200076fc 	.word	0x200076fc
 800740c:	2000b084 	.word	0x2000b084
 8007410:	2000b1b8 	.word	0x2000b1b8
 8007414:	20007700 	.word	0x20007700
 8007418:	20007718 	.word	0x20007718
 800741c:	2000b1a4 	.word	0x2000b1a4
 8007420:	20007724 	.word	0x20007724
    if (flags & TCP_ACK) {
 8007424:	4b9f      	ldr	r3, [pc, #636]	; (80076a4 <tcp_input+0x854>)
 8007426:	781b      	ldrb	r3, [r3, #0]
 8007428:	f013 0f10 	tst.w	r3, #16
 800742c:	d049      	beq.n	80074c2 <tcp_input+0x672>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 800742e:	4b9e      	ldr	r3, [pc, #632]	; (80076a8 <tcp_input+0x858>)
 8007430:	6818      	ldr	r0, [r3, #0]
 8007432:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8007434:	43db      	mvns	r3, r3
 8007436:	42c3      	cmn	r3, r0
 8007438:	d433      	bmi.n	80074a2 <tcp_input+0x652>
 800743a:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 800743c:	1ac3      	subs	r3, r0, r3
 800743e:	2b00      	cmp	r3, #0
 8007440:	dc2f      	bgt.n	80074a2 <tcp_input+0x652>
        pcb->state = ESTABLISHED;
 8007442:	2304      	movs	r3, #4
 8007444:	762b      	strb	r3, [r5, #24]
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
 8007446:	696b      	ldr	r3, [r5, #20]
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 8007448:	b143      	cbz	r3, 800745c <tcp_input+0x60c>
 800744a:	2200      	movs	r2, #0
 800744c:	4629      	mov	r1, r5
 800744e:	6928      	ldr	r0, [r5, #16]
 8007450:	4798      	blx	r3
        if (err != ERR_OK) {
 8007452:	b138      	cbz	r0, 8007464 <tcp_input+0x614>
          if (err != ERR_ABRT) {
 8007454:	f110 0f0a 	cmn.w	r0, #10
 8007458:	f43f ade5 	beq.w	8007026 <tcp_input+0x1d6>
            tcp_abort(pcb);
 800745c:	4628      	mov	r0, r5
 800745e:	f7fe ff49 	bl	80062f4 <tcp_abort>
 8007462:	e5e0      	b.n	8007026 <tcp_input+0x1d6>
        old_cwnd = pcb->cwnd;
 8007464:	f8b5 404c 	ldrh.w	r4, [r5, #76]	; 0x4c
        tcp_receive(pcb);
 8007468:	4628      	mov	r0, r5
 800746a:	f7ff f8a9 	bl	80065c0 <tcp_receive>
        if (pcb->acked != 0) {
 800746e:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
 8007472:	b113      	cbz	r3, 800747a <tcp_input+0x62a>
          pcb->acked--;
 8007474:	3b01      	subs	r3, #1
 8007476:	f8a5 3064 	strh.w	r3, [r5, #100]	; 0x64
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 800747a:	2c01      	cmp	r4, #1
 800747c:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
 800747e:	bf04      	itt	eq
 8007480:	005b      	lsleq	r3, r3, #1
 8007482:	b29b      	uxtheq	r3, r3
 8007484:	f8a5 304c 	strh.w	r3, [r5, #76]	; 0x4c
        if (recv_flags & TF_GOT_FIN) {
 8007488:	4b88      	ldr	r3, [pc, #544]	; (80076ac <tcp_input+0x85c>)
 800748a:	781b      	ldrb	r3, [r3, #0]
 800748c:	f013 0f20 	tst.w	r3, #32
 8007490:	f43f aee7 	beq.w	8007262 <tcp_input+0x412>
          tcp_ack_now(pcb);
 8007494:	7fab      	ldrb	r3, [r5, #30]
 8007496:	f043 0302 	orr.w	r3, r3, #2
 800749a:	77ab      	strb	r3, [r5, #30]
          pcb->state = CLOSE_WAIT;
 800749c:	2307      	movs	r3, #7
 800749e:	762b      	strb	r3, [r5, #24]
 80074a0:	e6df      	b.n	8007262 <tcp_input+0x412>
                tcphdr->dest, tcphdr->src);
 80074a2:	4b83      	ldr	r3, [pc, #524]	; (80076b0 <tcp_input+0x860>)
 80074a4:	681b      	ldr	r3, [r3, #0]
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 80074a6:	4a83      	ldr	r2, [pc, #524]	; (80076b4 <tcp_input+0x864>)
 80074a8:	8814      	ldrh	r4, [r2, #0]
 80074aa:	4a83      	ldr	r2, [pc, #524]	; (80076b8 <tcp_input+0x868>)
 80074ac:	6811      	ldr	r1, [r2, #0]
 80074ae:	881a      	ldrh	r2, [r3, #0]
 80074b0:	9201      	str	r2, [sp, #4]
 80074b2:	885b      	ldrh	r3, [r3, #2]
 80074b4:	9300      	str	r3, [sp, #0]
 80074b6:	4b81      	ldr	r3, [pc, #516]	; (80076bc <tcp_input+0x86c>)
 80074b8:	4a81      	ldr	r2, [pc, #516]	; (80076c0 <tcp_input+0x870>)
 80074ba:	4421      	add	r1, r4
 80074bc:	f000 fc88 	bl	8007dd0 <tcp_rst>
 80074c0:	e6cf      	b.n	8007262 <tcp_input+0x412>
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 80074c2:	f013 0f02 	tst.w	r3, #2
 80074c6:	f43f aecc 	beq.w	8007262 <tcp_input+0x412>
 80074ca:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80074cc:	3b01      	subs	r3, #1
 80074ce:	4a7a      	ldr	r2, [pc, #488]	; (80076b8 <tcp_input+0x868>)
 80074d0:	6812      	ldr	r2, [r2, #0]
 80074d2:	4293      	cmp	r3, r2
 80074d4:	f47f aec5 	bne.w	8007262 <tcp_input+0x412>
      tcp_rexmit(pcb);
 80074d8:	4628      	mov	r0, r5
 80074da:	f000 fce3 	bl	8007ea4 <tcp_rexmit>
 80074de:	e6c0      	b.n	8007262 <tcp_input+0x412>
    tcp_receive(pcb);
 80074e0:	4628      	mov	r0, r5
 80074e2:	f7ff f86d 	bl	80065c0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 80074e6:	4b71      	ldr	r3, [pc, #452]	; (80076ac <tcp_input+0x85c>)
 80074e8:	781b      	ldrb	r3, [r3, #0]
 80074ea:	f013 0f20 	tst.w	r3, #32
 80074ee:	f43f aeb8 	beq.w	8007262 <tcp_input+0x412>
      tcp_ack_now(pcb);
 80074f2:	7fab      	ldrb	r3, [r5, #30]
 80074f4:	f043 0302 	orr.w	r3, r3, #2
 80074f8:	77ab      	strb	r3, [r5, #30]
      pcb->state = CLOSE_WAIT;
 80074fa:	2307      	movs	r3, #7
 80074fc:	762b      	strb	r3, [r5, #24]
 80074fe:	e6b0      	b.n	8007262 <tcp_input+0x412>
    tcp_receive(pcb);
 8007500:	4628      	mov	r0, r5
 8007502:	f7ff f85d 	bl	80065c0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 8007506:	4b69      	ldr	r3, [pc, #420]	; (80076ac <tcp_input+0x85c>)
 8007508:	781b      	ldrb	r3, [r3, #0]
 800750a:	f013 0f20 	tst.w	r3, #32
 800750e:	d041      	beq.n	8007594 <tcp_input+0x744>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 8007510:	4b64      	ldr	r3, [pc, #400]	; (80076a4 <tcp_input+0x854>)
 8007512:	781b      	ldrb	r3, [r3, #0]
 8007514:	f013 0f10 	tst.w	r3, #16
 8007518:	d035      	beq.n	8007586 <tcp_input+0x736>
 800751a:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 800751c:	4b62      	ldr	r3, [pc, #392]	; (80076a8 <tcp_input+0x858>)
 800751e:	681b      	ldr	r3, [r3, #0]
 8007520:	429a      	cmp	r2, r3
 8007522:	d130      	bne.n	8007586 <tcp_input+0x736>
        tcp_ack_now(pcb);
 8007524:	7fab      	ldrb	r3, [r5, #30]
 8007526:	f043 0302 	orr.w	r3, r3, #2
 800752a:	77ab      	strb	r3, [r5, #30]
        tcp_pcb_purge(pcb);
 800752c:	4628      	mov	r0, r5
 800752e:	f7fe fb24 	bl	8005b7a <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 8007532:	4b64      	ldr	r3, [pc, #400]	; (80076c4 <tcp_input+0x874>)
 8007534:	681b      	ldr	r3, [r3, #0]
 8007536:	429d      	cmp	r5, r3
 8007538:	d10e      	bne.n	8007558 <tcp_input+0x708>
 800753a:	68ea      	ldr	r2, [r5, #12]
 800753c:	4b61      	ldr	r3, [pc, #388]	; (80076c4 <tcp_input+0x874>)
 800753e:	601a      	str	r2, [r3, #0]
 8007540:	2201      	movs	r2, #1
 8007542:	4b61      	ldr	r3, [pc, #388]	; (80076c8 <tcp_input+0x878>)
 8007544:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 8007546:	230a      	movs	r3, #10
 8007548:	762b      	strb	r3, [r5, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800754a:	4b60      	ldr	r3, [pc, #384]	; (80076cc <tcp_input+0x87c>)
 800754c:	681a      	ldr	r2, [r3, #0]
 800754e:	60ea      	str	r2, [r5, #12]
 8007550:	601d      	str	r5, [r3, #0]
 8007552:	f000 fdc7 	bl	80080e4 <tcp_timer_needed>
 8007556:	e684      	b.n	8007262 <tcp_input+0x412>
        TCP_RMV_ACTIVE(pcb);
 8007558:	4a5d      	ldr	r2, [pc, #372]	; (80076d0 <tcp_input+0x880>)
 800755a:	6013      	str	r3, [r2, #0]
 800755c:	2200      	movs	r2, #0
 800755e:	2001      	movs	r0, #1
 8007560:	b92b      	cbnz	r3, 800756e <tcp_input+0x71e>
 8007562:	2a00      	cmp	r2, #0
 8007564:	d0ec      	beq.n	8007540 <tcp_input+0x6f0>
 8007566:	2200      	movs	r2, #0
 8007568:	4b59      	ldr	r3, [pc, #356]	; (80076d0 <tcp_input+0x880>)
 800756a:	601a      	str	r2, [r3, #0]
 800756c:	e7e8      	b.n	8007540 <tcp_input+0x6f0>
 800756e:	68d9      	ldr	r1, [r3, #12]
 8007570:	428d      	cmp	r5, r1
 8007572:	d105      	bne.n	8007580 <tcp_input+0x730>
 8007574:	b10a      	cbz	r2, 800757a <tcp_input+0x72a>
 8007576:	4a56      	ldr	r2, [pc, #344]	; (80076d0 <tcp_input+0x880>)
 8007578:	6013      	str	r3, [r2, #0]
 800757a:	68ea      	ldr	r2, [r5, #12]
 800757c:	60da      	str	r2, [r3, #12]
 800757e:	e7df      	b.n	8007540 <tcp_input+0x6f0>
 8007580:	4602      	mov	r2, r0
 8007582:	460b      	mov	r3, r1
 8007584:	e7ec      	b.n	8007560 <tcp_input+0x710>
        tcp_ack_now(pcb);
 8007586:	7fab      	ldrb	r3, [r5, #30]
 8007588:	f043 0302 	orr.w	r3, r3, #2
 800758c:	77ab      	strb	r3, [r5, #30]
        pcb->state = CLOSING;
 800758e:	2308      	movs	r3, #8
 8007590:	762b      	strb	r3, [r5, #24]
 8007592:	e666      	b.n	8007262 <tcp_input+0x412>
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 8007594:	4b43      	ldr	r3, [pc, #268]	; (80076a4 <tcp_input+0x854>)
 8007596:	781b      	ldrb	r3, [r3, #0]
 8007598:	f013 0f10 	tst.w	r3, #16
 800759c:	f43f ae61 	beq.w	8007262 <tcp_input+0x412>
 80075a0:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 80075a2:	4b41      	ldr	r3, [pc, #260]	; (80076a8 <tcp_input+0x858>)
 80075a4:	681b      	ldr	r3, [r3, #0]
 80075a6:	429a      	cmp	r2, r3
 80075a8:	f47f ae5b 	bne.w	8007262 <tcp_input+0x412>
      pcb->state = FIN_WAIT_2;
 80075ac:	2306      	movs	r3, #6
 80075ae:	762b      	strb	r3, [r5, #24]
 80075b0:	e657      	b.n	8007262 <tcp_input+0x412>
    tcp_receive(pcb);
 80075b2:	4628      	mov	r0, r5
 80075b4:	f7ff f804 	bl	80065c0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 80075b8:	4b3c      	ldr	r3, [pc, #240]	; (80076ac <tcp_input+0x85c>)
 80075ba:	781b      	ldrb	r3, [r3, #0]
 80075bc:	f013 0f20 	tst.w	r3, #32
 80075c0:	f43f ae4f 	beq.w	8007262 <tcp_input+0x412>
      tcp_ack_now(pcb);
 80075c4:	7fab      	ldrb	r3, [r5, #30]
 80075c6:	f043 0302 	orr.w	r3, r3, #2
 80075ca:	77ab      	strb	r3, [r5, #30]
      tcp_pcb_purge(pcb);
 80075cc:	4628      	mov	r0, r5
 80075ce:	f7fe fad4 	bl	8005b7a <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 80075d2:	4b3c      	ldr	r3, [pc, #240]	; (80076c4 <tcp_input+0x874>)
 80075d4:	681b      	ldr	r3, [r3, #0]
 80075d6:	429d      	cmp	r5, r3
 80075d8:	d10e      	bne.n	80075f8 <tcp_input+0x7a8>
 80075da:	68ea      	ldr	r2, [r5, #12]
 80075dc:	4b39      	ldr	r3, [pc, #228]	; (80076c4 <tcp_input+0x874>)
 80075de:	601a      	str	r2, [r3, #0]
 80075e0:	2201      	movs	r2, #1
 80075e2:	4b39      	ldr	r3, [pc, #228]	; (80076c8 <tcp_input+0x878>)
 80075e4:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
 80075e6:	230a      	movs	r3, #10
 80075e8:	762b      	strb	r3, [r5, #24]
      TCP_REG(&tcp_tw_pcbs, pcb);
 80075ea:	4b38      	ldr	r3, [pc, #224]	; (80076cc <tcp_input+0x87c>)
 80075ec:	681a      	ldr	r2, [r3, #0]
 80075ee:	60ea      	str	r2, [r5, #12]
 80075f0:	601d      	str	r5, [r3, #0]
 80075f2:	f000 fd77 	bl	80080e4 <tcp_timer_needed>
 80075f6:	e634      	b.n	8007262 <tcp_input+0x412>
      TCP_RMV_ACTIVE(pcb);
 80075f8:	4a35      	ldr	r2, [pc, #212]	; (80076d0 <tcp_input+0x880>)
 80075fa:	6013      	str	r3, [r2, #0]
 80075fc:	2200      	movs	r2, #0
 80075fe:	2001      	movs	r0, #1
 8007600:	e004      	b.n	800760c <tcp_input+0x7bc>
 8007602:	68d9      	ldr	r1, [r3, #12]
 8007604:	428d      	cmp	r5, r1
 8007606:	d009      	beq.n	800761c <tcp_input+0x7cc>
 8007608:	4602      	mov	r2, r0
 800760a:	460b      	mov	r3, r1
 800760c:	2b00      	cmp	r3, #0
 800760e:	d1f8      	bne.n	8007602 <tcp_input+0x7b2>
 8007610:	2a00      	cmp	r2, #0
 8007612:	d0e5      	beq.n	80075e0 <tcp_input+0x790>
 8007614:	2200      	movs	r2, #0
 8007616:	4b2e      	ldr	r3, [pc, #184]	; (80076d0 <tcp_input+0x880>)
 8007618:	601a      	str	r2, [r3, #0]
 800761a:	e7e1      	b.n	80075e0 <tcp_input+0x790>
 800761c:	b10a      	cbz	r2, 8007622 <tcp_input+0x7d2>
 800761e:	4a2c      	ldr	r2, [pc, #176]	; (80076d0 <tcp_input+0x880>)
 8007620:	6013      	str	r3, [r2, #0]
 8007622:	68ea      	ldr	r2, [r5, #12]
 8007624:	60da      	str	r2, [r3, #12]
 8007626:	e7db      	b.n	80075e0 <tcp_input+0x790>
    tcp_receive(pcb);
 8007628:	4628      	mov	r0, r5
 800762a:	f7fe ffc9 	bl	80065c0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 800762e:	4b1d      	ldr	r3, [pc, #116]	; (80076a4 <tcp_input+0x854>)
 8007630:	781b      	ldrb	r3, [r3, #0]
 8007632:	f013 0f10 	tst.w	r3, #16
 8007636:	f43f ae14 	beq.w	8007262 <tcp_input+0x412>
 800763a:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 800763c:	4b1a      	ldr	r3, [pc, #104]	; (80076a8 <tcp_input+0x858>)
 800763e:	681b      	ldr	r3, [r3, #0]
 8007640:	429a      	cmp	r2, r3
 8007642:	f47f ae0e 	bne.w	8007262 <tcp_input+0x412>
      tcp_pcb_purge(pcb);
 8007646:	4628      	mov	r0, r5
 8007648:	f7fe fa97 	bl	8005b7a <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 800764c:	4b1d      	ldr	r3, [pc, #116]	; (80076c4 <tcp_input+0x874>)
 800764e:	681b      	ldr	r3, [r3, #0]
 8007650:	429d      	cmp	r5, r3
 8007652:	d10e      	bne.n	8007672 <tcp_input+0x822>
 8007654:	68ea      	ldr	r2, [r5, #12]
 8007656:	4b1b      	ldr	r3, [pc, #108]	; (80076c4 <tcp_input+0x874>)
 8007658:	601a      	str	r2, [r3, #0]
 800765a:	2201      	movs	r2, #1
 800765c:	4b1a      	ldr	r3, [pc, #104]	; (80076c8 <tcp_input+0x878>)
 800765e:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
 8007660:	230a      	movs	r3, #10
 8007662:	762b      	strb	r3, [r5, #24]
      TCP_REG(&tcp_tw_pcbs, pcb);
 8007664:	4b19      	ldr	r3, [pc, #100]	; (80076cc <tcp_input+0x87c>)
 8007666:	681a      	ldr	r2, [r3, #0]
 8007668:	60ea      	str	r2, [r5, #12]
 800766a:	601d      	str	r5, [r3, #0]
 800766c:	f000 fd3a 	bl	80080e4 <tcp_timer_needed>
 8007670:	e5f7      	b.n	8007262 <tcp_input+0x412>
      TCP_RMV_ACTIVE(pcb);
 8007672:	4a17      	ldr	r2, [pc, #92]	; (80076d0 <tcp_input+0x880>)
 8007674:	6013      	str	r3, [r2, #0]
 8007676:	2200      	movs	r2, #0
 8007678:	2001      	movs	r0, #1
 800767a:	e004      	b.n	8007686 <tcp_input+0x836>
 800767c:	68d9      	ldr	r1, [r3, #12]
 800767e:	428d      	cmp	r5, r1
 8007680:	d009      	beq.n	8007696 <tcp_input+0x846>
 8007682:	4602      	mov	r2, r0
 8007684:	460b      	mov	r3, r1
 8007686:	2b00      	cmp	r3, #0
 8007688:	d1f8      	bne.n	800767c <tcp_input+0x82c>
 800768a:	2a00      	cmp	r2, #0
 800768c:	d0e5      	beq.n	800765a <tcp_input+0x80a>
 800768e:	2200      	movs	r2, #0
 8007690:	4b0f      	ldr	r3, [pc, #60]	; (80076d0 <tcp_input+0x880>)
 8007692:	601a      	str	r2, [r3, #0]
 8007694:	e7e1      	b.n	800765a <tcp_input+0x80a>
 8007696:	b10a      	cbz	r2, 800769c <tcp_input+0x84c>
 8007698:	4a0d      	ldr	r2, [pc, #52]	; (80076d0 <tcp_input+0x880>)
 800769a:	6013      	str	r3, [r2, #0]
 800769c:	68ea      	ldr	r2, [r5, #12]
 800769e:	60da      	str	r2, [r3, #12]
 80076a0:	e7db      	b.n	800765a <tcp_input+0x80a>
 80076a2:	bf00      	nop
 80076a4:	20007700 	.word	0x20007700
 80076a8:	200076fc 	.word	0x200076fc
 80076ac:	20007718 	.word	0x20007718
 80076b0:	20007720 	.word	0x20007720
 80076b4:	20007724 	.word	0x20007724
 80076b8:	2000771c 	.word	0x2000771c
 80076bc:	20008944 	.word	0x20008944
 80076c0:	2000894c 	.word	0x2000894c
 80076c4:	2000b1a0 	.word	0x2000b1a0
 80076c8:	2000b19c 	.word	0x2000b19c
 80076cc:	2000b1b4 	.word	0x2000b1b4
 80076d0:	2000b1ac 	.word	0x2000b1ac
    tcp_receive(pcb);
 80076d4:	4628      	mov	r0, r5
 80076d6:	f7fe ff73 	bl	80065c0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 80076da:	4b53      	ldr	r3, [pc, #332]	; (8007828 <tcp_input+0x9d8>)
 80076dc:	781b      	ldrb	r3, [r3, #0]
 80076de:	f013 0f10 	tst.w	r3, #16
 80076e2:	f43f adbe 	beq.w	8007262 <tcp_input+0x412>
 80076e6:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 80076e8:	4b50      	ldr	r3, [pc, #320]	; (800782c <tcp_input+0x9dc>)
 80076ea:	681b      	ldr	r3, [r3, #0]
 80076ec:	429a      	cmp	r2, r3
 80076ee:	f47f adb8 	bne.w	8007262 <tcp_input+0x412>
      recv_flags |= TF_CLOSED;
 80076f2:	4a4f      	ldr	r2, [pc, #316]	; (8007830 <tcp_input+0x9e0>)
 80076f4:	7813      	ldrb	r3, [r2, #0]
 80076f6:	f043 0310 	orr.w	r3, r3, #16
 80076fa:	7013      	strb	r3, [r2, #0]
 80076fc:	e5b1      	b.n	8007262 <tcp_input+0x412>
      } else if (recv_flags & TF_CLOSED) {
 80076fe:	f013 0f10 	tst.w	r3, #16
 8007702:	d013      	beq.n	800772c <tcp_input+0x8dc>
        if (!(pcb->flags & TF_RXCLOSED)) {
 8007704:	7fab      	ldrb	r3, [r5, #30]
 8007706:	f013 0f10 	tst.w	r3, #16
 800770a:	d106      	bne.n	800771a <tcp_input+0x8ca>
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
 800770c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 8007710:	b11b      	cbz	r3, 800771a <tcp_input+0x8ca>
 8007712:	f06f 010b 	mvn.w	r1, #11
 8007716:	6928      	ldr	r0, [r5, #16]
 8007718:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800771a:	4629      	mov	r1, r5
 800771c:	4845      	ldr	r0, [pc, #276]	; (8007834 <tcp_input+0x9e4>)
 800771e:	f7fe fbfb 	bl	8005f18 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 8007722:	4629      	mov	r1, r5
 8007724:	2002      	movs	r0, #2
 8007726:	f7fd fec5 	bl	80054b4 <memp_free>
 800772a:	e47c      	b.n	8007026 <tcp_input+0x1d6>
        if (pcb->acked > 0) {
 800772c:	f8b5 2064 	ldrh.w	r2, [r5, #100]	; 0x64
 8007730:	b142      	cbz	r2, 8007744 <tcp_input+0x8f4>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
 8007732:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 8007734:	b133      	cbz	r3, 8007744 <tcp_input+0x8f4>
 8007736:	4629      	mov	r1, r5
 8007738:	6928      	ldr	r0, [r5, #16]
 800773a:	4798      	blx	r3
          if (err == ERR_ABRT) {
 800773c:	f110 0f0a 	cmn.w	r0, #10
 8007740:	f43f ac71 	beq.w	8007026 <tcp_input+0x1d6>
        if (recv_data != NULL) {
 8007744:	4b3c      	ldr	r3, [pc, #240]	; (8007838 <tcp_input+0x9e8>)
 8007746:	681a      	ldr	r2, [r3, #0]
 8007748:	b1ca      	cbz	r2, 800777e <tcp_input+0x92e>
          if (pcb->flags & TF_RXCLOSED) {
 800774a:	7fab      	ldrb	r3, [r5, #30]
 800774c:	f013 0f10 	tst.w	r3, #16
 8007750:	d006      	beq.n	8007760 <tcp_input+0x910>
            pbuf_free(recv_data);
 8007752:	4610      	mov	r0, r2
 8007754:	f7fd ffa5 	bl	80056a2 <pbuf_free>
            tcp_abort(pcb);
 8007758:	4628      	mov	r0, r5
 800775a:	f7fe fdcb 	bl	80062f4 <tcp_abort>
            goto aborted;
 800775e:	e462      	b.n	8007026 <tcp_input+0x1d6>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 8007760:	f8d5 4080 	ldr.w	r4, [r5, #128]	; 0x80
 8007764:	b1ec      	cbz	r4, 80077a2 <tcp_input+0x952>
 8007766:	2300      	movs	r3, #0
 8007768:	4629      	mov	r1, r5
 800776a:	6928      	ldr	r0, [r5, #16]
 800776c:	47a0      	blx	r4
          if (err == ERR_ABRT) {
 800776e:	f110 0f0a 	cmn.w	r0, #10
 8007772:	f43f ac58 	beq.w	8007026 <tcp_input+0x1d6>
          if (err != ERR_OK) {
 8007776:	b110      	cbz	r0, 800777e <tcp_input+0x92e>
            pcb->refused_data = recv_data;
 8007778:	4b2f      	ldr	r3, [pc, #188]	; (8007838 <tcp_input+0x9e8>)
 800777a:	681b      	ldr	r3, [r3, #0]
 800777c:	67ab      	str	r3, [r5, #120]	; 0x78
        if (recv_flags & TF_GOT_FIN) {
 800777e:	4b2c      	ldr	r3, [pc, #176]	; (8007830 <tcp_input+0x9e0>)
 8007780:	781b      	ldrb	r3, [r3, #0]
 8007782:	f013 0f20 	tst.w	r3, #32
 8007786:	d005      	beq.n	8007794 <tcp_input+0x944>
          if (pcb->refused_data != NULL) {
 8007788:	6fab      	ldr	r3, [r5, #120]	; 0x78
 800778a:	b183      	cbz	r3, 80077ae <tcp_input+0x95e>
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 800778c:	7b5a      	ldrb	r2, [r3, #13]
 800778e:	f042 0220 	orr.w	r2, r2, #32
 8007792:	735a      	strb	r2, [r3, #13]
        tcp_input_pcb = NULL;
 8007794:	2200      	movs	r2, #0
 8007796:	4b29      	ldr	r3, [pc, #164]	; (800783c <tcp_input+0x9ec>)
 8007798:	601a      	str	r2, [r3, #0]
        tcp_output(pcb);
 800779a:	4628      	mov	r0, r5
 800779c:	f000 f9c0 	bl	8007b20 <tcp_output>
 80077a0:	e441      	b.n	8007026 <tcp_input+0x1d6>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 80077a2:	2300      	movs	r3, #0
 80077a4:	4629      	mov	r1, r5
 80077a6:	4618      	mov	r0, r3
 80077a8:	f7fe fcc6 	bl	8006138 <tcp_recv_null>
 80077ac:	e7df      	b.n	800776e <tcp_input+0x91e>
            if (pcb->rcv_wnd != TCP_WND) {
 80077ae:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
 80077b0:	f241 62d0 	movw	r2, #5840	; 0x16d0
 80077b4:	4293      	cmp	r3, r2
              pcb->rcv_wnd++;
 80077b6:	bf1c      	itt	ne
 80077b8:	3301      	addne	r3, #1
 80077ba:	85ab      	strhne	r3, [r5, #44]	; 0x2c
            TCP_EVENT_CLOSED(pcb, err);
 80077bc:	f8d5 4080 	ldr.w	r4, [r5, #128]	; 0x80
 80077c0:	2c00      	cmp	r4, #0
 80077c2:	d0e7      	beq.n	8007794 <tcp_input+0x944>
 80077c4:	2300      	movs	r3, #0
 80077c6:	461a      	mov	r2, r3
 80077c8:	4629      	mov	r1, r5
 80077ca:	6928      	ldr	r0, [r5, #16]
 80077cc:	47a0      	blx	r4
            if (err == ERR_ABRT) {
 80077ce:	f110 0f0a 	cmn.w	r0, #10
 80077d2:	d1df      	bne.n	8007794 <tcp_input+0x944>
 80077d4:	e427      	b.n	8007026 <tcp_input+0x1d6>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 80077d6:	4b1a      	ldr	r3, [pc, #104]	; (8007840 <tcp_input+0x9f0>)
 80077d8:	681b      	ldr	r3, [r3, #0]
 80077da:	8998      	ldrh	r0, [r3, #12]
 80077dc:	f7fc fceb 	bl	80041b6 <lwip_ntohs>
 80077e0:	f010 0f04 	tst.w	r0, #4
 80077e4:	d11b      	bne.n	800781e <tcp_input+0x9ce>
      TCP_STATS_INC(tcp.proterr);
 80077e6:	4b17      	ldr	r3, [pc, #92]	; (8007844 <tcp_input+0x9f4>)
 80077e8:	f8b3 20a0 	ldrh.w	r2, [r3, #160]	; 0xa0
 80077ec:	3201      	adds	r2, #1
 80077ee:	f8a3 20a0 	strh.w	r2, [r3, #160]	; 0xa0
      TCP_STATS_INC(tcp.drop);
 80077f2:	f8b3 2096 	ldrh.w	r2, [r3, #150]	; 0x96
 80077f6:	3201      	adds	r2, #1
 80077f8:	f8a3 2096 	strh.w	r2, [r3, #150]	; 0x96
        tcphdr->dest, tcphdr->src);
 80077fc:	4b10      	ldr	r3, [pc, #64]	; (8007840 <tcp_input+0x9f0>)
 80077fe:	681b      	ldr	r3, [r3, #0]
      tcp_rst(ackno, seqno + tcplen,
 8007800:	4a11      	ldr	r2, [pc, #68]	; (8007848 <tcp_input+0x9f8>)
 8007802:	8810      	ldrh	r0, [r2, #0]
 8007804:	4a11      	ldr	r2, [pc, #68]	; (800784c <tcp_input+0x9fc>)
 8007806:	6811      	ldr	r1, [r2, #0]
 8007808:	881a      	ldrh	r2, [r3, #0]
 800780a:	9201      	str	r2, [sp, #4]
 800780c:	885b      	ldrh	r3, [r3, #2]
 800780e:	9300      	str	r3, [sp, #0]
 8007810:	4b0f      	ldr	r3, [pc, #60]	; (8007850 <tcp_input+0xa00>)
 8007812:	4a10      	ldr	r2, [pc, #64]	; (8007854 <tcp_input+0xa04>)
 8007814:	4401      	add	r1, r0
 8007816:	4805      	ldr	r0, [pc, #20]	; (800782c <tcp_input+0x9dc>)
 8007818:	6800      	ldr	r0, [r0, #0]
 800781a:	f000 fad9 	bl	8007dd0 <tcp_rst>
    pbuf_free(p);
 800781e:	4620      	mov	r0, r4
 8007820:	f7fd ff3f 	bl	80056a2 <pbuf_free>
 8007824:	f7ff bb3e 	b.w	8006ea4 <tcp_input+0x54>
 8007828:	20007700 	.word	0x20007700
 800782c:	200076fc 	.word	0x200076fc
 8007830:	20007718 	.word	0x20007718
 8007834:	2000b1a0 	.word	0x2000b1a0
 8007838:	20007714 	.word	0x20007714
 800783c:	2000b1b8 	.word	0x2000b1b8
 8007840:	20007720 	.word	0x20007720
 8007844:	2000b084 	.word	0x2000b084
 8007848:	20007724 	.word	0x20007724
 800784c:	2000771c 	.word	0x2000771c
 8007850:	20008944 	.word	0x20008944
 8007854:	2000894c 	.word	0x2000894c

08007858 <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
 8007858:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800785c:	4681      	mov	r9, r0
 800785e:	4688      	mov	r8, r1
 8007860:	4616      	mov	r6, r2
 8007862:	469a      	mov	sl, r3
 8007864:	f89d 7020 	ldrb.w	r7, [sp, #32]
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 8007868:	f007 0301 	and.w	r3, r7, #1
 800786c:	f007 0202 	and.w	r2, r7, #2
 8007870:	2a00      	cmp	r2, #0
 8007872:	bf14      	ite	ne
 8007874:	250c      	movne	r5, #12
 8007876:	2500      	moveq	r5, #0
 8007878:	eb05 0583 	add.w	r5, r5, r3, lsl #2

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800787c:	2004      	movs	r0, #4
 800787e:	f7fd fde3 	bl	8005448 <memp_malloc>
 8007882:	4604      	mov	r4, r0
 8007884:	b388      	cbz	r0, 80078ea <tcp_create_segment+0x92>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
 8007886:	7287      	strb	r7, [r0, #10]
  seg->next = NULL;
 8007888:	2300      	movs	r3, #0
 800788a:	6003      	str	r3, [r0, #0]
  seg->p = p;
 800788c:	f8c0 8004 	str.w	r8, [r0, #4]
  seg->len = p->tot_len - optlen;
 8007890:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 8007894:	1b5b      	subs	r3, r3, r5
 8007896:	8103      	strh	r3, [r0, #8]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 8007898:	2114      	movs	r1, #20
 800789a:	4640      	mov	r0, r8
 800789c:	f7fd fec3 	bl	8005626 <pbuf_header>
 80078a0:	bb38      	cbnz	r0, 80078f2 <tcp_create_segment+0x9a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 80078a2:	6863      	ldr	r3, [r4, #4]
 80078a4:	685f      	ldr	r7, [r3, #4]
 80078a6:	60e7      	str	r7, [r4, #12]
  seg->tcphdr->src = htons(pcb->local_port);
 80078a8:	f8b9 001a 	ldrh.w	r0, [r9, #26]
 80078ac:	f7fc fc7e 	bl	80041ac <lwip_htons>
 80078b0:	8038      	strh	r0, [r7, #0]
  seg->tcphdr->dest = htons(pcb->remote_port);
 80078b2:	68e7      	ldr	r7, [r4, #12]
 80078b4:	f8b9 001c 	ldrh.w	r0, [r9, #28]
 80078b8:	f7fc fc78 	bl	80041ac <lwip_htons>
 80078bc:	8078      	strh	r0, [r7, #2]
  seg->tcphdr->seqno = htonl(seqno);
 80078be:	68e7      	ldr	r7, [r4, #12]
 80078c0:	4650      	mov	r0, sl
 80078c2:	f7fc fc7d 	bl	80041c0 <lwip_htonl>
 80078c6:	6078      	str	r0, [r7, #4]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 80078c8:	68e7      	ldr	r7, [r4, #12]
 80078ca:	f3c5 0587 	ubfx	r5, r5, #2, #8
 80078ce:	3505      	adds	r5, #5
 80078d0:	ea46 3505 	orr.w	r5, r6, r5, lsl #12
 80078d4:	b2a8      	uxth	r0, r5
 80078d6:	f7fc fc69 	bl	80041ac <lwip_htons>
 80078da:	81b8      	strh	r0, [r7, #12]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 80078dc:	68e3      	ldr	r3, [r4, #12]
 80078de:	2200      	movs	r2, #0
 80078e0:	749a      	strb	r2, [r3, #18]
 80078e2:	74da      	strb	r2, [r3, #19]
  return seg;
} 
 80078e4:	4620      	mov	r0, r4
 80078e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    pbuf_free(p);
 80078ea:	4640      	mov	r0, r8
 80078ec:	f7fd fed9 	bl	80056a2 <pbuf_free>
    return NULL;
 80078f0:	e7f8      	b.n	80078e4 <tcp_create_segment+0x8c>
    TCP_STATS_INC(tcp.err);
 80078f2:	4a05      	ldr	r2, [pc, #20]	; (8007908 <tcp_create_segment+0xb0>)
 80078f4:	f8b2 30a4 	ldrh.w	r3, [r2, #164]	; 0xa4
 80078f8:	3301      	adds	r3, #1
 80078fa:	f8a2 30a4 	strh.w	r3, [r2, #164]	; 0xa4
    tcp_seg_free(seg);
 80078fe:	4620      	mov	r0, r4
 8007900:	f7fe f90e 	bl	8005b20 <tcp_seg_free>
    return NULL;
 8007904:	2400      	movs	r4, #0
 8007906:	e7ed      	b.n	80078e4 <tcp_create_segment+0x8c>
 8007908:	2000b084 	.word	0x2000b084

0800790c <tcp_output_alloc_header>:
{
 800790c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007910:	4606      	mov	r6, r0
 8007912:	460c      	mov	r4, r1
 8007914:	4698      	mov	r8, r3
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8007916:	3214      	adds	r2, #20
 8007918:	4411      	add	r1, r2
 800791a:	2200      	movs	r2, #0
 800791c:	b289      	uxth	r1, r1
 800791e:	2001      	movs	r0, #1
 8007920:	f7fd feee 	bl	8005700 <pbuf_alloc>
  if (p != NULL) {
 8007924:	4607      	mov	r7, r0
 8007926:	b328      	cbz	r0, 8007974 <tcp_output_alloc_header+0x68>
    tcphdr = (struct tcp_hdr *)p->payload;
 8007928:	6845      	ldr	r5, [r0, #4]
    tcphdr->src = htons(pcb->local_port);
 800792a:	8b70      	ldrh	r0, [r6, #26]
 800792c:	f7fc fc3e 	bl	80041ac <lwip_htons>
 8007930:	8028      	strh	r0, [r5, #0]
    tcphdr->dest = htons(pcb->remote_port);
 8007932:	8bb0      	ldrh	r0, [r6, #28]
 8007934:	f7fc fc3a 	bl	80041ac <lwip_htons>
 8007938:	8068      	strh	r0, [r5, #2]
    tcphdr->seqno = seqno_be;
 800793a:	f8c5 8004 	str.w	r8, [r5, #4]
    tcphdr->ackno = htonl(pcb->rcv_nxt);
 800793e:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 8007940:	f7fc fc3e 	bl	80041c0 <lwip_htonl>
 8007944:	60a8      	str	r0, [r5, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 8007946:	08a0      	lsrs	r0, r4, #2
 8007948:	3005      	adds	r0, #5
 800794a:	0300      	lsls	r0, r0, #12
 800794c:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
 8007950:	f040 0010 	orr.w	r0, r0, #16
 8007954:	f7fc fc2a 	bl	80041ac <lwip_htons>
 8007958:	81a8      	strh	r0, [r5, #12]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 800795a:	8df0      	ldrh	r0, [r6, #46]	; 0x2e
 800795c:	f7fc fc26 	bl	80041ac <lwip_htons>
 8007960:	81e8      	strh	r0, [r5, #14]
    tcphdr->chksum = 0;
 8007962:	2300      	movs	r3, #0
 8007964:	742b      	strb	r3, [r5, #16]
 8007966:	746b      	strb	r3, [r5, #17]
    tcphdr->urgp = 0;
 8007968:	74ab      	strb	r3, [r5, #18]
 800796a:	74eb      	strb	r3, [r5, #19]
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800796c:	8df2      	ldrh	r2, [r6, #46]	; 0x2e
 800796e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8007970:	4413      	add	r3, r2
 8007972:	6333      	str	r3, [r6, #48]	; 0x30
}
 8007974:	4638      	mov	r0, r7
 8007976:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

0800797c <tcp_enqueue_flags>:

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800797c:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
 8007980:	2b07      	cmp	r3, #7
 8007982:	d825      	bhi.n	80079d0 <tcp_enqueue_flags+0x54>
{
 8007984:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007986:	b083      	sub	sp, #12
 8007988:	f001 0603 	and.w	r6, r1, #3
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

  if (flags & TCP_SYN) {
 800798c:	f001 0302 	and.w	r3, r1, #2
  u8_t optflags = 0;
 8007990:	f3c1 0740 	ubfx	r7, r1, #1, #1
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 8007994:	2b00      	cmp	r3, #0
 8007996:	bf14      	ite	ne
 8007998:	f04f 0e04 	movne.w	lr, #4
 800799c:	f04f 0e00 	moveq.w	lr, #0

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
 80079a0:	f8b0 3066 	ldrh.w	r3, [r0, #102]	; 0x66
 80079a4:	b30b      	cbz	r3, 80079ea <tcp_enqueue_flags+0x6e>
 80079a6:	460d      	mov	r5, r1
 80079a8:	4604      	mov	r4, r0
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 80079aa:	2200      	movs	r2, #0
 80079ac:	4671      	mov	r1, lr
 80079ae:	4610      	mov	r0, r2
 80079b0:	f7fd fea6 	bl	8005700 <pbuf_alloc>
 80079b4:	4601      	mov	r1, r0
 80079b6:	b308      	cbz	r0, 80079fc <tcp_enqueue_flags+0x80>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 80079b8:	9700      	str	r7, [sp, #0]
 80079ba:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80079bc:	462a      	mov	r2, r5
 80079be:	4620      	mov	r0, r4
 80079c0:	f7ff ff4a 	bl	8007858 <tcp_create_segment>
 80079c4:	4601      	mov	r1, r0
 80079c6:	b330      	cbz	r0, 8007a16 <tcp_enqueue_flags+0x9a>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 80079c8:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80079ca:	bb92      	cbnz	r2, 8007a32 <tcp_enqueue_flags+0xb6>
    pcb->unsent = seg;
 80079cc:	66e0      	str	r0, [r4, #108]	; 0x6c
 80079ce:	e034      	b.n	8007a3a <tcp_enqueue_flags+0xbe>
    TCP_STATS_INC(tcp.memerr);
 80079d0:	4a29      	ldr	r2, [pc, #164]	; (8007a78 <tcp_enqueue_flags+0xfc>)
 80079d2:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 80079d6:	3301      	adds	r3, #1
 80079d8:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    pcb->flags |= TF_NAGLEMEMERR;
 80079dc:	7f83      	ldrb	r3, [r0, #30]
 80079de:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80079e2:	7783      	strb	r3, [r0, #30]
    return ERR_MEM;
 80079e4:	f04f 30ff 	mov.w	r0, #4294967295
 80079e8:	4770      	bx	lr
    TCP_STATS_INC(tcp.memerr);
 80079ea:	4a23      	ldr	r2, [pc, #140]	; (8007a78 <tcp_enqueue_flags+0xfc>)
 80079ec:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 80079f0:	3301      	adds	r3, #1
 80079f2:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    return ERR_MEM;
 80079f6:	f04f 30ff 	mov.w	r0, #4294967295
 80079fa:	e03a      	b.n	8007a72 <tcp_enqueue_flags+0xf6>
    pcb->flags |= TF_NAGLEMEMERR;
 80079fc:	7fa3      	ldrb	r3, [r4, #30]
 80079fe:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8007a02:	77a3      	strb	r3, [r4, #30]
    TCP_STATS_INC(tcp.memerr);
 8007a04:	4a1c      	ldr	r2, [pc, #112]	; (8007a78 <tcp_enqueue_flags+0xfc>)
 8007a06:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 8007a0a:	3301      	adds	r3, #1
 8007a0c:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    return ERR_MEM;
 8007a10:	f04f 30ff 	mov.w	r0, #4294967295
 8007a14:	e02d      	b.n	8007a72 <tcp_enqueue_flags+0xf6>
    pcb->flags |= TF_NAGLEMEMERR;
 8007a16:	7fa3      	ldrb	r3, [r4, #30]
 8007a18:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8007a1c:	77a3      	strb	r3, [r4, #30]
    TCP_STATS_INC(tcp.memerr);
 8007a1e:	4a16      	ldr	r2, [pc, #88]	; (8007a78 <tcp_enqueue_flags+0xfc>)
 8007a20:	f8b2 309c 	ldrh.w	r3, [r2, #156]	; 0x9c
 8007a24:	3301      	adds	r3, #1
 8007a26:	f8a2 309c 	strh.w	r3, [r2, #156]	; 0x9c
    return ERR_MEM;
 8007a2a:	f04f 30ff 	mov.w	r0, #4294967295
 8007a2e:	e020      	b.n	8007a72 <tcp_enqueue_flags+0xf6>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 8007a30:	461a      	mov	r2, r3
 8007a32:	6813      	ldr	r3, [r2, #0]
 8007a34:	2b00      	cmp	r3, #0
 8007a36:	d1fb      	bne.n	8007a30 <tcp_enqueue_flags+0xb4>
    useg->next = seg;
 8007a38:	6011      	str	r1, [r2, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 8007a3a:	2300      	movs	r3, #0
 8007a3c:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 8007a40:	b13e      	cbz	r6, 8007a52 <tcp_enqueue_flags+0xd6>
    pcb->snd_lbb++;
 8007a42:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8007a44:	3301      	adds	r3, #1
 8007a46:	65e3      	str	r3, [r4, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 8007a48:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
 8007a4c:	3b01      	subs	r3, #1
 8007a4e:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
  }
  if (flags & TCP_FIN) {
 8007a52:	f015 0f01 	tst.w	r5, #1
 8007a56:	d003      	beq.n	8007a60 <tcp_enqueue_flags+0xe4>
    pcb->flags |= TF_FIN;
 8007a58:	7fa3      	ldrb	r3, [r4, #30]
 8007a5a:	f043 0320 	orr.w	r3, r3, #32
 8007a5e:	77a3      	strb	r3, [r4, #30]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 8007a60:	6848      	ldr	r0, [r1, #4]
 8007a62:	f7fd ff10 	bl	8005886 <pbuf_clen>
 8007a66:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8007a6a:	4418      	add	r0, r3
 8007a6c:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 8007a70:	2000      	movs	r0, #0
}
 8007a72:	b003      	add	sp, #12
 8007a74:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007a76:	bf00      	nop
 8007a78:	2000b084 	.word	0x2000b084

08007a7c <tcp_send_fin>:
{
 8007a7c:	b570      	push	{r4, r5, r6, lr}
 8007a7e:	4605      	mov	r5, r0
  if (pcb->unsent != NULL) {
 8007a80:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
 8007a82:	b90c      	cbnz	r4, 8007a88 <tcp_send_fin+0xc>
 8007a84:	e00a      	b.n	8007a9c <tcp_send_fin+0x20>
         last_unsent = last_unsent->next);
 8007a86:	461c      	mov	r4, r3
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8007a88:	6823      	ldr	r3, [r4, #0]
 8007a8a:	2b00      	cmp	r3, #0
 8007a8c:	d1fb      	bne.n	8007a86 <tcp_send_fin+0xa>
    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 8007a8e:	68e3      	ldr	r3, [r4, #12]
 8007a90:	8998      	ldrh	r0, [r3, #12]
 8007a92:	f7fc fb90 	bl	80041b6 <lwip_ntohs>
 8007a96:	f010 0f07 	tst.w	r0, #7
 8007a9a:	d004      	beq.n	8007aa6 <tcp_send_fin+0x2a>
  return tcp_enqueue_flags(pcb, TCP_FIN);
 8007a9c:	2101      	movs	r1, #1
 8007a9e:	4628      	mov	r0, r5
 8007aa0:	f7ff ff6c 	bl	800797c <tcp_enqueue_flags>
}
 8007aa4:	bd70      	pop	{r4, r5, r6, pc}
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 8007aa6:	68e6      	ldr	r6, [r4, #12]
 8007aa8:	89b4      	ldrh	r4, [r6, #12]
 8007aaa:	2001      	movs	r0, #1
 8007aac:	f7fc fb7e 	bl	80041ac <lwip_htons>
 8007ab0:	4320      	orrs	r0, r4
 8007ab2:	81b0      	strh	r0, [r6, #12]
      pcb->flags |= TF_FIN;
 8007ab4:	7fab      	ldrb	r3, [r5, #30]
 8007ab6:	f043 0320 	orr.w	r3, r3, #32
 8007aba:	77ab      	strb	r3, [r5, #30]
      return ERR_OK;
 8007abc:	2000      	movs	r0, #0
 8007abe:	bd70      	pop	{r4, r5, r6, pc}

08007ac0 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 8007ac0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007ac2:	b083      	sub	sp, #12
 8007ac4:	4604      	mov	r4, r0
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
 8007ac6:	6d00      	ldr	r0, [r0, #80]	; 0x50
 8007ac8:	f7fc fb7a 	bl	80041c0 <lwip_htonl>
 8007acc:	4603      	mov	r3, r0
 8007ace:	2200      	movs	r2, #0
 8007ad0:	4611      	mov	r1, r2
 8007ad2:	4620      	mov	r0, r4
 8007ad4:	f7ff ff1a 	bl	800790c <tcp_output_alloc_header>
  if (p == NULL) {
 8007ad8:	b1f0      	cbz	r0, 8007b18 <tcp_send_empty_ack+0x58>
 8007ada:	4605      	mov	r5, r0
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8007adc:	6847      	ldr	r7, [r0, #4]
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8007ade:	7fa3      	ldrb	r3, [r4, #30]
 8007ae0:	f023 0303 	bic.w	r3, r3, #3
 8007ae4:	77a3      	strb	r3, [r4, #30]
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
 8007ae6:	1d26      	adds	r6, r4, #4
 8007ae8:	8903      	ldrh	r3, [r0, #8]
 8007aea:	9300      	str	r3, [sp, #0]
 8007aec:	2306      	movs	r3, #6
 8007aee:	4632      	mov	r2, r6
 8007af0:	4621      	mov	r1, r4
 8007af2:	f7fc fcf3 	bl	80044dc <inet_chksum_pseudo>
 8007af6:	8238      	strh	r0, [r7, #16]
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 8007af8:	7aa3      	ldrb	r3, [r4, #10]
 8007afa:	2206      	movs	r2, #6
 8007afc:	9201      	str	r2, [sp, #4]
 8007afe:	7a62      	ldrb	r2, [r4, #9]
 8007b00:	9200      	str	r2, [sp, #0]
 8007b02:	4632      	mov	r2, r6
 8007b04:	4621      	mov	r1, r4
 8007b06:	4628      	mov	r0, r5
 8007b08:	f7fc ff28 	bl	800495c <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
 8007b0c:	4628      	mov	r0, r5
 8007b0e:	f7fd fdc8 	bl	80056a2 <pbuf_free>

  return ERR_OK;
 8007b12:	2000      	movs	r0, #0
}
 8007b14:	b003      	add	sp, #12
 8007b16:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return ERR_BUF;
 8007b18:	f06f 0001 	mvn.w	r0, #1
 8007b1c:	e7fa      	b.n	8007b14 <tcp_send_empty_ack+0x54>
	...

08007b20 <tcp_output>:

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 8007b20:	4ba8      	ldr	r3, [pc, #672]	; (8007dc4 <tcp_output+0x2a4>)
 8007b22:	681b      	ldr	r3, [r3, #0]
 8007b24:	4298      	cmp	r0, r3
 8007b26:	f000 814a 	beq.w	8007dbe <tcp_output+0x29e>
{
 8007b2a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007b2e:	b083      	sub	sp, #12
 8007b30:	4605      	mov	r5, r0
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 8007b32:	f8b0 a060 	ldrh.w	sl, [r0, #96]	; 0x60
 8007b36:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
 8007b3a:	459a      	cmp	sl, r3
 8007b3c:	bf28      	it	cs
 8007b3e:	469a      	movcs	sl, r3

  seg = pcb->unsent;
 8007b40:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 8007b42:	7f83      	ldrb	r3, [r0, #30]
 8007b44:	f013 0f02 	tst.w	r3, #2
 8007b48:	d014      	beq.n	8007b74 <tcp_output+0x54>
 8007b4a:	b17c      	cbz	r4, 8007b6c <tcp_output+0x4c>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 8007b4c:	68e3      	ldr	r3, [r4, #12]
 8007b4e:	6858      	ldr	r0, [r3, #4]
 8007b50:	f7fc fb42 	bl	80041d8 <lwip_ntohl>
 8007b54:	8923      	ldrh	r3, [r4, #8]
 8007b56:	6caa      	ldr	r2, [r5, #72]	; 0x48
 8007b58:	1a9b      	subs	r3, r3, r2
 8007b5a:	4418      	add	r0, r3
     (seg == NULL ||
 8007b5c:	4582      	cmp	sl, r0
 8007b5e:	d305      	bcc.n	8007b6c <tcp_output+0x4c>
     return tcp_send_empty_ack(pcb);
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 8007b60:	f8d5 8070 	ldr.w	r8, [r5, #112]	; 0x70
  if (useg != NULL) {
 8007b64:	f1b8 0f00 	cmp.w	r8, #0
 8007b68:	d10f      	bne.n	8007b8a <tcp_output+0x6a>
 8007b6a:	e015      	b.n	8007b98 <tcp_output+0x78>
     return tcp_send_empty_ack(pcb);
 8007b6c:	4628      	mov	r0, r5
 8007b6e:	f7ff ffa7 	bl	8007ac0 <tcp_send_empty_ack>
 8007b72:	e121      	b.n	8007db8 <tcp_output+0x298>
  useg = pcb->unacked;
 8007b74:	f8d0 8070 	ldr.w	r8, [r0, #112]	; 0x70
  if (useg != NULL) {
 8007b78:	f1b8 0f00 	cmp.w	r8, #0
 8007b7c:	d105      	bne.n	8007b8a <tcp_output+0x6a>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 8007b7e:	b95c      	cbnz	r4, 8007b98 <tcp_output+0x78>
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8007b80:	2300      	movs	r3, #0
 8007b82:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
 8007b86:	e112      	b.n	8007dae <tcp_output+0x28e>
    for (; useg->next != NULL; useg = useg->next);
 8007b88:	4698      	mov	r8, r3
 8007b8a:	f8d8 3000 	ldr.w	r3, [r8]
 8007b8e:	2b00      	cmp	r3, #0
 8007b90:	d1fa      	bne.n	8007b88 <tcp_output+0x68>
  while (seg != NULL &&
 8007b92:	2c00      	cmp	r4, #0
 8007b94:	f000 8107 	beq.w	8007da6 <tcp_output+0x286>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
 8007b98:	f8df 922c 	ldr.w	r9, [pc, #556]	; 8007dc8 <tcp_output+0x2a8>
    pcb->rttest = tcp_ticks;
 8007b9c:	f8df b22c 	ldr.w	fp, [pc, #556]	; 8007dcc <tcp_output+0x2ac>
 8007ba0:	e0a8      	b.n	8007cf4 <tcp_output+0x1d4>
    if((tcp_do_output_nagle(pcb) == 0) &&
 8007ba2:	f8b5 2066 	ldrh.w	r2, [r5, #102]	; 0x66
 8007ba6:	b13a      	cbz	r2, 8007bb8 <tcp_output+0x98>
 8007ba8:	f8b5 2068 	ldrh.w	r2, [r5, #104]	; 0x68
 8007bac:	2a07      	cmp	r2, #7
 8007bae:	d803      	bhi.n	8007bb8 <tcp_output+0x98>
 8007bb0:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 8007bb4:	f000 80f7 	beq.w	8007da6 <tcp_output+0x286>
    pcb->unsent = seg->next;
 8007bb8:	6823      	ldr	r3, [r4, #0]
 8007bba:	66eb      	str	r3, [r5, #108]	; 0x6c
    if (pcb->state != SYN_SENT) {
 8007bbc:	7e2b      	ldrb	r3, [r5, #24]
 8007bbe:	2b02      	cmp	r3, #2
 8007bc0:	d00a      	beq.n	8007bd8 <tcp_output+0xb8>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 8007bc2:	68e7      	ldr	r7, [r4, #12]
 8007bc4:	89be      	ldrh	r6, [r7, #12]
 8007bc6:	2010      	movs	r0, #16
 8007bc8:	f7fc faf0 	bl	80041ac <lwip_htons>
 8007bcc:	4330      	orrs	r0, r6
 8007bce:	81b8      	strh	r0, [r7, #12]
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8007bd0:	7fab      	ldrb	r3, [r5, #30]
 8007bd2:	f023 0303 	bic.w	r3, r3, #3
 8007bd6:	77ab      	strb	r3, [r5, #30]
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
 8007bd8:	68e6      	ldr	r6, [r4, #12]
 8007bda:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 8007bdc:	f7fc faf0 	bl	80041c0 <lwip_htonl>
 8007be0:	60b0      	str	r0, [r6, #8]
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8007be2:	68e6      	ldr	r6, [r4, #12]
 8007be4:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
 8007be6:	f7fc fae1 	bl	80041ac <lwip_htons>
 8007bea:	81f0      	strh	r0, [r6, #14]
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8007bec:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
 8007bee:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8007bf0:	4413      	add	r3, r2
 8007bf2:	632b      	str	r3, [r5, #48]	; 0x30
  if (seg->flags & TF_SEG_OPTS_MSS) {
 8007bf4:	7aa3      	ldrb	r3, [r4, #10]
 8007bf6:	f013 0f01 	tst.w	r3, #1
 8007bfa:	f040 80a0 	bne.w	8007d3e <tcp_output+0x21e>
  if (pcb->rtime == -1) {
 8007bfe:	f9b5 3034 	ldrsh.w	r3, [r5, #52]	; 0x34
 8007c02:	f1b3 3fff 	cmp.w	r3, #4294967295
    pcb->rtime = 0;
 8007c06:	bf04      	itt	eq
 8007c08:	2300      	moveq	r3, #0
 8007c0a:	86ab      	strheq	r3, [r5, #52]	; 0x34
  if (ip_addr_isany(&(pcb->local_ip))) {
 8007c0c:	b10d      	cbz	r5, 8007c12 <tcp_output+0xf2>
 8007c0e:	682b      	ldr	r3, [r5, #0]
 8007c10:	b933      	cbnz	r3, 8007c20 <tcp_output+0x100>
    netif = ip_route(&(pcb->remote_ip));
 8007c12:	1d28      	adds	r0, r5, #4
 8007c14:	f7fc fcda 	bl	80045cc <ip_route>
    if (netif == NULL) {
 8007c18:	2800      	cmp	r0, #0
 8007c1a:	d032      	beq.n	8007c82 <tcp_output+0x162>
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
 8007c1c:	6843      	ldr	r3, [r0, #4]
 8007c1e:	602b      	str	r3, [r5, #0]
  if (pcb->rttest == 0) {
 8007c20:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8007c22:	2b00      	cmp	r3, #0
 8007c24:	f000 8097 	beq.w	8007d56 <tcp_output+0x236>
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8007c28:	6862      	ldr	r2, [r4, #4]
 8007c2a:	68e3      	ldr	r3, [r4, #12]
 8007c2c:	6851      	ldr	r1, [r2, #4]
 8007c2e:	1a5b      	subs	r3, r3, r1
 8007c30:	b29b      	uxth	r3, r3
  seg->p->len -= len;
 8007c32:	8951      	ldrh	r1, [r2, #10]
 8007c34:	1ac9      	subs	r1, r1, r3
 8007c36:	8151      	strh	r1, [r2, #10]
  seg->p->tot_len -= len;
 8007c38:	6861      	ldr	r1, [r4, #4]
 8007c3a:	890a      	ldrh	r2, [r1, #8]
 8007c3c:	1ad3      	subs	r3, r2, r3
 8007c3e:	810b      	strh	r3, [r1, #8]
  seg->p->payload = seg->tcphdr;
 8007c40:	6863      	ldr	r3, [r4, #4]
 8007c42:	68e2      	ldr	r2, [r4, #12]
 8007c44:	605a      	str	r2, [r3, #4]
  seg->tcphdr->chksum = 0;
 8007c46:	68e3      	ldr	r3, [r4, #12]
 8007c48:	2200      	movs	r2, #0
 8007c4a:	741a      	strb	r2, [r3, #16]
 8007c4c:	745a      	strb	r2, [r3, #17]
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
 8007c4e:	68e7      	ldr	r7, [r4, #12]
 8007c50:	6860      	ldr	r0, [r4, #4]
 8007c52:	1d2e      	adds	r6, r5, #4
 8007c54:	8903      	ldrh	r3, [r0, #8]
 8007c56:	9300      	str	r3, [sp, #0]
 8007c58:	2306      	movs	r3, #6
 8007c5a:	4632      	mov	r2, r6
 8007c5c:	4629      	mov	r1, r5
 8007c5e:	f7fc fc3d 	bl	80044dc <inet_chksum_pseudo>
 8007c62:	8238      	strh	r0, [r7, #16]
  TCP_STATS_INC(tcp.xmit);
 8007c64:	f8b9 3090 	ldrh.w	r3, [r9, #144]	; 0x90
 8007c68:	3301      	adds	r3, #1
 8007c6a:	f8a9 3090 	strh.w	r3, [r9, #144]	; 0x90

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 8007c6e:	7aab      	ldrb	r3, [r5, #10]
 8007c70:	6860      	ldr	r0, [r4, #4]
 8007c72:	2206      	movs	r2, #6
 8007c74:	9201      	str	r2, [sp, #4]
 8007c76:	7a6a      	ldrb	r2, [r5, #9]
 8007c78:	9200      	str	r2, [sp, #0]
 8007c7a:	4632      	mov	r2, r6
 8007c7c:	4629      	mov	r1, r5
 8007c7e:	f7fc fe6d 	bl	800495c <ip_output>
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 8007c82:	68e3      	ldr	r3, [r4, #12]
 8007c84:	6858      	ldr	r0, [r3, #4]
 8007c86:	f7fc faa7 	bl	80041d8 <lwip_ntohl>
 8007c8a:	4606      	mov	r6, r0
 8007c8c:	8927      	ldrh	r7, [r4, #8]
 8007c8e:	68e3      	ldr	r3, [r4, #12]
 8007c90:	8998      	ldrh	r0, [r3, #12]
 8007c92:	f7fc fa90 	bl	80041b6 <lwip_ntohs>
 8007c96:	f010 0003 	ands.w	r0, r0, #3
 8007c9a:	bf18      	it	ne
 8007c9c:	2001      	movne	r0, #1
 8007c9e:	4438      	add	r0, r7
 8007ca0:	4406      	add	r6, r0
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 8007ca2:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8007ca4:	1b9b      	subs	r3, r3, r6
 8007ca6:	2b00      	cmp	r3, #0
      pcb->snd_nxt = snd_nxt;
 8007ca8:	bfb8      	it	lt
 8007caa:	652e      	strlt	r6, [r5, #80]	; 0x50
    if (TCP_TCPLEN(seg) > 0) {
 8007cac:	8926      	ldrh	r6, [r4, #8]
 8007cae:	68e3      	ldr	r3, [r4, #12]
 8007cb0:	8998      	ldrh	r0, [r3, #12]
 8007cb2:	f7fc fa80 	bl	80041b6 <lwip_ntohs>
 8007cb6:	f010 0003 	ands.w	r0, r0, #3
 8007cba:	bf18      	it	ne
 8007cbc:	2001      	movne	r0, #1
 8007cbe:	42f0      	cmn	r0, r6
 8007cc0:	d06d      	beq.n	8007d9e <tcp_output+0x27e>
      seg->next = NULL;
 8007cc2:	2300      	movs	r3, #0
 8007cc4:	6023      	str	r3, [r4, #0]
      if (pcb->unacked == NULL) {
 8007cc6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007cc8:	2b00      	cmp	r3, #0
 8007cca:	d04d      	beq.n	8007d68 <tcp_output+0x248>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
 8007ccc:	68e3      	ldr	r3, [r4, #12]
 8007cce:	6858      	ldr	r0, [r3, #4]
 8007cd0:	f7fc fa82 	bl	80041d8 <lwip_ntohl>
 8007cd4:	4606      	mov	r6, r0
 8007cd6:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8007cda:	6858      	ldr	r0, [r3, #4]
 8007cdc:	f7fc fa7c 	bl	80041d8 <lwip_ntohl>
 8007ce0:	1a30      	subs	r0, r6, r0
 8007ce2:	2800      	cmp	r0, #0
 8007ce4:	db43      	blt.n	8007d6e <tcp_output+0x24e>
          useg->next = seg;
 8007ce6:	f8c8 4000 	str.w	r4, [r8]
 8007cea:	46a0      	mov	r8, r4
    seg = pcb->unsent;
 8007cec:	6eec      	ldr	r4, [r5, #108]	; 0x6c
  while (seg != NULL &&
 8007cee:	2c00      	cmp	r4, #0
 8007cf0:	f43f af46 	beq.w	8007b80 <tcp_output+0x60>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 8007cf4:	68e3      	ldr	r3, [r4, #12]
 8007cf6:	6858      	ldr	r0, [r3, #4]
 8007cf8:	f7fc fa6e 	bl	80041d8 <lwip_ntohl>
 8007cfc:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8007cfe:	1ac0      	subs	r0, r0, r3
 8007d00:	8923      	ldrh	r3, [r4, #8]
 8007d02:	4418      	add	r0, r3
  while (seg != NULL &&
 8007d04:	4582      	cmp	sl, r0
 8007d06:	d34e      	bcc.n	8007da6 <tcp_output+0x286>
    LWIP_ASSERT("RST not expected here!", 
 8007d08:	68e3      	ldr	r3, [r4, #12]
 8007d0a:	8998      	ldrh	r0, [r3, #12]
 8007d0c:	f7fc fa53 	bl	80041b6 <lwip_ntohs>
    if((tcp_do_output_nagle(pcb) == 0) &&
 8007d10:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007d12:	2b00      	cmp	r3, #0
 8007d14:	f43f af50 	beq.w	8007bb8 <tcp_output+0x98>
 8007d18:	7fab      	ldrb	r3, [r5, #30]
 8007d1a:	f013 0f44 	tst.w	r3, #68	; 0x44
 8007d1e:	f47f af4b 	bne.w	8007bb8 <tcp_output+0x98>
 8007d22:	6eea      	ldr	r2, [r5, #108]	; 0x6c
 8007d24:	2a00      	cmp	r2, #0
 8007d26:	f43f af3c 	beq.w	8007ba2 <tcp_output+0x82>
 8007d2a:	6811      	ldr	r1, [r2, #0]
 8007d2c:	2900      	cmp	r1, #0
 8007d2e:	f47f af43 	bne.w	8007bb8 <tcp_output+0x98>
 8007d32:	8911      	ldrh	r1, [r2, #8]
 8007d34:	8eea      	ldrh	r2, [r5, #54]	; 0x36
 8007d36:	4291      	cmp	r1, r2
 8007d38:	f4bf af3e 	bcs.w	8007bb8 <tcp_output+0x98>
 8007d3c:	e731      	b.n	8007ba2 <tcp_output+0x82>
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 8007d3e:	68e6      	ldr	r6, [r4, #12]
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
 8007d40:	1d29      	adds	r1, r5, #4
 8007d42:	f240 50b4 	movw	r0, #1460	; 0x5b4
 8007d46:	f7fe fb81 	bl	800644c <tcp_eff_send_mss>
    *opts = TCP_BUILD_MSS_OPTION(mss);
 8007d4a:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
 8007d4e:	f7fc fa37 	bl	80041c0 <lwip_htonl>
 8007d52:	6170      	str	r0, [r6, #20]
 8007d54:	e753      	b.n	8007bfe <tcp_output+0xde>
    pcb->rttest = tcp_ticks;
 8007d56:	f8db 3000 	ldr.w	r3, [fp]
 8007d5a:	63ab      	str	r3, [r5, #56]	; 0x38
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 8007d5c:	68e3      	ldr	r3, [r4, #12]
 8007d5e:	6858      	ldr	r0, [r3, #4]
 8007d60:	f7fc fa3a 	bl	80041d8 <lwip_ntohl>
 8007d64:	63e8      	str	r0, [r5, #60]	; 0x3c
 8007d66:	e75f      	b.n	8007c28 <tcp_output+0x108>
        pcb->unacked = seg;
 8007d68:	672c      	str	r4, [r5, #112]	; 0x70
 8007d6a:	46a0      	mov	r8, r4
 8007d6c:	e7be      	b.n	8007cec <tcp_output+0x1cc>
          struct tcp_seg **cur_seg = &(pcb->unacked);
 8007d6e:	f105 0770 	add.w	r7, r5, #112	; 0x70
          while (*cur_seg &&
 8007d72:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007d74:	b17b      	cbz	r3, 8007d96 <tcp_output+0x276>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 8007d76:	68db      	ldr	r3, [r3, #12]
 8007d78:	6858      	ldr	r0, [r3, #4]
 8007d7a:	f7fc fa2d 	bl	80041d8 <lwip_ntohl>
 8007d7e:	4606      	mov	r6, r0
 8007d80:	68e3      	ldr	r3, [r4, #12]
 8007d82:	6858      	ldr	r0, [r3, #4]
 8007d84:	f7fc fa28 	bl	80041d8 <lwip_ntohl>
 8007d88:	1a30      	subs	r0, r6, r0
          while (*cur_seg &&
 8007d8a:	2800      	cmp	r0, #0
 8007d8c:	da03      	bge.n	8007d96 <tcp_output+0x276>
              cur_seg = &((*cur_seg)->next );
 8007d8e:	683f      	ldr	r7, [r7, #0]
          while (*cur_seg &&
 8007d90:	683b      	ldr	r3, [r7, #0]
 8007d92:	2b00      	cmp	r3, #0
 8007d94:	d1ef      	bne.n	8007d76 <tcp_output+0x256>
          seg->next = (*cur_seg);
 8007d96:	683b      	ldr	r3, [r7, #0]
 8007d98:	6023      	str	r3, [r4, #0]
          (*cur_seg) = seg;
 8007d9a:	603c      	str	r4, [r7, #0]
 8007d9c:	e7a6      	b.n	8007cec <tcp_output+0x1cc>
      tcp_seg_free(seg);
 8007d9e:	4620      	mov	r0, r4
 8007da0:	f7fd febe 	bl	8005b20 <tcp_seg_free>
 8007da4:	e7a2      	b.n	8007cec <tcp_output+0x1cc>
  if (pcb->unsent == NULL) {
 8007da6:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 8007da8:	2b00      	cmp	r3, #0
 8007daa:	f43f aee9 	beq.w	8007b80 <tcp_output+0x60>
  pcb->flags &= ~TF_NAGLEMEMERR;
 8007dae:	7fab      	ldrb	r3, [r5, #30]
 8007db0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8007db4:	77ab      	strb	r3, [r5, #30]
  return ERR_OK;
 8007db6:	2000      	movs	r0, #0
}
 8007db8:	b003      	add	sp, #12
 8007dba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return ERR_OK;
 8007dbe:	2000      	movs	r0, #0
 8007dc0:	4770      	bx	lr
 8007dc2:	bf00      	nop
 8007dc4:	2000b1b8 	.word	0x2000b1b8
 8007dc8:	2000b084 	.word	0x2000b084
 8007dcc:	2000b1a4 	.word	0x2000b1a4

08007dd0 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 8007dd0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8007dd4:	b083      	sub	sp, #12
 8007dd6:	4681      	mov	r9, r0
 8007dd8:	460e      	mov	r6, r1
 8007dda:	4617      	mov	r7, r2
 8007ddc:	4698      	mov	r8, r3
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 8007dde:	2200      	movs	r2, #0
 8007de0:	2114      	movs	r1, #20
 8007de2:	2001      	movs	r0, #1
 8007de4:	f7fd fc8c 	bl	8005700 <pbuf_alloc>
  if (p == NULL) {
 8007de8:	2800      	cmp	r0, #0
 8007dea:	d03d      	beq.n	8007e68 <tcp_rst+0x98>
 8007dec:	4605      	mov	r5, r0
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
 8007dee:	6844      	ldr	r4, [r0, #4]
  tcphdr->src = htons(local_port);
 8007df0:	f8bd 0028 	ldrh.w	r0, [sp, #40]	; 0x28
 8007df4:	f7fc f9da 	bl	80041ac <lwip_htons>
 8007df8:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = htons(remote_port);
 8007dfa:	f8bd 002c 	ldrh.w	r0, [sp, #44]	; 0x2c
 8007dfe:	f7fc f9d5 	bl	80041ac <lwip_htons>
 8007e02:	8060      	strh	r0, [r4, #2]
  tcphdr->seqno = htonl(seqno);
 8007e04:	4648      	mov	r0, r9
 8007e06:	f7fc f9db 	bl	80041c0 <lwip_htonl>
 8007e0a:	6060      	str	r0, [r4, #4]
  tcphdr->ackno = htonl(ackno);
 8007e0c:	4630      	mov	r0, r6
 8007e0e:	f7fc f9d7 	bl	80041c0 <lwip_htonl>
 8007e12:	60a0      	str	r0, [r4, #8]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 8007e14:	f245 0014 	movw	r0, #20500	; 0x5014
 8007e18:	f7fc f9c8 	bl	80041ac <lwip_htons>
 8007e1c:	81a0      	strh	r0, [r4, #12]
  tcphdr->wnd = PP_HTONS(TCP_WND);
 8007e1e:	2600      	movs	r6, #0
 8007e20:	2316      	movs	r3, #22
 8007e22:	73a3      	strb	r3, [r4, #14]
 8007e24:	f06f 032f 	mvn.w	r3, #47	; 0x2f
 8007e28:	73e3      	strb	r3, [r4, #15]
  tcphdr->chksum = 0;
 8007e2a:	7426      	strb	r6, [r4, #16]
 8007e2c:	7466      	strb	r6, [r4, #17]
  tcphdr->urgp = 0;
 8007e2e:	74a6      	strb	r6, [r4, #18]
 8007e30:	74e6      	strb	r6, [r4, #19]

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
 8007e32:	892b      	ldrh	r3, [r5, #8]
 8007e34:	9300      	str	r3, [sp, #0]
 8007e36:	2306      	movs	r3, #6
 8007e38:	4642      	mov	r2, r8
 8007e3a:	4639      	mov	r1, r7
 8007e3c:	4628      	mov	r0, r5
 8007e3e:	f7fc fb4d 	bl	80044dc <inet_chksum_pseudo>
 8007e42:	8220      	strh	r0, [r4, #16]
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 8007e44:	4a0a      	ldr	r2, [pc, #40]	; (8007e70 <tcp_rst+0xa0>)
 8007e46:	f8b2 3090 	ldrh.w	r3, [r2, #144]	; 0x90
 8007e4a:	3301      	adds	r3, #1
 8007e4c:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 8007e50:	2306      	movs	r3, #6
 8007e52:	9301      	str	r3, [sp, #4]
 8007e54:	9600      	str	r6, [sp, #0]
 8007e56:	23ff      	movs	r3, #255	; 0xff
 8007e58:	4642      	mov	r2, r8
 8007e5a:	4639      	mov	r1, r7
 8007e5c:	4628      	mov	r0, r5
 8007e5e:	f7fc fd7d 	bl	800495c <ip_output>
  pbuf_free(p);
 8007e62:	4628      	mov	r0, r5
 8007e64:	f7fd fc1d 	bl	80056a2 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 8007e68:	b003      	add	sp, #12
 8007e6a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8007e6e:	bf00      	nop
 8007e70:	2000b084 	.word	0x2000b084

08007e74 <tcp_rexmit_rto>:
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 8007e74:	6f02      	ldr	r2, [r0, #112]	; 0x70
 8007e76:	b10a      	cbz	r2, 8007e7c <tcp_rexmit_rto+0x8>
{
 8007e78:	b508      	push	{r3, lr}
 8007e7a:	e001      	b.n	8007e80 <tcp_rexmit_rto+0xc>
 8007e7c:	4770      	bx	lr
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 8007e7e:	461a      	mov	r2, r3
 8007e80:	6813      	ldr	r3, [r2, #0]
 8007e82:	2b00      	cmp	r3, #0
 8007e84:	d1fb      	bne.n	8007e7e <tcp_rexmit_rto+0xa>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 8007e86:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8007e88:	6013      	str	r3, [r2, #0]
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 8007e8a:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8007e8c:	66c3      	str	r3, [r0, #108]	; 0x6c
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 8007e8e:	2200      	movs	r2, #0
 8007e90:	6702      	str	r2, [r0, #112]	; 0x70
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
 8007e92:	f890 3046 	ldrb.w	r3, [r0, #70]	; 0x46
 8007e96:	3301      	adds	r3, #1
 8007e98:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 8007e9c:	6382      	str	r2, [r0, #56]	; 0x38

  /* Do the actual retransmission */
  tcp_output(pcb);
 8007e9e:	f7ff fe3f 	bl	8007b20 <tcp_output>
 8007ea2:	bd08      	pop	{r3, pc}

08007ea4 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 8007ea4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 8007ea6:	6f06      	ldr	r6, [r0, #112]	; 0x70
 8007ea8:	b316      	cbz	r6, 8007ef0 <tcp_rexmit+0x4c>
 8007eaa:	4607      	mov	r7, r0
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
 8007eac:	6833      	ldr	r3, [r6, #0]
 8007eae:	6703      	str	r3, [r0, #112]	; 0x70

  cur_seg = &(pcb->unsent);
 8007eb0:	f100 056c 	add.w	r5, r0, #108	; 0x6c
  while (*cur_seg &&
 8007eb4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8007eb6:	b17b      	cbz	r3, 8007ed8 <tcp_rexmit+0x34>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 8007eb8:	68db      	ldr	r3, [r3, #12]
 8007eba:	6858      	ldr	r0, [r3, #4]
 8007ebc:	f7fc f98c 	bl	80041d8 <lwip_ntohl>
 8007ec0:	4604      	mov	r4, r0
 8007ec2:	68f3      	ldr	r3, [r6, #12]
 8007ec4:	6858      	ldr	r0, [r3, #4]
 8007ec6:	f7fc f987 	bl	80041d8 <lwip_ntohl>
 8007eca:	1a20      	subs	r0, r4, r0
  while (*cur_seg &&
 8007ecc:	2800      	cmp	r0, #0
 8007ece:	da03      	bge.n	8007ed8 <tcp_rexmit+0x34>
      cur_seg = &((*cur_seg)->next );
 8007ed0:	682d      	ldr	r5, [r5, #0]
  while (*cur_seg &&
 8007ed2:	682b      	ldr	r3, [r5, #0]
 8007ed4:	2b00      	cmp	r3, #0
 8007ed6:	d1ef      	bne.n	8007eb8 <tcp_rexmit+0x14>
  }
  seg->next = *cur_seg;
 8007ed8:	682b      	ldr	r3, [r5, #0]
 8007eda:	6033      	str	r3, [r6, #0]
  *cur_seg = seg;
 8007edc:	602e      	str	r6, [r5, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 8007ede:	6833      	ldr	r3, [r6, #0]
 8007ee0:	b13b      	cbz	r3, 8007ef2 <tcp_rexmit+0x4e>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 8007ee2:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 8007ee6:	3301      	adds	r3, #1
 8007ee8:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 8007eec:	2300      	movs	r3, #0
 8007eee:	63bb      	str	r3, [r7, #56]	; 0x38
 8007ef0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pcb->unsent_oversize = 0;
 8007ef2:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 8007ef6:	e7f4      	b.n	8007ee2 <tcp_rexmit+0x3e>

08007ef8 <tcp_rexmit_fast>:
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 8007ef8:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8007efa:	b11b      	cbz	r3, 8007f04 <tcp_rexmit_fast+0xc>
 8007efc:	7f83      	ldrb	r3, [r0, #30]
 8007efe:	f013 0f04 	tst.w	r3, #4
 8007f02:	d000      	beq.n	8007f06 <tcp_rexmit_fast+0xe>
 8007f04:	4770      	bx	lr
{
 8007f06:	b510      	push	{r4, lr}
 8007f08:	4604      	mov	r4, r0
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
 8007f0a:	f7ff ffcb 	bl	8007ea4 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
 8007f0e:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
 8007f12:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
 8007f16:	4293      	cmp	r3, r2
      pcb->ssthresh = pcb->snd_wnd / 2;
 8007f18:	bf87      	ittee	hi
 8007f1a:	0852      	lsrhi	r2, r2, #1
 8007f1c:	f8a4 204e 	strhhi.w	r2, [r4, #78]	; 0x4e
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
 8007f20:	085b      	lsrls	r3, r3, #1
 8007f22:	f8a4 304e 	strhls.w	r3, [r4, #78]	; 0x4e
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 8007f26:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8007f28:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
 8007f2c:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 8007f30:	bfbc      	itt	lt
 8007f32:	005a      	lsllt	r2, r3, #1
 8007f34:	f8a4 204e 	strhlt.w	r2, [r4, #78]	; 0x4e
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 8007f38:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8007f3c:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
 8007f40:	4413      	add	r3, r2
 8007f42:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    pcb->flags |= TF_INFR;
 8007f46:	7fa3      	ldrb	r3, [r4, #30]
 8007f48:	f043 0304 	orr.w	r3, r3, #4
 8007f4c:	77a3      	strb	r3, [r4, #30]
 8007f4e:	bd10      	pop	{r4, pc}

08007f50 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 8007f50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007f52:	b083      	sub	sp, #12
 8007f54:	4604      	mov	r4, r0
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 8007f56:	6d00      	ldr	r0, [r0, #80]	; 0x50
 8007f58:	3801      	subs	r0, #1
 8007f5a:	f7fc f931 	bl	80041c0 <lwip_htonl>
 8007f5e:	4603      	mov	r3, r0
 8007f60:	2200      	movs	r2, #0
 8007f62:	4611      	mov	r1, r2
 8007f64:	4620      	mov	r0, r4
 8007f66:	f7ff fcd1 	bl	800790c <tcp_output_alloc_header>
  if(p == NULL) {
 8007f6a:	b1e8      	cbz	r0, 8007fa8 <tcp_keepalive+0x58>
 8007f6c:	4605      	mov	r5, r0
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8007f6e:	6847      	ldr	r7, [r0, #4]

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 8007f70:	1d26      	adds	r6, r4, #4
 8007f72:	8903      	ldrh	r3, [r0, #8]
 8007f74:	9300      	str	r3, [sp, #0]
 8007f76:	2306      	movs	r3, #6
 8007f78:	4632      	mov	r2, r6
 8007f7a:	4621      	mov	r1, r4
 8007f7c:	f7fc faae 	bl	80044dc <inet_chksum_pseudo>
 8007f80:	8238      	strh	r0, [r7, #16]
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 8007f82:	4a0a      	ldr	r2, [pc, #40]	; (8007fac <tcp_keepalive+0x5c>)
 8007f84:	f8b2 3090 	ldrh.w	r3, [r2, #144]	; 0x90
 8007f88:	3301      	adds	r3, #1
 8007f8a:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 8007f8e:	7aa3      	ldrb	r3, [r4, #10]
 8007f90:	2206      	movs	r2, #6
 8007f92:	9201      	str	r2, [sp, #4]
 8007f94:	2200      	movs	r2, #0
 8007f96:	9200      	str	r2, [sp, #0]
 8007f98:	4632      	mov	r2, r6
 8007f9a:	4621      	mov	r1, r4
 8007f9c:	4628      	mov	r0, r5
 8007f9e:	f7fc fcdd 	bl	800495c <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 8007fa2:	4628      	mov	r0, r5
 8007fa4:	f7fd fb7d 	bl	80056a2 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 8007fa8:	b003      	add	sp, #12
 8007faa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007fac:	2000b084 	.word	0x2000b084

08007fb0 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 8007fb0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007fb2:	b083      	sub	sp, #12
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
 8007fb4:	6f05      	ldr	r5, [r0, #112]	; 0x70

  if(seg == NULL) {
 8007fb6:	b1fd      	cbz	r5, 8007ff8 <tcp_zero_window_probe+0x48>
 8007fb8:	4604      	mov	r4, r0
  }
  if(seg == NULL) {
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8007fba:	68eb      	ldr	r3, [r5, #12]
 8007fbc:	8998      	ldrh	r0, [r3, #12]
 8007fbe:	f7fc f8fa 	bl	80041b6 <lwip_ntohs>
 8007fc2:	f010 0f01 	tst.w	r0, #1
 8007fc6:	d001      	beq.n	8007fcc <tcp_zero_window_probe+0x1c>
 8007fc8:	892b      	ldrh	r3, [r5, #8]
 8007fca:	b1c3      	cbz	r3, 8007ffe <tcp_zero_window_probe+0x4e>
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 8007fcc:	68eb      	ldr	r3, [r5, #12]
 8007fce:	685b      	ldr	r3, [r3, #4]
 8007fd0:	2201      	movs	r2, #1
 8007fd2:	2100      	movs	r1, #0
 8007fd4:	4620      	mov	r0, r4
 8007fd6:	f7ff fc99 	bl	800790c <tcp_output_alloc_header>
  if(p == NULL) {
 8007fda:	4606      	mov	r6, r0
 8007fdc:	2800      	cmp	r0, #0
 8007fde:	d03e      	beq.n	800805e <tcp_zero_window_probe+0xae>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8007fe0:	6877      	ldr	r7, [r6, #4]
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 8007fe2:	6868      	ldr	r0, [r5, #4]
 8007fe4:	8903      	ldrh	r3, [r0, #8]
 8007fe6:	892a      	ldrh	r2, [r5, #8]
 8007fe8:	1a9b      	subs	r3, r3, r2
 8007fea:	b29b      	uxth	r3, r3
 8007fec:	2201      	movs	r2, #1
 8007fee:	f107 0114 	add.w	r1, r7, #20
 8007ff2:	f7fd fce9 	bl	80059c8 <pbuf_copy_partial>
 8007ff6:	e015      	b.n	8008024 <tcp_zero_window_probe+0x74>
    seg = pcb->unsent;
 8007ff8:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
  if(seg == NULL) {
 8007ffa:	b385      	cbz	r5, 800805e <tcp_zero_window_probe+0xae>
 8007ffc:	e7dc      	b.n	8007fb8 <tcp_zero_window_probe+0x8>
  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 8007ffe:	68eb      	ldr	r3, [r5, #12]
 8008000:	685b      	ldr	r3, [r3, #4]
 8008002:	2200      	movs	r2, #0
 8008004:	4611      	mov	r1, r2
 8008006:	4620      	mov	r0, r4
 8008008:	f7ff fc80 	bl	800790c <tcp_output_alloc_header>
  if(p == NULL) {
 800800c:	4606      	mov	r6, r0
 800800e:	b330      	cbz	r0, 800805e <tcp_zero_window_probe+0xae>
  tcphdr = (struct tcp_hdr *)p->payload;
 8008010:	6877      	ldr	r7, [r6, #4]
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 8008012:	f9b7 500c 	ldrsh.w	r5, [r7, #12]
 8008016:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 800801a:	2011      	movs	r0, #17
 800801c:	f7fc f8c6 	bl	80041ac <lwip_htons>
 8008020:	4328      	orrs	r0, r5
 8008022:	81b8      	strh	r0, [r7, #12]
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 8008024:	1d25      	adds	r5, r4, #4
 8008026:	8933      	ldrh	r3, [r6, #8]
 8008028:	9300      	str	r3, [sp, #0]
 800802a:	2306      	movs	r3, #6
 800802c:	462a      	mov	r2, r5
 800802e:	4621      	mov	r1, r4
 8008030:	4630      	mov	r0, r6
 8008032:	f7fc fa53 	bl	80044dc <inet_chksum_pseudo>
 8008036:	8238      	strh	r0, [r7, #16]
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 8008038:	4a0a      	ldr	r2, [pc, #40]	; (8008064 <tcp_zero_window_probe+0xb4>)
 800803a:	f8b2 3090 	ldrh.w	r3, [r2, #144]	; 0x90
 800803e:	3301      	adds	r3, #1
 8008040:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 8008044:	7aa3      	ldrb	r3, [r4, #10]
 8008046:	2206      	movs	r2, #6
 8008048:	9201      	str	r2, [sp, #4]
 800804a:	2200      	movs	r2, #0
 800804c:	9200      	str	r2, [sp, #0]
 800804e:	462a      	mov	r2, r5
 8008050:	4621      	mov	r1, r4
 8008052:	4630      	mov	r0, r6
 8008054:	f7fc fc82 	bl	800495c <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 8008058:	4630      	mov	r0, r6
 800805a:	f7fd fb22 	bl	80056a2 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 800805e:	b003      	add	sp, #12
 8008060:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008062:	bf00      	nop
 8008064:	2000b084 	.word	0x2000b084

08008068 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 8008068:	b570      	push	{r4, r5, r6, lr}
 800806a:	4604      	mov	r4, r0
 800806c:	460e      	mov	r6, r1
 800806e:	4615      	mov	r5, r2
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 8008070:	2007      	movs	r0, #7
 8008072:	f7fd f9e9 	bl	8005448 <memp_malloc>
  if (timeout == NULL) {
 8008076:	2800      	cmp	r0, #0
 8008078:	d030      	beq.n	80080dc <sys_timeout+0x74>
 800807a:	4601      	mov	r1, r0
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
 800807c:	2300      	movs	r3, #0
 800807e:	6003      	str	r3, [r0, #0]
  timeout->h = handler;
 8008080:	6086      	str	r6, [r0, #8]
  timeout->arg = arg;
 8008082:	60c5      	str	r5, [r0, #12]
  timeout->time = msecs;
 8008084:	6044      	str	r4, [r0, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 8008086:	4b16      	ldr	r3, [pc, #88]	; (80080e0 <sys_timeout+0x78>)
 8008088:	681d      	ldr	r5, [r3, #0]
 800808a:	b1a5      	cbz	r5, 80080b6 <sys_timeout+0x4e>
    next_timeout = timeout;
    return;
  }

  if (next_timeout->time > msecs) {
 800808c:	6868      	ldr	r0, [r5, #4]
 800808e:	4284      	cmp	r4, r0
 8008090:	d313      	bcc.n	80080ba <sys_timeout+0x52>
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
      timeout->time -= t->time;
 8008092:	1a20      	subs	r0, r4, r0
 8008094:	6048      	str	r0, [r1, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 8008096:	682a      	ldr	r2, [r5, #0]
 8008098:	b1f2      	cbz	r2, 80080d8 <sys_timeout+0x70>
 800809a:	6853      	ldr	r3, [r2, #4]
 800809c:	4298      	cmp	r0, r3
 800809e:	d312      	bcc.n	80080c6 <sys_timeout+0x5e>
      timeout->time -= t->time;
 80080a0:	6848      	ldr	r0, [r1, #4]
 80080a2:	6853      	ldr	r3, [r2, #4]
 80080a4:	1ac0      	subs	r0, r0, r3
 80080a6:	6048      	str	r0, [r1, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 80080a8:	6813      	ldr	r3, [r2, #0]
 80080aa:	b18b      	cbz	r3, 80080d0 <sys_timeout+0x68>
 80080ac:	685c      	ldr	r4, [r3, #4]
 80080ae:	42a0      	cmp	r0, r4
 80080b0:	d30b      	bcc.n	80080ca <sys_timeout+0x62>
 80080b2:	461a      	mov	r2, r3
 80080b4:	e7f4      	b.n	80080a0 <sys_timeout+0x38>
    next_timeout = timeout;
 80080b6:	6018      	str	r0, [r3, #0]
    return;
 80080b8:	bd70      	pop	{r4, r5, r6, pc}
    next_timeout->time -= msecs;
 80080ba:	1b00      	subs	r0, r0, r4
 80080bc:	6068      	str	r0, [r5, #4]
    timeout->next = next_timeout;
 80080be:	600d      	str	r5, [r1, #0]
    next_timeout = timeout;
 80080c0:	4b07      	ldr	r3, [pc, #28]	; (80080e0 <sys_timeout+0x78>)
 80080c2:	6019      	str	r1, [r3, #0]
 80080c4:	bd70      	pop	{r4, r5, r6, pc}
      if (t->next == NULL || t->next->time > timeout->time) {
 80080c6:	4613      	mov	r3, r2
 80080c8:	462a      	mov	r2, r5
        if (t->next != NULL) {
          t->next->time -= timeout->time;
 80080ca:	685c      	ldr	r4, [r3, #4]
 80080cc:	1a20      	subs	r0, r4, r0
 80080ce:	6058      	str	r0, [r3, #4]
        }
        timeout->next = t->next;
 80080d0:	6813      	ldr	r3, [r2, #0]
 80080d2:	600b      	str	r3, [r1, #0]
        t->next = timeout;
 80080d4:	6011      	str	r1, [r2, #0]
        break;
 80080d6:	bd70      	pop	{r4, r5, r6, pc}
      if (t->next == NULL || t->next->time > timeout->time) {
 80080d8:	462a      	mov	r2, r5
 80080da:	e7f9      	b.n	80080d0 <sys_timeout+0x68>
 80080dc:	bd70      	pop	{r4, r5, r6, pc}
 80080de:	bf00      	nop
 80080e0:	20007728 	.word	0x20007728

080080e4 <tcp_timer_needed>:
{
 80080e4:	b508      	push	{r3, lr}
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 80080e6:	4b0a      	ldr	r3, [pc, #40]	; (8008110 <tcp_timer_needed+0x2c>)
 80080e8:	681b      	ldr	r3, [r3, #0]
 80080ea:	b953      	cbnz	r3, 8008102 <tcp_timer_needed+0x1e>
 80080ec:	4b09      	ldr	r3, [pc, #36]	; (8008114 <tcp_timer_needed+0x30>)
 80080ee:	681b      	ldr	r3, [r3, #0]
 80080f0:	b143      	cbz	r3, 8008104 <tcp_timer_needed+0x20>
    tcpip_tcp_timer_active = 1;
 80080f2:	2201      	movs	r2, #1
 80080f4:	4b06      	ldr	r3, [pc, #24]	; (8008110 <tcp_timer_needed+0x2c>)
 80080f6:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 80080f8:	2200      	movs	r2, #0
 80080fa:	4907      	ldr	r1, [pc, #28]	; (8008118 <tcp_timer_needed+0x34>)
 80080fc:	20fa      	movs	r0, #250	; 0xfa
 80080fe:	f7ff ffb3 	bl	8008068 <sys_timeout>
 8008102:	bd08      	pop	{r3, pc}
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 8008104:	4b05      	ldr	r3, [pc, #20]	; (800811c <tcp_timer_needed+0x38>)
 8008106:	681b      	ldr	r3, [r3, #0]
 8008108:	2b00      	cmp	r3, #0
 800810a:	d1f2      	bne.n	80080f2 <tcp_timer_needed+0xe>
 800810c:	e7f9      	b.n	8008102 <tcp_timer_needed+0x1e>
 800810e:	bf00      	nop
 8008110:	2000772c 	.word	0x2000772c
 8008114:	2000b1a0 	.word	0x2000b1a0
 8008118:	08008121 	.word	0x08008121
 800811c:	2000b1b4 	.word	0x2000b1b4

08008120 <tcpip_tcp_timer>:
{
 8008120:	b508      	push	{r3, lr}
  tcp_tmr();
 8008122:	f7fe f88b 	bl	800623c <tcp_tmr>
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 8008126:	4b08      	ldr	r3, [pc, #32]	; (8008148 <tcpip_tcp_timer+0x28>)
 8008128:	681b      	ldr	r3, [r3, #0]
 800812a:	b12b      	cbz	r3, 8008138 <tcpip_tcp_timer+0x18>
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 800812c:	2200      	movs	r2, #0
 800812e:	4907      	ldr	r1, [pc, #28]	; (800814c <tcpip_tcp_timer+0x2c>)
 8008130:	20fa      	movs	r0, #250	; 0xfa
 8008132:	f7ff ff99 	bl	8008068 <sys_timeout>
 8008136:	bd08      	pop	{r3, pc}
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 8008138:	4b05      	ldr	r3, [pc, #20]	; (8008150 <tcpip_tcp_timer+0x30>)
 800813a:	681b      	ldr	r3, [r3, #0]
 800813c:	2b00      	cmp	r3, #0
 800813e:	d1f5      	bne.n	800812c <tcpip_tcp_timer+0xc>
    tcpip_tcp_timer_active = 0;
 8008140:	2200      	movs	r2, #0
 8008142:	4b04      	ldr	r3, [pc, #16]	; (8008154 <tcpip_tcp_timer+0x34>)
 8008144:	601a      	str	r2, [r3, #0]
 8008146:	bd08      	pop	{r3, pc}
 8008148:	2000b1a0 	.word	0x2000b1a0
 800814c:	08008121 	.word	0x08008121
 8008150:	2000b1b4 	.word	0x2000b1b4
 8008154:	2000772c 	.word	0x2000772c

08008158 <sys_timeouts_init>:
{
 8008158:	b508      	push	{r3, lr}
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 800815a:	2200      	movs	r2, #0
 800815c:	4907      	ldr	r1, [pc, #28]	; (800817c <sys_timeouts_init+0x24>)
 800815e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008162:	f7ff ff81 	bl	8008068 <sys_timeout>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 8008166:	2200      	movs	r2, #0
 8008168:	4905      	ldr	r1, [pc, #20]	; (8008180 <sys_timeouts_init+0x28>)
 800816a:	f241 3088 	movw	r0, #5000	; 0x1388
 800816e:	f7ff ff7b 	bl	8008068 <sys_timeout>
  timeouts_last_time = sys_now();
 8008172:	f7fb fa82 	bl	800367a <sys_now>
 8008176:	4b03      	ldr	r3, [pc, #12]	; (8008184 <sys_timeouts_init+0x2c>)
 8008178:	6018      	str	r0, [r3, #0]
 800817a:	bd08      	pop	{r3, pc}
 800817c:	080081a1 	.word	0x080081a1
 8008180:	08008189 	.word	0x08008189
 8008184:	20007730 	.word	0x20007730

08008188 <arp_timer>:
{
 8008188:	b508      	push	{r3, lr}
  etharp_tmr();
 800818a:	f000 fb61 	bl	8008850 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 800818e:	2200      	movs	r2, #0
 8008190:	4902      	ldr	r1, [pc, #8]	; (800819c <arp_timer+0x14>)
 8008192:	f241 3088 	movw	r0, #5000	; 0x1388
 8008196:	f7ff ff67 	bl	8008068 <sys_timeout>
 800819a:	bd08      	pop	{r3, pc}
 800819c:	08008189 	.word	0x08008189

080081a0 <ip_reass_timer>:
{
 80081a0:	b508      	push	{r3, lr}
  ip_reass_tmr();
 80081a2:	f7fc fcb1 	bl	8004b08 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 80081a6:	2200      	movs	r2, #0
 80081a8:	4902      	ldr	r1, [pc, #8]	; (80081b4 <ip_reass_timer+0x14>)
 80081aa:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80081ae:	f7ff ff5b 	bl	8008068 <sys_timeout>
 80081b2:	bd08      	pop	{r3, pc}
 80081b4:	080081a1 	.word	0x080081a1

080081b8 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 80081b8:	4770      	bx	lr
	...

080081bc <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 80081bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80081c0:	b085      	sub	sp, #20
 80081c2:	4604      	mov	r4, r0
 80081c4:	4689      	mov	r9, r1
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
 80081c6:	4a7c      	ldr	r2, [pc, #496]	; (80083b8 <udp_input+0x1fc>)
 80081c8:	f8b2 307a 	ldrh.w	r3, [r2, #122]	; 0x7a
 80081cc:	3301      	adds	r3, #1
 80081ce:	f8a2 307a 	strh.w	r3, [r2, #122]	; 0x7a

  iphdr = (struct ip_hdr *)p->payload;
 80081d2:	f8d0 8004 	ldr.w	r8, [r0, #4]
 80081d6:	f898 1000 	ldrb.w	r1, [r8]
 80081da:	f001 010f 	and.w	r1, r1, #15

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 80081de:	8903      	ldrh	r3, [r0, #8]
 80081e0:	1c8a      	adds	r2, r1, #2
 80081e2:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80081e6:	db04      	blt.n	80081f2 <udp_input+0x36>
 80081e8:	0089      	lsls	r1, r1, #2
 80081ea:	4249      	negs	r1, r1
 80081ec:	f7fd fa1b 	bl	8005626 <pbuf_header>
 80081f0:	b180      	cbz	r0, 8008214 <udp_input+0x58>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
 80081f2:	4b71      	ldr	r3, [pc, #452]	; (80083b8 <udp_input+0x1fc>)
 80081f4:	f8b3 2082 	ldrh.w	r2, [r3, #130]	; 0x82
 80081f8:	3201      	adds	r2, #1
 80081fa:	f8a3 2082 	strh.w	r2, [r3, #130]	; 0x82
    UDP_STATS_INC(udp.drop);
 80081fe:	f8b3 207e 	ldrh.w	r2, [r3, #126]	; 0x7e
 8008202:	3201      	adds	r2, #1
 8008204:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
    snmp_inc_udpinerrors();
    pbuf_free(p);
 8008208:	4620      	mov	r0, r4
 800820a:	f7fd fa4a 	bl	80056a2 <pbuf_free>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
 800820e:	b005      	add	sp, #20
 8008210:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  udphdr = (struct udp_hdr *)p->payload;
 8008214:	f8d4 a004 	ldr.w	sl, [r4, #4]
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 8008218:	4649      	mov	r1, r9
 800821a:	4b68      	ldr	r3, [pc, #416]	; (80083bc <udp_input+0x200>)
 800821c:	6818      	ldr	r0, [r3, #0]
 800821e:	f7fc fbc1 	bl	80049a4 <ip4_addr_isbroadcast>
 8008222:	4607      	mov	r7, r0
  src = ntohs(udphdr->src);
 8008224:	f8ba 0000 	ldrh.w	r0, [sl]
 8008228:	f7fb ffc5 	bl	80041b6 <lwip_ntohs>
 800822c:	4605      	mov	r5, r0
  dest = ntohs(udphdr->dest);
 800822e:	f8ba 0002 	ldrh.w	r0, [sl, #2]
 8008232:	f7fb ffc0 	bl	80041b6 <lwip_ntohs>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008236:	4b62      	ldr	r3, [pc, #392]	; (80083c0 <udp_input+0x204>)
 8008238:	f8d3 e000 	ldr.w	lr, [r3]
 800823c:	f1be 0f00 	cmp.w	lr, #0
 8008240:	d049      	beq.n	80082d6 <udp_input+0x11a>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 8008242:	4b5e      	ldr	r3, [pc, #376]	; (80083bc <udp_input+0x200>)
 8008244:	f8d3 c000 	ldr.w	ip, [r3]
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 8008248:	4b5e      	ldr	r3, [pc, #376]	; (80083c4 <udp_input+0x208>)
 800824a:	f8d3 b000 	ldr.w	fp, [r3]
 800824e:	4673      	mov	r3, lr
 8008250:	2600      	movs	r6, #0
 8008252:	4632      	mov	r2, r6
 8008254:	9403      	str	r4, [sp, #12]
 8008256:	e0a2      	b.n	800839e <udp_input+0x1e2>
          if ((uncon_pcb == NULL) && 
 8008258:	7c19      	ldrb	r1, [r3, #16]
 800825a:	f001 0104 	and.w	r1, r1, #4
 800825e:	2900      	cmp	r1, #0
 8008260:	bf08      	it	eq
 8008262:	461e      	moveq	r6, r3
 8008264:	e091      	b.n	800838a <udp_input+0x1ce>
          (pcb->remote_port == src) &&
 8008266:	f113 0f04 	cmn.w	r3, #4
 800826a:	d004      	beq.n	8008276 <udp_input+0xba>
          (ip_addr_isany(&pcb->remote_ip) ||
 800826c:	6859      	ldr	r1, [r3, #4]
 800826e:	b111      	cbz	r1, 8008276 <udp_input+0xba>
 8008270:	4559      	cmp	r1, fp
 8008272:	f040 808e 	bne.w	8008392 <udp_input+0x1d6>
 8008276:	9c03      	ldr	r4, [sp, #12]
        if (prev != NULL) {
 8008278:	b142      	cbz	r2, 800828c <udp_input+0xd0>
          prev->next = pcb->next;
 800827a:	68d9      	ldr	r1, [r3, #12]
 800827c:	60d1      	str	r1, [r2, #12]
          pcb->next = udp_pcbs;
 800827e:	f8c3 e00c 	str.w	lr, [r3, #12]
          udp_pcbs = pcb;
 8008282:	4a4f      	ldr	r2, [pc, #316]	; (80083c0 <udp_input+0x204>)
 8008284:	6013      	str	r3, [r2, #0]
    if (pcb == NULL) {
 8008286:	b14b      	cbz	r3, 800829c <udp_input+0xe0>
 8008288:	461e      	mov	r6, r3
 800828a:	e008      	b.n	800829e <udp_input+0xe2>
          UDP_STATS_INC(udp.cachehit);
 800828c:	494a      	ldr	r1, [pc, #296]	; (80083b8 <udp_input+0x1fc>)
 800828e:	f8b1 208e 	ldrh.w	r2, [r1, #142]	; 0x8e
 8008292:	3201      	adds	r2, #1
 8008294:	f8a1 208e 	strh.w	r2, [r1, #142]	; 0x8e
 8008298:	e7f5      	b.n	8008286 <udp_input+0xca>
 800829a:	9c03      	ldr	r4, [sp, #12]
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 800829c:	b1de      	cbz	r6, 80082d6 <udp_input+0x11a>
      if (udphdr->chksum != 0) {
 800829e:	f8ba 3006 	ldrh.w	r3, [sl, #6]
 80082a2:	b143      	cbz	r3, 80082b6 <udp_input+0xfa>
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 80082a4:	8923      	ldrh	r3, [r4, #8]
 80082a6:	9300      	str	r3, [sp, #0]
 80082a8:	2311      	movs	r3, #17
 80082aa:	4a44      	ldr	r2, [pc, #272]	; (80083bc <udp_input+0x200>)
 80082ac:	4945      	ldr	r1, [pc, #276]	; (80083c4 <udp_input+0x208>)
 80082ae:	4620      	mov	r0, r4
 80082b0:	f7fc f914 	bl	80044dc <inet_chksum_pseudo>
 80082b4:	b9d8      	cbnz	r0, 80082ee <udp_input+0x132>
    if(pbuf_header(p, -UDP_HLEN)) {
 80082b6:	f06f 0107 	mvn.w	r1, #7
 80082ba:	4620      	mov	r0, r4
 80082bc:	f7fd f9b3 	bl	8005626 <pbuf_header>
 80082c0:	bb20      	cbnz	r0, 800830c <udp_input+0x150>
    if (pcb != NULL) {
 80082c2:	b38e      	cbz	r6, 8008328 <udp_input+0x16c>
      if (pcb->recv != NULL) {
 80082c4:	69b7      	ldr	r7, [r6, #24]
 80082c6:	b35f      	cbz	r7, 8008320 <udp_input+0x164>
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 80082c8:	69f0      	ldr	r0, [r6, #28]
 80082ca:	9500      	str	r5, [sp, #0]
 80082cc:	4b3d      	ldr	r3, [pc, #244]	; (80083c4 <udp_input+0x208>)
 80082ce:	4622      	mov	r2, r4
 80082d0:	4631      	mov	r1, r6
 80082d2:	47b8      	blx	r7
 80082d4:	e79b      	b.n	800820e <udp_input+0x52>
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 80082d6:	f8d9 2004 	ldr.w	r2, [r9, #4]
 80082da:	4b38      	ldr	r3, [pc, #224]	; (80083bc <udp_input+0x200>)
 80082dc:	681b      	ldr	r3, [r3, #0]
 80082de:	429a      	cmp	r2, r3
 80082e0:	d003      	beq.n	80082ea <udp_input+0x12e>
    pbuf_free(p);
 80082e2:	4620      	mov	r0, r4
 80082e4:	f7fd f9dd 	bl	80056a2 <pbuf_free>
}
 80082e8:	e791      	b.n	800820e <udp_input+0x52>
 80082ea:	2600      	movs	r6, #0
 80082ec:	e7d7      	b.n	800829e <udp_input+0xe2>
          UDP_STATS_INC(udp.chkerr);
 80082ee:	4b32      	ldr	r3, [pc, #200]	; (80083b8 <udp_input+0x1fc>)
 80082f0:	f8b3 2080 	ldrh.w	r2, [r3, #128]	; 0x80
 80082f4:	3201      	adds	r2, #1
 80082f6:	f8a3 2080 	strh.w	r2, [r3, #128]	; 0x80
          UDP_STATS_INC(udp.drop);
 80082fa:	f8b3 207e 	ldrh.w	r2, [r3, #126]	; 0x7e
 80082fe:	3201      	adds	r2, #1
 8008300:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
          pbuf_free(p);
 8008304:	4620      	mov	r0, r4
 8008306:	f7fd f9cc 	bl	80056a2 <pbuf_free>
          goto end;
 800830a:	e780      	b.n	800820e <udp_input+0x52>
      UDP_STATS_INC(udp.drop);
 800830c:	4a2a      	ldr	r2, [pc, #168]	; (80083b8 <udp_input+0x1fc>)
 800830e:	f8b2 307e 	ldrh.w	r3, [r2, #126]	; 0x7e
 8008312:	3301      	adds	r3, #1
 8008314:	f8a2 307e 	strh.w	r3, [r2, #126]	; 0x7e
      pbuf_free(p);
 8008318:	4620      	mov	r0, r4
 800831a:	f7fd f9c2 	bl	80056a2 <pbuf_free>
      goto end;
 800831e:	e776      	b.n	800820e <udp_input+0x52>
        pbuf_free(p);
 8008320:	4620      	mov	r0, r4
 8008322:	f7fd f9be 	bl	80056a2 <pbuf_free>
        goto end;
 8008326:	e772      	b.n	800820e <udp_input+0x52>
      if (!broadcast &&
 8008328:	b997      	cbnz	r7, 8008350 <udp_input+0x194>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 800832a:	4b24      	ldr	r3, [pc, #144]	; (80083bc <udp_input+0x200>)
 800832c:	681b      	ldr	r3, [r3, #0]
 800832e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      if (!broadcast &&
 8008332:	2be0      	cmp	r3, #224	; 0xe0
 8008334:	d00c      	beq.n	8008350 <udp_input+0x194>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
 8008336:	f898 1000 	ldrb.w	r1, [r8]
 800833a:	f001 010f 	and.w	r1, r1, #15
 800833e:	3102      	adds	r1, #2
 8008340:	0089      	lsls	r1, r1, #2
 8008342:	4620      	mov	r0, r4
 8008344:	f7fd f96f 	bl	8005626 <pbuf_header>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
 8008348:	2103      	movs	r1, #3
 800834a:	4620      	mov	r0, r4
 800834c:	f7fc f87e 	bl	800444c <icmp_dest_unreach>
      UDP_STATS_INC(udp.proterr);
 8008350:	4b19      	ldr	r3, [pc, #100]	; (80083b8 <udp_input+0x1fc>)
 8008352:	f8b3 2088 	ldrh.w	r2, [r3, #136]	; 0x88
 8008356:	3201      	adds	r2, #1
 8008358:	f8a3 2088 	strh.w	r2, [r3, #136]	; 0x88
      UDP_STATS_INC(udp.drop);
 800835c:	f8b3 207e 	ldrh.w	r2, [r3, #126]	; 0x7e
 8008360:	3201      	adds	r2, #1
 8008362:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
      pbuf_free(p);
 8008366:	4620      	mov	r0, r4
 8008368:	f7fd f99b 	bl	80056a2 <pbuf_free>
 800836c:	e74f      	b.n	800820e <udp_input+0x52>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 800836e:	6819      	ldr	r1, [r3, #0]
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 8008370:	458c      	cmp	ip, r1
 8008372:	d007      	beq.n	8008384 <udp_input+0x1c8>
            (broadcast &&
 8008374:	b133      	cbz	r3, 8008384 <udp_input+0x1c8>
             (ip_addr_isany(&pcb->local_ip) ||
 8008376:	b129      	cbz	r1, 8008384 <udp_input+0x1c8>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
 8008378:	ea8c 0401 	eor.w	r4, ip, r1
             (ip_addr_isany(&pcb->local_ip) ||
 800837c:	f8d9 1008 	ldr.w	r1, [r9, #8]
 8008380:	420c      	tst	r4, r1
 8008382:	d106      	bne.n	8008392 <udp_input+0x1d6>
          if ((uncon_pcb == NULL) && 
 8008384:	2e00      	cmp	r6, #0
 8008386:	f43f af67 	beq.w	8008258 <udp_input+0x9c>
      if ((local_match != 0) &&
 800838a:	8a99      	ldrh	r1, [r3, #20]
 800838c:	42a9      	cmp	r1, r5
 800838e:	f43f af6a 	beq.w	8008266 <udp_input+0xaa>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008392:	68d9      	ldr	r1, [r3, #12]
 8008394:	461a      	mov	r2, r3
 8008396:	2900      	cmp	r1, #0
 8008398:	f43f af7f 	beq.w	800829a <udp_input+0xde>
 800839c:	460b      	mov	r3, r1
      if (pcb->local_port == dest) {
 800839e:	8a59      	ldrh	r1, [r3, #18]
 80083a0:	4281      	cmp	r1, r0
 80083a2:	d1f6      	bne.n	8008392 <udp_input+0x1d6>
        if (
 80083a4:	2f00      	cmp	r7, #0
 80083a6:	d1e2      	bne.n	800836e <udp_input+0x1b2>
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 80083a8:	2b00      	cmp	r3, #0
 80083aa:	d0eb      	beq.n	8008384 <udp_input+0x1c8>
 80083ac:	6819      	ldr	r1, [r3, #0]
 80083ae:	2900      	cmp	r1, #0
 80083b0:	d0e8      	beq.n	8008384 <udp_input+0x1c8>
 80083b2:	4561      	cmp	r1, ip
 80083b4:	d1ed      	bne.n	8008392 <udp_input+0x1d6>
 80083b6:	e7e5      	b.n	8008384 <udp_input+0x1c8>
 80083b8:	2000b084 	.word	0x2000b084
 80083bc:	2000894c 	.word	0x2000894c
 80083c0:	2000b1bc 	.word	0x2000b1bc
 80083c4:	20008944 	.word	0x20008944

080083c8 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 80083c8:	b5f0      	push	{r4, r5, r6, r7, lr}
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80083ca:	4b34      	ldr	r3, [pc, #208]	; (800849c <udp_bind+0xd4>)
 80083cc:	681b      	ldr	r3, [r3, #0]
 80083ce:	b1cb      	cbz	r3, 8008404 <udp_bind+0x3c>
 80083d0:	2600      	movs	r6, #0
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
 80083d2:	2701      	movs	r7, #1
 80083d4:	e002      	b.n	80083dc <udp_bind+0x14>
 80083d6:	463e      	mov	r6, r7
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80083d8:	68db      	ldr	r3, [r3, #12]
 80083da:	b1a3      	cbz	r3, 8008406 <udp_bind+0x3e>
    if (pcb == ipcb) {
 80083dc:	4298      	cmp	r0, r3
 80083de:	d0fa      	beq.n	80083d6 <udp_bind+0xe>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 80083e0:	8a5c      	ldrh	r4, [r3, #18]
 80083e2:	4294      	cmp	r4, r2
 80083e4:	d1f8      	bne.n	80083d8 <udp_bind+0x10>
 80083e6:	2b00      	cmp	r3, #0
 80083e8:	d04a      	beq.n	8008480 <udp_bind+0xb8>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
 80083ea:	681c      	ldr	r4, [r3, #0]
 80083ec:	2c00      	cmp	r4, #0
 80083ee:	d04a      	beq.n	8008486 <udp_bind+0xbe>
 80083f0:	2900      	cmp	r1, #0
 80083f2:	d04b      	beq.n	800848c <udp_bind+0xc4>
           ip_addr_isany(ipaddr) ||
 80083f4:	680d      	ldr	r5, [r1, #0]
 80083f6:	2d00      	cmp	r5, #0
 80083f8:	d04b      	beq.n	8008492 <udp_bind+0xca>
 80083fa:	42ac      	cmp	r4, r5
 80083fc:	d1ec      	bne.n	80083d8 <udp_bind+0x10>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
 80083fe:	f06f 0007 	mvn.w	r0, #7
 8008402:	bdf0      	pop	{r4, r5, r6, r7, pc}
  rebind = 0;
 8008404:	2600      	movs	r6, #0
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
 8008406:	b159      	cbz	r1, 8008420 <udp_bind+0x58>
 8008408:	680b      	ldr	r3, [r1, #0]
 800840a:	6003      	str	r3, [r0, #0]

  /* no port specified? */
  if (port == 0) {
 800840c:	b152      	cbz	r2, 8008424 <udp_bind+0x5c>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
 800840e:	8242      	strh	r2, [r0, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 8008410:	2e00      	cmp	r6, #0
 8008412:	d141      	bne.n	8008498 <udp_bind+0xd0>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 8008414:	4b21      	ldr	r3, [pc, #132]	; (800849c <udp_bind+0xd4>)
 8008416:	681a      	ldr	r2, [r3, #0]
 8008418:	60c2      	str	r2, [r0, #12]
    udp_pcbs = pcb;
 800841a:	6018      	str	r0, [r3, #0]
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
 800841c:	2000      	movs	r0, #0
 800841e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  ip_addr_set(&pcb->local_ip, ipaddr);
 8008420:	2300      	movs	r3, #0
 8008422:	e7f2      	b.n	800840a <udp_bind+0x42>
 8008424:	4b1e      	ldr	r3, [pc, #120]	; (80084a0 <udp_bind+0xd8>)
 8008426:	8819      	ldrh	r1, [r3, #0]
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008428:	4b1c      	ldr	r3, [pc, #112]	; (800849c <udp_bind+0xd4>)
 800842a:	681c      	ldr	r4, [r3, #0]
 800842c:	f44f 4580 	mov.w	r5, #16384	; 0x4000
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 8008430:	f64f 77ff 	movw	r7, #65535	; 0xffff
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8008434:	f44f 4e40 	mov.w	lr, #49152	; 0xc000
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 8008438:	42b9      	cmp	r1, r7
 800843a:	bf1a      	itte	ne
 800843c:	3101      	addne	r1, #1
 800843e:	b289      	uxthne	r1, r1
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8008440:	4671      	moveq	r1, lr
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8008442:	b18c      	cbz	r4, 8008468 <udp_bind+0xa0>
    if (pcb->local_port == udp_port) {
 8008444:	8a63      	ldrh	r3, [r4, #18]
 8008446:	428b      	cmp	r3, r1
 8008448:	d005      	beq.n	8008456 <udp_bind+0x8e>
 800844a:	4623      	mov	r3, r4
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 800844c:	68db      	ldr	r3, [r3, #12]
 800844e:	b173      	cbz	r3, 800846e <udp_bind+0xa6>
    if (pcb->local_port == udp_port) {
 8008450:	8a5a      	ldrh	r2, [r3, #18]
 8008452:	428a      	cmp	r2, r1
 8008454:	d1fa      	bne.n	800844c <udp_bind+0x84>
 8008456:	3d01      	subs	r5, #1
 8008458:	b2ad      	uxth	r5, r5
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 800845a:	2d00      	cmp	r5, #0
 800845c:	d1ec      	bne.n	8008438 <udp_bind+0x70>
 800845e:	4b10      	ldr	r3, [pc, #64]	; (80084a0 <udp_bind+0xd8>)
 8008460:	8019      	strh	r1, [r3, #0]
      return ERR_USE;
 8008462:	f06f 0007 	mvn.w	r0, #7
 8008466:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008468:	4b0d      	ldr	r3, [pc, #52]	; (80084a0 <udp_bind+0xd8>)
 800846a:	8019      	strh	r1, [r3, #0]
 800846c:	e001      	b.n	8008472 <udp_bind+0xaa>
 800846e:	4b0c      	ldr	r3, [pc, #48]	; (80084a0 <udp_bind+0xd8>)
 8008470:	8019      	strh	r1, [r3, #0]
  return udp_port;
 8008472:	4b0b      	ldr	r3, [pc, #44]	; (80084a0 <udp_bind+0xd8>)
 8008474:	881a      	ldrh	r2, [r3, #0]
    if (port == 0) {
 8008476:	2a00      	cmp	r2, #0
 8008478:	d1c9      	bne.n	800840e <udp_bind+0x46>
      return ERR_USE;
 800847a:	f06f 0007 	mvn.w	r0, #7
 800847e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return ERR_USE;
 8008480:	f06f 0007 	mvn.w	r0, #7
 8008484:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008486:	f06f 0007 	mvn.w	r0, #7
 800848a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800848c:	f06f 0007 	mvn.w	r0, #7
 8008490:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008492:	f06f 0007 	mvn.w	r0, #7
 8008496:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return ERR_OK;
 8008498:	2000      	movs	r0, #0
}
 800849a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800849c:	2000b1bc 	.word	0x2000b1bc
 80084a0:	20000150 	.word	0x20000150

080084a4 <udp_sendto_if>:
{
 80084a4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80084a8:	b084      	sub	sp, #16
 80084aa:	4604      	mov	r4, r0
 80084ac:	460f      	mov	r7, r1
 80084ae:	4691      	mov	r9, r2
 80084b0:	469a      	mov	sl, r3
 80084b2:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
  if (pcb->local_port == 0) {
 80084b6:	8a43      	ldrh	r3, [r0, #18]
 80084b8:	b933      	cbnz	r3, 80084c8 <udp_sendto_if+0x24>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 80084ba:	2200      	movs	r2, #0
 80084bc:	4601      	mov	r1, r0
 80084be:	f7ff ff83 	bl	80083c8 <udp_bind>
    if (err != ERR_OK) {
 80084c2:	4605      	mov	r5, r0
 80084c4:	2800      	cmp	r0, #0
 80084c6:	d145      	bne.n	8008554 <udp_sendto_if+0xb0>
  if (pbuf_header(p, UDP_HLEN)) {
 80084c8:	2108      	movs	r1, #8
 80084ca:	4638      	mov	r0, r7
 80084cc:	f7fd f8ab 	bl	8005626 <pbuf_header>
 80084d0:	b168      	cbz	r0, 80084ee <udp_sendto_if+0x4a>
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 80084d2:	2200      	movs	r2, #0
 80084d4:	2108      	movs	r1, #8
 80084d6:	2001      	movs	r0, #1
 80084d8:	f7fd f912 	bl	8005700 <pbuf_alloc>
    if (q == NULL) {
 80084dc:	4606      	mov	r6, r0
 80084de:	2800      	cmp	r0, #0
 80084e0:	d057      	beq.n	8008592 <udp_sendto_if+0xee>
    if (p->tot_len != 0) {
 80084e2:	893b      	ldrh	r3, [r7, #8]
 80084e4:	b123      	cbz	r3, 80084f0 <udp_sendto_if+0x4c>
      pbuf_chain(q, p);
 80084e6:	4639      	mov	r1, r7
 80084e8:	f7fd f9f6 	bl	80058d8 <pbuf_chain>
 80084ec:	e000      	b.n	80084f0 <udp_sendto_if+0x4c>
    q = p;
 80084ee:	463e      	mov	r6, r7
  udphdr = (struct udp_hdr *)q->payload;
 80084f0:	6875      	ldr	r5, [r6, #4]
  udphdr->src = htons(pcb->local_port);
 80084f2:	8a60      	ldrh	r0, [r4, #18]
 80084f4:	f7fb fe5a 	bl	80041ac <lwip_htons>
 80084f8:	8028      	strh	r0, [r5, #0]
  udphdr->dest = htons(dst_port);
 80084fa:	4650      	mov	r0, sl
 80084fc:	f7fb fe56 	bl	80041ac <lwip_htons>
 8008500:	8068      	strh	r0, [r5, #2]
  udphdr->chksum = 0x0000; 
 8008502:	2300      	movs	r3, #0
 8008504:	71ab      	strb	r3, [r5, #6]
 8008506:	71eb      	strb	r3, [r5, #7]
  if (ip_addr_isany(&pcb->local_ip)) {
 8008508:	46a2      	mov	sl, r4
 800850a:	b10c      	cbz	r4, 8008510 <udp_sendto_if+0x6c>
 800850c:	6823      	ldr	r3, [r4, #0]
 800850e:	bb2b      	cbnz	r3, 800855c <udp_sendto_if+0xb8>
    src_ip = &(netif->ip_addr);
 8008510:	f108 0a04 	add.w	sl, r8, #4
    udphdr->len = htons(q->tot_len);
 8008514:	8930      	ldrh	r0, [r6, #8]
 8008516:	f7fb fe49 	bl	80041ac <lwip_htons>
 800851a:	80a8      	strh	r0, [r5, #4]
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 800851c:	7c23      	ldrb	r3, [r4, #16]
 800851e:	f013 0f01 	tst.w	r3, #1
 8008522:	d027      	beq.n	8008574 <udp_sendto_if+0xd0>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 8008524:	7aa3      	ldrb	r3, [r4, #10]
 8008526:	f8cd 8008 	str.w	r8, [sp, #8]
 800852a:	2211      	movs	r2, #17
 800852c:	9201      	str	r2, [sp, #4]
 800852e:	7a62      	ldrb	r2, [r4, #9]
 8008530:	9200      	str	r2, [sp, #0]
 8008532:	464a      	mov	r2, r9
 8008534:	4651      	mov	r1, sl
 8008536:	4630      	mov	r0, r6
 8008538:	f7fc f98e 	bl	8004858 <ip_output_if>
 800853c:	4605      	mov	r5, r0
  if (q != p) {
 800853e:	42be      	cmp	r6, r7
 8008540:	d002      	beq.n	8008548 <udp_sendto_if+0xa4>
    pbuf_free(q);
 8008542:	4630      	mov	r0, r6
 8008544:	f7fd f8ad 	bl	80056a2 <pbuf_free>
  UDP_STATS_INC(udp.xmit);
 8008548:	4a15      	ldr	r2, [pc, #84]	; (80085a0 <udp_sendto_if+0xfc>)
 800854a:	f8b2 3078 	ldrh.w	r3, [r2, #120]	; 0x78
 800854e:	3301      	adds	r3, #1
 8008550:	f8a2 3078 	strh.w	r3, [r2, #120]	; 0x78
}
 8008554:	4628      	mov	r0, r5
 8008556:	b004      	add	sp, #16
 8008558:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 800855c:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8008560:	4293      	cmp	r3, r2
 8008562:	d0d7      	beq.n	8008514 <udp_sendto_if+0x70>
      if (q != p) {
 8008564:	42be      	cmp	r6, r7
 8008566:	d017      	beq.n	8008598 <udp_sendto_if+0xf4>
        pbuf_free(q);
 8008568:	4630      	mov	r0, r6
 800856a:	f7fd f89a 	bl	80056a2 <pbuf_free>
      return ERR_VAL;
 800856e:	f06f 0505 	mvn.w	r5, #5
 8008572:	e7ef      	b.n	8008554 <udp_sendto_if+0xb0>
        udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
 8008574:	8933      	ldrh	r3, [r6, #8]
 8008576:	9300      	str	r3, [sp, #0]
 8008578:	2311      	movs	r3, #17
 800857a:	464a      	mov	r2, r9
 800857c:	4651      	mov	r1, sl
 800857e:	4630      	mov	r0, r6
 8008580:	f7fb ffac 	bl	80044dc <inet_chksum_pseudo>
      udphdr->chksum = udpchksum;
 8008584:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008588:	2800      	cmp	r0, #0
 800858a:	bf08      	it	eq
 800858c:	4618      	moveq	r0, r3
 800858e:	80e8      	strh	r0, [r5, #6]
 8008590:	e7c8      	b.n	8008524 <udp_sendto_if+0x80>
      return ERR_MEM;
 8008592:	f04f 35ff 	mov.w	r5, #4294967295
 8008596:	e7dd      	b.n	8008554 <udp_sendto_if+0xb0>
      return ERR_VAL;
 8008598:	f06f 0505 	mvn.w	r5, #5
 800859c:	e7da      	b.n	8008554 <udp_sendto_if+0xb0>
 800859e:	bf00      	nop
 80085a0:	2000b084 	.word	0x2000b084

080085a4 <udp_sendto>:
{
 80085a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80085a6:	b083      	sub	sp, #12
 80085a8:	4605      	mov	r5, r0
 80085aa:	460e      	mov	r6, r1
 80085ac:	4614      	mov	r4, r2
 80085ae:	461f      	mov	r7, r3
  netif = ip_route(dst_ip);
 80085b0:	4610      	mov	r0, r2
 80085b2:	f7fc f80b 	bl	80045cc <ip_route>
  if (netif == NULL) {
 80085b6:	b140      	cbz	r0, 80085ca <udp_sendto+0x26>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 80085b8:	9000      	str	r0, [sp, #0]
 80085ba:	463b      	mov	r3, r7
 80085bc:	4622      	mov	r2, r4
 80085be:	4631      	mov	r1, r6
 80085c0:	4628      	mov	r0, r5
 80085c2:	f7ff ff6f 	bl	80084a4 <udp_sendto_if>
}
 80085c6:	b003      	add	sp, #12
 80085c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    UDP_STATS_INC(udp.rterr);
 80085ca:	4a04      	ldr	r2, [pc, #16]	; (80085dc <udp_sendto+0x38>)
 80085cc:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80085d0:	3301      	adds	r3, #1
 80085d2:	f8a2 3086 	strh.w	r3, [r2, #134]	; 0x86
    return ERR_RTE;
 80085d6:	f06f 0003 	mvn.w	r0, #3
 80085da:	e7f4      	b.n	80085c6 <udp_sendto+0x22>
 80085dc:	2000b084 	.word	0x2000b084

080085e0 <udp_recv>:
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
 80085e0:	6181      	str	r1, [r0, #24]
  pcb->recv_arg = recv_arg;
 80085e2:	61c2      	str	r2, [r0, #28]
 80085e4:	4770      	bx	lr
	...

080085e8 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 80085e8:	b508      	push	{r3, lr}
 80085ea:	4601      	mov	r1, r0
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 80085ec:	4b0b      	ldr	r3, [pc, #44]	; (800861c <udp_remove+0x34>)
 80085ee:	681a      	ldr	r2, [r3, #0]
 80085f0:	4282      	cmp	r2, r0
 80085f2:	d001      	beq.n	80085f8 <udp_remove+0x10>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 80085f4:	b942      	cbnz	r2, 8008608 <udp_remove+0x20>
 80085f6:	e002      	b.n	80085fe <udp_remove+0x16>
    udp_pcbs = udp_pcbs->next;
 80085f8:	68d2      	ldr	r2, [r2, #12]
 80085fa:	4b08      	ldr	r3, [pc, #32]	; (800861c <udp_remove+0x34>)
 80085fc:	601a      	str	r2, [r3, #0]
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 80085fe:	2001      	movs	r0, #1
 8008600:	f7fc ff58 	bl	80054b4 <memp_free>
 8008604:	bd08      	pop	{r3, pc}
{
 8008606:	461a      	mov	r2, r3
      if (pcb2->next != NULL && pcb2->next == pcb) {
 8008608:	68d3      	ldr	r3, [r2, #12]
 800860a:	2b00      	cmp	r3, #0
 800860c:	d0f7      	beq.n	80085fe <udp_remove+0x16>
 800860e:	4299      	cmp	r1, r3
 8008610:	d1f9      	bne.n	8008606 <udp_remove+0x1e>
        pcb2->next = pcb->next;
 8008612:	68cb      	ldr	r3, [r1, #12]
 8008614:	60d3      	str	r3, [r2, #12]
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8008616:	2b00      	cmp	r3, #0
 8008618:	d1f5      	bne.n	8008606 <udp_remove+0x1e>
 800861a:	e7f0      	b.n	80085fe <udp_remove+0x16>
 800861c:	2000b1bc 	.word	0x2000b1bc

08008620 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 8008620:	b510      	push	{r4, lr}
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 8008622:	2001      	movs	r0, #1
 8008624:	f7fc ff10 	bl	8005448 <memp_malloc>
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 8008628:	4604      	mov	r4, r0
 800862a:	b128      	cbz	r0, 8008638 <udp_new+0x18>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 800862c:	2220      	movs	r2, #32
 800862e:	2100      	movs	r1, #0
 8008630:	f000 fc4e 	bl	8008ed0 <memset>
    pcb->ttl = UDP_TTL;
 8008634:	23ff      	movs	r3, #255	; 0xff
 8008636:	72a3      	strb	r3, [r4, #10]
  }
  return pcb;
}
 8008638:	4620      	mov	r0, r4
 800863a:	bd10      	pop	{r4, pc}

0800863c <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 800863c:	b510      	push	{r4, lr}
 800863e:	4604      	mov	r4, r0
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8008640:	eb00 0280 	add.w	r2, r0, r0, lsl #2
 8008644:	4b09      	ldr	r3, [pc, #36]	; (800866c <etharp_free_entry+0x30>)
 8008646:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 800864a:	b138      	cbz	r0, 800865c <etharp_free_entry+0x20>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 800864c:	f7fd f829 	bl	80056a2 <pbuf_free>
    arp_table[i].q = NULL;
 8008650:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 8008654:	009b      	lsls	r3, r3, #2
 8008656:	2100      	movs	r1, #0
 8008658:	4a04      	ldr	r2, [pc, #16]	; (800866c <etharp_free_entry+0x30>)
 800865a:	50d1      	str	r1, [r2, r3]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 800865c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8008660:	4b02      	ldr	r3, [pc, #8]	; (800866c <etharp_free_entry+0x30>)
 8008662:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8008666:	2300      	movs	r3, #0
 8008668:	74a3      	strb	r3, [r4, #18]
 800866a:	bd10      	pop	{r4, pc}
 800866c:	20007734 	.word	0x20007734

08008670 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
 8008670:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008674:	b083      	sub	sp, #12
 8008676:	4a3f      	ldr	r2, [pc, #252]	; (8008774 <etharp_find_entry+0x104>)
 8008678:	2300      	movs	r3, #0
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u8_t age_queue = 0;
 800867a:	4698      	mov	r8, r3
  s8_t old_queue = ARP_TABLE_SIZE;
 800867c:	f04f 0e0a 	mov.w	lr, #10
  u8_t i = 0, age_pending = 0, age_stable = 0;
 8008680:	469c      	mov	ip, r3
  s8_t empty = ARP_TABLE_SIZE;
 8008682:	4675      	mov	r5, lr
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8008684:	46f1      	mov	r9, lr
 8008686:	46f2      	mov	sl, lr
 8008688:	9301      	str	r3, [sp, #4]
 800868a:	e005      	b.n	8008698 <etharp_find_entry+0x28>
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800868c:	b957      	cbnz	r7, 80086a4 <etharp_find_entry+0x34>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 800868e:	b25d      	sxtb	r5, r3
 8008690:	3301      	adds	r3, #1
 8008692:	3214      	adds	r2, #20
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8008694:	2b0a      	cmp	r3, #10
 8008696:	d02e      	beq.n	80086f6 <etharp_find_entry+0x86>
 8008698:	4614      	mov	r4, r2
    u8_t state = arp_table[i].state;
 800869a:	7c97      	ldrb	r7, [r2, #18]
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800869c:	2d0a      	cmp	r5, #10
 800869e:	d0f5      	beq.n	800868c <etharp_find_entry+0x1c>
    } else if (state != ETHARP_STATE_EMPTY) {
 80086a0:	2f00      	cmp	r7, #0
 80086a2:	d0f5      	beq.n	8008690 <etharp_find_entry+0x20>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 80086a4:	b120      	cbz	r0, 80086b0 <etharp_find_entry+0x40>
 80086a6:	6806      	ldr	r6, [r0, #0]
 80086a8:	46b3      	mov	fp, r6
 80086aa:	6866      	ldr	r6, [r4, #4]
 80086ac:	45b3      	cmp	fp, r6
 80086ae:	d00f      	beq.n	80086d0 <etharp_find_entry+0x60>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 80086b0:	2f01      	cmp	r7, #1
 80086b2:	d00f      	beq.n	80086d4 <etharp_find_entry+0x64>
            old_pending = i;
            age_pending = arp_table[i].ctime;
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
 80086b4:	f1a7 0b02 	sub.w	fp, r7, #2
 80086b8:	fa5f fb8b 	uxtb.w	fp, fp
 80086bc:	f1bb 0f01 	cmp.w	fp, #1
 80086c0:	d8e6      	bhi.n	8008690 <etharp_find_entry+0x20>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 80086c2:	7ce4      	ldrb	r4, [r4, #19]
 80086c4:	4564      	cmp	r4, ip
            old_stable = i;
 80086c6:	bf24      	itt	cs
 80086c8:	fa4f f983 	sxtbcs.w	r9, r3
            age_stable = arp_table[i].ctime;
 80086cc:	46a4      	movcs	ip, r4
 80086ce:	e7df      	b.n	8008690 <etharp_find_entry+0x20>
        return i;
 80086d0:	b258      	sxtb	r0, r3
 80086d2:	e02a      	b.n	800872a <etharp_find_entry+0xba>
        if (arp_table[i].q != NULL) {
 80086d4:	6827      	ldr	r7, [r4, #0]
 80086d6:	b137      	cbz	r7, 80086e6 <etharp_find_entry+0x76>
          if (arp_table[i].ctime >= age_queue) {
 80086d8:	7ce4      	ldrb	r4, [r4, #19]
 80086da:	4544      	cmp	r4, r8
 80086dc:	d3d8      	bcc.n	8008690 <etharp_find_entry+0x20>
            old_queue = i;
 80086de:	fa4f fe83 	sxtb.w	lr, r3
            age_queue = arp_table[i].ctime;
 80086e2:	46a0      	mov	r8, r4
 80086e4:	e7d4      	b.n	8008690 <etharp_find_entry+0x20>
          if (arp_table[i].ctime >= age_pending) {
 80086e6:	7ce4      	ldrb	r4, [r4, #19]
 80086e8:	9e01      	ldr	r6, [sp, #4]
 80086ea:	42b4      	cmp	r4, r6
 80086ec:	d3d0      	bcc.n	8008690 <etharp_find_entry+0x20>
            old_pending = i;
 80086ee:	fa4f fa83 	sxtb.w	sl, r3
            age_pending = arp_table[i].ctime;
 80086f2:	9401      	str	r4, [sp, #4]
 80086f4:	e7cc      	b.n	8008690 <etharp_find_entry+0x20>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 80086f6:	f011 0f02 	tst.w	r1, #2
 80086fa:	d131      	bne.n	8008760 <etharp_find_entry+0xf0>
 80086fc:	4604      	mov	r4, r0
 80086fe:	2d0a      	cmp	r5, #10
 8008700:	d016      	beq.n	8008730 <etharp_find_entry+0xc0>
   * 
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 8008702:	2d09      	cmp	r5, #9
 8008704:	dc17      	bgt.n	8008736 <etharp_find_entry+0xc6>
    i = empty;
 8008706:	b2ed      	uxtb	r5, r5
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 8008708:	462b      	mov	r3, r5
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 800870a:	b134      	cbz	r4, 800871a <etharp_find_entry+0xaa>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
 800870c:	6820      	ldr	r0, [r4, #0]
 800870e:	eb05 0285 	add.w	r2, r5, r5, lsl #2
 8008712:	4918      	ldr	r1, [pc, #96]	; (8008774 <etharp_find_entry+0x104>)
 8008714:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8008718:	6050      	str	r0, [r2, #4]
  }
  arp_table[i].ctime = 0;
 800871a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800871e:	4a15      	ldr	r2, [pc, #84]	; (8008774 <etharp_find_entry+0x104>)
 8008720:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008724:	2200      	movs	r2, #0
 8008726:	74da      	strb	r2, [r3, #19]
  return (err_t)i;
 8008728:	b268      	sxtb	r0, r5
}
 800872a:	b003      	add	sp, #12
 800872c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 8008730:	f011 0f01 	tst.w	r1, #1
 8008734:	d017      	beq.n	8008766 <etharp_find_entry+0xf6>
    if (old_stable < ARP_TABLE_SIZE) {
 8008736:	f1b9 0f09 	cmp.w	r9, #9
 800873a:	dc05      	bgt.n	8008748 <etharp_find_entry+0xd8>
      i = old_stable;
 800873c:	fa5f f589 	uxtb.w	r5, r9
    etharp_free_entry(i);
 8008740:	4628      	mov	r0, r5
 8008742:	f7ff ff7b 	bl	800863c <etharp_free_entry>
 8008746:	e7df      	b.n	8008708 <etharp_find_entry+0x98>
    } else if (old_pending < ARP_TABLE_SIZE) {
 8008748:	f1ba 0f09 	cmp.w	sl, #9
 800874c:	dc02      	bgt.n	8008754 <etharp_find_entry+0xe4>
      i = old_pending;
 800874e:	fa5f f58a 	uxtb.w	r5, sl
 8008752:	e7f5      	b.n	8008740 <etharp_find_entry+0xd0>
    } else if (old_queue < ARP_TABLE_SIZE) {
 8008754:	f1be 0f09 	cmp.w	lr, #9
 8008758:	dc08      	bgt.n	800876c <etharp_find_entry+0xfc>
      i = old_queue;
 800875a:	fa5f f58e 	uxtb.w	r5, lr
 800875e:	e7ef      	b.n	8008740 <etharp_find_entry+0xd0>
    return (s8_t)ERR_MEM;
 8008760:	f04f 30ff 	mov.w	r0, #4294967295
 8008764:	e7e1      	b.n	800872a <etharp_find_entry+0xba>
 8008766:	f04f 30ff 	mov.w	r0, #4294967295
 800876a:	e7de      	b.n	800872a <etharp_find_entry+0xba>
      return (s8_t)ERR_MEM;
 800876c:	f04f 30ff 	mov.w	r0, #4294967295
 8008770:	e7db      	b.n	800872a <etharp_find_entry+0xba>
 8008772:	bf00      	nop
 8008774:	20007734 	.word	0x20007734

08008778 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
 8008778:	b538      	push	{r3, r4, r5, lr}
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 800877a:	684c      	ldr	r4, [r1, #4]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 800877c:	681d      	ldr	r5, [r3, #0]
 800877e:	6025      	str	r5, [r4, #0]
 8008780:	889b      	ldrh	r3, [r3, #4]
 8008782:	80a3      	strh	r3, [r4, #4]
  ETHADDR16_COPY(&ethhdr->src, src);
 8008784:	6813      	ldr	r3, [r2, #0]
 8008786:	f8c4 3006 	str.w	r3, [r4, #6]
 800878a:	8893      	ldrh	r3, [r2, #4]
 800878c:	8163      	strh	r3, [r4, #10]
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 800878e:	2308      	movs	r3, #8
 8008790:	7323      	strb	r3, [r4, #12]
 8008792:	2300      	movs	r3, #0
 8008794:	7363      	strb	r3, [r4, #13]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 8008796:	6983      	ldr	r3, [r0, #24]
 8008798:	4798      	blx	r3
}
 800879a:	bd38      	pop	{r3, r4, r5, pc}

0800879c <etharp_update_arp_entry>:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 800879c:	2900      	cmp	r1, #0
 800879e:	d045      	beq.n	800882c <etharp_update_arp_entry+0x90>
{
 80087a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80087a2:	4604      	mov	r4, r0
 80087a4:	460e      	mov	r6, r1
  if (ip_addr_isany(ipaddr) ||
 80087a6:	6808      	ldr	r0, [r1, #0]
 80087a8:	2800      	cmp	r0, #0
 80087aa:	d043      	beq.n	8008834 <etharp_update_arp_entry+0x98>
 80087ac:	461f      	mov	r7, r3
 80087ae:	4615      	mov	r5, r2
      ip_addr_isbroadcast(ipaddr, netif) ||
 80087b0:	4621      	mov	r1, r4
 80087b2:	f7fc f8f7 	bl	80049a4 <ip4_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
 80087b6:	2800      	cmp	r0, #0
 80087b8:	d13f      	bne.n	800883a <etharp_update_arp_entry+0x9e>
      ip_addr_ismulticast(ipaddr)) {
 80087ba:	6832      	ldr	r2, [r6, #0]
 80087bc:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
      ip_addr_isbroadcast(ipaddr, netif) ||
 80087c0:	2ae0      	cmp	r2, #224	; 0xe0
 80087c2:	d03d      	beq.n	8008840 <etharp_update_arp_entry+0xa4>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
 80087c4:	4639      	mov	r1, r7
 80087c6:	4630      	mov	r0, r6
 80087c8:	f7ff ff52 	bl	8008670 <etharp_find_entry>
  /* bail out if no entry could be found */
  if (i < 0) {
 80087cc:	1e01      	subs	r1, r0, #0
 80087ce:	db2b      	blt.n	8008828 <etharp_update_arp_entry+0x8c>
    return (err_t)i;
  }

#if ETHARP_SUPPORT_STATIC_ENTRIES
  if (flags & ETHARP_FLAG_STATIC_ENTRY) {
 80087d0:	f017 0f04 	tst.w	r7, #4
    /* record static type */
    arp_table[i].state = ETHARP_STATE_STATIC;
 80087d4:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 80087d8:	4a1c      	ldr	r2, [pc, #112]	; (800884c <etharp_update_arp_entry+0xb0>)
 80087da:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80087de:	bf14      	ite	ne
 80087e0:	2204      	movne	r2, #4
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 80087e2:	2202      	moveq	r2, #2
 80087e4:	749a      	strb	r2, [r3, #18]
  }

  /* record network interface */
  arp_table[i].netif = netif;
 80087e6:	4e19      	ldr	r6, [pc, #100]	; (800884c <etharp_update_arp_entry+0xb0>)
 80087e8:	008b      	lsls	r3, r1, #2
 80087ea:	185a      	adds	r2, r3, r1
 80087ec:	0092      	lsls	r2, r2, #2
 80087ee:	18b7      	adds	r7, r6, r2
 80087f0:	60bc      	str	r4, [r7, #8]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 80087f2:	4613      	mov	r3, r2
 80087f4:	330c      	adds	r3, #12
 80087f6:	eb06 0e03 	add.w	lr, r6, r3
 80087fa:	6828      	ldr	r0, [r5, #0]
 80087fc:	50f0      	str	r0, [r6, r3]
 80087fe:	88ab      	ldrh	r3, [r5, #4]
 8008800:	f8ae 3004 	strh.w	r3, [lr, #4]
  /* reset time stamp */
  arp_table[i].ctime = 0;
 8008804:	2300      	movs	r3, #0
 8008806:	74fb      	strb	r3, [r7, #19]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
 8008808:	58b6      	ldr	r6, [r6, r2]
 800880a:	b1e6      	cbz	r6, 8008846 <etharp_update_arp_entry+0xaa>
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
 800880c:	461f      	mov	r7, r3
 800880e:	4b0f      	ldr	r3, [pc, #60]	; (800884c <etharp_update_arp_entry+0xb0>)
 8008810:	509f      	str	r7, [r3, r2]
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
 8008812:	462b      	mov	r3, r5
 8008814:	f104 0223 	add.w	r2, r4, #35	; 0x23
 8008818:	4631      	mov	r1, r6
 800881a:	4620      	mov	r0, r4
 800881c:	f7ff ffac 	bl	8008778 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
 8008820:	4630      	mov	r0, r6
 8008822:	f7fc ff3e 	bl	80056a2 <pbuf_free>
  }
  return ERR_OK;
 8008826:	4639      	mov	r1, r7
}
 8008828:	4608      	mov	r0, r1
 800882a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return ERR_ARG;
 800882c:	f06f 010d 	mvn.w	r1, #13
}
 8008830:	4608      	mov	r0, r1
 8008832:	4770      	bx	lr
    return ERR_ARG;
 8008834:	f06f 010d 	mvn.w	r1, #13
 8008838:	e7f6      	b.n	8008828 <etharp_update_arp_entry+0x8c>
 800883a:	f06f 010d 	mvn.w	r1, #13
 800883e:	e7f3      	b.n	8008828 <etharp_update_arp_entry+0x8c>
 8008840:	f06f 010d 	mvn.w	r1, #13
 8008844:	e7f0      	b.n	8008828 <etharp_update_arp_entry+0x8c>
  return ERR_OK;
 8008846:	2100      	movs	r1, #0
 8008848:	e7ee      	b.n	8008828 <etharp_update_arp_entry+0x8c>
 800884a:	bf00      	nop
 800884c:	20007734 	.word	0x20007734

08008850 <etharp_tmr>:
{
 8008850:	b570      	push	{r4, r5, r6, lr}
 8008852:	4c0f      	ldr	r4, [pc, #60]	; (8008890 <etharp_tmr+0x40>)
 8008854:	2500      	movs	r5, #0
        arp_table[i].state = ETHARP_STATE_STABLE;
 8008856:	2602      	movs	r6, #2
 8008858:	e007      	b.n	800886a <etharp_tmr+0x1a>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 800885a:	2b01      	cmp	r3, #1
 800885c:	d901      	bls.n	8008862 <etharp_tmr+0x12>
        etharp_free_entry(i);
 800885e:	f7ff feed 	bl	800863c <etharp_free_entry>
 8008862:	3501      	adds	r5, #1
 8008864:	3414      	adds	r4, #20
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8008866:	2d0a      	cmp	r5, #10
 8008868:	d010      	beq.n	800888c <etharp_tmr+0x3c>
    u8_t state = arp_table[i].state;
 800886a:	4628      	mov	r0, r5
 800886c:	7ca2      	ldrb	r2, [r4, #18]
    if (state != ETHARP_STATE_EMPTY
 800886e:	f012 0ffb 	tst.w	r2, #251	; 0xfb
 8008872:	d0f6      	beq.n	8008862 <etharp_tmr+0x12>
      arp_table[i].ctime++;
 8008874:	7ce3      	ldrb	r3, [r4, #19]
 8008876:	3301      	adds	r3, #1
 8008878:	b2db      	uxtb	r3, r3
 800887a:	74e3      	strb	r3, [r4, #19]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 800887c:	2bef      	cmp	r3, #239	; 0xef
 800887e:	d8ee      	bhi.n	800885e <etharp_tmr+0xe>
 8008880:	2a01      	cmp	r2, #1
 8008882:	d0ea      	beq.n	800885a <etharp_tmr+0xa>
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
 8008884:	2a03      	cmp	r2, #3
        arp_table[i].state = ETHARP_STATE_STABLE;
 8008886:	bf08      	it	eq
 8008888:	74a6      	strbeq	r6, [r4, #18]
 800888a:	e7ea      	b.n	8008862 <etharp_tmr+0x12>
}
 800888c:	bd70      	pop	{r4, r5, r6, pc}
 800888e:	bf00      	nop
 8008890:	20007734 	.word	0x20007734

08008894 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
 8008894:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008898:	4605      	mov	r5, r0
 800889a:	4688      	mov	r8, r1
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 800889c:	f100 0623 	add.w	r6, r0, #35	; 0x23
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 80088a0:	2200      	movs	r2, #0
 80088a2:	212a      	movs	r1, #42	; 0x2a
 80088a4:	2003      	movs	r0, #3
 80088a6:	f7fc ff2b 	bl	8005700 <pbuf_alloc>
  if (p == NULL) {
 80088aa:	2800      	cmp	r0, #0
 80088ac:	d03c      	beq.n	8008928 <etharp_request+0x94>
 80088ae:	4607      	mov	r7, r0
  ethhdr = (struct eth_hdr *)p->payload;
 80088b0:	6844      	ldr	r4, [r0, #4]
  hdr->opcode = htons(opcode);
 80088b2:	2001      	movs	r0, #1
 80088b4:	f7fb fc7a 	bl	80041ac <lwip_htons>
 80088b8:	82a0      	strh	r0, [r4, #20]
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 80088ba:	6833      	ldr	r3, [r6, #0]
 80088bc:	f8c4 3016 	str.w	r3, [r4, #22]
 80088c0:	88b3      	ldrh	r3, [r6, #4]
 80088c2:	8363      	strh	r3, [r4, #26]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 80088c4:	4b1c      	ldr	r3, [pc, #112]	; (8008938 <etharp_request+0xa4>)
 80088c6:	6818      	ldr	r0, [r3, #0]
 80088c8:	6220      	str	r0, [r4, #32]
 80088ca:	889b      	ldrh	r3, [r3, #4]
 80088cc:	84a3      	strh	r3, [r4, #36]	; 0x24
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 80088ce:	4b1b      	ldr	r3, [pc, #108]	; (800893c <etharp_request+0xa8>)
 80088d0:	6818      	ldr	r0, [r3, #0]
 80088d2:	6020      	str	r0, [r4, #0]
 80088d4:	889b      	ldrh	r3, [r3, #4]
 80088d6:	80a3      	strh	r3, [r4, #4]
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
 80088d8:	6833      	ldr	r3, [r6, #0]
 80088da:	f8c4 3006 	str.w	r3, [r4, #6]
 80088de:	88b3      	ldrh	r3, [r6, #4]
 80088e0:	8163      	strh	r3, [r4, #10]
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 80088e2:	686b      	ldr	r3, [r5, #4]
 80088e4:	61e3      	str	r3, [r4, #28]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 80088e6:	f8d8 3000 	ldr.w	r3, [r8]
 80088ea:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 80088ee:	2200      	movs	r2, #0
 80088f0:	73a2      	strb	r2, [r4, #14]
 80088f2:	2301      	movs	r3, #1
 80088f4:	73e3      	strb	r3, [r4, #15]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 80088f6:	2308      	movs	r3, #8
 80088f8:	7423      	strb	r3, [r4, #16]
 80088fa:	7462      	strb	r2, [r4, #17]
  hdr->hwlen = ETHARP_HWADDR_LEN;
 80088fc:	2206      	movs	r2, #6
 80088fe:	74a2      	strb	r2, [r4, #18]
  hdr->protolen = sizeof(ip_addr_t);
 8008900:	2204      	movs	r2, #4
 8008902:	74e2      	strb	r2, [r4, #19]
  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 8008904:	7323      	strb	r3, [r4, #12]
 8008906:	2306      	movs	r3, #6
 8008908:	7363      	strb	r3, [r4, #13]
  result = netif->linkoutput(netif, p);
 800890a:	69ab      	ldr	r3, [r5, #24]
 800890c:	4639      	mov	r1, r7
 800890e:	4628      	mov	r0, r5
 8008910:	4798      	blx	r3
 8008912:	4604      	mov	r4, r0
  ETHARP_STATS_INC(etharp.xmit);
 8008914:	4a0a      	ldr	r2, [pc, #40]	; (8008940 <etharp_request+0xac>)
 8008916:	8b13      	ldrh	r3, [r2, #24]
 8008918:	3301      	adds	r3, #1
 800891a:	8313      	strh	r3, [r2, #24]
  pbuf_free(p);
 800891c:	4638      	mov	r0, r7
 800891e:	f7fc fec0 	bl	80056a2 <pbuf_free>
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
 8008922:	4620      	mov	r0, r4
 8008924:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ETHARP_STATS_INC(etharp.memerr);
 8008928:	4a05      	ldr	r2, [pc, #20]	; (8008940 <etharp_request+0xac>)
 800892a:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 800892c:	3301      	adds	r3, #1
 800892e:	8493      	strh	r3, [r2, #36]	; 0x24
    return ERR_MEM;
 8008930:	f04f 34ff 	mov.w	r4, #4294967295
 8008934:	e7f5      	b.n	8008922 <etharp_request+0x8e>
 8008936:	bf00      	nop
 8008938:	0800905c 	.word	0x0800905c
 800893c:	08009054 	.word	0x08009054
 8008940:	2000b084 	.word	0x2000b084

08008944 <etharp_output_to_arp_index>:
{
 8008944:	b570      	push	{r4, r5, r6, lr}
 8008946:	4605      	mov	r5, r0
 8008948:	460e      	mov	r6, r1
 800894a:	4614      	mov	r4, r2
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 800894c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8008950:	4b15      	ldr	r3, [pc, #84]	; (80089a8 <etharp_output_to_arp_index+0x64>)
 8008952:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 8008956:	7c9b      	ldrb	r3, [r3, #18]
 8008958:	2b02      	cmp	r3, #2
 800895a:	d00c      	beq.n	8008976 <etharp_output_to_arp_index+0x32>
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 800895c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8008960:	4b11      	ldr	r3, [pc, #68]	; (80089a8 <etharp_output_to_arp_index+0x64>)
 8008962:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8008966:	330c      	adds	r3, #12
 8008968:	f105 0223 	add.w	r2, r5, #35	; 0x23
 800896c:	4631      	mov	r1, r6
 800896e:	4628      	mov	r0, r5
 8008970:	f7ff ff02 	bl	8008778 <etharp_send_ip>
}
 8008974:	bd70      	pop	{r4, r5, r6, pc}
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
 8008976:	4613      	mov	r3, r2
 8008978:	4a0b      	ldr	r2, [pc, #44]	; (80089a8 <etharp_output_to_arp_index+0x64>)
 800897a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 800897e:	7cdb      	ldrb	r3, [r3, #19]
 8008980:	2be3      	cmp	r3, #227	; 0xe3
 8008982:	d9eb      	bls.n	800895c <etharp_output_to_arp_index+0x18>
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 8008984:	eb04 0184 	add.w	r1, r4, r4, lsl #2
 8008988:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 800898c:	3104      	adds	r1, #4
 800898e:	f7ff ff81 	bl	8008894 <etharp_request>
 8008992:	2800      	cmp	r0, #0
 8008994:	d1e2      	bne.n	800895c <etharp_output_to_arp_index+0x18>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
 8008996:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 800899a:	4a03      	ldr	r2, [pc, #12]	; (80089a8 <etharp_output_to_arp_index+0x64>)
 800899c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80089a0:	2203      	movs	r2, #3
 80089a2:	749a      	strb	r2, [r3, #18]
 80089a4:	e7da      	b.n	800895c <etharp_output_to_arp_index+0x18>
 80089a6:	bf00      	nop
 80089a8:	20007734 	.word	0x20007734

080089ac <etharp_query>:
{
 80089ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80089b0:	4606      	mov	r6, r0
 80089b2:	460d      	mov	r5, r1
 80089b4:	4617      	mov	r7, r2
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 80089b6:	4601      	mov	r1, r0
 80089b8:	6828      	ldr	r0, [r5, #0]
 80089ba:	f7fb fff3 	bl	80049a4 <ip4_addr_isbroadcast>
 80089be:	2800      	cmp	r0, #0
 80089c0:	d16c      	bne.n	8008a9c <etharp_query+0xf0>
      ip_addr_ismulticast(ipaddr) ||
 80089c2:	682b      	ldr	r3, [r5, #0]
 80089c4:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 80089c8:	2ae0      	cmp	r2, #224	; 0xe0
 80089ca:	d06a      	beq.n	8008aa2 <etharp_query+0xf6>
      ip_addr_ismulticast(ipaddr) ||
 80089cc:	2d00      	cmp	r5, #0
 80089ce:	d06b      	beq.n	8008aa8 <etharp_query+0xfc>
      ip_addr_isany(ipaddr)) {
 80089d0:	2b00      	cmp	r3, #0
 80089d2:	d06c      	beq.n	8008aae <etharp_query+0x102>
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
 80089d4:	2101      	movs	r1, #1
 80089d6:	4628      	mov	r0, r5
 80089d8:	f7ff fe4a 	bl	8008670 <etharp_find_entry>
  if (i < 0) {
 80089dc:	1e04      	subs	r4, r0, #0
 80089de:	db36      	blt.n	8008a4e <etharp_query+0xa2>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 80089e0:	46a0      	mov	r8, r4
 80089e2:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 80089e6:	4a44      	ldr	r2, [pc, #272]	; (8008af8 <etharp_query+0x14c>)
 80089e8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80089ec:	7c9b      	ldrb	r3, [r3, #18]
 80089ee:	2b00      	cmp	r3, #0
 80089f0:	d133      	bne.n	8008a5a <etharp_query+0xae>
    arp_table[i].state = ETHARP_STATE_PENDING;
 80089f2:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 80089f6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80089fa:	2201      	movs	r2, #1
 80089fc:	749a      	strb	r2, [r3, #18]
    result = etharp_request(netif, ipaddr);
 80089fe:	4629      	mov	r1, r5
 8008a00:	4630      	mov	r0, r6
 8008a02:	f7ff ff47 	bl	8008894 <etharp_request>
    if (q == NULL) {
 8008a06:	2f00      	cmp	r7, #0
 8008a08:	d054      	beq.n	8008ab4 <etharp_query+0x108>
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 8008a0a:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 8008a0e:	4a3a      	ldr	r2, [pc, #232]	; (8008af8 <etharp_query+0x14c>)
 8008a10:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008a14:	7c9b      	ldrb	r3, [r3, #18]
 8008a16:	2b01      	cmp	r3, #1
 8008a18:	d824      	bhi.n	8008a64 <etharp_query+0xb8>
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 8008a1a:	2b01      	cmp	r3, #1
 8008a1c:	d14c      	bne.n	8008ab8 <etharp_query+0x10c>
      if(p->type != PBUF_ROM) {
 8008a1e:	7b3b      	ldrb	r3, [r7, #12]
 8008a20:	2b01      	cmp	r3, #1
 8008a22:	d154      	bne.n	8008ace <etharp_query+0x122>
 8008a24:	463b      	mov	r3, r7
      p = p->next;
 8008a26:	681b      	ldr	r3, [r3, #0]
    while (p) {
 8008a28:	2b00      	cmp	r3, #0
 8008a2a:	d052      	beq.n	8008ad2 <etharp_query+0x126>
      if(p->type != PBUF_ROM) {
 8008a2c:	7b1a      	ldrb	r2, [r3, #12]
 8008a2e:	2a01      	cmp	r2, #1
 8008a30:	d0f9      	beq.n	8008a26 <etharp_query+0x7a>
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 8008a32:	2200      	movs	r2, #0
 8008a34:	8919      	ldrh	r1, [r3, #8]
 8008a36:	2003      	movs	r0, #3
 8008a38:	f7fc fe62 	bl	8005700 <pbuf_alloc>
      if(p != NULL) {
 8008a3c:	4604      	mov	r4, r0
 8008a3e:	b330      	cbz	r0, 8008a8e <etharp_query+0xe2>
        if (pbuf_copy(p, q) != ERR_OK) {
 8008a40:	4639      	mov	r1, r7
 8008a42:	4620      	mov	r0, r4
 8008a44:	f7fc ff50 	bl	80058e8 <pbuf_copy>
 8008a48:	b9f0      	cbnz	r0, 8008a88 <etharp_query+0xdc>
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 8008a4a:	4627      	mov	r7, r4
 8008a4c:	e044      	b.n	8008ad8 <etharp_query+0x12c>
    if (q) {
 8008a4e:	b1c7      	cbz	r7, 8008a82 <etharp_query+0xd6>
      ETHARP_STATS_INC(etharp.memerr);
 8008a50:	4a2a      	ldr	r2, [pc, #168]	; (8008afc <etharp_query+0x150>)
 8008a52:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8008a54:	3301      	adds	r3, #1
 8008a56:	8493      	strh	r3, [r2, #36]	; 0x24
 8008a58:	e013      	b.n	8008a82 <etharp_query+0xd6>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 8008a5a:	2b01      	cmp	r3, #1
 8008a5c:	d0cf      	beq.n	80089fe <etharp_query+0x52>
 8008a5e:	b36f      	cbz	r7, 8008abc <etharp_query+0x110>
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 8008a60:	2b01      	cmp	r3, #1
 8008a62:	d931      	bls.n	8008ac8 <etharp_query+0x11c>
    ETHARP_SET_HINT(netif, i);
 8008a64:	4b26      	ldr	r3, [pc, #152]	; (8008b00 <etharp_query+0x154>)
 8008a66:	701c      	strb	r4, [r3, #0]
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 8008a68:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8008a6c:	4b22      	ldr	r3, [pc, #136]	; (8008af8 <etharp_query+0x14c>)
 8008a6e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8008a72:	330c      	adds	r3, #12
 8008a74:	f106 0223 	add.w	r2, r6, #35	; 0x23
 8008a78:	4639      	mov	r1, r7
 8008a7a:	4630      	mov	r0, r6
 8008a7c:	f7ff fe7c 	bl	8008778 <etharp_send_ip>
 8008a80:	4604      	mov	r4, r0
}
 8008a82:	4620      	mov	r0, r4
 8008a84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          pbuf_free(p);
 8008a88:	4620      	mov	r0, r4
 8008a8a:	f7fc fe0a 	bl	80056a2 <pbuf_free>
      ETHARP_STATS_INC(etharp.memerr);
 8008a8e:	4a1b      	ldr	r2, [pc, #108]	; (8008afc <etharp_query+0x150>)
 8008a90:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8008a92:	3301      	adds	r3, #1
 8008a94:	8493      	strh	r3, [r2, #36]	; 0x24
      result = ERR_MEM;
 8008a96:	f04f 34ff 	mov.w	r4, #4294967295
 8008a9a:	e7f2      	b.n	8008a82 <etharp_query+0xd6>
    return ERR_ARG;
 8008a9c:	f06f 040d 	mvn.w	r4, #13
 8008aa0:	e7ef      	b.n	8008a82 <etharp_query+0xd6>
 8008aa2:	f06f 040d 	mvn.w	r4, #13
 8008aa6:	e7ec      	b.n	8008a82 <etharp_query+0xd6>
 8008aa8:	f06f 040d 	mvn.w	r4, #13
 8008aac:	e7e9      	b.n	8008a82 <etharp_query+0xd6>
 8008aae:	f06f 040d 	mvn.w	r4, #13
 8008ab2:	e7e6      	b.n	8008a82 <etharp_query+0xd6>
    result = etharp_request(netif, ipaddr);
 8008ab4:	4604      	mov	r4, r0
 8008ab6:	e7e4      	b.n	8008a82 <etharp_query+0xd6>
 8008ab8:	4604      	mov	r4, r0
 8008aba:	e7e2      	b.n	8008a82 <etharp_query+0xd6>
 8008abc:	4629      	mov	r1, r5
 8008abe:	4630      	mov	r0, r6
 8008ac0:	f7ff fee8 	bl	8008894 <etharp_request>
 8008ac4:	4604      	mov	r4, r0
 8008ac6:	e7dc      	b.n	8008a82 <etharp_query+0xd6>
  err_t result = ERR_MEM;
 8008ac8:	f04f 34ff 	mov.w	r4, #4294967295
 8008acc:	e7d9      	b.n	8008a82 <etharp_query+0xd6>
      if(p->type != PBUF_ROM) {
 8008ace:	463b      	mov	r3, r7
 8008ad0:	e7af      	b.n	8008a32 <etharp_query+0x86>
      pbuf_ref(p);
 8008ad2:	4638      	mov	r0, r7
 8008ad4:	f7fc fee2 	bl	800589c <pbuf_ref>
      if (arp_table[i].q != NULL) {
 8008ad8:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 8008adc:	4a06      	ldr	r2, [pc, #24]	; (8008af8 <etharp_query+0x14c>)
 8008ade:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8008ae2:	b108      	cbz	r0, 8008ae8 <etharp_query+0x13c>
        pbuf_free(arp_table[i].q);
 8008ae4:	f7fc fddd 	bl	80056a2 <pbuf_free>
      arp_table[i].q = p;
 8008ae8:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 8008aec:	4b02      	ldr	r3, [pc, #8]	; (8008af8 <etharp_query+0x14c>)
 8008aee:	f843 7028 	str.w	r7, [r3, r8, lsl #2]
      result = ERR_OK;
 8008af2:	2400      	movs	r4, #0
 8008af4:	e7c5      	b.n	8008a82 <etharp_query+0xd6>
 8008af6:	bf00      	nop
 8008af8:	20007734 	.word	0x20007734
 8008afc:	2000b084 	.word	0x2000b084
 8008b00:	200077fc 	.word	0x200077fc

08008b04 <etharp_output>:
{
 8008b04:	b570      	push	{r4, r5, r6, lr}
 8008b06:	b082      	sub	sp, #8
 8008b08:	4605      	mov	r5, r0
 8008b0a:	460e      	mov	r6, r1
 8008b0c:	4614      	mov	r4, r2
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 8008b0e:	210e      	movs	r1, #14
 8008b10:	4630      	mov	r0, r6
 8008b12:	f7fc fd88 	bl	8005626 <pbuf_header>
 8008b16:	2800      	cmp	r0, #0
 8008b18:	d12f      	bne.n	8008b7a <etharp_output+0x76>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
 8008b1a:	4629      	mov	r1, r5
 8008b1c:	6820      	ldr	r0, [r4, #0]
 8008b1e:	f7fb ff41 	bl	80049a4 <ip4_addr_isbroadcast>
 8008b22:	2800      	cmp	r0, #0
 8008b24:	d168      	bne.n	8008bf8 <etharp_output+0xf4>
  } else if (ip_addr_ismulticast(ipaddr)) {
 8008b26:	6823      	ldr	r3, [r4, #0]
 8008b28:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8008b2c:	2ae0      	cmp	r2, #224	; 0xe0
 8008b2e:	d02b      	beq.n	8008b88 <etharp_output+0x84>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 8008b30:	686a      	ldr	r2, [r5, #4]
 8008b32:	405a      	eors	r2, r3
 8008b34:	68a9      	ldr	r1, [r5, #8]
 8008b36:	420a      	tst	r2, r1
 8008b38:	d00a      	beq.n	8008b50 <etharp_output+0x4c>
        !ip_addr_islinklocal(ipaddr)) {
 8008b3a:	b29b      	uxth	r3, r3
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 8008b3c:	f64f 62a9 	movw	r2, #65193	; 0xfea9
 8008b40:	4293      	cmp	r3, r2
 8008b42:	d005      	beq.n	8008b50 <etharp_output+0x4c>
        if (!ip_addr_isany(&netif->gw)) {
 8008b44:	f115 040c 	adds.w	r4, r5, #12
 8008b48:	d05f      	beq.n	8008c0a <etharp_output+0x106>
 8008b4a:	68eb      	ldr	r3, [r5, #12]
 8008b4c:	2b00      	cmp	r3, #0
 8008b4e:	d05f      	beq.n	8008c10 <etharp_output+0x10c>
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 8008b50:	4b31      	ldr	r3, [pc, #196]	; (8008c18 <etharp_output+0x114>)
 8008b52:	781a      	ldrb	r2, [r3, #0]
 8008b54:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 8008b58:	4b30      	ldr	r3, [pc, #192]	; (8008c1c <etharp_output+0x118>)
 8008b5a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8008b5e:	7c9b      	ldrb	r3, [r3, #18]
 8008b60:	2b01      	cmp	r3, #1
 8008b62:	d907      	bls.n	8008b74 <etharp_output+0x70>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 8008b64:	460b      	mov	r3, r1
 8008b66:	492d      	ldr	r1, [pc, #180]	; (8008c1c <etharp_output+0x118>)
 8008b68:	eb01 0383 	add.w	r3, r1, r3, lsl #2
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 8008b6c:	6821      	ldr	r1, [r4, #0]
 8008b6e:	685b      	ldr	r3, [r3, #4]
 8008b70:	4299      	cmp	r1, r3
 8008b72:	d01f      	beq.n	8008bb4 <etharp_output+0xb0>
 8008b74:	4b29      	ldr	r3, [pc, #164]	; (8008c1c <etharp_output+0x118>)
{
 8008b76:	2200      	movs	r2, #0
 8008b78:	e029      	b.n	8008bce <etharp_output+0xca>
    LINK_STATS_INC(link.lenerr);
 8008b7a:	4a29      	ldr	r2, [pc, #164]	; (8008c20 <etharp_output+0x11c>)
 8008b7c:	8953      	ldrh	r3, [r2, #10]
 8008b7e:	3301      	adds	r3, #1
 8008b80:	8153      	strh	r3, [r2, #10]
    return ERR_BUF;
 8008b82:	f06f 0001 	mvn.w	r0, #1
 8008b86:	e03e      	b.n	8008c06 <etharp_output+0x102>
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 8008b88:	2301      	movs	r3, #1
 8008b8a:	f88d 3000 	strb.w	r3, [sp]
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
 8008b8e:	2300      	movs	r3, #0
 8008b90:	f88d 3001 	strb.w	r3, [sp, #1]
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 8008b94:	235e      	movs	r3, #94	; 0x5e
 8008b96:	f88d 3002 	strb.w	r3, [sp, #2]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 8008b9a:	7863      	ldrb	r3, [r4, #1]
 8008b9c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8008ba0:	f88d 3003 	strb.w	r3, [sp, #3]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 8008ba4:	78a3      	ldrb	r3, [r4, #2]
 8008ba6:	f88d 3004 	strb.w	r3, [sp, #4]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 8008baa:	78e3      	ldrb	r3, [r4, #3]
 8008bac:	f88d 3005 	strb.w	r3, [sp, #5]
    dest = &mcastaddr;
 8008bb0:	466b      	mov	r3, sp
 8008bb2:	e022      	b.n	8008bfa <etharp_output+0xf6>
          ETHARP_STATS_INC(etharp.cachehit);
 8008bb4:	491a      	ldr	r1, [pc, #104]	; (8008c20 <etharp_output+0x11c>)
 8008bb6:	8dcb      	ldrh	r3, [r1, #46]	; 0x2e
 8008bb8:	3301      	adds	r3, #1
 8008bba:	85cb      	strh	r3, [r1, #46]	; 0x2e
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 8008bbc:	4631      	mov	r1, r6
 8008bbe:	4628      	mov	r0, r5
 8008bc0:	f7ff fec0 	bl	8008944 <etharp_output_to_arp_index>
 8008bc4:	e01f      	b.n	8008c06 <etharp_output+0x102>
 8008bc6:	3201      	adds	r2, #1
 8008bc8:	3314      	adds	r3, #20
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 8008bca:	2a0a      	cmp	r2, #10
 8008bcc:	d00e      	beq.n	8008bec <etharp_output+0xe8>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 8008bce:	7c99      	ldrb	r1, [r3, #18]
 8008bd0:	2901      	cmp	r1, #1
 8008bd2:	d9f8      	bls.n	8008bc6 <etharp_output+0xc2>
 8008bd4:	6820      	ldr	r0, [r4, #0]
 8008bd6:	6859      	ldr	r1, [r3, #4]
 8008bd8:	4288      	cmp	r0, r1
 8008bda:	d1f4      	bne.n	8008bc6 <etharp_output+0xc2>
        ETHARP_SET_HINT(netif, i);
 8008bdc:	b2d2      	uxtb	r2, r2
 8008bde:	4b0e      	ldr	r3, [pc, #56]	; (8008c18 <etharp_output+0x114>)
 8008be0:	701a      	strb	r2, [r3, #0]
        return etharp_output_to_arp_index(netif, q, i);
 8008be2:	4631      	mov	r1, r6
 8008be4:	4628      	mov	r0, r5
 8008be6:	f7ff fead 	bl	8008944 <etharp_output_to_arp_index>
 8008bea:	e00c      	b.n	8008c06 <etharp_output+0x102>
    return etharp_query(netif, dst_addr, q);
 8008bec:	4632      	mov	r2, r6
 8008bee:	4621      	mov	r1, r4
 8008bf0:	4628      	mov	r0, r5
 8008bf2:	f7ff fedb 	bl	80089ac <etharp_query>
 8008bf6:	e006      	b.n	8008c06 <etharp_output+0x102>
    dest = (struct eth_addr *)&ethbroadcast;
 8008bf8:	4b0a      	ldr	r3, [pc, #40]	; (8008c24 <etharp_output+0x120>)
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
 8008bfa:	f105 0223 	add.w	r2, r5, #35	; 0x23
 8008bfe:	4631      	mov	r1, r6
 8008c00:	4628      	mov	r0, r5
 8008c02:	f7ff fdb9 	bl	8008778 <etharp_send_ip>
}
 8008c06:	b002      	add	sp, #8
 8008c08:	bd70      	pop	{r4, r5, r6, pc}
          return ERR_RTE;
 8008c0a:	f06f 0003 	mvn.w	r0, #3
 8008c0e:	e7fa      	b.n	8008c06 <etharp_output+0x102>
 8008c10:	f06f 0003 	mvn.w	r0, #3
 8008c14:	e7f7      	b.n	8008c06 <etharp_output+0x102>
 8008c16:	bf00      	nop
 8008c18:	200077fc 	.word	0x200077fc
 8008c1c:	20007734 	.word	0x20007734
 8008c20:	2000b084 	.word	0x2000b084
 8008c24:	08009054 	.word	0x08009054

08008c28 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 8008c28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008c2c:	b082      	sub	sp, #8
 8008c2e:	4604      	mov	r4, r0
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 8008c30:	8945      	ldrh	r5, [r0, #10]
 8008c32:	2d0e      	cmp	r5, #14
 8008c34:	d80d      	bhi.n	8008c52 <ethernet_input+0x2a>
    /* a packet with only an ethernet header (or less) is not valid for us */
    ETHARP_STATS_INC(etharp.proterr);
 8008c36:	4b70      	ldr	r3, [pc, #448]	; (8008df8 <ethernet_input+0x1d0>)
 8008c38:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8008c3a:	3201      	adds	r2, #1
 8008c3c:	851a      	strh	r2, [r3, #40]	; 0x28
    ETHARP_STATS_INC(etharp.drop);
 8008c3e:	8bda      	ldrh	r2, [r3, #30]
 8008c40:	3201      	adds	r2, #1
 8008c42:	83da      	strh	r2, [r3, #30]
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 8008c44:	4620      	mov	r0, r4
 8008c46:	f7fc fd2c 	bl	80056a2 <pbuf_free>
  return ERR_OK;
}
 8008c4a:	2000      	movs	r0, #0
 8008c4c:	b002      	add	sp, #8
 8008c4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008c52:	460f      	mov	r7, r1
  ethhdr = (struct eth_hdr *)p->payload;
 8008c54:	6846      	ldr	r6, [r0, #4]
  type = ethhdr->type;
 8008c56:	f8b6 800c 	ldrh.w	r8, [r6, #12]
  if (ethhdr->dest.addr[0] & 1) {
 8008c5a:	7833      	ldrb	r3, [r6, #0]
 8008c5c:	f013 0f01 	tst.w	r3, #1
 8008c60:	d00b      	beq.n	8008c7a <ethernet_input+0x52>
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
 8008c62:	2b01      	cmp	r3, #1
 8008c64:	d017      	beq.n	8008c96 <ethernet_input+0x6e>
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 8008c66:	2206      	movs	r2, #6
 8008c68:	4964      	ldr	r1, [pc, #400]	; (8008dfc <ethernet_input+0x1d4>)
 8008c6a:	4630      	mov	r0, r6
 8008c6c:	f000 f916 	bl	8008e9c <memcmp>
 8008c70:	b918      	cbnz	r0, 8008c7a <ethernet_input+0x52>
      p->flags |= PBUF_FLAG_LLBCAST;
 8008c72:	7b63      	ldrb	r3, [r4, #13]
 8008c74:	f043 0308 	orr.w	r3, r3, #8
 8008c78:	7363      	strb	r3, [r4, #13]
  switch (type) {
 8008c7a:	f1b8 0f08 	cmp.w	r8, #8
 8008c7e:	d015      	beq.n	8008cac <ethernet_input+0x84>
 8008c80:	f5b8 6fc1 	cmp.w	r8, #1544	; 0x608
 8008c84:	d023      	beq.n	8008cce <ethernet_input+0xa6>
      ETHARP_STATS_INC(etharp.proterr);
 8008c86:	4b5c      	ldr	r3, [pc, #368]	; (8008df8 <ethernet_input+0x1d0>)
 8008c88:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8008c8a:	3201      	adds	r2, #1
 8008c8c:	851a      	strh	r2, [r3, #40]	; 0x28
      ETHARP_STATS_INC(etharp.drop);
 8008c8e:	8bda      	ldrh	r2, [r3, #30]
 8008c90:	3201      	adds	r2, #1
 8008c92:	83da      	strh	r2, [r3, #30]
      goto free_and_return;
 8008c94:	e7d6      	b.n	8008c44 <ethernet_input+0x1c>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 8008c96:	7873      	ldrb	r3, [r6, #1]
 8008c98:	2b00      	cmp	r3, #0
 8008c9a:	d1ee      	bne.n	8008c7a <ethernet_input+0x52>
 8008c9c:	78b3      	ldrb	r3, [r6, #2]
 8008c9e:	2b5e      	cmp	r3, #94	; 0x5e
 8008ca0:	d1eb      	bne.n	8008c7a <ethernet_input+0x52>
        p->flags |= PBUF_FLAG_LLMCAST;
 8008ca2:	7b43      	ldrb	r3, [r0, #13]
 8008ca4:	f043 0310 	orr.w	r3, r3, #16
 8008ca8:	7343      	strb	r3, [r0, #13]
 8008caa:	e7e6      	b.n	8008c7a <ethernet_input+0x52>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 8008cac:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8008cb0:	f013 0f20 	tst.w	r3, #32
 8008cb4:	d0c6      	beq.n	8008c44 <ethernet_input+0x1c>
      if(pbuf_header(p, -ip_hdr_offset)) {
 8008cb6:	f06f 010d 	mvn.w	r1, #13
 8008cba:	4620      	mov	r0, r4
 8008cbc:	f7fc fcb3 	bl	8005626 <pbuf_header>
 8008cc0:	2800      	cmp	r0, #0
 8008cc2:	d1bf      	bne.n	8008c44 <ethernet_input+0x1c>
        ip_input(p, netif);
 8008cc4:	4639      	mov	r1, r7
 8008cc6:	4620      	mov	r0, r4
 8008cc8:	f7fb fcaa 	bl	8004620 <ip_input>
      break;
 8008ccc:	e7bd      	b.n	8008c4a <ethernet_input+0x22>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 8008cce:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8008cd2:	f013 0f20 	tst.w	r3, #32
 8008cd6:	d0b5      	beq.n	8008c44 <ethernet_input+0x1c>
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 8008cd8:	2f00      	cmp	r7, #0
 8008cda:	d0b6      	beq.n	8008c4a <ethernet_input+0x22>
  if (p->len < SIZEOF_ETHARP_PACKET) {
 8008cdc:	2d29      	cmp	r5, #41	; 0x29
 8008cde:	d90e      	bls.n	8008cfe <ethernet_input+0xd6>
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 8008ce0:	89f3      	ldrh	r3, [r6, #14]
 8008ce2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008ce6:	d015      	beq.n	8008d14 <ethernet_input+0xec>
    ETHARP_STATS_INC(etharp.proterr);
 8008ce8:	4b43      	ldr	r3, [pc, #268]	; (8008df8 <ethernet_input+0x1d0>)
 8008cea:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8008cec:	3201      	adds	r2, #1
 8008cee:	851a      	strh	r2, [r3, #40]	; 0x28
    ETHARP_STATS_INC(etharp.drop);
 8008cf0:	8bda      	ldrh	r2, [r3, #30]
 8008cf2:	3201      	adds	r2, #1
 8008cf4:	83da      	strh	r2, [r3, #30]
    pbuf_free(p);
 8008cf6:	4620      	mov	r0, r4
 8008cf8:	f7fc fcd3 	bl	80056a2 <pbuf_free>
 8008cfc:	e7a5      	b.n	8008c4a <ethernet_input+0x22>
    ETHARP_STATS_INC(etharp.lenerr);
 8008cfe:	4b3e      	ldr	r3, [pc, #248]	; (8008df8 <ethernet_input+0x1d0>)
 8008d00:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 8008d02:	3201      	adds	r2, #1
 8008d04:	845a      	strh	r2, [r3, #34]	; 0x22
    ETHARP_STATS_INC(etharp.drop);
 8008d06:	8bda      	ldrh	r2, [r3, #30]
 8008d08:	3201      	adds	r2, #1
 8008d0a:	83da      	strh	r2, [r3, #30]
    pbuf_free(p);
 8008d0c:	4620      	mov	r0, r4
 8008d0e:	f7fc fcc8 	bl	80056a2 <pbuf_free>
 8008d12:	e79a      	b.n	8008c4a <ethernet_input+0x22>
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 8008d14:	7cb3      	ldrb	r3, [r6, #18]
 8008d16:	2b06      	cmp	r3, #6
 8008d18:	d1e6      	bne.n	8008ce8 <ethernet_input+0xc0>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 8008d1a:	7cf3      	ldrb	r3, [r6, #19]
 8008d1c:	2b04      	cmp	r3, #4
 8008d1e:	d1e3      	bne.n	8008ce8 <ethernet_input+0xc0>
      (hdr->protolen != sizeof(ip_addr_t)) ||
 8008d20:	8a33      	ldrh	r3, [r6, #16]
 8008d22:	2b08      	cmp	r3, #8
 8008d24:	d1e0      	bne.n	8008ce8 <ethernet_input+0xc0>
  ETHARP_STATS_INC(etharp.recv);
 8008d26:	4a34      	ldr	r2, [pc, #208]	; (8008df8 <ethernet_input+0x1d0>)
 8008d28:	8b53      	ldrh	r3, [r2, #26]
 8008d2a:	3301      	adds	r3, #1
 8008d2c:	8353      	strh	r3, [r2, #26]
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 8008d2e:	69f3      	ldr	r3, [r6, #28]
 8008d30:	9301      	str	r3, [sp, #4]
  if (ip_addr_isany(&netif->ip_addr)) {
 8008d32:	f117 0f04 	cmn.w	r7, #4
 8008d36:	d03a      	beq.n	8008dae <ethernet_input+0x186>
 8008d38:	687b      	ldr	r3, [r7, #4]
 8008d3a:	b3c3      	cbz	r3, 8008dae <ethernet_input+0x186>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008d3c:	f106 0516 	add.w	r5, r6, #22
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 8008d40:	f8d6 2026 	ldr.w	r2, [r6, #38]	; 0x26
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008d44:	429a      	cmp	r2, r3
 8008d46:	d148      	bne.n	8008dda <ethernet_input+0x1b2>
 8008d48:	2301      	movs	r3, #1
 8008d4a:	462a      	mov	r2, r5
 8008d4c:	a901      	add	r1, sp, #4
 8008d4e:	4638      	mov	r0, r7
 8008d50:	f7ff fd24 	bl	800879c <etharp_update_arp_entry>
  switch (hdr->opcode) {
 8008d54:	8ab3      	ldrh	r3, [r6, #20]
 8008d56:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008d5a:	d003      	beq.n	8008d64 <ethernet_input+0x13c>
 8008d5c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008d60:	d037      	beq.n	8008dd2 <ethernet_input+0x1aa>
 8008d62:	e032      	b.n	8008dca <ethernet_input+0x1a2>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
 8008d64:	46b8      	mov	r8, r7
      hdr->opcode = htons(ARP_REPLY);
 8008d66:	2002      	movs	r0, #2
 8008d68:	f7fb fa20 	bl	80041ac <lwip_htons>
 8008d6c:	82b0      	strh	r0, [r6, #20]
      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 8008d6e:	69f3      	ldr	r3, [r6, #28]
 8008d70:	f8c6 3026 	str.w	r3, [r6, #38]	; 0x26
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
 8008d74:	687b      	ldr	r3, [r7, #4]
 8008d76:	61f3      	str	r3, [r6, #28]
      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
 8008d78:	682b      	ldr	r3, [r5, #0]
 8008d7a:	6233      	str	r3, [r6, #32]
 8008d7c:	88ab      	ldrh	r3, [r5, #4]
 8008d7e:	84b3      	strh	r3, [r6, #36]	; 0x24
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
 8008d80:	682b      	ldr	r3, [r5, #0]
 8008d82:	6033      	str	r3, [r6, #0]
 8008d84:	88ab      	ldrh	r3, [r5, #4]
 8008d86:	80b3      	strh	r3, [r6, #4]
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
 8008d88:	f858 3f23 	ldr.w	r3, [r8, #35]!
 8008d8c:	f8c6 3016 	str.w	r3, [r6, #22]
 8008d90:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8008d94:	80ab      	strh	r3, [r5, #4]
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
 8008d96:	f8d8 3000 	ldr.w	r3, [r8]
 8008d9a:	f8c6 3006 	str.w	r3, [r6, #6]
 8008d9e:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8008da2:	8173      	strh	r3, [r6, #10]
      netif->linkoutput(netif, p);
 8008da4:	69bb      	ldr	r3, [r7, #24]
 8008da6:	4621      	mov	r1, r4
 8008da8:	4638      	mov	r0, r7
 8008daa:	4798      	blx	r3
 8008dac:	e011      	b.n	8008dd2 <ethernet_input+0x1aa>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008dae:	2302      	movs	r3, #2
 8008db0:	f106 0216 	add.w	r2, r6, #22
 8008db4:	a901      	add	r1, sp, #4
 8008db6:	4638      	mov	r0, r7
 8008db8:	f7ff fcf0 	bl	800879c <etharp_update_arp_entry>
  switch (hdr->opcode) {
 8008dbc:	8ab3      	ldrh	r3, [r6, #20]
 8008dbe:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008dc2:	d006      	beq.n	8008dd2 <ethernet_input+0x1aa>
 8008dc4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008dc8:	d003      	beq.n	8008dd2 <ethernet_input+0x1aa>
    ETHARP_STATS_INC(etharp.err);
 8008dca:	4a0b      	ldr	r2, [pc, #44]	; (8008df8 <ethernet_input+0x1d0>)
 8008dcc:	8d93      	ldrh	r3, [r2, #44]	; 0x2c
 8008dce:	3301      	adds	r3, #1
 8008dd0:	8593      	strh	r3, [r2, #44]	; 0x2c
  pbuf_free(p);
 8008dd2:	4620      	mov	r0, r4
 8008dd4:	f7fc fc65 	bl	80056a2 <pbuf_free>
 8008dd8:	e737      	b.n	8008c4a <ethernet_input+0x22>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 8008dda:	2302      	movs	r3, #2
 8008ddc:	462a      	mov	r2, r5
 8008dde:	a901      	add	r1, sp, #4
 8008de0:	4638      	mov	r0, r7
 8008de2:	f7ff fcdb 	bl	800879c <etharp_update_arp_entry>
  switch (hdr->opcode) {
 8008de6:	8ab3      	ldrh	r3, [r6, #20]
 8008de8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008dec:	d0f1      	beq.n	8008dd2 <ethernet_input+0x1aa>
 8008dee:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008df2:	d0ee      	beq.n	8008dd2 <ethernet_input+0x1aa>
 8008df4:	e7e9      	b.n	8008dca <ethernet_input+0x1a2>
 8008df6:	bf00      	nop
 8008df8:	2000b084 	.word	0x2000b084
 8008dfc:	08009054 	.word	0x08009054

08008e00 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 8008e00:	f8df d034 	ldr.w	sp, [pc, #52]	; 8008e38 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8008e04:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8008e06:	e003      	b.n	8008e10 <LoopCopyDataInit>

08008e08 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8008e08:	4b0c      	ldr	r3, [pc, #48]	; (8008e3c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8008e0a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8008e0c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8008e0e:	3104      	adds	r1, #4

08008e10 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8008e10:	480b      	ldr	r0, [pc, #44]	; (8008e40 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8008e12:	4b0c      	ldr	r3, [pc, #48]	; (8008e44 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8008e14:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8008e16:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8008e18:	d3f6      	bcc.n	8008e08 <CopyDataInit>
  ldr  r2, =_sbss
 8008e1a:	4a0b      	ldr	r2, [pc, #44]	; (8008e48 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8008e1c:	e002      	b.n	8008e24 <LoopFillZerobss>

08008e1e <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8008e1e:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8008e20:	f842 3b04 	str.w	r3, [r2], #4

08008e24 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8008e24:	4b09      	ldr	r3, [pc, #36]	; (8008e4c <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8008e26:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8008e28:	d3f9      	bcc.n	8008e1e <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8008e2a:	f7fa fddd 	bl	80039e8 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8008e2e:	f000 f811 	bl	8008e54 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8008e32:	f7fa fd39 	bl	80038a8 <main>
  bx  lr    
 8008e36:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 8008e38:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8008e3c:	08009074 	.word	0x08009074
  ldr  r0, =_sdata
 8008e40:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8008e44:	20000154 	.word	0x20000154
  ldr  r2, =_sbss
 8008e48:	20000158 	.word	0x20000158
  ldr  r3, = _ebss
 8008e4c:	2000b1c0 	.word	0x2000b1c0

08008e50 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8008e50:	e7fe      	b.n	8008e50 <ADC_IRQHandler>
	...

08008e54 <__libc_init_array>:
 8008e54:	b570      	push	{r4, r5, r6, lr}
 8008e56:	4e0d      	ldr	r6, [pc, #52]	; (8008e8c <__libc_init_array+0x38>)
 8008e58:	4c0d      	ldr	r4, [pc, #52]	; (8008e90 <__libc_init_array+0x3c>)
 8008e5a:	1ba4      	subs	r4, r4, r6
 8008e5c:	10a4      	asrs	r4, r4, #2
 8008e5e:	2500      	movs	r5, #0
 8008e60:	42a5      	cmp	r5, r4
 8008e62:	d109      	bne.n	8008e78 <__libc_init_array+0x24>
 8008e64:	4e0b      	ldr	r6, [pc, #44]	; (8008e94 <__libc_init_array+0x40>)
 8008e66:	4c0c      	ldr	r4, [pc, #48]	; (8008e98 <__libc_init_array+0x44>)
 8008e68:	f000 f83a 	bl	8008ee0 <_init>
 8008e6c:	1ba4      	subs	r4, r4, r6
 8008e6e:	10a4      	asrs	r4, r4, #2
 8008e70:	2500      	movs	r5, #0
 8008e72:	42a5      	cmp	r5, r4
 8008e74:	d105      	bne.n	8008e82 <__libc_init_array+0x2e>
 8008e76:	bd70      	pop	{r4, r5, r6, pc}
 8008e78:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8008e7c:	4798      	blx	r3
 8008e7e:	3501      	adds	r5, #1
 8008e80:	e7ee      	b.n	8008e60 <__libc_init_array+0xc>
 8008e82:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8008e86:	4798      	blx	r3
 8008e88:	3501      	adds	r5, #1
 8008e8a:	e7f2      	b.n	8008e72 <__libc_init_array+0x1e>
 8008e8c:	0800906c 	.word	0x0800906c
 8008e90:	0800906c 	.word	0x0800906c
 8008e94:	0800906c 	.word	0x0800906c
 8008e98:	08009070 	.word	0x08009070

08008e9c <memcmp>:
 8008e9c:	b510      	push	{r4, lr}
 8008e9e:	3901      	subs	r1, #1
 8008ea0:	4402      	add	r2, r0
 8008ea2:	4290      	cmp	r0, r2
 8008ea4:	d101      	bne.n	8008eaa <memcmp+0xe>
 8008ea6:	2000      	movs	r0, #0
 8008ea8:	bd10      	pop	{r4, pc}
 8008eaa:	f810 3b01 	ldrb.w	r3, [r0], #1
 8008eae:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8008eb2:	42a3      	cmp	r3, r4
 8008eb4:	d0f5      	beq.n	8008ea2 <memcmp+0x6>
 8008eb6:	1b18      	subs	r0, r3, r4
 8008eb8:	bd10      	pop	{r4, pc}

08008eba <memcpy>:
 8008eba:	b510      	push	{r4, lr}
 8008ebc:	1e43      	subs	r3, r0, #1
 8008ebe:	440a      	add	r2, r1
 8008ec0:	4291      	cmp	r1, r2
 8008ec2:	d100      	bne.n	8008ec6 <memcpy+0xc>
 8008ec4:	bd10      	pop	{r4, pc}
 8008ec6:	f811 4b01 	ldrb.w	r4, [r1], #1
 8008eca:	f803 4f01 	strb.w	r4, [r3, #1]!
 8008ece:	e7f7      	b.n	8008ec0 <memcpy+0x6>

08008ed0 <memset>:
 8008ed0:	4402      	add	r2, r0
 8008ed2:	4603      	mov	r3, r0
 8008ed4:	4293      	cmp	r3, r2
 8008ed6:	d100      	bne.n	8008eda <memset+0xa>
 8008ed8:	4770      	bx	lr
 8008eda:	f803 1b01 	strb.w	r1, [r3], #1
 8008ede:	e7f9      	b.n	8008ed4 <memset+0x4>

08008ee0 <_init>:
 8008ee0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008ee2:	bf00      	nop
 8008ee4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8008ee6:	bc08      	pop	{r3}
 8008ee8:	469e      	mov	lr, r3
 8008eea:	4770      	bx	lr

08008eec <_fini>:
 8008eec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008eee:	bf00      	nop
 8008ef0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8008ef2:	bc08      	pop	{r3}
 8008ef4:	469e      	mov	lr, r3
 8008ef6:	4770      	bx	lr
